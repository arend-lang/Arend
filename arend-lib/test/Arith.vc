\open Paths
\open Relation
\open Combinators

\open Data.Unit
\open Data.Bool
\open Data.Empty
\open Data.Either

\static \function
pred (x : Nat) : Nat <= \elim x
    | zero => 0
    | suc x' => x'

\static \function \infixl 6
(+) (x y : Nat) : Nat <= \elim x
    | zero => y
    | suc x' => suc $ x' + y

\static \function \infixl 7
(*) (x y : Nat) : Nat <= \elim x
    | zero => zero
    | suc x' => y + (x' * y)

\static \function \infixl 6
(-) (x y : Nat) : Nat <= \elim y
    | zero => x
    | suc y' => pred $ x - y'

\static \data \infix 4
(=<) (n m : Nat)
  | (=<) zero m => le_z
  | (=<) (suc n) (suc m) => le_ss (n =< m)

\static \function \infix 4
(<) (n m : Nat) : \Type0 => suc n =< m

\static \function \infix 4
(>) (n m : Nat) : \Type0 => m < n

\static \function
sdec {x y : Nat} (d : Dec (x = y)) : Dec (suc x = suc y) <= \elim d
    | inl f => inl (\lam p => f $ pmap pred p)
    | inr p => inr $ pmap suc p

\static \function
is_zero_b (x : Nat) : Bool <= \elim x
    | zero => true
    | _ => false

\static \function
is_zero : Nat -> \Prop => True `o` is_zero_b

\static \function
is_suc : Nat -> \Prop => True `o` not `o` is_zero_b

\static \function \infix 2
(=?) (x y : Nat) : Dec (x = y) <= \elim x, y
    | suc x', suc y' <= sdec (x' =? y')
    | suc _, zero => inl (\lam p => transport is_suc p unit)
    | zero, zero => inr idp
    | zero, suc y => inl (\lam p => transport is_zero p unit)

\static \function
suc_nle_zero {n : Nat} (p : suc n =< zero) : Empty <= \elim p

\static \function
le_unsuc {n m : Nat} (sn-le-sm : (suc n) =< (suc m)) : n =< m <= \elim sn-le-sm
  | le_ss p => p

\static \function
(=<?) (x y : Nat) : Dec (x =< y) <= \elim x, y
    | zero, _ => inr le_z
    | suc x', zero => inl suc_nle_zero
    | suc x', suc y' => \case (x' =<? y')
       | inl nleq => inl (nleq `o` le_unsuc)
       | inr leq => inr (le_ss leq)

\static \function
plus-assoc (x y z : Nat) : (x + y) + z = x + (y + z) <= \elim x
    | zero => path (\lam _ => y + z)
    | suc x' => path (\lam i => suc (plus-assoc x' y z @ i))

\static \function
plus-comm0 (y : Nat) : y = y + zero <= \elim y
    | zero => idp
    | suc y' => pmap suc (plus-comm0 y')

\static \function
plus-comm (x y : Nat) : x + y = y + x <= \elim x, y
    | zero, _ => plus-comm0 y
    | suc x', zero => inv (plus-comm0 (suc x'))
    | suc x', suc y' => pmap suc (plus-comm x' (suc y') *> pmap suc (inv (plus-comm x' y')) *> plus-comm (suc x') y')

\static \function
mul-distr (x y z : Nat) : (x + y) * z = x * z + y * z <= \elim x
    | zero => idp
    | suc x' => pmap (\lam t => z + t) (mul-distr x' y z) *> inv (plus-assoc z (x' * z) (y * z))

\static \function
mul-assoc (x y z : Nat) : (x * y) * z = x * (y * z) => \elim x
    | zero => idp
    | suc x' => mul-distr y (x' * y) z *> pmap (\lam t => y * z + t) (mul-assoc x' y z)

\static \function
mul-comm0 (y : Nat) : zero = y * zero <= \elim y
    | zero => idp
    | suc y' => mul-comm0 y'

\static \function
mul-comm (x y : Nat) : x * y = y * x <= \elim x, y
    | zero, _ => mul-comm0 y
    | suc x', zero => inv (mul-comm0 x')
    | suc x', suc y' => pmap suc (
            y' + (x' * suc y')      ==< pmap (\lam t => y' + t) (mul-comm x' (suc y'))      >==
            y' + (x' + y' * x')     ==< inv (plus-assoc y' x' (y' * x'))                    >==
            y' + x' + y' * x'       ==< pmap (\lam t => t + y' * x') (plus-comm y' x')      >==
            x' + y' + y' * x'       ==< pmap (\lam t => x' + y' + t) (inv (mul-comm x' y')) >==
            x' + y' + x' * y'       ==< plus-assoc x' y' (x' * y')                          >==
            x' + (y' + x' * y')     ==< pmap (\lam t => x' + t) (mul-comm (suc x') y')      >==
            x' + y' * suc x'        !qed)

\static \class TODO {
  \abstract pred-assoc (x y : Nat) : pred (x - y) = (pred x) - y
}
