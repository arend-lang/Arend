
\open ::Paths

\open ::Data::Bool

\open ::Equiv

\open ::HITs::Circle

\function
Pointed => \Sigma (A : \Type) (a : A)

\function
Omega (A : Pointed) : Pointed =>
    (A.2 = A.2, idp)

\data Susp (A : \Type)
    | south
    | north
    | merid A I
\with
    | merid a (left) => north
    | merid a (right) => south

\function
meridP {A : \Type} (a : A) : north {A} = south {A} =>
    path (\lam i => merid a i)

\function
meridArcP {A : \Type} (a : A) (i : I) : north {A} = merid a i =>
    path (\lam j => merid a (squeeze i j))

\function
Susp-ind-hetero {A : \Type} (B : Susp A -> \Type) (n : B north) (s : B south) (l : \Pi (a : A) -> Path (\lam i => B (merid a i)) n s)
    (x : Susp A) : B x <=
    \elim x
        | north => n
        | south => s
        | merid a i => l a @ i
        ;

\function
Susp-ind-homo {A : \Type} (B : Susp A -> \Type) (n : B north) (s : B south) (l : \Pi (a : A) -> transport B (meridP a) n = s)
    (x : Susp A) : B x <=
    \elim x
        | north => n
        | south => s
        | merid a i => pathOver (l a) @ i
        ;

\function
concat-hetero-assoc1 {A : \Type} {a1 a2 a3 a4 : A} (p : a1 = a2) (q : a2 = a3) (r : a3 = a4) : p <* q *> r = (p <* q) *> r <=
    Jl (\lam _ r => p <* q *> r = (p <* q) *> r) idp r

\function
concat-hetero-assoc2 {A : \Type} {a1 a2 a3 a4 : A} (p : a1 = a2) (q : a2 = a3) (r : a3 = a4) : p *> q <* r = (p *> q) <* r <=
    {!error}

\function
inv-concat2 {A : \Type} {a a' : A} (p : a = a') : inv p <* p = idp <=
    Jl (\lam _ q => inv q <* q = idp) idp p

\function
lemma_a {A : \Type} {a a' a'' : A} (p : a = a') (q : a'' = a') : (p *> inv q) <* q *> inv p = idp =>
    concat-hetero-assoc1 _ _ _ *> pmap (\lam x => x *> inv p) (inv (concat-hetero-assoc2 _ _ _)) *>
    pmap (\lam x => (p *> x) *> inv p) (inv-concat2 q) *> pmap (\lam x => x *> inv p) (idp-concat _) *> concat-inv _

\function
lemma651 : Susp Bool =~= S1 =>
    {?}
\where {
    \function
    f (x : Susp Bool) : S1 <=
        \elim x
            | north => base
            | south => base
            | merid (true) _ => base
            | merid (false) i => loop i
            ;

    \function
    g (x : S1) : Susp Bool <=
        \elim x
            | base => north
            | loop i => path (merid false) *> inv (path (merid true)) @ i
            ;

    \function
    p (x : Susp Bool) : g (f x) = x <=
        \elim x
            | north => idp
            | south => path (merid true)
            | merid (true) i => meridArcP true i
            | merid (false) i => 
                \let | leftSide : north = north <= path (merid false) *> inv (path (merid true))
                     | rightSide : north = south <= path (merid false)
                     | bottomSide : north = north <= idpe north
                     | topSide : north = south <= path (merid true)
                     | squareType <= square leftSide rightSide bottomSide topSide
                     | squarePath <= bottomSide = leftSide <* topSide *> inv rightSide
                     | pathProof : squarePath <= inv (lemma_a rightSide topSide)
                     | squareEquality : squarePath = squareType <= square-path leftSide rightSide bottomSide topSide
                     | mySquare : Path (\lam i => leftSide @ i = rightSide @ i) bottomSide topSide <= transport (\lam x => x) squareEquality pathProof
                \in mySquare @ i
            ;
}
