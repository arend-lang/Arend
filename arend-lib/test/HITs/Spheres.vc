
\open ::Paths

\open ::Data::Bool

\open ::Equiv

\open ::HITs::Circle

\function
Pointed => \Sigma (A : \Type) (a : A)

\function
Omega (A : Pointed) : Pointed =>
    (A.2 = A.2, idp)

\data Susp (A : \Type)
    | south
    | north
    | merid (a : A) (i : I) => \elim i {
        | left => north
        | right => south
    }

\function
meridP {A : \Type} (a : A) : north {A} = south {A} =>
    path (\lam i => merid a i)

\function
meridArcP {A : \Type} (a : A) (i : I) : north {A} = merid a i =>
    path (\lam j => merid a (squeeze i j))

\function
Susp-ind-hetero {A : \Type} (B : Susp A -> \Type) (n : B north) (s : B south) (l : \Pi (a : A) -> Path (\lam i => B (merid a i)) n s)
    (x : Susp A) : B x =>
    \elim x
        | north => n
        | south => s
        | merid a i => l a @ i

\function
Susp-ind-homo {A : \Type} (B : Susp A -> \Type) (n : B north) (s : B south) (l : \Pi (a : A) -> transport B (meridP a) n = s)
    (x : Susp A) : B x =>
    \elim x
        | north => n
        | south => s
        | merid a i => pathOver (l a) @ i

\function
lemma_a {A : \Type} {a a' a'' : A} (p : a = a') (q : a'' = a') : (p *> inv q) <* q *> inv p = idp =>
    concat-hetero-assoc1 _ _ _ *> pmap (\lam x => x *> inv p) (inv (concat-hetero-assoc2 _ _ _)) *>
    pmap (\lam x => (p *> x) *> inv p) (inv-concat2 q) *> pmap (\lam x => x *> inv p) (idp-concat _) *> concat-inv _

\function
susp2-S1 : Susp Bool =~= S1 =>
    (f, ((g, p), (g, q)))
  \where {
    \function
    f (x : Susp Bool) : S1
        | north => base
        | south => base
        | merid (true) _ => base
        | merid (false) i => loop i

    \function
    g (x : S1) : Susp Bool
        | base => north
        | loop i => (path (merid false) *> inv (path (merid true))) @ i

    \function
    p (x : Susp Bool) : g (f x) = x
        | north => idp
        | south => path (merid true)
        | merid (true) i => meridArcP true i
        | merid (false) i => 
            \let | leftSide : north = north => path (merid false) *> inv (path (merid true))
                 | rightSide : north = south => path (merid false)
                 | bottomSide : north = north => idpe north
                 | topSide : north = south => path (merid true)
                 | squareType => square leftSide rightSide bottomSide topSide
                 | squarePath => bottomSide = leftSide <* topSide *> inv rightSide
                 | pathProof : squarePath => inv (lemma_a rightSide topSide)
                 | squareEquality : squarePath = squareType => square-path leftSide rightSide bottomSide topSide
                 | mySquare : Path (\lam i => leftSide @ i = rightSide @ i) bottomSide topSide => transport (\lam x => x) squareEquality pathProof
            \in mySquare @ i

    \function
    q (x : S1) : f (g x) = x
        | base => idp
        | loop i => pmap (\lam x => x @ i) ((pmap-concat-commute f (path (merid false)) (inv (path (merid true)))) *>
                       (pmap (\lam z => (path loop) *> z) (pmap-inv-comm f (path (merid true)))))
  }

\function based-map (A B : Pointed) => \Sigma (f : A.1 -> B.1) (p : f A.2 = B.2)

\function based-map-eq {A B : Pointed} {f g : based-map A B} (p : f.1 = g.1) : f = g => 
    \let se => sigma-equiv {A.1 -> B.1} (\lam z => z A.2 = B.2) f g
    \in se.2.1.1 (p, {?})

\function + (A : \Type) : Pointed 
    => (Either A Unit, inr unit)

\function pointed-adj (A : \Type) (B : Pointed) : based-map (A +`) B =~= (A -> B.1) 
    => \let | F : based-map (A +`) B -> A -> B.1 => \lam f => f.1 `o inl
            | G : (A -> B.1) -> based-map (A +`) B => \lam f => (\lam z => (\case z \with {
                | inl a => f a
                | inr _ => B.2
                }), idp)
            | P : \Pi (bm : based-map (A +`) B) -> G (F bm) = bm => {?}
       \in (F, ((G, P), (G, \lam x => idp)))
