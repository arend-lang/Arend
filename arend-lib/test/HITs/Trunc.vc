\open ::Paths
\open ::Hlevel
\open ::HITs::Spheres
\open ::Combinators
\open ::Equiv

\data Trunc (n : Nat) (A : \Type) 
    | inT A
    | hT (r : (S n).1 -> Trunc n A)
    | spokeT (r : (S n).1 -> Trunc n A) (x : (S n).1) (i : I) => \elim i {
        | left => r x
        | right => hT r
    }

\function
ofHlevel-Trunc (n : Nat) (A : \Type) : ofHlevel (suc n) (Trunc n A) => 
    \let TA => Trunc n A
    \in transport id (inv (ofHlevel-Omega-contr TA n))
        (\lam (b : TA) => transport id (pmap isContr (SphereOmega-adj n (TA, b))) (
            \let cb : (S n).1 -> TA => \lam x => b
            \in ((cb, idp), \lam r => (
                    \let | P => \lam (f : (S n).1 -> TA) => f (S n).2 = b
                         | A1 : cb = r.1 => fun-ext (\lam (x : (S n).1) => inv (path (spokeT r.1 x) *> inv (path (spokeT r.1 (S n).2)) *> r.2))
                         | A2 : transport P A1 idp = r.2 => coePath (pmap (\lam (f : (S n).1 -> TA) => f (S n).2) A1) idp (idpe b) *>
                             inv-inv _ *> inv (concat-assoc _ _ _) *> pmap (\lam p => p *> r.2) (concat-inv (path (spokeT r.1 (S n).2))) *> concat-idp _
                    \in sigma-ext-eq P (A1, A2)))))

\function
Trunc-UP {n : Nat} {A : \Type} {P : Trunc n A -> \Type} (nT : \Pi (x : Trunc n A) -> ofHlevel (suc n) (P x))
    (g : \Pi (a : A) -> P (inT a)) (x : Trunc n A) : P x => \elim x
    | inT a => g a
    | hT r => transport P (path (spokeT r (S n).2)) (Trunc-UP {n} {A} {P} nT g (r (S n).2))
    | spokeT r x i => pathOver (ofHlevel-sphere-map-contr (nT (hT r))
        (\lam (z : (S n).1) => transport P (path (spokeT r z)) (Trunc-UP {n} {A} {P} nT g (r z))) x) @ i

\function
ext {n : Nat} {A E : \Type} (nT : ofHlevel (suc n) E) (f : A -> E) : Trunc n A -> E 
    => Trunc-UP {n} {A} {\lam _ => E} (\lam _ => nT) f

\function
uniq {n : Nat} {A E : \Type} (nT : ofHlevel (suc n) E) (f1 f2 : Trunc n A -> E) (eq : \Pi (a : A) -> f1 (inT a) = f2 (inT a)) : f1 ~ f2 
    => \lam (x : Trunc n A) => Trunc-UP {n} {A} {\lam x => f1 x = f2 x} (\lam x => ofHlevel-suc {E} {suc n} nT (f1 x) (f2 x)) eq x

\function
Trunc-UP2 {n : Nat} (A B : \Type) (nT : ofHlevel (suc n) B) : isequiv (\lam (g : Trunc n A -> B) => g `o inT) => 
    \let G => ext {n} {A} {B} nT
    \in ((G, \lam g => fun-ext (uniq nT (G (g `o inT)) g (\lam _ => idp))),
            (G, \lam f => fun-ext {A} {B} {G f `o inT} {f} (\lam _ => idp)))

\function
inM {A B : \Type} (f : A -> B) (n : Nat) : Trunc n A -> Trunc n B => ext (ofHlevel-Trunc n B) (inT `o f)

-- It is obvious that
--   inM f n (inT a) = inT (f a)

\function
inM-o {A B C : \Type} (f : A -> B) (g : B -> C) (n : Nat) : inM g n `o inM f n = inM (g `o f) n 
    => fun-ext (uniq (ofHlevel-Trunc n C) (inM g n `o inM f n) (inM (g `o f) n) (\lam _ => idp))

\function
inM-id {A : \Type} (n : Nat) : inM (id {A}) n = id {Trunc n A} 
    => fun-ext (uniq (ofHlevel-Trunc n A) (inM (id {A}) n) (id {Trunc n A}) (\lam _ => idp))

\function
inH {A B : \Type} (f g : A -> B) (h : f ~ g) (n : Nat) : inM f n ~ inM g n => 
    \let | A0 : inM f n `o inT = inM g n `o inT => fun-ext (\lam a => pmap (\lam b => inT {n} {B} b) (h a))
         | A1 => Trunc-UP2 A (Trunc n B) (ofHlevel-Trunc n B)
    \in fun-ext-inv (inv (A1.1.2 (inM f n)) *> pmap A1.1.1 A0 *> A1.1.2 (inM g n))

\function
ofHlevel-inT-equiv (A : \Type) (n : Nat) (nT : ofHlevel (suc n) A) : isequiv (inT {n} {A}) => 
    \let G => ext nT (id {A})
    \in ((G, \lam _ => idp), (G, uniq (ofHlevel-Trunc n A) (inT `o G) id (\lam _ => idp)))

\function
inT-equiv-ofHlevel (A : \Type) (n : Nat) (e : isequiv (inT {n} {A})) : ofHlevel (suc n) A 
    => transport (\lam B => ofHlevel (suc n) B) (inv (equiv-to-path (inT {n} {A}, e))) (ofHlevel-Trunc n A)

\function
sigma-Trunc (A B : \Type) (n : Nat) : Trunc n (\Sigma A B) =~= (\Sigma (Trunc n A) (Trunc n B)) => 
    \let | P1 => Trunc n (\Sigma A B)
         | P2 => \Sigma (Trunc n A) (Trunc n B)
         | nTP1 => ofHlevel-Trunc n (\Sigma A B)
         | nTP2 => ofHlevel-sigma {Trunc n A} (\lam _ => Trunc n B) {suc n} (ofHlevel-Trunc n A) (\lam _ => ofHlevel-Trunc n B)
         | nTM => \lam P (nTP : ofHlevel (suc n) P) => ofHlevel-codom (Trunc n B) (const P) (suc n) (const nTP)
         | F : P1 -> P2 => ext {n} {\Sigma A B} {\Sigma (Trunc n A) (Trunc n B)} nTP2 (\lam p => (inT p.1, inT p.2))
         | G : P2 -> P1 => uncurry (ext {n} {A} {Trunc n B -> P1} (nTM P1 nTP1) (\lam a => ext {n} {B} {P1} nTP1 (\lam b => inT (a, b))))
         | cFG => curry (F `o G)
         | cId => curry (id {P2})
    \in (F, ((G, uniq nTP1 (G `o F) id (\lam x => idp)), (G, curry-fun-eq (F `o G) (id {P2})
            (uniq (nTM P2 nTP2) cFG cId (\lam a => fun-ext (uniq nTP2 (cFG (inT a)) (cId (inT a)) (\lam _ => idp)))))))

\function
sigma-fibers-Trunc {A : \Type} (P : A -> \Type) (n : Nat) : Trunc n (\Sigma (x : A) (Trunc n (P x))) =~= Trunc n (\Sigma (x : A) (P x)) => 
    \let | T1 => \Sigma (x : A) (Trunc n (P x))
         | T2 => \Sigma (x : A) (P x)
         | P1 => Trunc n T1
         | P2 => Trunc n T2
         | F : P1 -> P2 => ext (ofHlevel-Trunc n T2)
             (uncurry-d (\lam x => Trunc n (P x)) (\lam (x : A) => ext (ofHlevel-Trunc n T2) (\lam (y : P x) => inT (x, y))))
         | G : P2 -> P1 => inM {T2} {T1} (\lam (p : T2) => (p.1, inT p.2)) n
    \in (F, ((G, uniq (ofHlevel-Trunc n T1) (G `o F) id (curry-d-fun-eq (\lam x => Trunc n (P x)) (G `o F `o inT) inT
            (\lam x => fun-ext {Trunc n (P x)} {P1} (uniq (ofHlevel-Trunc n T1) (curry-d (\lam x => Trunc n (P x)) (G `o F `o inT) x)
                (curry-d (\lam x => Trunc n (P x)) (inT {n} {T1}) x) (\lam _ => idp))))),
            (G, uniq (ofHlevel-Trunc n T2) (F `o G) id (\lam _ => idp))))
