\open ::LC::RVec
\open ::LC::Ctx
\open ::LC::Term
\open ::LC::Either

\open ::Paths
\open ::Data::Bool
\open ::Data::Fin
\open ::Data::Nat::Base

-- Предикат "переменная лежит в контексте"

\function
VarInCtx {n : Nat} (env : Ctx n) (x : Nat) => \Sigma (i : Fin n) (env !! i = x)


-- Предикат "терм определен в контексте"

\data TermInCtx {n : Nat} (env : Ctx n) (t : Term)
   | TermInCtx env (Var x)     => Variable (p : VarInCtx env x)
   | TermInCtx env (App t1 t2) => Application (p : TermInCtx env t1) (q : TermInCtx env t2)
   | TermInCtx env (Lam x t)   => Abstraction (p : TermInCtx (extend env x) t)


-- Альфа-эквивалентность для именованных термов

\data AlphaEq
  {n : Nat}
  (env1 : Ctx n)
  (t1 : Term)
  (p1 : TermInCtx env1 t1)
  (env2 : Ctx n)
  (t2 : Term)
  (p2 : TermInCtx env2 t2)
    | AlphaEq env1 (Var x) (Variable p) env2 (Var y) (Variable q)                       => VarEq (p : p.1 = q.1)
    | AlphaEq env1 (App t1 s1) (Application p1 q1) env2 (App t2 s2) (Application p2 q2) => AppEq (p : AlphaEq env1 t1 p1 env2 t2 p2) (q : AlphaEq env1 s1 q1 env2 s2 q2)
    | AlphaEq env1 (Lam x t1) (Abstraction p1) env2 (Lam y t2) (Abstraction p2)         => LamEq (p : AlphaEq (extend env1 x) t1 p1 (extend env2 y) t2 p2)


-- Вперед

\function
phi
  {n : Nat}
  (env : Ctx n)
  (t : Term)
  (proof : TermInCtx env t) : Term'' n <= \elim t, proof
    | Var x, Variable p             => Var'' (p.1)
    | App t1 t2, Application p q    => App'' (phi env t1 p) (phi env t2 q)
    | Lam x t, Abstraction p        => Lam'' (phi (extend env x) t p)


-- Назад.

\function
psi
  {n : Nat}
  (t : Term'' n) : \Sigma (env : Ctx n) (t' : Term) (proof : TermInCtx env t') <= \elim t
    | Var'' i       =>  \let
                          | env => gen_env n
                          | var => env !! i
                        \in (env, Var var, Variable (i, idp))
    | App'' t1 t2   =>  \let
                          | res1  => psi t1
                          | res2  => psi t2
                          | env1  => res1.1
                          | env2  => res2.1
                          | t1    => res1.2
                          | t2    => res2.2
                          | pr1   => res1.3
                          | pr2   => res2.3
                        \in (env1, App t1 t2, Application pr1 {?})
    | Lam'' t       =>  \let
                          | res => psi t
                          | env => res.1
                          | t'  => res.2
                          | p   => res.3
                          | x   => rhead env
                          | xs  => rtail env
                          | pr  => transport (\lam a => TermInCtx a t') (inv (snoc-lemma env)) p
                        \in (xs, Lam x t', Abstraction pr)

-- Доказательства

\function
phi-respects-alpha-eq
   {n : Nat}
   (env1 env2 : Ctx n)
   (t1 t2 : Term)
   (p1 : TermInCtx env1 t1)
   (p2 : TermInCtx env2 t2)
   (proof : AlphaEq env1 t1 p1 env2 t2 p2) : (phi env1 t1 p1) = (phi env2 t2 p2) <= \elim t1, t2, p1, p2, proof
       | Var x, Var y, Variable p, Variable q, VarEq r                         => pmap Var'' r
       | App t1 s1, App t2 s2, Application p1 q1, Application p2 q2, AppEq p q => \let
                                                                                    | pr1 => phi-respects-alpha-eq env1 env2 t1 t2 p1 p2 p
                                                                                    | pr2 => phi-respects-alpha-eq env1 env2 s1 s2 q1 q2 q
                                                                                  \in pmap2 App'' pr1 pr2
       | Lam x t1, Lam y t2, Abstraction p1, Abstraction p2, LamEq p           => \let
                                                                                    | pr => phi-respects-alpha-eq (extend env1 x) (extend env2 y) t1 t2 p1 p2 p
                                                                                  \in pmap Lam'' pr




-- phi (psi t) == t
\function
phi-psi-id
{n : Nat}
(t : Term'' n) : phi (psi t).1 (psi t).2 (psi t).3 = t <= \elim t
    | Var'' i     => {?}
    | App'' t1 t2 => {?}
    | Lam'' t     => {?}


-- psi (phi t) == t
\function
psi-phi-id
 {n : Nat}
 (t : Term)
 (env : Ctx n)
 (proof : TermInCtx env t) : (AlphaEq (psi (phi env t proof)).1 (psi (phi env t proof)).2 (psi (phi env t proof)).3 env t proof) <= \elim t, proof
   | Var x, Variable p           => VarEq {?}
   | App t1 t2, Application p q  => AppEq {?} {?}
   | Lam x t, Abstraction p      => LamEq {?}
