\open ::LC::Term
\open ::LC::Ctx
\open ::LC::Properties

\open ::Data::Either
\open ::Data::Nat::Base
\open ::Data::Vector
\open ::Data::Unit

{-
\function
nsubst
    {n m : Nat}
    (env1 : Ctx n)
    (t1 : NTerm)
    (p1 : TermInCtx env1 t1)
    (x : Nat)
    (env2 : Ctx n)
    (t2 : NTerm)
    (p2 : TermInCtx env2 t2) : \Sigma (env' : Ctx (pred (n + m))) (t' : NTerm) (p' : TermInCtx env' t') <= \elim t1, p1
        | NVar x, Variable p => {?}
        | NApp m n, Application p q => {?}
        | NLam x t, Abstraction p => {?}


\function
isubst
    {n m : Nat}
    (t : ITerm n)
    (ts : Vector n (ITerm m)) : ITerm m <= \elim t
        | IVar i => {?}
        | IApp t1 t2 => {?}
        | ILam t => {?}
-}

-- http://stackoverflow.com/questions/35926898/are-parameterized-lambda-terms-a-monad

\function
return
    {V : \Type}
    (v : V) : FTerm V => FVar v


\function
fmap
    {V W : \Type}
    (f : V -> W)
    (t : FTerm V) : FTerm W <= \elim t
        | FVar v        => FVar (f v)
        | FApp t1 t2    => FApp (fmap f t1) (fmap f t2)
        | FLam t        => FLam (fmap (map-inl f) t)


\function
dist
    {V : \Type}
    (x : Either (FTerm V) Unit) : FTerm (Either V Unit) <= \elim x
        | inl t => fmap inl t
        | inr unit => FVar (inr unit)


-- TODO: gfold(see link above and article in Downloads on laptop)


\function
join
    {V : \Type}
    (t : FTerm (FTerm V)) : FTerm V <= \elim t
        | FVar t => t
        | FApp t1 t2 => FApp (join t1) (join t2)
        | FLam t => {?}


\function
bind
    {V W : \Type}
    (t : FTerm V)
    (k : V -> FTerm W) : FTerm W => join (fmap k t)
