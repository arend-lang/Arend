\open ::LC::Subst::Subst
\open ::LC::Term
\open ::LC::RVec

\open ::Data::Bool
\open ::Data::Either
\open ::Data::Empty
\open ::Data::Fin
\open ::Data::Nat::Base
\open ::Data::Nat::Compare
\open ::Data::Unit
\open ::Logic
\open ::Paths


-- All named stuff
{-
\function
nsubst-right-unit-var-helper
    (y x : Nat)
    (d : Dec (y = x)) : var-helper y x d (NVar x) (NVar y) = NVar y <= \elim d
        | inr pro       => pmap NVar (inv pro)
        | inl contra    => idpe (NVar y)


\function
nsubst-right-unit-lam-helper
    (y x : Nat)
    (t : NTerm)
    (dv : Dec (y = x)) : lam-helper y (NVar x) (var-helper-is-free-dec y x dv) (NLam (suc y) (nsubst' t x (NVar x) (\lam z => \case z =? y | inr p => suc y | inl np => z))) (NLam y (nsubst' t x (NVar x) (\lam x' => x'))) = NLam y t <= \elim dv
        | inr pro       => transport (\lam k => lam-helper x (NVar x) (var-helper-is-free-dec x x (x =? x)) (NLam (suc x) (nsubst' t x (NVar x) (\lam z => (\case z =? k | inr _ => suc k | inl _ =>  z)))) (NLam x (nsubst' t x (NVar x) (\lam x  => x))) = NLam x t) (inv pro) (nsubst-right-unit (NLam x t) x)
        | inl contra    => pmap (NLam y) (nsubst-right-unit t x)


\function
nsubst-right-unit
    (t : NTerm)
    (x : Nat) : nsubst t x (NVar x) = t <= \elim t
        | NVar y        => nsubst-right-unit-var-helper y x (y =? x)
        | NApp t1 t2    => pmap2 NApp (nsubst-right-unit t1 x) (nsubst-right-unit t2 x)
        | NLam y t      => nsubst-right-unit-lam-helper y x t (y =? x)


\function
nsubst-left-unit-helper
    (x : Nat)
    (d : Dec (x = x))
    (t : NTerm) : var-helper x x d t (NVar x) = t <= \elim d
        | inr idp       => idpe t
        | inl contra    => absurd (contra (idpe x))


\function
nsubst-left-unit
    (x : Nat)
    (t : NTerm) : nsubst (NVar x) x t = t => nsubst-left-unit-helper x (x =? x) t


\function
nsubst-not-free-var-id-var-helper
    (v x : Nat)
    (d : Dec (v = x))
    (s : NTerm)
    (p : IsFree x (NVar v) -> Empty) : var-helper v x d s (NVar v) = NVar v <= \elim d
        | inr pro       => absurd (p (VarIsFree (inv pro)))
        | inl contra    => idp


\function
nsubst-not-free-var-id-lam-helper
    (v x : Nat)
    (t s : NTerm)
    (d : Dec (IsFree v s))
    (p : IsFree x (NLam v t) -> Empty) : lam-helper v s d (NLam (suc v) (nsubst' t x s (\lam (z : Nat) => (\case z =? v | inl _ => z | inr _ => suc v)))) (NLam v (nsubst t x s)) = NLam v t <= \elim d
        | inr pro       => {?}
        | inl contra    => {?}


\function
nsubst-not-free-var-id
    (t : NTerm)
    (x : Nat)
    (s : NTerm)
    (p : IsFree x t -> Empty) : nsubst t x s = t <= \elim t
        | NVar v        => nsubst-not-free-var-id-var-helper v x (v =? x) s p
        | NApp t1 t2    =>  \let
                                | p1 => \lam (q : IsFree x t1) => p (AppLeftIsFree q)
                                | p2 => \lam (q : IsFree x t2) => p (AppRightIsFree q)
                            \in pmap2 NApp (nsubst-not-free-var-id t1 x s p1) (nsubst-not-free-var-id t2 x s p2)
        | NLam v t => {?}


\function
nsubst-assoc-var-helper
    (v x y : Nat)
    (d1 : Dec (v = x))
    (d2 : Dec (v = y))
    (M N : NTerm)
    (p : IsFree x M -> Empty) : nsubst (var-helper v x d1 N (NVar v)) y M = nsubst (var-helper v y d2 M (NVar v)) x (nsubst N y M) <= \elim d1, d2
        | inr pro1, inr pro2 => {?}
        | inr pro1, inl contra2 => {?}
        | inl contra1, inr pro2 => {?}
        | inl contra1, inl contra2 => {?}


\function
nsubst-assoc
    (t : NTerm)
    (x y : Nat)
    (M N : NTerm)
    (p : IsFree x M -> Empty) : nsubst (nsubst t x N) y M = nsubst (nsubst t y M) x (nsubst N y M) <= \elim t
		| NVar v 		=> nsubst-assoc-var-helper v x y (v =? x) (v =? y) M N p
		| NApp t1 t2 	=> pmap2 NApp (nsubst-assoc t1 x y M N p) (nsubst-assoc t2 x y M N p)
		| NLam v t 		=> {?}
-}

\function
gen-vars
    (n : Nat) : RVec n (ITerm n) <= \elim n
        | zero => vnil
        | suc n => snoc (rmap weak (gen-vars n)) (IVar fzero)


\function
identity2 : gen-vars 2 = snoc (snoc  vnil (IVar (fsuc fzero))) (IVar fzero) => idp

\function
identity3 : gen-vars 3 = snoc (snoc (snoc  vnil (IVar (fsuc (fsuc fzero)))) (IVar (fsuc fzero))) (IVar fzero) => idp


-- All index stuff

\function
isubst-right-unit-weak-lemma
    {n m : Nat}
    (i : Fin n)
    (ts : RVec n (ITerm m)) : (rmap weak ts) !! i = weak (ts !! i) <= \elim n, i, ts
        | suc n, fzero, snoc ts t => idp
        | suc n, fsuc i, snoc ts t => isubst-right-unit-weak-lemma i ts


\function
isubst-right-unit-var-helper
    (n : Nat)
    (i : Fin n) : (gen-vars n) !! i = IVar i <= \elim n, i
        | suc n, fzero => idp
        | suc n, fsuc j =>  \let
                                | p => isubst-right-unit-weak-lemma j (gen-vars n)
                                | rec => isubst-right-unit-var-helper n j
                                | q => transport (\lam x => (rmap weak (gen-vars n)) !! j = weak x) rec p
                            \in transport (\lam x => (rmap weak (gen-vars n)) !! j = x) idp q


\function
isubst-right-unit
    {n : Nat}
    (t : ITerm n) : isubst t (gen-vars n) = t <= \elim t
        | IVar i        => isubst-right-unit-var-helper n i
        | IApp t1 t2    => pmap2 IApp (isubst-right-unit t1) (isubst-right-unit t2)
        | ILam t        => pmap ILam (isubst-right-unit t)


\function
isubst-left-unit
    {n m : Nat}
    (i : Fin n)
    (ts : RVec n (ITerm m)) : isubst (IVar i) ts = ts !! i => idp


\function
isubst-assoc-var-helper
    (n m k : Nat)
    (i : Fin n)
    (ts : RVec n (ITerm m))
    (ss : RVec m (ITerm k)) : isubst (ts !! i) ss = rmap (\lam x => isubst x ss) ts !! i <= \elim n, i, ts
        | suc n, fzero, snoc ts t   => idp
        | suc n, fsuc i, snoc ts t  => isubst-assoc-var-helper n m k i ts ss


\function
isubst-weak-lemma-helper-helper
    {n m : Nat}
    (i : Fin n)
    (ss : RVec n (ITerm m)) : rmap weak ss !! i = weak (ss !! i) <= \elim n, i, ss
        | suc n, fzero, snoc ss s => idp
        | suc n, fsuc i, snoc ss s => isubst-weak-lemma-helper-helper i ss


\function
isubst-weak-lemma-helper
    {n m : Nat}
    (t : ITerm n)
    (ss : RVec n (ITerm m)) : isubst (weak t) (snoc (rmap weak ss) (IVar fzero)) = weak (isubst t ss) <= \elim t
        | IVar i => isubst-weak-lemma-helper-helper i ss
        | IApp t1 t2 => pmap2 IApp (isubst-weak-lemma-helper t1 ss) (isubst-weak-lemma-helper t2 ss)
        | ILam t => pmap ILam (isubst-weak-lemma-helper t (snoc (rmap weak ss) (IVar fzero)))


\function
isubst-weak-lemma
    (n m k : Nat)
    (ts : RVec n (ITerm m))
    (ss : RVec m (ITerm k)) : rmap (\lam x => isubst x (snoc (rmap weak ss) (IVar fzero))) (rmap weak ts) = rmap weak (rmap (\lam x => isubst x ss) ts) <= \elim n, ts
        | zero, vnil => idp
        | suc n, snoc ts t => pmap2 snoc (isubst-weak-lemma n m k ts ss) (isubst-weak-lemma-helper t ss)


\function
isubst-assoc
    {n m k : Nat}
    (t : ITerm n)
    (ts : RVec n (ITerm m))
    (ss : RVec m (ITerm k)) : isubst (isubst t ts) ss = isubst t (rmap (\lam x => isubst x ss) ts) <= \elim t
        | IVar i        => isubst-assoc-var-helper n m k i ts ss
        | IApp t1 t2    => pmap2 IApp (isubst-assoc t1 ts ss) (isubst-assoc t2 ts ss)
        | ILam t        => \let
                                | ts' => snoc (rmap weak ts) (IVar fzero)
                                | ss' => snoc (rmap weak ss) (IVar fzero)
                                | p => isubst-assoc t ts' ss'
                                | pt => transport (\lam x => isubst (isubst t ts') ss' = isubst t x) (pmap2 snoc (isubst-weak-lemma n m k ts ss) idp) p
                            \in pmap ILam pt



-- All monadic stuff
-- Lemmata


\function
return-right-unit-funext-helper
    {V : \Type} 
    (e : Either V Unit) : return e = (bind-fun-helper return) e <= \elim e
        | inl v => idp
        | inr unit => idp


{-
bind (fmap {B} {Either B Unit} inl (f a)) (bind-fun-helper g) = fmap {C} {Either C Unit} inl (bind (f a) g)
-}

\function
fmap-inl-shit
    {A : \Type}
    (t : FTerm (Either A Unit)) : fmap {Either A Unit} {Either (Either A Unit) Unit} inl t = fmap (\lam e => map-inl {A} {Either A Unit} {Unit} inl e) t <= \elim t
        | FVar (inl a)          => idp
        | FVar (inr unit)       => {?}
        | FApp t1 t2            => {?}
        | FLam t                => {?}

{-
t : FTerm (Either V Unit)
f' : Either V Unit -> FTerm (Either W Unit)
fmap (map-inl inl) t >>= helper f'
fmap (map-inl inl) (t >>= f')
-}


\function
bind-fmap-comm
    {A B : \Type}
    (t : FTerm A)
    (f : A -> FTerm B) : bind (fmap {A} {Either A Unit} inl t) (bind-fun-helper f) = fmap {B} {Either B Unit} inl (bind t f) <= \elim t
        | FVar v        => idp
        | FApp t1 t2    => pmap2 FApp (bind-fmap-comm t1 f) (bind-fmap-comm t2 f)
        | FLam t        => pmap FLam {?} --(bind-fmap-comm t (bind-fun-helper f))


\function
bind-assoc-funext-helper
    {A B C : \Type}
    (f : A -> FTerm B)
    (g : B -> FTerm C)
    (x : Either A Unit) : bind ((bind-fun-helper f) x) (bind-fun-helper g) = bind-fun-helper (\lam a => bind (f a) g) x <= \elim x
        | inl a     => bind-fmap-comm (f a) g
        | inr unit  => idp


-- Proofs

\function
return-right-unit
    {V : \Type}
    (t : FTerm V) : t `bind` return = t <= \elim t
        | FVar v        => idp
        | FApp t1 t2    => pmap2 FApp (return-right-unit t1) (return-right-unit t2)
        | FLam t        =>  \let
                                | rec       => return-right-unit t
                                | funext    => funExt (\lam _ => FTerm (Either V Unit)) return (bind-fun-helper return) return-right-unit-funext-helper
                                | trrec     => transport (\lam x => bind t x = t) funext rec
                            \in pmap FLam trrec


\function
return-left-unit
    {V W : \Type}
    (x : V)
    (k : V -> FTerm W) : ((return x) `bind` k = k x) => idp


\function
bind-assoc
    {A B C : \Type}
    (f : A -> FTerm B)
    (g : B -> FTerm C)
    (t : FTerm A) : (t `bind` f) `bind` g = t `bind` (\lam x => (f x) `bind` g) <= \elim t
        | FVar v        => idp
        | FApp t1 t2    => pmap2 FApp (bind-assoc f g t1) (bind-assoc f g t2)
        | FLam t        =>  \let
                                | f'    => bind-fun-helper f
                                | g'    => bind-fun-helper g
                                | rec   => bind-assoc f' g' t
                                | fext  => funExt (\lam _ => FTerm (Either C Unit)) (\lam x => (f' x) `bind` g') (bind-fun-helper (\lam x => (f x) `bind` g)) (bind-assoc-funext-helper f g)
                                | trrec => transport (\lam x => (t `bind` f') `bind` g' = t `bind` x) fext rec
                            \in pmap FLam trrec
