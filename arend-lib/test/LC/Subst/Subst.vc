\open ::LC::Term
\open ::LC::Ctx
\open ::LC::Properties
\open ::LC::RVec

\open ::Data::Bool
\open ::Data::Either
\open ::Data::Empty
\open ::Data::Fin
\open ::Data::Nat::Base
\open ::Data::Nat::Compare
\open ::Data::Unit
\open ::Logic
\open ::Paths


\data
IsFree (x : Nat) (t : NTerm)
    | IsFree x (NVar v) 	=> VarIsFree (p : x = v)
    | IsFree x (NApp t1 t2) => AppLeftIsFree (p : IsFree x t1)
    | IsFree x (NApp t1 t2) => AppRightIsFree (p : IsFree x t2)
    | IsFree x (NApp t1 t2) => AppBothIsFree (p : IsFree x t1) (q : IsFree x t2)
    | IsFree x (NLam v t) 	=> LamIsFree (p : x = v -> Empty) (q : IsFree x t)


\function
var-helper-is-free-dec
    (x v : Nat)
    (d : Dec (x = v)) : Dec (IsFree x (NVar v)) <= \elim d
        | inr pro       => inr (VarIsFree pro)
        | inl contra    => inl (\lam p => \case p | VarIsFree q => contra q)


\function
app-helper-is-free-dec
    (x : Nat)
    (t1 t2 : NTerm)
    (d1 : Dec (IsFree x t1))
    (d2 : Dec (IsFree x t2)) : Dec (IsFree x (NApp t1 t2)) <= \elim d1, d2
        | inr pro1, inr pro2        => inr (AppBothIsFree pro1 pro2)
        | inr pro1, inl contra2     => inr (AppLeftIsFree pro1)
        | inl contra1, inr pro2     => inr (AppRightIsFree pro2)
        | inl contra1, inl contra2  => inl (\lam p => \case p | AppLeftIsFree q1 => contra1 q1 | AppRightIsFree q2 => contra2 q2)


\function
lam-helper-is-free-dec
    (x v : Nat)
    (t : NTerm)
    (dv : Dec (x = v))
    (dt : Dec (IsFree x t)) : Dec (IsFree x (NLam v t)) <= \elim dv
        | inr pro       => inl (\lam p => \case p | LamIsFree p q => p pro)
        | inl contra    => \case dt
            | inr pro => inr (LamIsFree contra pro)
            | inl contra => inl (\lam p => \case p | LamIsFree p q => contra q)


\function
isFreeDec
    (x : Nat)
    (t : NTerm) : Dec (IsFree x t) <= \elim t
        | NVar v        => var-helper-is-free-dec x v (x =? v)
        | NApp t1 t2    => app-helper-is-free-dec x t1 t2 (isFreeDec x t1) (isFreeDec x t2)
        | NLam v t      => lam-helper-is-free-dec x v t (x =? v) (isFreeDec x t)


\function
var-helper
	(n m : Nat)
	(d : Dec (n = m))
	(t1 : NTerm)
	(t2 : NTerm) : NTerm <= \elim d
		| inr pro       => t1
        | inl contra    => t2


\function
lam-helper
    (x : Nat)
    (s : NTerm)
    (d : Dec (IsFree x s))
    (t1 : NTerm)
    (t2 : NTerm) : NTerm <= \elim d
        | inr pro       => t1
        | inl contra    => t2


\function
nsubst'
    (t : NTerm)
    (y : Nat)
    (s : NTerm)
    (rho : Nat -> Nat) : NTerm <= \elim t
        | NVar x     => var-helper (rho x) y (rho x =? y) s (NVar (rho x))
        | NApp t1 t2 => NApp (nsubst' t1 y s rho) (nsubst' t2 y s rho)
        | NLam x t   => lam-helper x s (isFreeDec x s) (NLam (suc x) (nsubst' t y s (\lam z => \case (z =? x) | inr pro => suc x | inl contra => rho z))) (NLam x (nsubst' t y s rho))


\function
nsubst
    (t : NTerm)
    (y : Nat)
    (s : NTerm) : NTerm => nsubst' t y s (\lam x => x)


\function
weak
    {n : Nat}
    (t : ITerm n) : ITerm (suc n) <= \elim t
        | IVar i        => IVar (fsuc i)
        | IApp t1 t2    => IApp (weak t1) (weak t2)
        | ILam t        => ILam (weak t)


\function
isubst
    {n m : Nat}
    (t : ITerm n)
    (ss : RVec n (ITerm m)) : ITerm m <= \elim t
        | IVar i        => ss !! i
        | IApp t1 t2    => IApp (isubst t1 ss) (isubst t2 ss)
        | ILam t        => ILam (isubst t (snoc (rmap weak ss) (IVar (from-nat m))))


\function
fmap
    {V W : \Type}
    (f : V -> W)
    (t : FTerm V) : FTerm W <= \elim t
        | FVar v        => FVar (f v)
        | FApp t1 t2    => FApp (fmap f t1) (fmap f t2)
        | FLam t        => FLam (fmap (map-inl f) t)

\function
return
    {V : \Type}
    (v : V) : FTerm V => FVar v


-- Something like Fun n, but parametrized with some type
-- God damn it, i have no idea how to name these types
\function
Telescope
    (n : Nat)
    (V : \Type) : \Type <= \elim n
        | zero  => V
        | suc n => Either (Telescope n V) Unit


\function
fmap-telescope-helper
    {V W : \Type}
    (n : Nat)
    (f : V -> W)
    (x : Either (Telescope n V) Unit) : Either (Telescope n W) Unit <= \elim x
        | inl y     => inl (fmap-telescope n f y)
        | inr unit  => inr unit


\function
fmap-telescope
    {V W : \Type}
    (n : Nat)
    (f : V -> W)
    (x : Telescope n V) : Telescope n W <= \elim n
        | zero  => f x
        | suc n => fmap-telescope-helper n f x


-- T is for Telescope
\function
    twistT-helper
    {V : \Type}
    (n : Nat)
    (t : Either (Telescope n (FTerm V)) Unit) : FTerm (Either (Telescope n V) Unit) <= \elim t
        | inl x => fmap {Telescope n V} {Either (Telescope n V) Unit} inl (twistT n x)
        | inr unit => FVar (inr unit)


\function
twistT
    {V : \Type}
    (n : Nat)
    (x : Telescope n (FTerm V)) : FTerm (Telescope n V) <= \elim n
        | zero  => x
        | suc n => twistT-helper n x


\function
bind-helper
    {V W : \Type}
    (n : Nat)
    (t : FTerm (Telescope n V))
    (k : V -> FTerm W) : FTerm (Telescope n W) <= \elim t
        | FVar x        => twistT n (fmap-telescope n k x)
        | FApp t1 t2    => FApp (bind-helper n t1 k) (bind-helper n t2 k)
        | FLam t        => FLam (bind-helper (suc n) t k)


\function
bind
    {V W : \Type}
    (t : FTerm V)
    (k : V -> FTerm W) : FTerm W => bind-helper zero t k
