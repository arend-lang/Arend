\open ::LC::Relation::Fresh
\open ::LC::Term::Term
\open ::LC::Util::Ctx
\open ::LC::Util::RVec

\open ::Combinators
\open ::Data::Bool
\open ::Data::Either
\open ::Data::Empty
\open ::Data::Fin
\open ::Data::List \hiding(concat, snoc)
\open ::Data::Nat::Base
\open ::Data::Nat::Compare
\open ::Data::Unit
\open ::Logic
\open ::Paths


\data
IsFree (x : Nat) (t : NTerm)
    | IsFree x (NVar v) 	=> VarIsFree (p : x = v)
    | IsFree x (NApp t1 t2) => AppLeftIsFree (p : IsFree x t1)
    | IsFree x (NApp t1 t2) => AppRightIsFree (p : IsFree x t2)
    | IsFree x (NApp t1 t2) => AppBothIsFree (p : IsFree x t1) (q : IsFree x t2)
    | IsFree x (NLam v t) 	=> LamIsFree (p : x != v) (q : IsFree x t)


\function
var-helper-is-free-dec
    (x v : Nat)
    (d : Dec (x = v)) : Dec (IsFree x (NVar v)) <= \elim d
        | inr pro => inr (VarIsFree pro)
        | inl con => inl (\lam p => \case p | VarIsFree q => con q)


\function
app-helper-is-free-dec
    (x : Nat)
    (t1 t2 : NTerm)
    (d1 : Dec (IsFree x t1))
    (d2 : Dec (IsFree x t2)) : Dec (IsFree x (NApp t1 t2)) <= \elim d1, d2
        | inr pro1, inr pro2 => inr (AppBothIsFree pro1 pro2)
        | inr pro1, inl con2 => inr (AppLeftIsFree pro1)
        | inl con1, inr pro2 => inr (AppRightIsFree pro2)
        | inl con1, inl con2 => inl (\lam p => \case p | AppLeftIsFree q1 => con1 q1 | AppRightIsFree q2 => con2 q2 | AppBothIsFree p1 q1 => con1 p1)


\function
lam-helper-is-free-dec
    (x v : Nat)
    (t : NTerm)
    (dv : Dec (x = v))
    (dt : Dec (IsFree x t)) : Dec (IsFree x (NLam v t)) <= \elim dv
        | inr pro => inl (\lam p => \case p | LamIsFree p q => p pro)
        | inl con => \case dt
            | inr pro => inr (LamIsFree con pro)
            | inl con => inl (\lam p => \case p | LamIsFree p q => con q)


\function
isFreeDec
    (x : Nat)
    (t : NTerm) : Dec (IsFree x t) <= \elim t
        | NVar v        => var-helper-is-free-dec x v (x =? v)
        | NApp t1 t2    => app-helper-is-free-dec x t1 t2 (isFreeDec x t1) (isFreeDec x t2)
        | NLam v t      => lam-helper-is-free-dec x v t (x =? v) (isFreeDec x t)


-- t[x -> y]
\function
nsubst-var
    (t : NTerm)
    (x y : Nat) : NTerm <= \elim t
        | NVar z        => \case z =? x | inr _ => NVar y | inl _ => NVar z;
        | NApp t1 t2    => NApp (nsubst-var t1 x y) (nsubst-var t2 x y)
        | NLam z t      => \case z =? x | inr _ => NLam y (nsubst-var t x y) | inl _ => NLam z (nsubst-var t x y)


\function
vars (t : NTerm) : List Nat <= \elim t
        | NVar x        => singleton x
        | NApp t1 t2    => vars t1 ++ vars t2
        | NLam x t      => x :-: vars t


\function
maxl (l : List Nat) : Nat => foldr max zero l


\function
gen-fresh-var (ts : List NTerm) : Nat => suc (maxl (concatMap vars ts))


\function
lookup
    (ps : List (\Sigma Nat NTerm))
    (x : Nat) : NTerm <= \elim ps
        | nil           => NVar x
        | (:-:) p ps    =>  \case p.1 =? x
                                | inr _ => p.2
                                | inl _ => lookup ps x 


\function
nsubst
    (t : NTerm)
    (ps : List (\Sigma Nat NTerm)) : NTerm <= \elim t
        | NVar x        => lookup ps x 
        | NApp t1 t2    => NApp (nsubst t1 ps) (nsubst t2 ps)
        | NLam x t      =>  \let
                                | ts => (NLam x t) :-: (map (\lam (p : \Sigma Nat NTerm)  => p.2) ps)
                                | x' => gen-fresh-var ts
                            \in NLam x' (nsubst t ((x, NVar x') :-: ps))


\function
weak
    {n : Nat}
    (t : ITerm n) : ITerm (suc n) <= \elim t
        | IVar i        => IVar (fsuc i)
        | IApp t1 t2    => IApp (weak t1) (weak t2)
        | ILam t        => ILam (weak t)


\function
isubst
    {n m : Nat}
    (t : ITerm n)
    (ss : RVec n (ITerm m)) : ITerm m <= \elim t
        | IVar i        => ss !! i
        | IApp t1 t2    => IApp (isubst t1 ss) (isubst t2 ss)
        | ILam t        => ILam (isubst t (snoc (rmap weak ss) (IVar fzero)))


\function
fmap
    {V W : \Set}
    (f : V -> W)
    (t : FTerm V) : FTerm W <= \elim t
        | FVar v        => FVar (f v)
        | FApp t1 t2    => FApp (fmap f t1) (fmap f t2)
        | FLam t        => FLam (fmap (map-inl f) t)


\function
return
    {V : \Set}
    (v : V) : FTerm V => FVar v


\function
bind-fun-helper
    {V W : \Set}
    (k : V -> FTerm W)
    (e : Either V Unit) : FTerm (Either W Unit) <= \elim e
        | inl v     => fmap {W} {Either W Unit} inl (k v)
        | inr unit  => FVar (inr unit)


\function
bind
    {V W : \Set}
    (t : FTerm V)
    (k : V -> FTerm W) : FTerm W <= \elim t
        | FVar x        => k x
        | FApp t1 t2    => FApp (t1 `bind` k) (t2 `bind` k)
        | FLam t        => FLam (t `bind` (bind-fun-helper k))
