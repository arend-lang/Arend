\open ::LC::Term
\open ::LC::Ctx
\open ::LC::Properties
\open ::LC::RVec

\open ::Data::Either
\open ::Data::Nat::Base
\open ::Data::Unit

{-
-- TODO: what should i do with contexts?

\function
nsubst
    {n m : Nat}
    (env1 : Ctx n)
    (t1 : NTerm)
    (p1 : TermInCtx env1 t1)
    (x : Nat)
    (proof : VarInCtx env1 x)
    (env2 : Ctx m)
    (t2 : NTerm)
    (p2 : TermInCtx env2 t2) : \Sigma (env' : Ctx (pred (n + m))) (t' : NTerm) (p' : TermInCtx env' t') <= \elim t1, p1
        | NVar x, Variable p        => ({?}, {?}, {?})
        | NApp m n, Application p q => ({?}, {?}, {?})
        | NLam x t, Abstraction p   => ({?}, {?}, {?})


\function
isubst
    {n m : Nat}
    (t : ITerm n)
    (ts : RVec n (ITerm m)) : ITerm m <= \elim t
        | IVar i        => ts !! i
        | IApp t1 t2    => IApp (isubst t1 ts) (isubst t2 ts)
        | ILam t        => ILam {?}
-}

-- http://stackoverflow.com/questions/35926898/are-parameterized-lambda-terms-a-monad

\function
return
    {V : \Type}
    (v : V) : FTerm V => FVar v


\function
fmap
    {V W : \Type}
    (f : V -> W)
    (t : FTerm V) : FTerm W <= \elim t
        | FVar v        => FVar (f v)
        | FApp t1 t2    => FApp (fmap f t1) (fmap f t2)
        | FLam t        => FLam (fmap (map-inl f) t)



\function
twist
    {V : \Type}
    (x : Either (FTerm V) Unit) : FTerm (Either V Unit) <= \elim x
        | inl t     => fmap inl t
        | inr unit  => FVar (inr unit)


{-
\function
join
    {V : \Type}
    (t : FTerm (FTerm V)) : FTerm V <= \elim t
        | FVar t        => t
        | FApp t1 t2    => FApp (join t1) (join t2)
        | FLam t        => {?} -- FLam (join (fmap twist t)) -- termination =(


\function
bind
    {V W : \Type}
    (t : FTerm V)
    (k : V -> FTerm W) : FTerm W => join (fmap k t)
-}

{-
e : FTerm (Maybe a)
k : a -> FTerm b
? : Fterm (Maybe b)
-}


-- Something like Fun n, but parametrized with some type
-- God damn it, i have no idea how to name these types
\function
Telescope
    (n : Nat)
    (V : \Type) : \Type <= \elim n
        | zero  => Either V Unit
        | suc n => Either (Telescope n V) Unit

\function
fmap-telescope
    {V W : \Type}
    (n : Nat)
    (f : V -> W)
    (x : Telescope n V) : Telescope n W <= \elim n
        | zero  => map-inl f x
        | suc n => fmap-telescope-helper n f x
        \where
            \function
                fmap-telescope-helper
                    {V W : \Type}
                    (n : Nat)
                    (f : V -> W)
                    (x : Either (Telescope n V) Unit) : Either (Telescope n W) Unit <= \elim x
                        | inl y     => inl (fmap-telescope n f y)
                        | inr unit  => inr unit


-- T is for Telescope
\function
twistT
    {V : \Type}
    (n : Nat)
    (x : Telescope n (FTerm V)) : FTerm (Telescope n V) <= \elim n
        | zero  => twist x
        | suc n => twistT-helper n x
        \where
            \function
                twistT-helper
                {V : \Type}
                (n : Nat)
                (t : Either (Telescope n (FTerm V)) Unit) : FTerm (Either (Telescope n V) Unit) <= \elim t
                    | inl x => {?}
                    | inr unit => FVar (inr unit)


\function
bind-helper'
    {V W : \Type}
    (n : Nat)
    (t : FTerm (Telescope n V))
    (k : V -> FTerm W) : FTerm (Telescope n W) <= \elim t
        | FVar x         => \let
                                | x' => fmap-telescope n k x
                                | x'' => twistT n x'
                            \in FVar {?}
        | FApp t1 t2     => FApp (bind-helper' n t1 k) (bind-helper' n t2 k)
        | FLam t         => FLam (bind-helper' (suc n) t k)

{-
\function
bind-helper
    {V W : \Type}
    (n : Nat)
    (t : FTerm (Telescope n V))
    (k : V -> FTerm W) : FTerm (Telescope n W) <= \elim n, t
        | zero, FVar x          => twist (map-inl k x)
        | zero, FApp t1 t2      => FApp (bind-helper zero t1 k) (bind-helper zero t2 k)
        | zero, FLam t          => FLam (bind-helper (suc zero) t k)
        | suc n, FVar x         => {?}
        | suc n, FApp t1 t2     => {?} -- bind-helper n (FApp t1 t2) k
        | suc n, FLam t         => {?} -- FLam (bind-helper (suc (suc n)) t k)





\function
bind
    {V W : \Type}
    (t : FTerm V)
    (k : V -> FTerm W) : FTerm W <= \elim t
        | FVar x        => k x
        | FApp t1 t2    => FApp (bind t1 k) (bind t2 k)
        | FLam t        => FLam (bind-helper zero t k)
-}
