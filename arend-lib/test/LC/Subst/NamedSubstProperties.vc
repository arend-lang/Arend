\open ::LC::Relation::AlphaEq
\open ::LC::Relation::Fresh
\open ::LC::Subst::Subst
\open ::LC::Term::Term
\open ::LC::Util::RVec


\open ::Combinators
\open ::Data::Bool
\open ::Data::Either
\open ::Data::Empty
\open ::Data::Fin
\open ::Data::List::In
\open ::Data::List \hiding (concat, snoc)
\open ::Data::Nat::Base
\open ::Data::Nat::Compare
\open ::Data::Unit
\open ::Logic
\open ::Paths


-- Named substitution properties

-- Some helper notes


\function
nsubst-var-respects-alpha-eq-var-helper
    (x1 x2 x y : Nat)
    (d1 : Dec (x1 = x))
    (d2 : Dec (x2 = x))
    (pr : x1 = x2) : AlphaEq (\case d1 | inl _ => NVar x1 | inr _ => NVar y;) (\case d2 | inl _ => NVar x2 | inr _ => NVar y;) <= \elim d1, d2
        | inr pro1, inr pro2 => VarEq idp
        | inr pro1, inl con2 => absurd (con2 ((inv pr) *> pro1))
        | inl con1, inr pro2 => absurd (con1 (pr *> pro2))
        | inl con1, inl con2 => VarEq pr


\function
nsubst-var-respects-alpha-eq-lam-helper
    (x1 x2 x y : Nat)
    (t1 t2 : NTerm)
    (d1 : Dec (x1 = x))
    (d2 : Dec (x2 = x))
    (f : Nat)
    (ne1 : f != x1)
    (ne2 : f != x2)
    (p1 : f # t1)
    (p2 : f # t2)
    (pr : AlphaEq (nsubst-var t1 x1 f) (nsubst-var t2 x2 f)) : AlphaEq (\case d1 | inl _ => NLam x1 (nsubst-var t1 x y) | inr _ => NLam y (nsubst-var t1 x y);) (\case d2 | inl _ => NLam x2 (nsubst-var t2 x y) | inr _ => NLam y (nsubst-var t2 x y);) <= \elim d1, d2 
        | inr pro1, inr pro2 => {?}
        | inr pro1, inl con2 => {?} --LamEq {?} {?} {?} {?} {?} {?}
        | inl con1, inr pro2 => {?} --LamEq {?} {?} {?} {?} {?} {?}
        | inl con1, inl con2 => {?} --LamEq {?} {?} {?} {?} {?} {?}
        

\function
nsubst-var-respects-alpha-eq
    (t1 t2 : NTerm)
    (x y : Nat)
    (p : t1 `AlphaEq` t2) : nsubst-var t1 x y `AlphaEq` nsubst-var t2 x y <= \elim t1, t2, p
        | NVar x1, NVar x2, VarEq pr                        => nsubst-var-respects-alpha-eq-var-helper x1 x2 x y (x1 =? x) (x2 =? x) pr
        | NApp t1 t2, NApp s1 s2, AppEq p q                 => AppEq (nsubst-var-respects-alpha-eq t1 s1 x y p) (nsubst-var-respects-alpha-eq t2 s2 x y q) 
        | NLam x1 t1, NLam x2 t2, LamEq f ne1 ne2 p1 p2 pr  => nsubst-var-respects-alpha-eq-lam-helper x1 x2 x y t1 t2 (x1 =? x) (x2 =? x) f ne1 ne2 p1 p2 pr


{-
\function
nsubst-right-unit-var-helper
    (v x : Nat)
    (d : Dec (x = v)) : AlphaEq (\case d | inr _ => NVar x | inl _ => NVar v) (NVar v) <= \elim d
        | inr pro => VarEq pro
        | inl con => VarEq idp


\function
nsubst-right-unit
   (t : NTerm)
   (x : Nat) : nsubst t (singleton (x, (NVar x))) `AlphaEq` t <= \elim t
        | NVar v     => nsubst-right-unit-var-helper v x (x =? v) 
        | NApp t1 t2 => AppEq (nsubst-right-unit t1 x) (nsubst-right-unit t2 x)
        | NLam v t   => LamEq {?}


\function
nsubst-left-unit-helper
    (x : Nat)
    (t : NTerm)
    (d : Dec (x = x)) : AlphaEq (lookup-helper x (x, t) nil d) t <= \elim d
        | inr pro => alpha-eq-refl
        | inl con => absurd (con idp)

\function
nsubst-left-unit
    (t : NTerm)
    (x : Nat) : nsubst (NVar x) (singleton (x, t)) `AlphaEq` t => nsubst-left-unit-helper x t (x =? x) 
-}
{-
\function
nsubst-assoc
    (t N M : NTerm)
    (x y : Nat)
    (p : Not (x = y))
    (pr : Not (IsFree x M)) : nsubst (nsubst t x N) y M `AlphaEq` nsubst (nsubst t y M) x (nsubst N y M) => {?}
-}
