\open ::LC::Subst::Subst
\open ::LC::Term
\open ::LC::RVec

\open ::Combinators
\open ::Data::Bool
\open ::Data::Either
\open ::Data::Empty
\open ::Data::Fin
\open ::Data::Nat::Base
\open ::Data::Nat::Compare
\open ::Data::Unit
\open ::Logic
\open ::Paths


-- All monadic stuff

--  fmap props

\function
map-inl-respects-id
    {L R : \Type}
    (e : Either L R) : map-inl (\lam x => x) e = e <= \elim e
        | inl l => idp
        | inr r => idp


\function
map-inl-respects-comp
    {A B C R : \Type}
    (f : A -> B)
    (g : B -> C)
    (e : Either A R) : map-inl g (map-inl f e) = map-inl (g `o` f) e <= \elim e
        | inl l => idp
        | inr r => idp


\function
fmap-respects-id
    {V : \Type}
    (t : FTerm V) : fmap (\lam x => x) t = t <= \elim t
        | FVar v => idp
        | FApp t1 t2 => pmap2 FApp (fmap-respects-id t1) (fmap-respects-id t2)
        | FLam t => \let
                        | rec => fmap-respects-id t
                        | fext => funExt (\lam _ => Either V Unit) (\lam x => x) (map-inl (\lam x => x)) (\lam e => inv (map-inl-respects-id e))
                        | rect => transport (\lam x => fmap {Either V Unit} {Either V Unit} x t = t) fext rec
                    \in pmap FLam rect


\function
fmap-respects-comp
    {A B C : \Type}
    (f : A -> B)
    (g : B -> C)
    (t : FTerm A) : fmap g (fmap f t) = fmap (g `o` f) t <= \elim t
        | FVar v => idp
        | FApp t1 t2 => pmap2 FApp (fmap-respects-comp f g t1) (fmap-respects-comp f g t2)
        | FLam t => \let
                        | rec => fmap-respects-comp (map-inl {A} {B} {Unit} f) (map-inl {B} {C} {Unit} g) t
                        | fext => funExt (\lam _ => Either C Unit) (\lam x => map-inl {B} {C} {Unit} g (map-inl {A} {B} f x)) (map-inl (g `o` f)) (map-inl-respects-comp f g)
                        | trrec => transport (\lam x => fmap (map-inl {B} {C} {Unit} g) (fmap (\lam (e : Either A Unit) => map-inl {A} {B} {Unit} f e) t) = fmap x t) fext rec
                    \in pmap FLam trrec


-- Helper lemmata

\function
return-right-unit-funext-helper
    {V : \Type}
    (e : Either V Unit) : return e = (bind-fun-helper return) e <= \elim e
        | inl v => idp
        | inr unit => idp


\function
Telescope
    (n : Nat)
    (A : \Type) : \Type <= \elim n
        | zero  => A
        | suc n => Either (Telescope n A) Unit


\function
map-inl-iterate
    {A : \Type}
    (n : Nat) : Telescope n A -> Telescope (suc n) A <= \elim n
        | zero  => inl
        | suc n => map-inl {_} {_} {Unit} (map-inl-iterate n)


\function
bind-fun-helper-iterate
    {A B : \Type}
    (n : Nat)
    (f : A -> FTerm B) : Telescope n A -> FTerm (Telescope n B) <= \elim n
        | zero  => f
        | suc n => bind-fun-helper (bind-fun-helper-iterate n f)

{-
fmap {Either (Telescope n B) Unit} {Either (Either (Telescope n B) Unit) Unit} inl ((bind-fun-helper-iterate (suc n) f) (map-inl-iterate {A} n t)) =
fmap {Either (Telescope n B) Unit} {Either (Either (Telescope n B) Unit) Unit} (map-inl-iterate {B} (suc n)) (fmap {Telescope n B} {Either (Telescope n B) Unit} inl (bind-fun-helper-iterate {A} {B} n f t))
-}

\function
bind-fmap-comm-lemma-helper
    {A B : \Type}
    (n : Nat)
    (t : Telescope (suc n) A)
    (f : A -> FTerm B) : fmap {Either _ Unit} {Either _ Unit} inl ((bind-fun-helper-iterate (suc (suc n)) f) (map-inl-iterate {A} (suc n) t)) = fmap {Either _ Unit} {Either _ Unit} (map-inl-iterate {B} (suc (suc n))) (fmap {_} {Either _ Unit} inl (bind-fun-helper-iterate {A} {B} (suc n) f t)) <= \elim t
        | inl t     => {?}
        | inr unit  => idp



\function
bind-fmap-comm-lemma
    {A B : \Type}
    (n : Nat)
    (t : Telescope n A)
    (f : A -> FTerm B) : fmap {Either _ Unit} {Either _ Unit} inl ((bind-fun-helper-iterate (suc n) f) (map-inl-iterate {A} n t)) = fmap {Either _ Unit} {Either _ Unit} (map-inl-iterate {B} (suc n)) (fmap {_} {Either _ Unit} inl (bind-fun-helper-iterate {A} {B} n f t)) <= \elim n
        | zero => {?}
        | suc n => bind-fmap-comm-lemma-helper n t f


\function
bind-fmap-comm
    {A B : \Type}
    (n : Nat)
    (t : FTerm (Telescope n A))
    (f : A -> FTerm B) : bind (fmap (map-inl-iterate {A} n) t) (bind-fun-helper-iterate (suc n) f) = fmap (map-inl-iterate {B} n) (bind t (bind-fun-helper-iterate n f)) <= \elim n, t
        | zero, FVar v              => idp
        | suc n, FVar (inl t)       => bind-fmap-comm-lemma n t f
                                        -- \let
                                        --     | comp => fmap-respects-comp {Telescope n B} {Either (Telescope n B) Unit} {Either (Either (Telescope n B) Unit) Unit} (inl) (map-inl-iterate {B} (suc n)) (bind-fun-helper-iterate {A} {B} n f t)
                                        -- \in {?}
        | suc n, FVar (inr unit)    => idp
        | _, FApp t1 t2             => pmap2 FApp (bind-fmap-comm n t1 f) (bind-fmap-comm n t2 f)
        | _, FLam t                 => pmap FLam (bind-fmap-comm (suc n) t f)


\function
bind-assoc-funext-helper
    {A B C : \Type}
    (f : A -> FTerm B)
    (g : B -> FTerm C)
    (x : Either A Unit) : bind ((bind-fun-helper f) x) (bind-fun-helper g) = bind-fun-helper (\lam a => bind (f a) g) x <= \elim x
        | inl a     => bind-fmap-comm zero (f a) g
        | inr unit  => idp


-- Proofs

\function
return-right-unit
    {V : \Type}
    (t : FTerm V) : t `bind` return = t <= \elim t
        | FVar v        => idp
        | FApp t1 t2    => pmap2 FApp (return-right-unit t1) (return-right-unit t2)
        | FLam t        =>  \let
                                | rec       => return-right-unit t
                                | funext    => funExt (\lam _ => FTerm (Either V Unit)) return (bind-fun-helper return) return-right-unit-funext-helper
                                | trrec     => transport (\lam x => bind t x = t) funext rec
                            \in pmap FLam trrec


\function
return-left-unit
    {V W : \Type}
    (x : V)
    (k : V -> FTerm W) : ((return x) `bind` k = k x) => idp


\function
bind-assoc
    {A B C : \Type}
    (f : A -> FTerm B)
    (g : B -> FTerm C)
    (t : FTerm A) : (t `bind` f) `bind` g = t `bind` (\lam x => (f x) `bind` g) <= \elim t
        | FVar v        => idp
        | FApp t1 t2    => pmap2 FApp (bind-assoc f g t1) (bind-assoc f g t2)
        | FLam t        =>  \let
                                | f'    => bind-fun-helper f
                                | g'    => bind-fun-helper g
                                | rec   => bind-assoc f' g' t
                                | fext  => funExt (\lam _ => FTerm (Either C Unit)) (\lam x => (f' x) `bind` g') (bind-fun-helper (\lam x => (f x) `bind` g)) (bind-assoc-funext-helper f g)
                                | trrec => transport (\lam x => (t `bind` f') `bind` g' = t `bind` x) fext rec
                            \in pmap FLam trrec
