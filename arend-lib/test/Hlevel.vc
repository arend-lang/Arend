\open ::Paths
\open ::Combinators
\open ::Equiv

\function
isContr (A : \Type) => \Sigma (a : A) (\Pi (a' : A) -> a = a')

\function
I-isContr : isContr I => (left, \lam i => path (\lam j => squeeze i j))

\function
isProp (A : \Type) => \Pi (a a' : A) -> a = a'

\function
isSet (A : \Type) => \Pi (a a' : A) -> isProp (a = a')

\function
ofHlevel (n : Nat) (A : \Type) : \Type => \elim n
    | zero => isContr A
    | suc n => \Pi (a a' : A) -> ofHlevel n (a = a')

\function
prop-eq {A B : \Type} (pa : isProp A) (pb : isProp B) (f : A -> B) (g : B -> A) : A = B 
    => equiv-to-path (f, ((g, \lam _ => pa _ _), (g, \lam _ => pb _ _)))

\function
ofHlevel1-isProp (A : \Type) (f : ofHlevel (suc zero) A) : isProp A => \lam a a' => (f a a').1

\function
ofHlevel2-isSet (A : \Type) (f : ofHlevel 2 A) : isSet A => \lam a a' => ofHlevel1-isProp (a = a') (f a a')

\function
ofHlevel1-eq-isProp (A : \Type) : ofHlevel 1 A = isProp A 
    => prop-eq (ofHlevel-isProp 1 A) (isProp-isProp A) (ofHlevel1-isProp A) (isProp-ofHlevel1 A)

\function
ofHlevel2-eq-isSet (A : \Type) : ofHlevel 2 A = isSet A 
    => prop-eq (ofHlevel-isProp 2 A) (isSet-isProp A) (ofHlevel2-isSet A) (isSet-ofHlevel2 A)

\function
contr-codom (A : \Type) (B : A -> \Type) (nT : \Pi (a : A) -> isContr (B a)) : isContr (\Pi (a : A) -> B a) => 
    \let f0 : \Pi (a : A) -> B a => \lam a => (nT a).1
    \in (f0, \lam f1 => funExt B f0 f1 (\lam a => inv ((nT a).2 (f0 a)) *> (nT a).2 (f1 a)))

\function
ofHlevel-codom (A : \Type) (B : A -> \Type) (n : Nat) (nT : \Pi (a : A) -> ofHlevel n (B a)) : ofHlevel n (\Pi (a : A) -> B a) => \elim n
    | zero => contr-codom A B nT
    | suc n' => \lam f0 f1 => (
        \let | IH => ofHlevel-codom A (\lam a => f0 a = f1 a) n' (\lam a => nT a (f0 a) (f1 a))
             | A0 : ofHlevel n' (\Pi (a : A) -> f0 a = f1 a) => IH
        \in transport (\lam eq => ofHlevel n' eq) (inv (funExt-eq B f0 f1)) A0)

\function
isContr-isProp (A : \Type) (c : isContr A) : isProp A => \lam a a' => inv (c.2 a) *> c.2 a'

\function
isProp-fun-isContr (A : \Type) : (A -> isContr A) = isProp A => 
    \let A1 : isProp (A -> isContr A) => \lam y y' => funExt (\lam x0 => isContr A) y y' (\lam z => ofHlevel-isProp 0 A (y z) (y' z))
    \in prop-eq A1 (isProp-isProp A) (isProp-isContr A) (\lam f a => (a, f a))

\function
ofHlevel-suc {E : \Type} {n : Nat} (nT : ofHlevel n E) : ofHlevel (suc n) E => \elim n
    | zero => transport id (inv (ofHlevel1-eq-isProp E)) (isContr-isProp E nT)
    | suc n' => \lam a a' => ofHlevel-suc {a = a'} {n'} (nT a a')

\function
isProp-ofHlevel1 (A : \Type) (f : isProp A) : ofHlevel (suc zero) A => \lam a a' => (inv (f a a) *> f a a', Jl (\lam x q => inv (f a a) *> f a x = q) (inv-concat (f a a)))

\function
isSet-ofHlevel2 (A : \Type) (f : isSet A) : ofHlevel 2 A => \lam a a' => isProp-ofHlevel1 (a = a') (f a a')

\function
isProp-isSet (A : \Type) (p : isProp A) : isSet A => \lam a a' => isContr-isProp (a = a') (isProp-ofHlevel1 A p a a')

\function
SigmaExt {A : \Type} (B : A -> \Type) (x y : \Sigma (a : A) (B a)) (p : x.1 = y.1) (q : transport B p x.2 = y.2) : x = y
    => path (\lam i => (p @ i, pathOver q @ i))

\function
isContrFun-isProp (A : \Type) : isProp (isContr A) =>
    \lam c1 c2 => SigmaExt (\lam a => \Pi (a' : A) -> a = a') c1 c2 (c1.2 (c2.1))
    (path (\lam i a' => isProp-isSet A (isContr-isProp A c1) (c2.1) a'
        (transport (\lam a => \Pi (a' : A) -> a = a') (c1.2 (c2.1)) (c1.2) a') (c2.2 a') @ i))

\function
isProp-isProp (A : \Type) : isProp (isProp A) => \lam f g => path (\lam i a a' => isProp-isSet A f a a' (f a a') (g a a') @ i)

\function
isSet-isProp (A : \Type) : isProp (isSet A) => \lam p1 p2 => funExt (\lam a => \Pi (a' : A) -> isProp (a = a')) p1 p2
    (\lam a => funExt (\lam a' => isProp (a = a')) (p1 a) (p2 a) (\lam a' => (
        \let A0 => isProp-isProp (a = a')
        \in A0 (p1 a a') (p2 a a'))))

\function
ofHlevel-isProp (n : Nat) (A : \Type) : isProp (ofHlevel n A) => \elim n
    | zero => isContrFun-isProp A
    | suc n => \lam f g => path (\lam i a a' => ofHlevel-isProp n (a = a') (f a a') (g a a') @ i)

\function
depfun-preserve-contr {A : \Type} (B : A -> \Type) (c : \Pi (a : A) -> isContr (B a)) : isContr (\Pi (a : A) -> B a) => 
    \let section => \lam a => (c a).1
    \in (section, \lam f => funExt B section f (\lam a => (c a).2 (f a)))

\function
depfun-preserve-prop {A : \Type} (B : A -> \Type) (c : \Pi (a : A) -> isProp (B a)) : isProp (\Pi (a : A) -> B a) 
    => \lam y y' => funExt (\lam a => B a) y y' (\lam a => c a (y a) (y' a))

\function
ofHlevel-map (X : \Type) (n : Nat) (f : X -> ofHlevel (suc n) X) : ofHlevel (suc n) X => \lam a a' => f a a a'

\function
ofHlevel-sigma {A : \Type} (B : A -> \Type) {n : Nat} (nTA : ofHlevel n A) (nTB : \Pi (a : A) -> ofHlevel n (B a)) :
    ofHlevel n (\Sigma (a : A) (B a)) => \elim n
    | zero => transport (\lam (T : \Type) => isContr T) (inv (equiv-to-path (sigma-contr-fibers B nTB))) nTA
    | suc n' => \lam a a' => transport (\lam T => ofHlevel n' T) (inv (equiv-to-path (sigma-equiv B a a')))
        (ofHlevel-sigma (\lam (p : a.1 = a'.1) => transport B p a.2 = a'.2) (nTA a.1 a'.1)
            (\lam p => nTB a'.1 (transport B p a.2) a'.2))

\function
Types (n : Nat) => \Sigma (A : \Type) (ofHlevel n A)

\function
eq-sigma-prop {A : \Type} (P : A -> \Type) (pr : \Pi (x : A) -> isProp (P x)) (u v : \Sigma (x : A) (P x)) (p : u.1 = v.1) : u = v 
    => sigma-ext-eq P {u} {v} (p, pr v.1 _ _)

\function
Types-eq (n : Nat) (A B : n Types`) : (A = B) =~= (A.1 = B.1) => 
    \let | P => \lam C => ofHlevel n C
         | F => \lam (p : A = B) => (sigma-eq-ext P p).1
         | G => \lam (p : A.1 = B.1) => eq-sigma-prop P (\lam A => ofHlevel-isProp n A) A B p
         | A0 => equiv-to-path (sigma-equiv P A B)
         | TI => transp-invpath-linv id A0
    \in (F, ((G, \lam x => inv (TI (G (F x))) *>
            pmap (\lam z => transport id (inv A0) z) (eq-sigma-prop {A.1 = B.1} (\lam p => transport P p A.2 = B.2)
                (\lam p => isProp-isSet (ofHlevel n B.1) (ofHlevel-isProp n B.1) _ _) (transport id A0 (G (F x))) (transport id A0 x) idp) *> TI x),
            (G, \lam x => idp)))

\function
ofHlevel-embedding {A B : \Type} {n : Nat} (f : A -> B) (e : is_embedding f) (nT : ofHlevel (suc n) B) : ofHlevel (suc n) A 
    => \lam x y => transport (\lam z => ofHlevel n z) (inv (equiv-to-path (pmap f, e x y))) (nT (f x) (f y))

\function
isequiv-isProp (A B : \Type) (f : A -> B) : isProp (isequiv f) => {?}

\function
proj-embedding (A B : \Type) : is_embedding (\lam (x : A =~= B) => x.1) => \lam x y => (
    \let G => \lam (p : x.1 = y.1) => sigma-ext-eq (isequiv {A} {B}) (p, {?})
    \in ((G, {?}), (G, {?})))

\function
ofHlevel-Types (n : Nat) : ofHlevel (suc n) (n Types`) => {?}
