\open Paths
\open Combinators
\open Logic

\static \function \infix 2
(~) {A B : \Type0} (f : A -> B) (g : A -> B) => \Pi (x : A) -> f x = g x

\static \function
linv {A B : \Type0} (f : A -> B) => \Sigma (g : B -> A) (g `o` f ~ id)

\static \function
rinv {A B : \Type0} (f : A -> B) => \Sigma (g : B -> A) (f `o` g ~ id)

\static \function
isequiv {A B : \Type0} (f : A -> B) => \Sigma (linv f) (rinv f)

\static \function \infix 2
(=~=) (A : \Type0) (B : \Type0) => \Sigma (f : A -> B) (isequiv f)

\static \function fun-ext {A B : \Type0} {f g : A -> B} (p : f ~ g) : f = g =>
  path (\lam i => (\lam x => p x @ i))

-- Quasi-equivalences

\static \function
qinv {A B : \Type0} (f : A -> B) => \Sigma (g : B -> A) (g `o` f ~ id) (f `o` g ~ id)

\static \function
sigma-equiv {A : \Type0} {P : A -> \Type0} {w w' : \Sigma (x : A) (px : P x)} 
            (y : \Sigma (p : w.1 = w'.1) (transport P p w.2 = w'.2)) : w = w' => 
path (\lam i =>  (y.1 @ i, pathOver y.2 @ i))

\static \function
qinv-to-equiv {A B : \Type0} {f : A -> B} (x : qinv f) : isequiv f => 
  ((x.1, x.3), (x.1, x.2))

\static \function
equiv-to-qinv {A B : \Type0} (f : A -> B) (x : isequiv f) : qinv f => 
  (x.1.1 `o` f `o` x.2.1, 
   \lam x' => pmap f (x.1.2 $ x.2.1 x') *> x.2.2 x',
   \lam x' => pmap x.1.1 (x.2.2 $ f x') *> x.1.2 x'
  )

-- Half Adjoin Equivalences

\static \function
hae {A B : \Type0} (f : A -> B) => 
  \Sigma (g : B -> A) (eta : g `o` f ~ id) (eps : f `o` g ~ id) 
    (tau : \Pi (x : A) -> pmap f (eta x) = eps (f x))

\static \function 
section {A : \Type0} {a a' : A} (p q : a = a') (e : p = q) (i : I) : (p @ i = q @ i) => pmap (\lam p => p @ i) e

\static \function 
cancel {A : \Type0} {a a' a'' : A} (p q : a = a') (p' q' : a' = a'') (h : p = q) (e : p *> p' = q *> q') : p' = q' 
 => \let | h1 : inv p *> p *> p' = inv p *> q *> q' => pmap (concat (inv p)) e
         | h2 : inv p *> q *> q' = inv q *> q *> q' => pmap (\lam r => inv r *> q *> q') h
    \in p'                 ==< inv (concat-idp p') >==
        idp *> p'          ==< pmap (\lam r => r *> p') (inv (inv-concat p)) >==
        (inv p *> p) *> p' ==< concat-assoc (inv p) p p' >==
        inv p *> p *> p'   ==< pmap (concat (inv p)) e >==
        inv p *> q *> q'   ==< pmap (\lam r => inv r *> q *> q') h >==
        inv q *> q *> q'   ==< inv (concat-assoc (inv q) q q') >==
        (inv q *> q) *> q' ==< pmap (\lam r => r *> q') (inv-concat q) >==
        idp *> q'          ==< concat-idp q' >==
        q'                 !qed

\static \function
hae-tau-equiv {A B : \Type0} (f : A -> B) (g : B -> A) (eta : g `o` f ~ id) (eps : f `o` g ~ id) 
  (tau : \Pi (x : A) -> pmap f (eta x) = eps (f x)) (y : B)
  : pmap g (eps y) = eta (g y) =>
  \let | d1 : pmap (g `o` f `o` g) (eps y) *> pmap g (eps y) = pmap g (eps `o` f `o` g $ y) *> pmap g (eps y)
           => pmap (g `o` f `o` g) (eps y) *> pmap g (eps y) 
           ==< (inv (pmap-concat-commute g (pmap (f `o` g) (eps y)) (eps y))) >==
           pmap g (pmap (f `o` g) (eps y) *> eps y)
           ==< (pmap (\lam p => pmap g p) (homotopy-isNatural (f `o` g) id eps (eps y))) >==
           pmap g (eps (f `o` g $ y) *> eps y) ==<  pmap-concat-commute g (eps (f `o` g $ y)) (eps y) >==
           pmap g (eps (f `o` g $ y)) *> pmap g (eps y) !qed
       | d2 : pmap (g `o` f) (eta (g y)) *> pmap g (eps y) = pmap g (eps `o` f `o` g $ y) *> pmap g (eps y)
           => Jl (\lam _ p => pmap (g `o` f) (eta (g y)) *> pmap g p = pmap g (eps `o` f `o` g $ y) *> pmap g p)
                tau (eps y)
       | d3 : eta (g `o` f `o` g $ y) *> pmap g (eps y) = pmap (g `o` f) (eta (g y)) *> pmap g (eps y)
           => Jl (\lam _ p => eta (g `o` f `o` g $ y) *> pmap g p = pmap (g `o` f) (eta (g y)) *> pmap g p) 
                (homotopy-comm-lemma (g `o` f) eta (g y)) (eps y)
       | d4 : pmap (g `o` f `o` g) (eps y) *> eta (g y) = eta (g `o` f `o` g $ y) *> pmap g (eps y)
           => homotopy-isNatural (g `o` f) id eta (pmap g (eps y))
       | d5 : pmap (g `o` f `o` g) (eps y) *> eta (g y) = pmap (g `o` f `o` g) (eps y) *> pmap g (eps y)
           => d4 *> d3 *> d2 *> (inv d1)
  \in inv $ cancel (pmap (g `o` f `o` g) (eps y)) (pmap (g `o` f `o` g) (eps y)) (eta (g y)) (pmap g (eps y)) 
              idp d5

\static \function 
qinv-to-hae{A B : \Type0} (f : A -> B) (x : qinv f) : hae f =>
 (x.1, x.3, \lam (b : B) => inv (x.2 (f $ x.1 b)) *> (pmap f (x.3 (x.1 b))) *> x.2 b, 
   \lam a => \let | eta-nat : x.2 (x.1 (f a)) = pmap (x.1 `o` f) (x.2 a) => homotopy-comm-lemma (x.1 `o` f) (x.2 a)
             \in {?}
 )
 


