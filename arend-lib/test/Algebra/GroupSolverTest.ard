\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Pointed
\import Arith.Int
\import Meta
\import Paths

\lemma testSimp {M : Group} (x y z w : M)
  : (x * (z * inverse y)) * ((ide * y) * (ide * inverse z)) * w = x * ((ide * (y * ide)) * inverse y) * w
  => equation.group

\lemma testArg {M : Group} (x y z : M) (p : x * x = ide)
  : (x * (z * inverse y)) * ((ide * y) * (ide * inverse z)) * x = x * ((ide * (y * ide)) * inverse y) * inverse x
  => equation.group p

\lemma testForward {M : Group} (x y z : M) (p : (x * (z * inverse y)) * ((ide * y) * (ide * inverse z)) * x = x * ((ide * (y * ide)) * inverse y) * inverse x)
  : x * x = ide
  => equation.group in p

\lemma testAddSimp {M : AddGroup} (x y z w : M)
  : (x + (z + negative y)) + ((zro + y) + (zro + negative z)) + w = x + ((zro + (y + zro)) + negative y) + w
  => equation.addGroup

\lemma testAddArg {M : AddGroup} (x y z : M) (p : x + x = zro)
  : (x + (z + negative y)) + ((zro + y) + (zro + negative z)) + x = x + ((zro + (y + zro)) + negative y) + negative x
  => equation.addGroup p

\lemma testAddForward {M : AddGroup} (x y z : M) (p : (x + (z + negative y)) + ((zro + y) + (zro + negative z)) + x = x + ((zro + (y + zro)) + negative y) + negative x)
  : x + x = zro
  => equation.addGroup in p

\lemma testProof1 {M : Group} (x y : M) (p : x * y * inverse x = ide) : y = ide
  => equation.group {pmap (inverse x * __ * x) p}

\lemma testProof2 {M : AddGroup} (x y : M) (p : y = zro) : x + y - x = zro
  => equation.addGroup {pmap (x + __ - x) p}

\lemma intTest1 {n m k : Nat} : pos ((n Nat.+ m) Nat.+ k) = pos (n Nat.+ (m Nat.+ k))
  => equation.addGroup

\lemma intTest2 {n m k : Nat} : neg ((n Nat.+ m) Nat.+ k) = neg (n Nat.+ (m Nat.+ k))
  => equation.addGroup

\lemma intTest3 {n m k : Nat} : n Nat.- (m Nat.+ k) = n Nat.- k - m
  => equation.addGroup
