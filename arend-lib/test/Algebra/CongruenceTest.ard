\import Algebra.Meta
\import Algebra.Monoid
\import Meta

\lemma basicTest (f g : Nat -> Nat) (a b : Nat) (p : a = b) (q : f = g) : f a = g b
  => congruence

\lemma funcComp (f : Nat -> Nat) (p : f (f (f 0)) = 0) (q : f (f (f (f (f 0)))) = 0) : f 0 = 0
  => congruence

\lemma funcCompArgRev (f : Nat -> Nat) (p : f (f (f 0)) = 0) (q : f (f (f (f (f 0)))) = 0) : f 0 = 0
  => congruence

\lemma binaryFunc (a b c : Nat) (+ : Nat -> Nat -> Nat) (p : b = c) : a `+` b = a `+` c
  => congruence

\lemma binop (a b c : Nat) (p : b = c) : a Nat.+ b Nat.+ c = a Nat.+ c Nat.+ b
  => congruence

\func defcall (a b c d : Nat) (p : b = d) (q : Foo a b c = Nat) : Foo a d c = Nat
  => congruence
  \where {
    \data Foo (a b c : Nat)
  }

\lemma monoid {M : Monoid} (a b c d : M) (p : b * c = d) (q : a * b = a * c) (r : c * c = b) : a * b = a * d
  => congruence {using (M.*-assoc {a} {b} {c}, M.*-assoc {a} {c} {c})}

\lemma dependentFail (f : \Pi (n : Nat) -> depFunc n) {x : Nat} (p : 0 = suc x)
  => fails {f 0 = f (suc x)} congruence
  \where {
    \func depFunc (n : Nat) : \Set
      | 0 => Nat
      | suc _ => Nat
  }
