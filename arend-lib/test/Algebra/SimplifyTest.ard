\import Algebra.Group
\import Algebra.Group.Solver
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Paths
\import Paths.Meta
\import Set

\func test1 {M : Monoid} (x : M) : x = x * ide
  => simplify

\func test2 {M : Monoid} (x : M) : x * x = (x * (ide * x)) * ide
  => simplify

\func test3 {M : Monoid} (x : M) : ide * x * x * ide = x * ide * x * ide * ide
  => simplify

\func test4 {M : AddMonoid} (x : M) : x + x = x + x + zro
  => simplify

\func test5 {R : Semiring} (x : R) : zro = x * zro
  => simplify

\func test6 {R : Ring} (x : R) : negative (x * x) = x * negative x
  => simplify

\func test6' {R : Ring} (x y : R) : x * negative y = negative (x * y)
  => simplify

\func test7 {R : AddGroup} (x : R) : negative (negative x) = x
  => simplify

\func test8 {R : Ring} (x : R) : x * negative ide = negative x
  => simplify

\func test10 {M : Monoid} (x y : M) (p : x * x = y) : x * (1 * x) = y * 1
  => simplify p

\func test11 {G : CGroup} (x : G) : x * inverse x = ide
   => simplify

\func test12 {G : CGroup} (x y : G) : x * y * inverse x = y
  => transport (\lam x0 => x0 = y) (Paths.inv ((((
    \let d => \new Algebra.Group.Solver.CData (\lam n => (\case n \with {
      | 0 => x
      | suc 0 => y
      | _ => G.ide
    }))
    \in CData.simplify-correct
        (var 0 :* var 1 :* :inv (var 0))) Paths.*> path (\lam i => G.ide-left @ i G.* G.inverse G.ide)) Paths.*> path (\lam i => y G.* Group.inverse_ide @ i)) Paths.*> path ((@) G.ide-right)))
      idp