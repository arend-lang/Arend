\open Arith
\open Data.Nat

\open Combinators
\open Data.Either
\open Data.Empty
\open Data.Unit
\open Paths
\open Relation

\static \function
zero-ne-suc {n : Nat} (p : 0 = suc n) : Empty => transport is_zero p unit

\static \function
n-lt-n-false (n : Nat) (p : n < n) : Empty <= \elim n, p
  | suc n', le_ss p' => n-lt-n-false n' p'

\static \function
lt-ngt {n m : Nat} (p : n < m) : (~~) (n > m) <= \elim n, m, p
  | zero, n', m' => \lam q => suc_nle_zero q
  | suc n', suc m', le_ss p' => \lam q => lt-ngt p' (le_unsuc q)

\static \function
le-trans {n m k : Nat} (nm : n =< m) (mk : m =< k) : n =< k <= \elim n, m, k
  | zero, m', _ => le_z
  | suc n', zero, _ => absurd (suc_nle_zero nm)
  | suc n', suc m', zero => absurd (suc_nle_zero mk)
  | suc n', suc m', suc k' => le_ss (le-trans (le_unsuc nm) (le_unsuc mk))

\static \function
lt-then-le {n m : Nat} (nm : n < m) : n =< m <= \elim n, m
  | zero, _ => le_z
  | suc n', zero => absurd (suc_nle_zero nm)
  | suc n', suc m' => le_ss (lt-then-le $ le_unsuc nm)

\static \function
lt-trans {n m k : Nat} (nm : n < m) (mk : m < k) : n < k => le-trans nm (lt-then-le mk)

\static \function
cmp (n m : Nat) : Tri (n < m) (n = m) (n > m) <= \elim n, m
  | zero, zero => tri_eq suc_nle_zero idp suc_nle_zero
  | zero, suc m' => tri_lt (le_ss le_z) zero-ne-suc suc_nle_zero
  | suc n', zero => tri_gt suc_nle_zero (\lam p => zero-ne-suc (inv p)) (le_ss le_z)
  | suc n', suc m' => \case (cmp n' m')
    | tri_lt lt neq ngt => tri_lt (le_ss lt) (\lam p => neq (pmap pred p)) (ngt `o` le_unsuc)
    | tri_eq nlt eq ngt => tri_eq (nlt `o` le_unsuc) (pmap suc eq) (ngt `o` le_unsuc)
    | tri_gt nlt neq gt => tri_gt (nlt `o` le_unsuc) (\lam p => neq (pmap pred p)) (le_ss gt)
  
\static \function
(<?) (n m : Nat) : Dec (n < m) <= \elim n, m
  | _, zero => inl suc_nle_zero
  | zero, suc m' => inr (le_ss le_z)
  | suc n', suc m' => \case (n' <? m')
    | inl p => inl (\lam q => p (le_unsuc q))
    | inr q => inr (le_ss q)
    