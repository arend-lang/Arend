\open Data.Nat.Base
\open Data.Nat.Properties

\open Combinators
\open Data.Either
\open Data.Unit
\open Paths
\open Relation

\static \function
cmp (n m : Nat) : Tri (n < m) (n = m) (n > m) <= \elim n, m
  | zero, zero => tri_eq suc_nle_zero idp suc_nle_zero
  | zero, suc m' => tri_lt (le_ss le_z) zero-ne-suc suc_nle_zero
  | suc n', zero => tri_gt suc_nle_zero (\lam p => zero-ne-suc (inv p)) (le_ss le_z)
  | suc n', suc m' => \case (cmp n' m')
    | tri_lt lt neq ngt => tri_lt (le_ss lt) (\lam p => neq (pmap pred p)) (ngt `o` le_unsuc)
    | tri_eq nlt eq ngt => tri_eq (nlt `o` le_unsuc) (pmap suc eq) (ngt `o` le_unsuc)
    | tri_gt nlt neq gt => tri_gt (nlt `o` le_unsuc) (\lam p => neq (pmap pred p)) (le_ss gt)
  
\static \function
(<?) (n m : Nat) : Dec (n < m) <= \elim n, m
  | _, zero => inl suc_nle_zero
  | zero, suc m' => inr (le_ss le_z)
  | suc n', suc m' => \case (n' <? m')
    | inl p => inl (\lam q => p (le_unsuc q))
    | inr q => inr (le_ss q)
    
\static \function \infix 2
(=?) (x y : Nat) : Dec (x = y) <= \elim x, y
    | suc x', suc y' <= sdec (x' =? y')
    | suc _, zero => inl (\lam p => transport is_suc p unit)
    | zero, zero => inr idp
    | zero, suc y => inl (\lam p => transport is_zero p unit)

\static \function
(=<?) (x y : Nat) : Dec (x =< y) <= \elim x, y
    | zero, _ => inr le_z
    | suc x', zero => inl suc_nle_zero
    | suc x', suc y' => \case (x' =<? y')
       | inl nleq => inl (nleq `o` le_unsuc)
       | inr leq => inr (le_ss leq)