\import Algebra.Meta
\import Algebra.Monoid
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.LinearOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta

\data List (A : \Type)
  | nil
  | \infixr 5 :: A (List A)

\func \infixr 5 ++ {A : \Type} (xs ys : List A) : List A \elim xs
  | nil => ys
  | :: a xs => a :: xs ++ ys

\func ++-assoc {A : \Type} {xs ys zs : List A} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs) \elim xs
  | nil => idp
  | :: x xs => pmap (x ::) ++-assoc

\func ++_nil {A : \Type} {l : List A} : l ++ nil = l \elim l
  | nil => idp
  | :: a l => pmap (a ::) ++_nil

\instance ListMonoid {A : \Set} : Monoid (List A)
  | ide => nil
  | * => ++
  | ide-left => idp
  | ide-right => ++_nil
  | *-assoc => ++-assoc

\func splitAt {A : \Type} (n : Nat) (l : List A) : \Sigma (List A) (List A) \elim n, l
  | 0, l => (nil, l)
  | suc _, nil => (nil, nil)
  | suc n, :: a l =>
      \let! (l1, l2) => splitAt n l
      \in (a :: l1, l2)
  \where
    \func appendLem {A : \Type} (n : Nat) (l : List A) : take n l ++ drop n l = l \elim n, l
      | 0, l => idp
      | suc n, nil => idp
      | suc n, :: a l => pmap (a ::) (appendLem n l)

\func take {A : \Type} (n : Nat) (l : List A) => (splitAt n l).1

\func drop {A : \Type} (n : Nat) (l : List A) => (splitAt n l).2

\func replace {A : \Type} (l : List A) (i s : Nat) (r : List A) =>
  \let! (l1, l2) => splitAt i l
  \in l1 ++ r ++ drop s l2

\func slice {A : \Type} (l : List A) (i s : Nat) => take s (drop i l)
  \where
    \func appendLem {A : \Type} (l : List A) (i s : Nat) : take i l ++ slice l i s ++ drop s (drop i l) = l \elim l, i, s
      | l, 0, s => splitAt.appendLem s l
      | nil, suc i, 0 => idp
      | nil, suc i, suc s => idp
      | :: a l, suc i, s => pmap (a ::) (appendLem l i s)

\module Sort \where {
  \truncated \data Perm {A : \Type} (xs ys : List A) : \Prop \elim xs, ys
    | nil, nil => perm-nil
    | :: x xs, :: y ys => perm-:: (x = y) (Perm xs ys)
    | :: x (:: x' xs), :: y (:: y' ys) => perm-swap (x = y') (x' = y) (xs = ys)
    | xs, ys => perm-trans {zs : List A} (Perm xs zs) (Perm zs ys)

  \lemma perm-refl {A : \Type} {xs : List A} : Perm xs xs \elim xs
    | nil => perm-nil
    | :: a l => perm-:: idp perm-refl

  \open LinearOrder

  \module Insertion \where {
    \func sort {A : Dec} (xs : List A) : List A
      | nil => nil
      | :: a xs => insert a (sort xs)
      \where {
        \func insert {A : Dec} (a : A) (xs : List A) : List A \elim xs
          | nil => a :: nil
          | :: x xs => \case dec<_<= x a \with {
            | inl x<a => x :: insert a xs
            | inr a<=x => a :: x :: xs
          }
      }

    \open sort

    \lemma sort-perm {A : Dec} (xs : List A) : Perm xs (sort xs) \elim xs
      | nil => perm-nil
      | :: a l => perm-trans (perm-:: idp (sort-perm l)) (insert-perm a (sort l))
      \where {
        \lemma insert-perm {A : Dec} (a : A) (xs : List A)
          : Perm (a :: xs) (insert a xs) \elim xs
          | nil => perm-:: idp perm-nil
          | :: b xs => mcases \with {
            | inl b<=a => perm-trans (perm-swap idp idp idp) (perm-:: idp (insert-perm a xs))
            | inr a<=b => perm-refl
          }

        \lemma insert-comm {A : Dec} (a a' : A) (l : List A) : insert a (insert a' l) = insert a' (insert a l)
          => \case trichotomy a a' \with {
            | less a<a' => aux a<a' l
            | equals a=a' => rewrite a=a' idp
            | greater a>a' => inv (aux a>a' l)
          }
          \where {
            \lemma aux {A : Dec} {a a' : A} (a<a' : a < a') (l : List A) : insert a (insert a' l) = insert a' (insert a l) \elim l
              | nil => mcases contradiction \with {
                | inl _, inr _ => idp
                | inr _, inl _ => idp
              }
              | :: a1 l => mcases {2} \with {
                | inl a1<a => run {
                  rewrite (dec<_reduce (<-transitive a1<a a<a')),
                  rewrite (dec<_reduce a1<a),
                  pmap (a1 ::) (aux a<a' l)
                }
                | inr _ => run {
                  rewrite (dec<_reduce a<a'),
                  mcases \with {
                    | inl a1<a' => mcases \with {
                      | inl _ => contradiction
                      | inr _ => idp
                    }
                    | inr a'<=a1 => rewrite (dec<=_reduce (byRight a<a')) idp
                  }
                }
              }
          }
      }
  }

  \module RedBlack \where {
    \func sort {A : Dec} (l : List A) => rbTreeToList (aux l rbLeaf) nil
      \where {
        \data Color | red | black

        \data RBTree (A : \Type) | rbLeaf | rbBranch Color (RBTree A) A (RBTree A)

        \func rbTreeToList {A : \Type} (t : RBTree A) (r : List A) : List A \elim t
          | rbLeaf => r
          | rbBranch _ t1 a t2 => rbTreeToList t1 (a :: rbTreeToList t2 r)

        \func aux {A : Dec} (l : List A) (\strict r : RBTree A) : RBTree A \elim l
          | nil => r
          | :: a l => aux l (repaint (insert a r))

        \func repaint {A : \Type} (t : RBTree A) : RBTree A
          | rbBranch red l a r => rbBranch black l a r
          | t => t

        \func insert {A : Dec} (a : A) (t : RBTree A) : RBTree A \elim t
          | rbLeaf => rbBranch red rbLeaf a rbLeaf
          | rbBranch c l1 a1 l2 => \case dec<_<= a1 a \with {
            | inl a1<a => balanceRight c l1 a1 (insert a l2)
            | inr a<=a1 => balanceLeft c (insert a l1) a1 l2
          }

        \func balanceLeft {A : \Type} (c : Color) (\strict l : RBTree A) (v : A) (r : RBTree A) : RBTree A \elim c, l
          | black, rbBranch red (rbBranch red a x b) y c => rbBranch red (rbBranch black a x b) y (rbBranch black c v r)
          | black, rbBranch red a x (rbBranch red b y c) => rbBranch red (rbBranch black a x b) y (rbBranch black c v r)
          | c, a => rbBranch c a v r

        \func balanceRight {A : \Type} (c : Color) (l : RBTree A) (v : A) (\strict r : RBTree A) : RBTree A \elim c, r
          | black, rbBranch red (rbBranch red b y c) z d => rbBranch red (rbBranch black l v b) y (rbBranch black c z d)
          | black, rbBranch red b y (rbBranch red c z d) => rbBranch red (rbBranch black l v b) y (rbBranch black c z d)
          | c, b => rbBranch c l v b
      }

    \open sort

    \func toList {A : \Type} (t : RBTree A) : List A \elim t
      | rbLeaf => nil
      | rbBranch _ t1 a t2 => toList t1 ++ a :: toList t2
      \where {
        \lemma =rbTreeToList {A : \Set} (t : RBTree A) : rbTreeToList t nil = toList t
          => aux t nil *> ++_nil
          \where
            \lemma aux {A : \Set} (t : RBTree A) (l : List A) : rbTreeToList t l = toList t ++ l \elim t
              | rbLeaf => idp
              | rbBranch c t1 a t2 => aux t1 (a :: rbTreeToList t2 l) *> pmap (toList t1 ++ a :: __) (aux t2 l) *> inv ++-assoc
      }

      \lemma sort=insert {A : Dec} (l : List A) : sort l = Insertion.sort l
        => toList.=rbTreeToList _ *> aux=makeTree l nil *> pmap (\lam s => toList (makeTree s)) ++_nil *> toList_mkTree l
        \where {
          \func makeTree {A : Dec} (l : List A) : RBTree A \elim l
            | nil => rbLeaf
            | :: a l => repaint (insert a (makeTree l))

          \lemma toList_repaint {A : \Set} (t : RBTree A) : toList (repaint t) = toList t \elim t
            | rbLeaf => idp
            | rbBranch red t1 a t2 => idp
            | rbBranch black t1 a t2 => idp

          \lemma toList_balanceLeft {A : \Set} (c : Color) (l : RBTree A) (v : A) (r : RBTree A)
            : toList (balanceLeft c l v r) = toList (rbBranch c l v r)
            => mcases {balanceLeft} equation

          \lemma toList_balanceRight {A : \Set} (c : Color) (l : RBTree A) (v : A) (r : RBTree A)
            : toList (balanceRight c l v r) = toList (rbBranch c l v r)
            => mcases {balanceRight} equation

          \lemma toList_insert {A : Dec} (a : A) (t : RBTree A) : toList (insert a t) = Insertion.sort.insert a (toList t) \elim t
            | rbLeaf => idp
            | rbBranch c t1 a1 t2 => mcases \with {
              | inl a1<a => toList_balanceRight _ _ _ _ *> {?}
              | inr a<=a1 => toList_balanceLeft _ _ _ _ *> {?}
            }

          \lemma toList_mkTree {A : Dec} (l : List A) : toList (makeTree l) = Insertion.sort l \elim l
            | nil => idp
            | :: a l => toList_repaint (insert a (makeTree l)) *> toList_insert a (makeTree l) *> pmap (Insertion.sort.insert a) (toList_mkTree l)

          \lemma makeTree_insert {A : Dec} (a : A) (l l' : List A) : toList (makeTree (l ++ a :: l')) = toList (repaint (insert a (makeTree (l ++ l')))) \elim l
            | nil => idp
            | :: a' l => toList_repaint _ *> toList_insert a' _ *> pmap (Insertion.sort.insert a') (makeTree_insert a l l' *> toList_repaint _ *> toList_insert a _) *>
                         Insertion.sort-perm.insert-comm a' a _ *> inv (toList_repaint _ *> toList_insert a _ *> pmap (Insertion.sort.insert a) (toList_repaint _ *> toList_insert a' _))

          \lemma aux=makeTree {A : Dec} (l l' : List A) : toList (aux l (makeTree l')) = toList (makeTree (l ++ l')) \elim l
            | nil => idp
            | :: a l => aux=makeTree l (a :: l') *> makeTree_insert a l l'
        }
  }
}
