\import Order.Lattice
\import Paths

\data List (A : \Type)
  | nil
  | \infixr 5 :: A (List A)

\func \infixr 5 ++ {A : \Type} (xs ys : List A) : List A \elim xs
  | nil => ys
  | :: a xs => a :: xs ++ ys

\func ++-assoc {A : \Type} {xs ys zs : List A} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs) \elim xs
  | nil => idp
  | :: x xs => pmap (x ::) ++-assoc

\func ++_nil {A : \Type} {l : List A} : l ++ nil = l \elim l
  | nil => idp
  | :: a l => pmap (a ::) ++_nil

\func splitAt {A : \Type} (n : Nat) (l : List A) : \Sigma (List A) (List A) \elim n, l
  | 0, l => (nil, l)
  | suc _, nil => (nil, nil)
  | suc n, :: a l =>
      \let! (l1, l2) => splitAt n l
      \in (a :: l1, l2)
  \where
    \func appendLem {A : \Type} (n : Nat) (l : List A) : take n l ++ drop n l = l \elim n, l
      | 0, l => idp
      | suc n, nil => idp
      | suc n, :: a l => pmap (a ::) (appendLem n l)

\func take {A : \Type} (n : Nat) (l : List A) => (splitAt n l).1

\func drop {A : \Type} (n : Nat) (l : List A) => (splitAt n l).2

\func replace {A : \Type} (l : List A) (i s : Nat) (r : List A) =>
  \let! (l1, l2) => splitAt i l
  \in l1 ++ r ++ drop s l2

\func slice {A : \Type} (l : List A) (i s : Nat) => take s (drop i l)
  \where
    \func appendLem {A : \Type} (l : List A) (i s : Nat) : take i l ++ slice l i s ++ drop s (drop i l) = l \elim l, i, s
      | l, 0, s => splitAt.appendLem s l
      | nil, suc i, 0 => idp
      | nil, suc i, suc s => idp
      | :: a l, suc i, s => pmap (a ::) (appendLem l i s)

\module Sort \where {
{-
  \data Perm {A : \Type} (xs ys : List A) \elim xs, ys
    | nil, nil => perm-nil
    | :: x xs, :: y ys => perm-:: (x = y) (Perm xs ys)
    | :: x (:: x' xs), :: y (:: y' ys) => perm-swap (x = y') (x' = y) (xs = ys)
    | xs, ys => perm-trans {zs : List A} (Perm xs zs) (Perm zs ys)

  \module Insertion \where {
    \func sort {A : Lattice} (xs : List A) : List A
      | nil => nil
      | :: a xs => insert a (sort xs)
      \where
        \func insert {A : TotalPreorder} (a : A) (xs : List A) : List A \elim xs
          | nil => a :: nil
          | :: x xs => \case totality x a \with {
            | inl _ => x :: insert a xs
            | inr _ => a :: x :: xs
          }

    \func perm-refl {A : \Type} {xs : List A} : Perm xs xs \elim xs
      | nil => perm-nil
      | cons a l => perm-cons idp perm-refl

    \func sort-perm {A : TotalPreorder} (xs : List A) : Perm xs (sort xs) \elim xs
      | nil => perm-nil
      | cons a l => perm-trans (perm-cons idp (sort-perm l)) (insert-perm a (sort l))
      \where {
        \func insert-perm {A : TotalPreorder} (a : A) (xs : List A)
          : Perm (cons a xs) (sort.insert a xs) \elim xs
          | nil => perm-cons idp perm-nil
          | cons b xs => \case totality b a \as r \return
          Perm (cons a (cons b xs)) (\case r \with {
            | inl _ => cons b (sort.insert a xs)
            | inr _ => cons a (cons b xs)
          }) \with {
            | inl b<=a => perm-trans (perm-swap idp idp idp) (perm-cons idp (insert-perm a xs))
            | inr a<=b => perm-refl
          }
      }
  }
-}
}
