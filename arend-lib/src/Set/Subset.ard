\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Topology.Locale

\func Set (A : \hType) => A -> \Prop
  \where {
    \func single {A : \Set} (a : A) : Set A
      => a =

    \lemma single_<= {A : \Set} {a : A} {U : Set A} (Ua : U a) : single a ⊆ U
      => \lam p => rewriteI p Ua

    \func Union {A : \hType} (S : Set A -> \hType) : Set A
      => \lam a => ∃ (U : S) (U a)

    \lemma Union-cond {A : \hType} {S : Set A -> \hType} {U : Set A} (SU : S U) : U ⊆ Union S
      => \lam Ux => inP (U,SU,Ux)

    \func Total {A : \Type} (U : Set A) => \Sigma (x : A) (U x)

    \func restrict {A : \Type} {U : Set A} (V : Set A) : Set (Total U)
      => \lam s => V s.1
  }

\func \infix 8 ^-1 {A B : \hType} (f : A -> B) (S : Set B) : Set A
  => \lam a => S (f a)

\type Subset \alias \infix 4 ⊆ {A : \hType} (U V : Set A) => \Pi {x : A} -> U x -> V x

\func Compl {A : \hType} (U : Set A) : Set A
  => \lam x => Not (U x)

\instance SetLattice (A : \hType) : Locale (Set A)
  | <= => ⊆
  | <=-refl p => p
  | <=-transitive p q u => q (p u)
  | <=-antisymmetric p q => ext \lam x => ext (p,q)
  | meet U V a => \Sigma (U a) (V a)
  | meet-left => __.1
  | meet-right => __.2
  | meet-univ p q c => (p c, q c)
  | top _ => \Sigma
  | top-univ _ => ()
  | Join {J} f a => ∃ (j : J) (f j a)
  | Join-cond j c => inP (j,c)
  | Join-univ d (inP (j,c)) => d j c
  | Join-ldistr>= (d, inP (j,c)) => inP (j,(d,c))

\func extend {A : \Type} {U : Set A} (V : Set (Set.Total U)) : Set A
  => \lam x => \Sigma (Ux : U x) (V (x,Ux))

\lemma extend-mono {A : \Type} {U : Set A} {V W : Set (Set.Total U)} (p : V ⊆ W) : extend V ⊆ extend W
  => \lam {x} (Ux,Vx) => (Ux, p Vx)

\lemma extend_meet {A : \Type} {U : Set A} {V W : Set (Set.Total U)} : extend (V ∧ W) = extend V ∧ extend W
  => <=-antisymmetric (\lam e => ((e.1, e.2.1), (e.1, e.2.2))) (\lam e => (e.1.1, (e.1.2, transport W (ext idp) e.2.2)))

\lemma extend_restrict {A : \Type} {U : Set A} {V : Set A} : extend (Set.restrict {A} {U} V) ⊆ V
  => __.2

\func ^-1_FrameHom {A B : \hType} (f : A -> B) : FrameHom (SetLattice B) (SetLattice A) \cowith
  | func => ^-1 f
  | func-<= p {_} => p
  | func-top>= {_} _ => ()
  | func-meet>= c => c
  | func-Join>= c => c