\import Arith.Nat
\import Data.Bool
\import Equiv
\import Equiv.Univalence
\import Logic
\import Order.PartialOrder
\import Paths
\import Paths.Meta

\record FinSet (A : \Set)
  | finCard : Nat
  | finEq : TruncP (A = Fin finCard)
  \where {
    \use \level levelProp (A : \Set) (X Y : FinSet A) : X = Y
      => ext (\case X.finEq, Y.finEq \with {
        | inP A=Xcard, inP A=Ycard => FinCardBij (inv A=Xcard *> A=Ycard)
      })

    \func pred {n : Nat} (x : Fin (suc (suc n))) : Fin (suc n) \elim x
      | 0 => 0
      | suc x => x

    \lemma suc-isInj {n : Nat} (x y : Fin n) (p : suc x = suc y) : x = y \elim n
      | suc n => pmap pred p

    \lemma FinCardBij {n m : Nat} (p : Fin n = Fin m) : n = m =>
      \have | e : ESEquiv => =-to-Equiv p
            | e' : ESEquiv => =-to-Equiv (inv p)
      \in <=-antisymmetric (FinCardInj e  (\lam x y => Retraction.sec {e.isEmb  x y}))
                           (FinCardInj e' (\lam x y => Retraction.sec {e'.isEmb x y}))

    \lemma FinCardInj {n m : Nat} (f : Fin n -> Fin m) (f-inj : \Pi (x y : Fin n) -> f x = f y -> x = y) : n <= m \elim n, m
      | 0, _ => zero<=_
      | suc n, 0 => \case f 0
      | suc n, suc m => suc<=suc (FinCardInj (\lam x => skip (f 0) (f (suc x)) (\lam f_0=f_suc => \case f-inj 0 (suc x) f_0=f_suc))
                                             (\lam x y p => suc-isInj x y (f-inj (suc x) (suc y) (skip-isInj p))))

    \func skip {n : Nat} (x0 x : Fin (suc n)) (d : x0 /= x) : Fin n \elim n, x0, x
      | _, 0, 0 => absurd (d idp)
      | _, 0, suc x => x
      | suc n, suc x0, 0 => 0
      | suc n, suc x0, suc x => suc (skip x0 x (\lam x0=x => d (pmap (suc __) x0=x)))

    \lemma skip-isInj {n : Nat} {x0 x y : Fin (suc n)} {d : x0 /= x} {d' : x0 /= y} (p : skip x0 x d = skip x0 y d') : x = y \elim n, x0, x, y
      | _, 0, 0, _ => absurd (d idp)
      | _, 0, _, 0 => absurd (d' idp)
      | _, _, 0, 0 => idp
      | suc n, 0, suc x, suc y => pmap (suc __) p
      | suc n, suc x0, 0, suc y => \case p
      | suc n, suc x0, suc x, 0 => \case p
      | suc n, suc x0, suc x, suc y => pmap (suc __) (skip-isInj (suc-isInj _ _ p))
  }

\lemma transport_zero {n m : Nat} (p : n = m) : transport Fin (pmap suc p) 0 = 0 \elim p
  | idp => idp

\lemma transport_suc {n m : Nat} (p : n = m) (x : Fin n) : transport Fin (pmap suc p) (suc x) = suc (transport Fin p x) \elim p
  | idp => idp
