\import Algebra.Group
\import Algebra.Group.GroupHom
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Arith.Rat
\import Arith.Real
\import Arith.Real.UpperReal
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.Lattice
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.CoverSpace
\import Topology.MetricSpace
\import Topology.TopAbGroup
\import Topology.TopAbGroup.Complete
\import Topology.UniformSpace
\import Topology.UniformSpace.Product
\open RatField(half,half>0)

\class ExPseudoNormedAbGroup \extends ExPseudoMetricSpace, TopAbGroup {
  | norm : E -> ExUpperReal
  | norm_zro : norm zro = 0
  | norm_negative {x : E} : norm (negative x) = norm x
  | norm_+ {x y : E} : norm (x + y) <= norm x ExUpperReal.+ norm y
  | norm-dist {x y : E} : dist x y = norm (x - y)

  | +-cont => \new UniformMap (ProductUniformSpace \this \this) \this {
    | func s => s.1 + s.2
    | func-uniform Eu => \case dist-uniform.1 Eu \with {
      | inP (eps,eps>0,h) => inP (_, metricUniform $ half>0 eps>0, _, metricUniform $ half>0 eps>0, \lam (inP (_, inP (x,idp), _, inP (y,idp), p)) => \case h (x + y) \with {
        | inP (V,EV,g) => inP (_, inP (V, EV, idp), rewrite p \lam {(x',y')} (xx'<eps/2,yy'<eps/2) => g $ rewrite (norm-dist, equation.abGroup : x + y - (x' + y') = x - x' + (y - y')) $ ExUpperReal.U_<= (ExUpperReal.<=_+-char norm_+ (rewrite norm-dist in xx'<eps/2) (rewrite norm-dist in yy'<eps/2)) linarith
        )
      })
    }
  }
  | negative-cont => \new UniformMap {
    | func-uniform Eu => \case dist-uniform.1 Eu \with {
      | inP (eps,eps>0,h) => dist-uniform.2 $ inP (eps, eps>0, \lam x => \case h (negative x) \with {
        | inP (U,EU,g) => inP (_, inP $ later (U,EU,idp), \lam {y} d => g {negative y} $ transportInv (ExUpperReal.U {__} eps) (norm-dist *> simplify (pmap norm +-comm) *> norm_negative *> inv norm-dist) d)
      })
    }
  }
  | neighborhood-uniform =>
    \have lem {x} {y} : dist 0 (x - y) = dist x y => norm-dist *> inv norm_negative *> pmap norm simplify *> inv norm-dist
    \in (\lam Cu => \case dist-uniform.1 Cu \with {
      | inP (eps,eps>0,h) => inP (OBall eps 0, OBall-open, OBall-center eps>0, \lam x => \case h x \with {
        | inP (U,CU,g) => inP (U, CU, \lam d => g $ transport (ExUpperReal.U {__} eps) lem d
                              )
      })
    }, \lam (inP (U,Uo,U0,h)) => \case dist_open.1 Uo U0 \with {
      | inP (eps,eps>0,p) => dist-uniform.2 $ inP (eps, eps>0, \lam x => \case h x \with {
        | inP (U,CU,g) => inP (U, CU, \lam d => g $ p $ transportInv (ExUpperReal.U {__} eps) lem d)
      })
    })
  | open-top => defaultImpl PrecoverSpace open-top
  | open-inter {U} {V} => defaultImpl PrecoverSpace open-inter {_} {U} {V}
  | open-Union {S} => defaultImpl PrecoverSpace open-Union {_} {S}
  | dist-refl => norm-dist *> pmap norm negative-right *> norm_zro
  | dist-symm => norm-dist *> simplify *> norm_negative *> inv norm-dist
  | dist-triang => repeat {3} (rewrite norm-dist) $ transport (norm __ <= _) simplify norm_+

  \default dist x y : ExUpperReal => norm (x - y)
  \default norm-dist \as norm-dist-impl {x} {y} : dist x y = norm (x - y) => idp

  \lemma norm_*n<= {n : Nat} {a : E} : norm (n *n a) <= n ExUpperRealAbMonoid.*n norm a \elim n
    | 0 => =_<= norm_zro
    | suc n => norm_+ <=∘ <=_+ norm_*n<= <=-refl

  \func IsBounded (x : E) : \Prop
    => ∃ (B : Rat) ((norm x).U B)

  \func IsUnbounded : \Prop
    => \Pi (B : Nat) -> ∃ (x : E) (ExUpperReal.fromRat B <= norm x)

  \lemma norm_BigSum {l : Array E} : norm (BigSum l) <= ExUpperRealAbMonoid.BigSum \lam j => norm (l j) \elim l
    | nil => transportInv (`<= _) norm_zro <=-refl
    | x :: l => norm_+ <=∘ <=_+ <=-refl norm_BigSum
}

\lemma norm>=0 {X : ExPseudoNormedAbGroup} {x : X} : 0 <= norm x
  => rewrite norm_dist dist>=0

\lemma norm_dist {X : ExPseudoNormedAbGroup} {x : X} : norm x = dist 0 x
  => inv norm_negative *> simplify *> inv norm-dist

\lemma norm_- {X : ExPseudoNormedAbGroup} {x y : X} : norm (x - y) = norm (y - x)
  => pmap norm (inv X.negative-isInv) *> norm_negative *> simplify

\lemma norm_dist-bound {X : ExPseudoNormedAbGroup} {x y : X} : norm x <= dist x y + norm y
  => rewrite norm-dist $ transport (norm  __ <= _) simplify norm_+

\class ExNormedAbGroup \extends ExPseudoNormedAbGroup, ExMetricSpace
  | norm-ext {x : E} : norm x = ExUpperRealAbMonoid.zro -> x = 0
  | dist-ext p => fromZero $ norm-ext $ inv norm-dist *> p

\class PseudoNormedAbGroup \extends ExPseudoNormedAbGroup, PseudoMetricSpace {
  \override norm : E -> Real
  \default dist x y : Real => norm (x - y)
  \default norm-dist \as norm-dist-impl {x} {y} : dist x y = norm (x - y) => idp
}

\func lnorm {X : PseudoNormedAbGroup} (x : X) : Real
  => X.norm x

\lemma lnorm>=0 {X : PseudoNormedAbGroup} {x : X} : 0 <= X.norm x
  => Real.<=-upper.2 (later norm>=0)

\lemma lnorm_zro {X : PseudoNormedAbGroup} : lnorm X.zro = RealAbGroup.zro
  => Real.=-upper.2 (later norm_zro)

\lemma lnorm_+ {X : PseudoNormedAbGroup} {x y : X} : lnorm (x + y) <= lnorm x + lnorm y
  => Real.<=-upper.2 $ transportInv (_ ExUpperRealAbMonoid.<=) RealAbGroup.+-upper X.norm_+

\lemma lnorm_BigSum {X : PseudoNormedAbGroup} {l : Array X} : lnorm (X.BigSum l) <= RealAbGroup.BigSum \lam j => lnorm (l j) \elim l
  | nil => transportInv (`<= _) lnorm_zro <=-refl
  | x :: l => lnorm_+ <=∘ <=_+ <=-refl lnorm_BigSum

\lemma lnorm_- {X : PseudoNormedAbGroup} {x y : X} : lnorm (x - y) = lnorm (y - x)
  => Real.=-upper.2 $ norm_- {X}

\lemma lnorm_-left {X : PseudoNormedAbGroup} {x y : X} : lnorm x - lnorm y <= lnorm (x - y)
  => transport (_ <=) (+-assoc *> pmap (_ +) negative-right *> zro-right) $ <=_+ (transport (lnorm __ <= _) (+-assoc *> pmap (x +) negative-left *> zro-right) lnorm_+) <=-refl

\lemma lnorm_-right {X : PseudoNormedAbGroup} {x y : X} : lnorm y - lnorm x <= lnorm (x - y)
  => transport (_ <=) lnorm_- lnorm_-left

\lemma lnorm_-_abs {X : PseudoNormedAbGroup} {x y : X} : RealAbGroup.abs (lnorm x - lnorm y) <= lnorm (x - y)
  => join-univ lnorm_-left (simplify lnorm_-right)

\class NormedAbGroup \extends PseudoNormedAbGroup, ExNormedAbGroup

\record UniformNormedAbGroupMap \extends UniformMetricMap, TopAbGroupMap {
  \override Dom : ExPseudoNormedAbGroup
  \override Cod : ExPseudoNormedAbGroup

  | func-norm-uniform : ∀ {eps : Rat} (0 < eps) ∃ (delta : Rat) (0 < delta) ∀ {x : Dom} ((norm x).U delta -> (norm (func x)).U eps)
  | func-dist-uniform eps>0 => \case func-norm-uniform eps>0 \with {
    | inP (delta,delta>0,h) => inP (delta, delta>0, unfold \lam d => rewrite (norm-dist {Cod}, inv AddGroupHom.func-minus) $ h $ rewriteI (norm-dist {Dom}) d)
  }

  \default func-norm-uniform eps>0 => \case dist_open.1 (func-cont OBall-open) $ rewrite func-zro $ OBall-center eps>0 \with {
    | inP (delta,delta>0,h) => inP (delta, delta>0, \lam d => rewrite (norm_dist {Cod}, inv func-zro) $ h $ rewrite (norm_dist {Dom}) in d)
  }
}

\record NormedAbGroupMap \extends UniformNormedAbGroupMap, MetricMap {
  \override Dom : ExPseudoNormedAbGroup
  \override Cod : ExPseudoNormedAbGroup

  | func-norm {x : Dom} : norm (func x) <= norm x
  | func-norm-uniform {eps} eps>0 => inP (eps, eps>0, func-norm __)
  | func-dist => unfold $ rewrite (norm-dist {Dom}, norm-dist {Cod}, inv AddGroupHom.func-minus) func-norm
}

\record NormedIsometricMap \extends NormedAbGroupMap, IsometricMap {
  \override Dom : ExPseudoNormedAbGroup
  \override Cod : ExPseudoNormedAbGroup

  | func-norm-isometry {x : Dom} : norm (func x) = norm x
  | func-norm => =_<= func-norm-isometry
  | func-isometry => norm-dist *> pmap norm (inv func-minus) *> func-norm-isometry *> inv norm-dist
}

\class CompleteExNormedAbGroup \extends ExNormedAbGroup, CompleteExMetricSpace, CompleteTopAbGroup

\class CompleteNormedAbGroup \extends CompleteExNormedAbGroup, NormedAbGroup, CompleteMetricSpace