\import Algebra.Group
\import Algebra.Group.GroupHom
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Arith.Real
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.Lattice
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.CoverSpace
\import Topology.MetricSpace
\import Topology.TopAbGroup
\import Topology.TopAbGroup.Complete
\import Topology.UniformSpace
\import Topology.UniformSpace.Product

\class ValuedPseudoNormedAbGroup \extends ValuedPseudoMetricSpace, TopAbGroup {
  | norm : E -> V
  | norm_zro : norm zro = 0
  | norm_negative {x : E} : norm (negative x) = norm x
  | norm_+ {x y : E} : norm (x + y) <= norm x V.+ norm y
  | norm-dist {x y : E} : dist x y = norm (x - y)

  | +-cont => \new UniformMap (ProductUniformSpace \this \this) \this {
    | func s => s.1 + s.2
    | func-uniform Eu => \case dist-uniform.1 Eu \with {
      | inP (eps,eps>0,h) => \case V.shrink2 eps>0 \with {
        | inP (delta,delta>0,delta<eps,delta+delta<eps) => inP (_, metricUniform delta>0, _, metricUniform delta>0, \lam (inP (_, inP (x,idp), _, inP (y,idp), p)) => \case h (x + y) \with {
          | inP (V,EV,g) => inP (_, inP (V, EV, idp), rewrite p \lam {(x',y')} (xx'<eps/2,yy'<eps/2) =>
              \have lem : x - x' + (y - y') = x + y - (x' + y') => +-assoc *> pmap (x +) (+-comm *> +-assoc *> pmap (y +) (inv negative_+)) *> inv +-assoc
              \in g $ rewrite (norm-dist, inv lem) $ norm_+ <∘r <=_+ (<=-less $ rewrite norm-dist in xx'<eps/2) (<=-less $ rewrite norm-dist in yy'<eps/2) <∘r delta+delta<eps
          )
        })
      }
    }
  }
  | negative-cont => \new UniformMap {
    | func-uniform Eu => \case dist-uniform.1 Eu \with {
      | inP (eps,eps>0,h) => dist-uniform.2 $ inP (eps, eps>0, \lam x => \case h (negative x) \with {
        | inP (U,EU,g) => inP (_, inP $ later (U,EU,idp), \lam {y} d => g {negative y} $ transportInv (`< _) (norm-dist *> simplify (pmap norm +-comm) *> norm_negative *> inv norm-dist) d)
      })
    }
  }
  | neighborhood-uniform =>
    \have lem {x} {y} : dist 0 (x - y) = dist x y => norm-dist *> inv norm_negative *> pmap norm simplify *> inv norm-dist
    \in (\lam Cu => \case dist-uniform.1 Cu \with {
      | inP (eps,eps>0,h) => inP (VOBall eps 0, OBall-open, OBall-center eps>0, \lam x => \case h x \with {
        | inP (U,CU,g) => inP (U, CU, \lam d => g $ unfold VOBall at d $ transport (`< _) lem d)
      })
    }, \lam (inP (U,Uo,U0,h)) => \case dist_open.1 Uo U0 \with {
      | inP (eps,eps>0,p) => dist-uniform.2 $ inP (eps, eps>0, \lam x => \case h x \with {
        | inP (U,CU,g) => inP (U, CU, \lam d => g $ p $ transportInv (`< _) lem d)
      })
    })
  | open-top => defaultImpl PrecoverSpace open-top
  | open-inter {U} {V} => defaultImpl PrecoverSpace open-inter {_} {U} {V}
  | open-Union {S} => defaultImpl PrecoverSpace open-Union {_} {S}
  | dist-refl => norm-dist *> pmap norm negative-right *> norm_zro
  | dist-symm => norm-dist *> simplify *> norm_negative *> inv norm-dist
  | dist-triang => repeat {3} (rewrite norm-dist) $ transport (norm __ <= _) simplify norm_+

  \default dist x y : V => norm (x - y)
  \default norm-dist \as norm-dist-impl {x} {y} : dist x y = norm (x - y) => idp
}

\lemma norm>=0 {X : ValuedPseudoNormedAbGroup} {x : X} : 0 <= norm x
  => rewrite norm_dist dist>=0

\lemma norm_dist {X : ValuedPseudoNormedAbGroup} {x : X} : norm x = dist 0 x
  => inv norm_negative *> simplify *> inv norm-dist

\lemma norm_- {X : ValuedPseudoNormedAbGroup} {x y : X} : norm (x - y) = norm (y - x)
  => pmap norm (inv X.negative-isInv) *> norm_negative *> simplify

\lemma norm_dist-bound {X : ValuedPseudoNormedAbGroup} {x y : X} : norm x <= dist x y + norm y
  => rewrite norm-dist $ transport (norm  __ <= _) simplify norm_+

\class PseudoNormedAbGroup \extends ValuedPseudoNormedAbGroup, LinearlyValuedPseudoMetricSpace, PseudoMetricSpace {
  \func IsUnbounded : \Prop
    => \Pi (B : Nat) -> ∃ (x : E) (B RealAbGroup.< norm x)

  \lemma norm_BigSum {l : Array E} : norm (BigSum l) <= RealAbGroup.BigSum \lam j => norm (l j) \elim l
    | nil => transportInv (`<= _) norm_zro <=-refl
    | x :: l => norm_+ <=∘ <=_+ <=-refl norm_BigSum
}

\class ValuedNormedAbGroup \extends ValuedPseudoNormedAbGroup, ValuedMetricSpace
  | norm-ext {x : E} : norm x = 0 -> x = zro
  | dist-ext p => fromZero $ norm-ext $ inv norm-dist *> p

\lemma norm_-left {X : PseudoNormedAbGroup} {x y : X} : norm x - norm y <= norm (x - y)
  => transport (_ <=) (+-assoc *> pmap (_ +) negative-right *> zro-right) $ <=_+ (transport (norm __ <= _) (+-assoc *> pmap (x +) negative-left *> zro-right) norm_+) <=-refl

\lemma norm_-right {X : PseudoNormedAbGroup} {x y : X} : norm y - norm x <= norm (x - y)
  => transport (_ <=) norm_- norm_-left

\lemma norm_-_abs {X : PseudoNormedAbGroup} {x y : X} : RealAbGroup.abs (norm x - norm y) <= norm (x - y)
  => join-univ norm_-left (simplify norm_-right)

\class NormedAbGroup \extends ValuedNormedAbGroup, PseudoNormedAbGroup, MetricSpace

\record UniformNormedAbGroupMap \extends UniformMetricMap, TopAbGroupMap {
  \override Dom : PseudoNormedAbGroup
  \override Cod : PseudoNormedAbGroup

  | func-norm-uniform : ∀ {eps : Real} (0 < eps) ∃ (delta : Real) (0 < delta) ∀ {x : Dom} (norm x < delta -> norm (func x) < eps)
  | func-dist-uniform eps>0 => \case func-norm-uniform eps>0 \with {
    | inP (delta,delta>0,h) => inP (delta, delta>0, unfold \lam d => rewrite (norm-dist {Cod}, inv AddGroupHom.func-minus) $ h $ rewriteI (norm-dist {Dom}) d)
  }

  \default func-norm-uniform eps>0 => \case dist_open.1 (func-cont OBall-open) $ rewrite func-zro $ OBall-center eps>0 \with {
    | inP (delta,delta>0,h) => inP (delta, delta>0, \lam d => rewrite (norm_dist {Cod}, inv func-zro) $ h $ rewrite (norm_dist {Dom}) in d)
  }
}

\record NormedAbGroupMap \extends UniformNormedAbGroupMap, MetricMap {
  \override Dom : PseudoNormedAbGroup
  \override Cod : PseudoNormedAbGroup

  | func-norm {x : Dom} : norm (func x) <= norm x
  | func-norm-uniform {eps} eps>0 => inP (eps, eps>0, \lam d => func-norm <∘r d)
  | func-dist => unfold $ rewrite (norm-dist {Dom}, norm-dist {Cod}, inv AddGroupHom.func-minus) func-norm
}

\record NormedIsometricMap \extends NormedAbGroupMap, IsometricMap {
  \override Dom : PseudoNormedAbGroup
  \override Cod : PseudoNormedAbGroup

  | func-norm-isometry {x : Dom} : norm (func x) = norm x
  | func-norm => Preorder.=_<= func-norm-isometry
  | func-isometry => norm-dist *> pmap norm (inv func-minus) *> func-norm-isometry *> inv norm-dist
}

\class CompleteNormedAbGroup \extends NormedAbGroup, CompleteMetricSpace, CompleteTopAbGroup
