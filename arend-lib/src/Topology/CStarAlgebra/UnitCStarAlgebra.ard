{- | The construction of {UnitC*Algebra} is taken from
     [1] Simon Henry, Constructive Gelfand Duality for non-unital commutative C*-algebras, 2014, https://arxiv.org/abs/1412.2009
 -}

\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Ordered.RieszSpace
\import Algebra.Pointed
\import Algebra.QModule
\import Algebra.Ring
\import Algebra.Ring.UnitAlgebra
\import Analysis.Limit
\import Arith.Nat
\import Arith.Rat
\import Arith.Real
\import Arith.Real.Field
\import Arith.Real.UpperReal
\import Arith.Real.UpperRealLattice
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set.Filter
\import Topology.BanachAlgebra
\import Topology.BanachSpace
\import Topology.MetricSpace
\import Topology.NormedAbGroup
\import Topology.NormedAbGroup.Real
\import Topology.StoneCStarAlgebra
\import Topology.NormedRing
\import Topology.TopSpace
\import Topology.TopSpace.Product

\instance UnitC*Algebra (A : StoneC*PseudoAlgebra) : StoneC*Algebra (\Sigma Real A)
  | Ring => UnitAlgebra RealField A.toRealAlgebra
  | *-comm => ext (RealField.*-comm, equation.abGroup $ A.toZero A.*-comm)
  | isDivisible x n/=0 => \case RealStoneC*Algebra.isDivisible x.1 n/=0, A.isDivisible x.2 n/=0 \with {
    | inP (y,ny=x1), inP (b,nb=x2) => inP ((y,b), UnitAlgebra.*n-comm *> pmap2 (__,__) ny=x1 nb=x2)
  }
  | norm (x : \Sigma Real A) : ExUpperReal => RealAbGroup.abs x.1 ExUpperRealLattice.∨ Join \lam (s : \Sigma (y : A) (A.norm y <= 1)) => A.norm (x.1 A.*r s.1 + x.2 * s.1)
  | norm_zro => <=-antisymmetric
    (join-univ (Real.<=-upper.1 $ =_<= {RealAbGroup} RealAbGroup.abs_zro) $ Join-univ \lam s => =_<= $ pmap A.norm (pmap2 (+) A.toRealModule.*c_zro-left A.zro_*-left *> zro-right) *> norm_zro)
    (Real.<=-upper.1 RealAbGroup.abs>=0 <=∘ ExUpperRealLattice.join-left)
  | norm_negative => pmap2 (__ ∨ Join __) RealStoneC*Algebra.norm_negative $ ext \lam s => pmap A.norm (pmap2 (+) A.toRealModule.*c_negative-left A.negative_*-left *> +-comm *> inv A.negative_+) *> norm_negative
  | norm_+ => join-univ (transport (_ ExUpperReal.<=) RealAbGroup.+-upper (later $ Real.<=-upper.1 RealAbGroup.abs_+) <=∘ <=_+ join-left join-left) $
    Join-univ \lam s => =_<= (pmap A.norm $ pmap2 (+) A.toRealModule.*c-rdistr A.rdistr *> equation.abMonoid) <=∘ norm_+ <=∘ <=_+ (Join-cond s <=∘ join-right) (Join-cond s <=∘ join-right)
  | norm_*n_>= {n} {x} => =_<= $ inv (ExUpperRealSemigroup.*n_* (later (Real.<=-upper.1 RealAbGroup.abs>=0) <=∘ join-left) $ ExUpperReal.join-bounded U-inh \case (RealAbGroup.abs x.1).U-inh, norm-bounded x.2 \with {
    | inP (B1,|x1|<B1), inP (B2,|x2|<B2) => inP (B1 + B2 + 1, inP $ later (B1 + B2, linarith, \lam s => norm_+ $ ExUpperReal.+_U_<=.2 $ inP (B1, (=_<= A.norm_*r <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ Real.<=-upper.1 RealAbGroup.abs>=0)) |x1|<B1, B2, (A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0)) |x2|<B2, <=-refl)))
  }) *> ExUpperRealLattice.*n_join *> pmap2 (∨) (inv RealAbGroup.*n-upper *> RealAbGroup.abs_*n *> pmap RealAbGroup.abs (inv UnitAlgebra.*n-comm1)) (ExUpperRealLattice.*n_Join' inhabitted *> ExUpperRealLattice.Join_= \lam s => inv A.norm_*n-comm *> pmap A.norm (A.*n-ldistr *> pmap2 (+) (inv A.*r_*n *> inv A.toRealAlgebra.*c-assoc *> pmap (A.`*r _) (RealField.natCoef_*_*n *> inv (UnitAlgebra.*n-comm1 {_} {A.toRealAlgebra}))) (A.*n-comm-left *> pmap (`* _) (inv $ UnitAlgebra.*n-comm2 {_} {A.toRealAlgebra}))))
  | norm_*_<= {x y : \Sigma Real A} : norm (x * {UnitAlgebra RealField A.toRealAlgebra} y) <= norm x * norm y => join-univ (transportInv (`<= _) (RealField.abs_* *> RealField.*-upper RealAbGroup.abs>=0 RealAbGroup.abs>=0) $ <=_* join-left join-left) $
    Join-univ \lam s => =_<= A.norm_*-char <=∘ Join-univ \lam s' => =_<= (pmap A.norm
    \have | lem1 : x.1 * y.1 A.*r s.1 * s'.1 = x.1 A.*r s.1 * (y.1 A.*r s'.1) => inv A.toRealAlgebra.*c-comm-left *> A.toRealAlgebra.*c-assoc *> pmap (_ A.*r) A.toRealAlgebra.*c-comm-right *> A.toRealAlgebra.*c-comm-left
          | lem2 z w c d : z * (c A.*r d * w) = z * (d * (c A.*r w)) => pmap (z *) (inv A.toRealAlgebra.*c-comm-left *> A.toRealAlgebra.*c-comm-right)
    \in equation.cRing {lem1, lem2 s'.1 s.1 x.1 y.2, lem2 s.1 s'.1 y.1 x.2}) <=∘ A.norm_*_<= <=∘ <=_* (Join-cond s <=∘ join-right) (Join-cond s' <=∘ join-right)
  | norm_ide_<= => join-univ RealStoneC*Algebra.norm_ide_<= $ Join-univ \lam s => =_<= (pmap A.norm $ pmap2 (+) A.toRealModule.ide_*c A.zro_*-left *> zro-right) <=∘ s.2
  | norm-ext {x} p =>
    \have x1=0 => RealAbGroup.abs_zro-ext $ RealAbGroup.<=-antisymmetric ((Real.<=-upper {_} {0}).2 $ join-left <=∘ =_<= p) RealAbGroup.abs>=0
    \in ext (x1=0, norm-ext $ <=-antisymmetric (=_<= A.norm_*-char <=∘ Join-univ \lam s => =_<= (pmap A.norm $ inv $ pmap (`+ _) (pmap (RealBanachSpace.`*r _) x1=0 *> A.toRealAlgebra.*c_zro-left) *> zro-left) <=∘ Join-cond s <=∘ join-right <=∘ =_<= p) norm>=0)
  | isCompleteMetric F Fc => \case
      RealNormed.isCompleteMetric (ProperFilter-map __.1 F) \lam eps>0 => TruncP.map (Fc eps>0) \lam (r,Fr) => (r.1, filter-mono Fr \lam d => ExUpperRealAbMonoid.join-left d),
      A.isCompleteMetric (ProperFilter-map __.2 F) (\lam {eps} eps>0 => TruncP.map (Fc $ RatField.half>0 $ RatField.half>0 eps>0) \lam (r,Fr) => (r.2, filter-mono Fr \lam {x} d => <-rat.1 $ rewrite (A.norm-dist, A.norm_*-char) $ Join-univ (\lam s =>
        \have | t1 => join-left <∘r <-rat.2 d
              | t2 => Join-cond s <∘r join-right <∘r <-rat.2 d
        \in norm_dist-left {_} {_} {negative (r.1 - x.1) A.*r s.1} <=∘ <=_+ (=_<= norm-dist) (=_<= A.norm_*r <=∘ <=_* (=_<= {ExUpperRealAbMonoid} RealAbGroup.abs_negative) s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ Real.<=-upper.1 RealAbGroup.abs>=0)) <=∘ unfold (-) (rewrite (A.toRealAlgebra.*c_negative-left,A.negative-isInv,A.+-comm) $ <=_+ (<=-less t2) (<=-less t1) <=∘ =_<= (ExUpperReal.+-rat *> pmap ExUpperReal.fromRat linarith))) <∘r (<-rat {RatField.half eps}).2 (RatField.half<id eps>0)))
    \with {
      | inP (a,al), inP (x,xl) => inP ((a,x), \lam {eps} eps>0 => filter-mono (filter-meet (al $ RatField.half>0 $ RatField.half>0 eps>0) (xl $ RatField.half>0 $ RatField.half>0 eps>0))
        \lam {z} d => <-rat.1 $ join-univ (<=-less (<-rat.2 d.1) <=∘ ExUpperReal.<=-rat.1 (<=-less $ RatField.half<id $ RatField.half>0 eps>0)) (Join-univ $ later \lam s => norm_+ <=∘ <=_+ (=_<= A.norm_*r <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ norm>=0 {RealNormed})) (A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0 *> inv norm-dist)) <=∘ <=_+ (ExUpperReal.<_<= d.1) (ExUpperReal.<_<= d.2) <=∘ =_<= (ExUpperReal.+-rat *> pmap ExUpperReal.fromRat linarith)) <∘r (<-rat {RatField.half eps}).2 (RatField.half<id eps>0))
    }
  | c*-sum {a} {b} => norm_*_<= <=∘ =_<= ExUpperRealLattice.join-square <=∘ join-univ (RealStoneC*Algebra.c*-square <=∘ RealStoneC*Algebra.c*-sum <=∘ join-left)
    (=_<= (ExUpperRealLattice.Join-square inhabitted) <=∘ Join-univ \lam s => A.c*-square <=∘ A.c*-sum {_} {b.1 A.*r s.1 + b.2 * s.1} <=∘ =_<= (pmap A.norm $ later $ rewrite A.toRealAlgebra.*c-rdistr $ equation.cRing {
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.1 A.*r s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) (inv A.toRealAlgebra.*c-assoc),
      inv (A.toRealAlgebra.*c-comm-left {b.1} {s.1} {b.1 A.*r s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) (inv A.toRealAlgebra.*c-assoc),
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.2 * s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) A.toRealAlgebra.*c-comm-left,
      inv (A.toRealAlgebra.*c-comm-right {b.1} {s.1} {b.2}) *> A.toRealAlgebra.*c-comm-left
    }) <=∘ A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0) <=∘ Join-cond s <=∘ join-right)
  | c*-square {a} => =_<= ExUpperRealLattice.join-square <=∘ join-univ (RealStoneC*Algebra.c*-square <=∘ join-left)
    (=_<= (ExUpperRealLattice.Join-square inhabitted) <=∘ Join-univ \lam s => A.c*-square <=∘ =_<= (pmap A.norm $ equation.cRing {
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.1 A.*r s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) (inv A.toRealAlgebra.*c-assoc),
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.2 * s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) A.toRealAlgebra.*c-comm-left
    }) <=∘ A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0) <=∘ Join-cond s <=∘ join-right)
  \where {
    \open ExUpperRealAbMonoid(<-rat)
    \open ExUpperRealSemigroup(<=_*)

    \private \lemma inhabitted : ∃ (y : A) (A.norm y <= 1)
      => inP (A.zro, transportInv (`<= _) norm_zro $ <=-less ExUpperRealAbMonoid.zro<ide)
  }

\func StoneC*AlgebraRieszSpace (A : StoneC*Algebra) : RieszSpace A
  => RieszSpace.fromAbs \lam a => {?}
  \where \protected {
    \func c*abs (a : A) (a<=1 : a <= 1) (-a<=1 : negative a <= 1) : A
      => A.sqrt (a * a) square-norm
      \where {
        \open RealBanachAlgebra
        \open RealBanachAlgebra.sqrt(yfunc,zfunc,zfunc-lim,UnitBall)
        \open ExUpperRealSemigroup(<=_*)

        \lemma yfunc>=0 (n : Nat) : 0 <= yfunc n (a * a) \elim n
          | 0 => transportInv (0 <=) (\peval yfunc 0 _) <=-refl
          | suc n => transportInv (0 <=) (\peval yfunc (suc n) _) $ A.*q_>=0 rat_<=-dec $ A.<=_+-positive (A.to>=0 $ c*-<=_*-square a<=1 -a<=1) c*-square-positive

        \lemma square-norm : norm (1 - a * a) <= 1
          => A.square-lem c*-square-positive (c*-<=_*-square a<=1 -a<=1)

        \lemma c*abs>=id : a <= c*abs a a<=1 -a<=1
          => transportInv (a <=) (\peval sqrt _ _) $ A.closed-limit (A.<=-right-closed a) limit-isLimit induction
          \where {
            \private \lemma induction (n : Nat) : a <= 1 - yfunc n (a * a) \elim n
              | 0 => transport (a <=) (inv zro-right *> pmap (1 +) (inv $ pmap negative (\peval yfunc 0 _) *> A.negative_zro)) a<=1
              | suc n => rewrite (\peval yfunc (suc n) _) $ A.<=_*q-cancel-left {2} idp $ later $ rewrite (A.toRatModule.*c-ldistr_-, inv A.*q-assoc, A.ide_*q, A.*q_*n, A.*q_*n) $ simplify $ A.from>=0 $ transport (0 <=) {(1 - yfunc n _ - a) * (1 - a + yfunc n _)} equation.cRing $ A.<=_*-positive (A.to>=0 $ induction n) $ A.<=_+-positive (A.to>=0 a<=1) (yfunc>=0 n)
          }

        \lemma zfunc_pow>0 {w : A} (w<=1 : w <= 1) (|1-w|<1 : (norm (1 - w)).U 1) : zfunc-lim (w * w, square-norm w<=1 $ ExUpperReal.<_<= |1-w|<1) = w
          => \case U-rounded |1-w|<1 \with {
            | inP (q,|1-w|<q,q<1) => A.limit-unique {_} {zfunc __ (w * w)} limit-isLimit $ nat-limit-metric (rewrite norm-dist $ norm-bounded _) {ratio 1 2 * (1 + q)} (ExUpperReal.<=-rat.1 $ linarith $ norm>=0 |1-w|<q) linarith
              \lam n => later $ rewrite (norm-dist, norm-dist, \peval yfunc (suc n) _) $ transport (norm __ <= _) {ratio 1 2 A.*q ((yfunc n (w * w) + (1 - w)) * (w - zfunc n (w * w)))}
                (A.*q-cancel {2} (RatField.>_/= idp) $ inv A.*q-assoc *> A.ide_*q *> inv (A.toRatModule.*c-ldistr_- *> pmap2 (-) A.*q_*n (A.toRatModule.*c-ldistr_- *> pmap2 (-) A.*q_*n (inv A.*q-assoc *> A.ide_*q)) *> equation.cRing)) $
                =_<= (A.norm_*q-ofPos rat_<=-dec) <=∘ <=_* <=-refl (A.norm_*_<= <=∘ <=_* (transport (_ <=) ExUpperReal.+-rat $ A.norm_+ <=∘ <=_+ (sqrt.yfunc<=rfunc {_} {_} {w * w, square-norm w<=1 $ ExUpperReal.<_<= |1-w|<1} <=∘ ExUpperReal.<=-rat.1 RealBanachAlgebra.rfunc<=1) (ExUpperReal.<_<= |1-w|<q)) (=_<= $ pmap norm equation.abGroup)) <=∘ =_<= (inv *-assoc *> pmap (`* _) (ExUpperReal.*-rat rat_<=-dec $ RatField.<=_+-positive zro<=ide $ <=-less $ norm>=0 |1-w|<q))
          }
          \where {
            \lemma square-norm (w<=1 : w <= 1) (|1-w|<=1 : norm (1 - w) <= 1) : norm (1 - w * w) <= 1
              => A.square-lem c*-square-positive $ c*-<=_*-square w<=1 $ transport (_ <=) A.negative_zro (A.negative_<= $ A.norm-c*-positive |1-w|<=1) <=∘ zro<=ide
          }

        \lemma zfunc_pow {w : A} (w<=1 : w <= 1) (|1-w|<=1 : norm (1 - w) <= 1) : zfunc-lim (w * w, zfunc_pow>0.square-norm w<=1 |1-w|<=1) = w
          => \let M => ExPseudoMetricTransfer {\Sigma (x : A) (\Sigma (x <= 1) (norm (1 - x) <= 1))} __.1
             \in denseSet-lift-unique (\lam {s} Uo Us => \case (dist_open {M}).1 Uo Us \with {
               | inP (eps,eps>0,p) =>
                 \let | delta => ratio 1 2 * (eps ∧ 1)
                      | delta>0 : 0 RatField.< delta => linarith (<_meet-univ eps>0 zro<ide)
                      | ide-delta>=0 : 0 <= 1 - delta => linarith $ RatField.meet-right {eps} {1}
                      | y => (1 - delta) A.*q s.1 + delta A.*q 1
                      | |1-y|<1 => transport (\lam z => (norm z).U 1) (A.toRatModule.*c-ldistr_- *> pmap (`- _) A.toRatModule.*c-rdistr_- *> +-assoc *> pmap2 (+) A.ide_*q (inv A.negative_+)) $ =_<= (A.norm_*q-ofPos ide-delta>=0) <=∘ <=_* <=-refl s.2.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ ExUpperReal.<=-rat.1 ide-delta>=0) $ linarith
                 \in inP ((y, (<=_+ (A.<=_*q-right ide-delta>=0 s.2.1) <=-refl <=∘ =_<= (inv A.toRatModule.*c-rdistr *> pmap (A.`*q _) linarith *> A.ide_*q), ExUpperReal.<_<= |1-y|<1)), |1-y|<1, p $ unfolds $ unfold y $ rewrite (dist-symm, norm-dist, A.toRatModule.*c-rdistr_-, A.ide_*q) $ simplify $ rewrite (+-comm, inv A.toRatModule.*c-ldistr_-) $ =_<= (A.norm_*q-ofPos $ <=-less delta>0) <=∘ <=_* <=-refl s.2.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ ExUpperReal.<=-rat.1 $ <=-less delta>0) $ linarith RatField.meet-left)
             })
             (zfunc-lim ContMap.∘ TopTransfer-lift (*-locally-uniform ContMap.∘ ProductTopSpace.tuple ContMap.id ContMap.id ContMap.∘ TopTransfer-map __.1) (later \lam s => zfunc_pow>0.square-norm s.2.1 s.2.2))
             (TopTransfer-map __.1) (\lam {s} p => zfunc_pow>0 s.2.1 p) {w,(w<=1,|1-w|<=1)}
      }
  }

\func StoneC*PseudoAlgebraRieszSpace (A : StoneC*PseudoAlgebra) : RieszSpace A
  => {?}