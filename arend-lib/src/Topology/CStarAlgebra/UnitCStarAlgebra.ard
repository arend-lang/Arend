{- | The construction of {UnitC*Algebra} is taken from
     [1] Simon Henry, Constructive Gelfand Duality for non-unital commutative C*-algebras, 2014, https://arxiv.org/abs/1412.2009
 -}

\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.QModule
\import Algebra.Ring
\import Algebra.Ring.UnitAlgebra
\import Arith.Rat
\import Arith.Real
\import Arith.Real.Field
\import Arith.Real.UpperReal
\import Arith.Real.UpperRealLattice
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set.Filter
\import Topology.BanachAlgebra
\import Topology.BanachSpace
\import Topology.NormedAbGroup
\import Topology.NormedAbGroup.Real
\import Topology.StoneCStarAlgebra
\import Topology.NormedRing

\instance UnitC*Algebra (A : StoneC*PseudoAlgebra) : StoneC*Algebra (\Sigma Real A)
  | Ring => UnitAlgebra RealField A.toRealAlgebra
  | *-comm => ext (RealField.*-comm, equation.abGroup $ A.toZero A.*-comm)
  | isDivisible x n/=0 => \case RealStoneC*Algebra.isDivisible x.1 n/=0, A.isDivisible x.2 n/=0 \with {
    | inP (y,ny=x1), inP (b,nb=x2) => inP ((y,b), UnitAlgebra.*n-comm *> pmap2 (__,__) ny=x1 nb=x2)
  }
  | norm (x : \Sigma Real A) : ExUpperReal => RealAbGroup.abs x.1 ExUpperRealLattice.∨ Join \lam (s : \Sigma (y : A) (A.norm y <= 1)) => A.norm (x.1 A.*r s.1 + x.2 * s.1)
  | norm_zro => <=-antisymmetric
    (join-univ (Real.<=-upper.1 $ =_<= {RealAbGroup} RealAbGroup.abs_zro) $ Join-univ \lam s => =_<= $ pmap A.norm (pmap2 (+) A.toRealModule.*c_zro-left A.zro_*-left *> zro-right) *> norm_zro)
    (Real.<=-upper.1 RealAbGroup.abs>=0 <=∘ ExUpperRealLattice.join-left)
  | norm_negative => pmap2 (__ ∨ Join __) RealStoneC*Algebra.norm_negative $ ext \lam s => pmap A.norm (pmap2 (+) A.toRealModule.*c_negative-left A.negative_*-left *> +-comm *> inv A.negative_+) *> norm_negative
  | norm_+ => join-univ (transport (_ ExUpperReal.<=) RealAbGroup.+-upper (later $ Real.<=-upper.1 RealAbGroup.abs_+) <=∘ <=_+ join-left join-left) $
    Join-univ \lam s => =_<= (pmap A.norm $ pmap2 (+) A.toRealModule.*c-rdistr A.rdistr *> equation.abMonoid) <=∘ norm_+ <=∘ <=_+ (Join-cond s <=∘ join-right) (Join-cond s <=∘ join-right)
  | norm_*n_>= {n} {x} => =_<= $ inv (ExUpperRealSemigroup.*n_* (later (Real.<=-upper.1 RealAbGroup.abs>=0) <=∘ join-left) $ ExUpperReal.join-bounded U-inh \case (RealAbGroup.abs x.1).U-inh, norm-bounded x.2 \with {
    | inP (B1,|x1|<B1), inP (B2,|x2|<B2) => inP (B1 + B2 + 1, inP $ later (B1 + B2, linarith, \lam s => norm_+ $ ExUpperReal.+_U_<=.2 $ inP (B1, (=_<= A.norm_*r <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ Real.<=-upper.1 RealAbGroup.abs>=0)) |x1|<B1, B2, (A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0)) |x2|<B2, <=-refl)))
  }) *> ExUpperRealLattice.*n_join *> pmap2 (∨) (inv RealAbGroup.*n-upper *> RealAbGroup.abs_*n *> pmap RealAbGroup.abs (inv UnitAlgebra.*n-comm1)) (ExUpperRealLattice.*n_Join' inhabitted *> ExUpperRealLattice.Join_= \lam s => inv A.norm_*n-comm *> pmap A.norm (A.*n-ldistr *> pmap2 (+) (inv A.*r_*n *> inv A.toRealAlgebra.*c-assoc *> pmap (A.`*r _) (RealField.natCoef_*_*n *> inv (UnitAlgebra.*n-comm1 {_} {A.toRealAlgebra}))) (A.*n-comm-left *> pmap (`* _) (inv $ UnitAlgebra.*n-comm2 {_} {A.toRealAlgebra}))))
  | norm_*_<= {x y : \Sigma Real A} : norm (x * {UnitAlgebra RealField A.toRealAlgebra} y) <= norm x * norm y => join-univ (transportInv (`<= _) (RealField.abs_* *> RealField.*-upper RealAbGroup.abs>=0 RealAbGroup.abs>=0) $ <=_* join-left join-left) $
    Join-univ \lam s => =_<= A.norm_*-char <=∘ Join-univ \lam s' => =_<= (pmap A.norm
    \have | lem1 : x.1 * y.1 A.*r s.1 * s'.1 = x.1 A.*r s.1 * (y.1 A.*r s'.1) => inv A.toRealAlgebra.*c-comm-left *> A.toRealAlgebra.*c-assoc *> pmap (_ A.*r) A.toRealAlgebra.*c-comm-right *> A.toRealAlgebra.*c-comm-left
          | lem2 z w c d : z * (c A.*r d * w) = z * (d * (c A.*r w)) => pmap (z *) (inv A.toRealAlgebra.*c-comm-left *> A.toRealAlgebra.*c-comm-right)
    \in equation.cRing {lem1, lem2 s'.1 s.1 x.1 y.2, lem2 s.1 s'.1 y.1 x.2}) <=∘ A.norm_*_<= <=∘ <=_* (Join-cond s <=∘ join-right) (Join-cond s' <=∘ join-right)
  | norm_ide_<= => join-univ RealStoneC*Algebra.norm_ide_<= $ Join-univ \lam s => =_<= (pmap A.norm $ pmap2 (+) A.toRealModule.ide_*c A.zro_*-left *> zro-right) <=∘ s.2
  | norm-ext {x} p =>
    \have x1=0 => RealAbGroup.abs_zro-ext $ RealAbGroup.<=-antisymmetric ((Real.<=-upper {_} {0}).2 $ join-left <=∘ =_<= p) RealAbGroup.abs>=0
    \in ext (x1=0, norm-ext $ <=-antisymmetric (=_<= A.norm_*-char <=∘ Join-univ \lam s => =_<= (pmap A.norm $ inv $ pmap (`+ _) (pmap (RealBanachSpace.`*r _) x1=0 *> A.toRealAlgebra.*c_zro-left) *> zro-left) <=∘ Join-cond s <=∘ join-right <=∘ =_<= p) norm>=0)
  | isCompleteMetric F Fc => \case
      RealNormed.isCompleteMetric (ProperFilter-map __.1 F) \lam eps>0 => TruncP.map (Fc eps>0) \lam (r,Fr) => (r.1, filter-mono Fr \lam d => ExUpperRealAbMonoid.join-left d),
      A.isCompleteMetric (ProperFilter-map __.2 F) (\lam {eps} eps>0 => TruncP.map (Fc $ RatField.half>0 $ RatField.half>0 eps>0) \lam (r,Fr) => (r.2, filter-mono Fr \lam {x} d => <-rat.1 $ rewrite (A.norm-dist, A.norm_*-char) $ Join-univ (\lam s =>
        \have | t1 => join-left <∘r <-rat.2 d
              | t2 => Join-cond s <∘r join-right <∘r <-rat.2 d
        \in norm_dist-left {_} {_} {negative (r.1 - x.1) A.*r s.1} <=∘ <=_+ (=_<= norm-dist) (=_<= A.norm_*r <=∘ <=_* (=_<= {ExUpperRealAbMonoid} RealAbGroup.abs_negative) s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ Real.<=-upper.1 RealAbGroup.abs>=0)) <=∘ unfold (-) (rewrite (A.toRealAlgebra.*c_negative-left,A.negative-isInv,A.+-comm) $ <=_+ (<=-less t2) (<=-less t1) <=∘ =_<= (ExUpperReal.+-rat *> pmap ExUpperReal.fromRat linarith))) <∘r (<-rat {RatField.half eps}).2 (RatField.half<id eps>0)))
    \with {
      | inP (a,al), inP (x,xl) => inP ((a,x), \lam {eps} eps>0 => filter-mono (filter-meet (al $ RatField.half>0 $ RatField.half>0 eps>0) (xl $ RatField.half>0 $ RatField.half>0 eps>0))
        \lam {z} d => <-rat.1 $ join-univ (<=-less (<-rat.2 d.1) <=∘ ExUpperReal.<=-rat.1 (<=-less $ RatField.half<id $ RatField.half>0 eps>0)) (Join-univ $ later \lam s => norm_+ <=∘ <=_+ (=_<= A.norm_*r <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right $ norm>=0 {RealNormed})) (A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0 *> inv norm-dist)) <=∘ <=_+ (ExUpperReal.<_<= d.1) (ExUpperReal.<_<= d.2) <=∘ =_<= (ExUpperReal.+-rat *> pmap ExUpperReal.fromRat linarith)) <∘r (<-rat {RatField.half eps}).2 (RatField.half<id eps>0))
    }
  | c*-sum {a} {b} => norm_*_<= <=∘ =_<= ExUpperRealLattice.join-square <=∘ join-univ (RealStoneC*Algebra.c*-square <=∘ RealStoneC*Algebra.c*-sum <=∘ join-left)
    (=_<= (ExUpperRealLattice.Join-square inhabitted) <=∘ Join-univ \lam s => A.c*-square <=∘ A.c*-sum {_} {b.1 A.*r s.1 + b.2 * s.1} <=∘ =_<= (pmap A.norm $ later $ rewrite A.toRealAlgebra.*c-rdistr $ equation.cRing {
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.1 A.*r s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) (inv A.toRealAlgebra.*c-assoc),
      inv (A.toRealAlgebra.*c-comm-left {b.1} {s.1} {b.1 A.*r s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) (inv A.toRealAlgebra.*c-assoc),
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.2 * s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) A.toRealAlgebra.*c-comm-left,
      inv (A.toRealAlgebra.*c-comm-right {b.1} {s.1} {b.2}) *> A.toRealAlgebra.*c-comm-left
    }) <=∘ A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0) <=∘ Join-cond s <=∘ join-right)
  | c*-square {a} => =_<= ExUpperRealLattice.join-square <=∘ join-univ (RealStoneC*Algebra.c*-square <=∘ join-left)
    (=_<= (ExUpperRealLattice.Join-square inhabitted) <=∘ Join-univ \lam s => A.c*-square <=∘ =_<= (pmap A.norm $ equation.cRing {
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.1 A.*r s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) (inv A.toRealAlgebra.*c-assoc),
      inv (A.toRealAlgebra.*c-comm-left {a.1} {s.1} {a.2 * s.1}) *> A.toRealAlgebra.*c-comm-right *> pmap (_ *) A.toRealAlgebra.*c-comm-left
    }) <=∘ A.norm_*_<= <=∘ <=_* <=-refl s.2 <=∘ =_<= (ExUpperRealSemigroup.ide-right norm>=0) <=∘ Join-cond s <=∘ join-right)
  \where {
    \open ExUpperRealAbMonoid(<-rat)
    \open ExUpperRealSemigroup(<=_*)

    \private \lemma inhabitted : ∃ (y : A) (A.norm y <= 1)
      => inP (A.zro, transportInv (`<= _) norm_zro $ <=-less ExUpperRealAbMonoid.zro<ide)
  }
