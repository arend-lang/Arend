\import Algebra.Group
\import Algebra.Module
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.QModule
\import Algebra.Ring.RingHom
\import Arith.Nat
\import Arith.Rat
\import Arith.Real.UpperReal
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Category
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Topology.BanachSpace
\import Topology.CStarAlgebra
\import Topology.MetricSpace
\import Topology.NormedAbGroup
\open QModule

\record PreC*AlgebraHom \extends RingHom, PosetHom {
  \override Dom : RealPreC*Algebra
  \override Cod : RealPreC*Algebra

  \func IsDense : \Prop
    => ∀ {eps} (0 < eps) y ∃ (x : Dom) (func x - y <= eps *q 1) (y - func x <= eps *q 1)

  \func IsIsometric : \Prop
    => \Pi {x : Dom} -> func x <= 1 -> negative (func x) <= 1 -> \Pi {q : Rat} -> 1 < q -> x <= q *q 1

  \lemma toNormed : NormedAbGroupMap toBanach toBanach func \cowith
    | func-+ => func-+
    | func-norm (inP (a,a<b,a>0,x<=a,-x<=a)) => inP (a, a<b, a>0,
        transport (_ <=) (func-*q *> pmap (a *q) func-ide) (func-<= x<=a),
        transport2 (<=) func-negative (func-*q *> pmap (a *q) func-ide) (func-<= -x<=a))

  \lemma dense-toNormed : IsDense <-> toNormed.IsDense
    => (\lam d {y} Uo Uy => \case (dist_open {toBanach}).1 Uo Uy \with {
      | inP (eps,eps>0,Up) => \case d (RatField.half>0 eps>0) y \with {
        | inP (x,xl,xr) => inP (func x, inP (x,idp), Up $ inP (RatField.half eps, RatField.half<id eps>0, RatField.half>0 eps>0, xr, rewrite AddGroup.negative_- xl))
      }
    }, \lam d {eps} eps>0 y => \case d {y} {OBall {toBanach} eps y} (OBall-open {toBanach}) (OBall-center {toBanach} eps>0) \with {
      | inP (_, inP (x,idp), inP (delta,delta<eps,_,y-x<=delta,x-y<=delta)) => inP (x, (rewrite AddGroup.negative_- in x-y<=delta) <=∘ <=_*q-left (RatField.<=-less delta<eps) zro<=ide, y-x<=delta <=∘ <=_*q-left (RatField.<=-less delta<eps) zro<=ide)
    })

  \lemma isometry-toNormed : IsIsometric <-> (\Pi {x : Dom} -> toBanach.norm (func x) = toBanach.norm x)
    => (\lam c {x} => <=-antisymmetric toNormed.func-norm \lam {b} (inP (a',a'<b,a'>0,fx<=a',-fx<=a')) => \case isDense a'<b \with {
      | inP (a,a'<a,a<b) =>
        \have | lem => =_<= (inv *q-assoc *> pmap (`*q 1) (RatField.finv-left $ RatField.>_/= a'>0) *> ide_*q)
              | x<=a {x} (fx<=a' : func x <= a' *q 1) (-fx<=a' : negative (func x) <= a' *q 1) => <=_*q-cancel-left (RatField.finv>0 a'>0) $ transport (_ <=) *q-assoc $ c
                       (=_<= func-*q <=∘ <=_*q-right (RatField.<=-less $ RatField.finv>0 a'>0) fx<=a' <=∘ lem)
                       (=_<= (pmap negative func-*q *> inv (later toRatModule.*c_negative-right)) <=∘ <=_*q-right (RatField.<=-less $ RatField.finv>0 a'>0) -fx<=a' <=∘ lem)
                       (transport (_ <) *-comm $ RatField.<_rotate-right a'>0 $ transportInv (`< _) ide-left a'<a)
        \in inP (a, a<b, a'>0 <∘ a'<a, x<=a fx<=a' -fx<=a', x<=a (rewrite func-negative -fx<=a') $ rewrite (func-negative,AddGroup.negative-isInv) fx<=a')
    }, \lam c {x} fx<=1 -fx<=1 q>1 => \case transport (`<= _) c (norm<=1 fx<=1 -fx<=1) q>1 \with {
      | inP (r,r<q,_,x<=r,_) => x<=r <=∘ <=_*q-left (RatField.<=-less r<q) zro<=ide
    })

  \lemma toIsometry (p : IsIsometric) : NormedIsometricMap toBanach toBanach func \cowith
    | NormedAbGroupMap => toNormed
    | func-norm-isometry => isometry-toNormed.1 p
} \where {
  \open RealPreC*Algebra
}

\record C*AlgebraHom \extends PreC*AlgebraHom, BoundedLinearMap {
  \override Dom : RealC*Algebra
  \override Cod : RealC*Algebra

  | func-<= (inP (a,aa=y-x)) => inP (func a, inv func-* *> pmap func aa=y-x *> func-minus)
  | isBounded => inP (1, idp, \lam x => transportInv (_ <=) (ExUpperRealSemigroup.ide-left norm>=0) $
      transport2 (<=) (inv RealC*Algebra.norm-char) (inv RealC*Algebra.norm-char) toNormed.func-norm)
} \where {
  \lemma fromRingHom {X Y : RealC*Algebra} (f : RingHom X Y) : C*AlgebraHom X Y f \cowith
    | RingHom => f
}