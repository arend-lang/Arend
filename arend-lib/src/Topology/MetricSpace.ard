\import Algebra.Linear.Solver
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.Ring.Solver
\import Arith.Real
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.CoverSpace
\import Topology.CoverSpace.Complete
\import Topology.UniformSpace
\open Bounded(top)
\open RealAbGroup(half,half+half,half>0)

\class PseudoMetricSpace \extends UniformSpace, StronglyRegularCoverSpace {
  | dist : E -> E -> Real
  | dist-refl {x : E} : dist x x = zro
  | dist-symm {x y : E} : dist x y = dist y x
  | dist-triang {x y z : E} : dist x z <= dist x y + dist y z

  | isUniform C => ∃ (eps : Real) (0 < eps) ∀ x ∃ (U : C) ∀ {y} (dist x y < eps -> U y)
  | uniform-cover (inP (eps,eps>0,h)) x => \case h x \with {
    | inP (U,CU,g) => inP (U, CU, g $ rewrite dist-refl eps>0)
  }
  | uniform-top => inP (3, inP (2, idp, -1, idp, idp), \lam x => inP (top, idp, \lam _ => ()))
  | uniform-extend (inP (eps,eps>0,h)) e => inP (eps, eps>0, \lam x => \case h x \with {
    | inP (U,CU,g) => \case e CU \with {
      | inP (V,DV,U<=V) => inP (V, DV, \lam d => U<=V $ g d)
    }
  })
  | uniform-inter (inP (eps,eps>0,h)) (inP (eps',eps'>0,h')) => inP (eps ∧ eps', LinearOrder.<_meet-univ eps>0 eps'>0, \lam x => \case h x, h' x \with {
    | inP (U,CU,g), inP (U',DU',g') => inP (U ∧ U', inP (U, CU, U', DU', idp), \lam d => (g $ d <∘l meet-left, g' $ d <∘l meet-right))
  })
  | uniform-star (inP (eps,eps>0,h)) => inP (\lam V => \Sigma (∃ V) (∀ {x y : V} (dist x y < half eps)), inP (half (half eps), half>0 (half>0 eps>0), \lam x => inP (\lam y => dist x y < half (half eps), (inP (x, rewrite dist-refl (half>0 (half>0 eps>0))), \lam {z} p q => dist-triang {_} {z} {x} <∘r rewrite dist-symm (OrderedAddMonoid.<_+ p q <∘l Preorder.=_<= (half+half {half eps}))), \lam c => c)), \case __ \with {
    | (inP (x,Vx),g) => \case h x \with {
      | inP (U,CU,f) => inP (U, CU, \case __ \with {
        | (inP (y,V'y),g') => \lam (z,(Vz,V'z)) => \lam {w} V'w => f $ dist-triang <∘r OrderedAddMonoid.<_+ (g Vx Vz) (g' V'z V'w) <∘l Preorder.=_<= half+half
      })
    }
  })
  | isStronglyRegular => ClosureCoverSpace.closure-regular {ClosurePrecoverSpace isUniform uniform-cover} StronglyRatherBelow $ later \case __ \with {
    | inP (eps,eps>0,h) => ClosurePrecoverSpace.closure $ inP (half (half eps), half>0 (half>0 eps>0), \lam x => \case h x \with {
      | inP (U,CU,f) => inP (\lam y => dist x y < half (half eps), inP (U, CU, ClosurePrecoverSpace.closure $ uniform-extend {_} {\lam U => ∃ (x : E) (U = \lam y => dist x y < half (half eps))} (inP (half (half eps), half>0 (half>0 eps>0), \lam x => inP (_, inP (x, idp), \lam r => r))) \lam {W} => \case __ \with {
        | inP (y,p) => rewrite p \case real-located {dist x y} {half eps} {half eps + half (half eps)} (transport (RealAbGroup.`< _) zro-right $ <_+-right _ $ half>0 $ half>0 eps>0) \with {
          | byLeft xy>1/2 => inP (_, byLeft idp, \lam {z} yz<1/4 => \lam xz<1/4 => <-irreflexive $ xy>1/2 <∘ (rewrite (half+half {half eps}) in dist-triang <∘r OrderedAddMonoid.<_+ xz<1/4 (rewrite dist-symm in yz<1/4)))
          | byRight xy<3/4 => inP (_, byRight idp, \lam {z} yz<1/4 => f $ dist-triang <∘r OrderedAddMonoid.<_+ xy<3/4 yz<1/4 <∘l Preorder.=_<= (+-assoc *> pmap (_ +) (half+half {half eps}) *> half+half))
        }
      }), \lam r => r)
    })
  }

  \lemma dist>=0 {x y : E} : 0 <= dist x y
    => \have t => rewrite (dist-refl,dist-symm) in dist-triang {_} {y} {x} {y}
       \in \lam d => t $ OrderedAddMonoid.<_+ d d <∘l Preorder.=_<= zro-left

  \lemma makeUniform {eps : Real} (eps>0 : 0 < eps) : isUniform \lam U => ∃ (x : E) (U = \lam y => dist x y < eps)
    => inP (eps, eps>0, \lam x => inP (_, inP (x, idp), \lam r => r))

  \func OBall (eps : Real) (x : E) : Set E
    => \lam y => dist x y < eps

  \func CBall (eps : Real) (x : E) : Set E
    => \lam y => dist x y <= eps
}

\class LinearBaseRingData \extends LinearData, BaseRingData {
  \override R : OrderedRing
}

\class MetricSpace \extends PseudoMetricSpace, SeparatedCoverSpace
  | dist-ext {x y : E} : dist x y = zro -> x = y
  | isSeparatedCoverSpace {x} {y} f => dist-ext $ <=-antisymmetric (\lam d>0 => \case f (ClosurePrecoverSpace.closure $ makeUniform {\this} {half (dist x y)} (half>0 d>0)) \with {
    | inP (U, inP (z,p), (Ux,Uy)) =>
      \have | U'x => rewrite (p,dist-symm) Ux
            | U'y => rewrite p Uy
      \in <-irreflexive $ rewrite half+half in dist-triang <∘r OrderedAddMonoid.<_+ U'x U'y
  }) dist>=0