\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Arith.Rat
\import Arith.Real
\import Arith.Real.UpperReal
\import Function
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Operations
\import Order.Biordered
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Filter
\import Set.Subset
\import Topology.CoverSpace
\import Topology.CoverSpace.Complete
\import Topology.TopSpace
\import Topology.UniformSpace
\import Topology.UniformSpace.Complete
\import Topology.UniformSpace.Product
\import Topology.UniformSpace.StronglyComplete (StronglyCompleteUniformSpace)
\open RealAbGroup \hiding (+, join, meet, negative, zro<ide)
\open ValuedPseudoMetricSpace (metricUniform)
\open PseudoMetricSpace (halving)

\class MetricValueOrder \extends BiorderedLatticeAbMonoid {
  | \protected hasPositive : ∃ (a : E) (0 < a)
  | \protected +_<-dense {a b : E} : a < b -> ∃ (d : E) (0 < d) (a + d < b)
  | \protected bounded-negative {a : E} : (\Pi {b : E} -> 0 < b -> a < b) -> a <= 0
  | \protected double-positive {a : E} : 0 <= a + a -> 0 <= a

  \lemma shrink2 {eps : E} (eps>0 : 0 < eps) : ∃ (delta : E) (0 < delta) (delta < eps) (delta + delta < eps)
    => \case +_<-dense eps>0 \with {
      | inP (delta,delta>0,p) =>
        \have delta<eps => transport (`< _) zro-left p
        \in \case +_<-dense delta<eps \with {
          | inP (delta',delta'>0,delta+delta'<eps) => inP (delta ∧ delta', <_meet-univ delta>0 delta'>0, meet-left <∘r delta<eps, <=_+ meet-left meet-right <∘r delta+delta'<eps)
        }
    }
}

\class ValuedPseudoMetricSpace (V : MetricValueOrder) \extends UniformSpace {
  | dist : E -> E -> V
  | dist-refl {x : E} : dist x x = 0
  | dist-symm {x y : E} : dist x y = dist y x
  | dist-triang {x y z : E} : dist x z <= dist x y + dist y z
  | dist-uniform {C : Set (Set E)} : isUniform C <-> ∃ (eps : V) (0 < eps) ∀ x ∃ (U : C) ∀ {y} (dist x y < eps -> U y)

  | uniform-cover Cu x => \case dist-uniform.1 Cu \with {
    | inP (eps,eps>0,h) => \case h x \with {
      | inP (U,CU,g) => inP (U, CU, g $ rewrite dist-refl eps>0)
    }
  }
  | uniform-top => dist-uniform.2 \case hasPositive \with {
    | inP (a,a>0) => inP (a, a>0, \lam x => inP (Bounded.top, idp, \lam _ => ()))
  }
  | uniform-refine Cu e => \case dist-uniform.1 Cu \with {
    | inP (eps,eps>0,h) => dist-uniform.2 $ inP (eps, eps>0, \lam x => \case h x \with {
      | inP (U,CU,g) => \case e CU \with {
        | inP (V,DV,U<=V) => inP (V, DV, \lam d => U<=V $ g d)
      }
    })
  }
  | uniform-inter Cu C'u => \case dist-uniform.1 Cu, dist-uniform.1 C'u \with {
    | inP (eps,eps>0,h), inP (eps',eps'>0,h') => dist-uniform.2 $ inP (eps ∧ eps', <_meet-univ eps>0 eps'>0, \lam x => \case h x, h' x \with {
      | inP (U,CU,g), inP (U',DU',g') => inP (U ∧ U', inP $ later (U, CU, U', DU', idp), \lam d => (g $ d <∘l meet-left, g' $ d <∘l meet-right))
    })
  }
  | uniform-star Cu => \case dist-uniform.1 Cu \with {
    | inP (eps,eps>0,h) => \case V.shrink2 eps>0 \with {
      | inP (delta',delta'>0,_,delta'+delta'<eps) => \case V.shrink2 delta'>0 \with {
        | inP (delta,delta>0,delta<delta',delta+delta<delta') => inP (\lam U => ∃ (x : E) (U = \lam y => dist x y < delta), dist-uniform.2 $ inP (delta, delta>0, \lam x => inP $ later (_, inP (x, idp), \lam d => d)), \lam {_} (inP (x,idp)) => \case h x \with {
          | inP (U,CU,g) => inP (U, CU, \lam {_} (inP (y,idp)) s {z} d => g $ dist-triang <∘r <=_+ (dist-triang <=∘ <=_+ (<=-less s.2.1) (<=-less $ transport (`< _) dist-symm s.2.2) <=∘ <=-less delta+delta<delta') (LinearOrder.<=-less $ d <∘ delta<delta') <∘r delta'+delta'<eps)
        })
      }
    }
  }

  \default isUniform C : \Prop => ∃ (eps : V) (0 < eps) ∀ x ∃ (U : C) ∀ {y} (dist x y < eps -> U y)
  \default dist-uniform \as dist-uniform-impl {C} : isUniform C <-> _ => <->refl

  \lemma metricProperUniform : IsProperUniform
    => \lam Cu => \case dist-uniform.1 Cu \with {
      | inP (eps,eps>0,h) => dist-uniform.2 $ inP (eps, eps>0, \lam x => \case h x \with {
        | inP (U,CU,g) => inP (U, later (CU, inP (x, g $ rewrite dist-refl eps>0)), g)
      })
    }

  \lemma metricUniform {eps : V} (eps>0 : 0 < eps) : PreuniformSpace.isUniform \lam U => ∃ (x : E) (U = \lam y => dist x y < eps)
    => dist-uniform.2 $ inP $ later (eps, eps>0, \lam x => inP (_, inP (x, idp), \lam r => r))

  \func NFilter (x : E) : SetFilter E \cowith
    | F U => ∃ (eps : V) (0 < eps) (VOBall eps x ⊆ U)
    | filter-mono (inP (eps,eps>0,q)) p => inP (eps, eps>0, q <=∘ p)
    | filter-top => \case hasPositive \with {
      | inP (a,a>0) => inP (a, a>0, \lam _ => ())
    }
    | filter-meet (inP (eps,eps>0,p)) (inP (eps',eps'>0,p')) => inP (eps ∧ eps', <_meet-univ eps>0 eps'>0, \lam d => (p $ d <∘l meet-left, p' $ d <∘l meet-right))
}

\lemma dist>=0 {X : ValuedPseudoMetricSpace} {x y : X} : 0 <= dist x y
  => double-positive $ transport2 (__ <= _ + __) dist-refl dist-symm dist-triang

\func VOBall {X : ValuedPseudoMetricSpace} (eps : X.V) (x : X) : Set X
  => \lam y => dist x y < eps

\lemma OBall-center {X : ValuedPseudoMetricSpace} {eps : X.V} (eps>0 : 0 < eps) {x : X} : VOBall eps x x
  => transportInv (`< _) dist-refl eps>0

\lemma OBall-open {X : ValuedPseudoMetricSpace} {eps : X.V} {x : X} : isOpen (VOBall eps x)
  => cauchy-open.2 \lam {y} xy<eps => \case +_<-dense xy<eps \with {
    | inP (delta,delta>0,xy+delta<eps) => \case X.V.shrink2 delta>0 \with {
      | inP (delta',delta'>0,delta'<delta,delta'+delta'<delta) => X.makeCauchy $ uniform-refine (X.metricUniform delta'>0) \lam {_} (inP (z,idp)) => inP (_, later \lam zy<delta' {w} zw<delta' => dist-triang <∘r <=_+ <=-refl (dist-triang {_} {_} {z} <=∘ <=_+ (<=-less $ transport (`< _) dist-symm zy<delta') (<=-less zw<delta') <=∘ <=-less delta'+delta'<delta) <∘r xy+delta<eps, <=-refl)
    }
  }

\lemma OBall-center_<=< {X : ValuedPseudoMetricSpace} {eps : X.V} (eps>0 : 0 < eps) {x : X} : single x <=< VOBall eps x
  => X.open-char.1 OBall-open (OBall-center eps>0)

\lemma dist_open {X : ValuedPseudoMetricSpace} {U : Set X} : isOpen U <-> ∀ {x : U} ∃ (eps : X.V) (0 < eps) (VOBall eps x ⊆ U)
  => (\lam Uo {x} Ux => \case cauchy-ball (cauchy-open.1 Uo Ux) x \with {
    | inP (eps,eps>0,V,h,p) => inP (eps, eps>0, p <=∘ h (p $ OBall-center eps>0))
  }, \lam f => X.cover-open \lam Ux => \case f Ux \with {
    | inP (eps,eps>0,h) => inP (_, OBall-open, OBall-center eps>0, h)
  })

\lemma cauchy-ball {X : ValuedPseudoMetricSpace} {C : Set (Set X)} (Cc : isCauchy C) (x : X) : ∃ (eps : X.V) (0 < eps) (U : C) (VOBall eps x ⊆ U)
  => \case ClosurePrecoverSpace.closure-filter (X.NFilter x) (\lam {D} Du => \case dist-uniform.1 Du \with {
    | inP (eps,eps>0,h) => \case h x \with {
      | inP (U,DU,p) => inP (U, DU, inP (eps, eps>0, p __))
    }
  }) (uniform-cauchy.1 Cc) \with {
    | inP (U, CU, inP (eps,eps>0,p)) => inP (eps, eps>0, U, CU, p)
  }

\lemma <=<-ball {X : ValuedPseudoMetricSpace} {x : X} {U : Set X} (x<=<U : single x <=< U) : ∃ (eps : X.V) (0 < eps) (VOBall eps x ⊆ U)
  => \case cauchy-ball (unfolds in x<=<U) x \with {
    | inP (eps,eps>0,V,h,p) => inP (eps, eps>0, p <=∘ h (x, (idp, p $ OBall-center eps>0)))
  }

\lemma OBall_<=* {X : ValuedPseudoMetricSpace} {x : X} {eps delta : X.V} (delta<eps : delta < eps) : VOBall delta x <=* VOBall eps x
  => \case +_<-dense delta<eps \with {
    | inP (d,d>0,delta+d<eps) => \case X.V.shrink2 d>0 \with {
      | inP (e,e>0,e<d,e+e<d) => inP (_, X.metricUniform e>0, \lam {w} (inP (_, (inP (y,idp), (z,(xz<delta,yz<e))), yw<e)) =>
        dist-triang <∘r <=_+ (<=-less xz<delta) (dist-triang {_} {_} {y} <=∘ <=_+ (<=-less $ transport (`< _) dist-symm yz<e) (<=-less yw<e) <=∘ <=-less e+e<d) <∘r delta+d<eps)
    }
  }

\func IsBoundedSet {X : ValuedPseudoMetricSpace} (S : Set X) : \Prop
  => ∃ (B : X.V) (0 < B) (x : S) ∀ {y : S} (dist x y < B)

\lemma metric-contAt-char {X Y : ValuedPseudoMetricSpace} {f : X -> Y} {x : X}
  : IsContAt f x <-> ∀ {eps : Y.V} (0 < eps) ∃ (delta : X.V) (0 < delta) ∀ {x'} (dist x x' < delta -> dist (f x) (f x') < eps)
  => (\lam fc {eps} eps>0 => \case fc {VOBall eps (f x)} OBall-open (OBall-center eps>0) \with {
    | inP (U,Uo,Ux,p) => \case dist_open.1 Uo Ux \with {
      | inP (delta,delta>0,q) => inP (delta, delta>0, \lam xx'<delta => p $ q xx'<delta)
    }
  }, \lam fc Vo Vfx => \case dist_open.1 Vo Vfx \with {
    | inP (eps,eps>0,p) => \case fc eps>0 \with {
      | inP (delta,delta>0,q) => inP (VOBall delta x, OBall-open, OBall-center delta>0, \lam d => p $ q d)
    }
  })

\class UpperPseudoMetricSpace \extends ValuedPseudoMetricSpace {
  | V => UpperRealMetricValueOrder
} \where {
  \open UpperRealAbMonoid(<-rat)
  \open PosUpperRealSemiring(+_U)

  \instance UpperRealMetricValueOrder : MetricValueOrder PosUpperReal
    | BiorderedLatticeAbMonoid => PosUpperRealLattice
    | hasPositive => inP (1, PosUpperRealSemiring.zro<ide)
    | +_<-dense (inP (c,a<c,c<=b)) => \case U-rounded a<c \with {
      | inP (d,a<d,d<c) => inP (PosUpperReal.fromRat ((c - d) * ratio 1 4) linarith, <-rat.2 linarith, inP (c, +_U.2 $ inP (d, a<d, (c - d) * ratio 1 2, linarith, linarith), c<=b))
    }
    | bounded-negative p {b} b>0 => <-rat.1 $ p {PosUpperReal.fromRat b $ <=-less b>0} $ <-rat.2 b>0
    | double-positive a+a>=0 a<b => linarith $ a+a>=0 \case U-rounded a<b \with {
      | inP (c,a<c,c<b) => +_U.2 $ inP (c, a<c, c, a<c, RatField.<_+ c<b c<b)
    }
}

\class ValuedMetricSpace \extends ValuedPseudoMetricSpace, SeparatedCoverSpace
  | dist-ext {x y : E} : dist x y = 0 -> x = y
  | isSeparatedCoverSpace f => dist-ext $ <=-antisymmetric (bounded-negative \lam b>0 =>
    \have | (inP (eps,eps>0,b>eps,eps+eps<b)) => V.shrink2 b>0
          | (inP (_, inP (z,idp), (zx<eps,zy<eps))) => f $ makeCauchy $ metricUniform eps>0
    \in dist-triang <∘r <=_+ (<=-less $ transport (`< _) dist-symm zx<eps) (<=-less zy<eps) <∘r eps+eps<b) dist>=0

\lemma metric-ext {X : ValuedMetricSpace} {x y : X} (p : \Pi {eps : X.V} -> 0 < eps -> dist x y < eps) : x = y
  => dist-ext $ <=-antisymmetric (bounded-negative p) dist>=0

\class MetricValueLinearOrder \extends MetricValueOrder, LinearlyBiorderedAbMonoid
  | bounded-negative p a>0 => <-irreflexive (p a>0)
  | double-positive p a<0 => \have a+0>=0 => p <=∘ <=_+ <=-refl (<=-less a<0)
                             \in a+0>=0 $ transportInv (`< 0) zro-right a<0

\class LinearlyValuedPseudoMetricSpace \extends ValuedPseudoMetricSpace, StronglyRegularUniformSpace {
  \override V : MetricValueLinearOrder
  | uniform-strongly-star Cu =>
    \have | (inP (eps,eps>0,h)) => dist-uniform.1 Cu
          | (inP (eps1,eps1>0,_,eps1+eps1<eps)) => V.shrink2 eps>0
          | (inP (eps2,eps2>0,eps2<eps1,eps2+eps2<eps1)) => V.shrink2 eps1>0
          | (inP (eps3,eps3>0,eps3<eps2,eps3+eps3<eps2)) => V.shrink2 eps2>0
    \in inP (\lam U => ∃ (x : E) (U = \lam y => dist x y < eps3), dist-uniform.2 $ inP (eps3, eps3>0, \lam x => inP $ later (_, inP (x,idp), \lam d => d)), \lam {_} (inP (x,idp)) => \case h x \with {
      | inP (U,CU,g) => inP (U, CU, \lam {_} (inP (y,idp)) => \case <-comparison (dist x y) eps2<eps1 \with {
        | byLeft xy>eps2 => byLeft \lam (z,(xz<eps3,yz<eps3)) => <-irreflexive $ xy>eps2 <∘ dist-triang <∘r <=_+ (<=-less xz<eps3) (<=-less $ transport (`< _) dist-symm yz<eps3) <∘r eps3+eps3<eps2
        | byRight xy<eps1 => byRight \lam {z} yz<eps3 => g $ dist-triang <∘r <=_+ (<=-less xy<eps1) (<=-less $ yz<eps3 <∘ eps3<eps2 <∘ eps2<eps1) <∘r eps1+eps1<eps
      })
    })
}

\class PseudoMetricSpace \extends LinearlyValuedPseudoMetricSpace {
  | V => RealMetricValueLinearOrder

  \lemma halving {z x y : E} {eps : Real} (d1 : dist z x < half eps) (d2 : dist z y < half eps) : dist x y < eps
    => dist-triang <∘r OrderedAddMonoid.<_+ (rewrite dist-symm in d1) d2 <∘l Preorder.=_<= half+half

  \lemma dist-uniform-rat {C : Set (Set E)} : PreuniformSpace.isUniform C <-> ∃ (eps : Rat) (0 < eps) ∀ x ∃ (U : C) ∀ {y} (dist x y < eps -> U y)
    => (\lam Cu => \case dist-uniform.1 Cu \with {
          | inP (eps,eps>0,h) => \case real_<-rat-char.1 eps>0 \with {
            | inP (eps',eps'>0,eps'<eps) => inP (eps', eps'>0, \lam x => \case h x \with {
              | inP (U,CU,g) => inP (U, CU, \lam d => g $ d <∘ real_<_L.2 eps'<eps)
            })
          }
    }, \lam (inP (eps,eps>0,h)) => dist-uniform.2 $ inP (eps, real_<_L.2 eps>0, h))
} \where {
  \instance RealMetricValueLinearOrder : MetricValueLinearOrder Real
    | LinearlyBiorderedAbMonoid => RealAbGroup
    | hasPositive => inP (1, RealAbGroup.zro<ide)
    | +_<-dense {a} {b} a<b => \case isDense a<b \with {
      | inP (c,a<c,c<b) => inP (c - a, transport (`< _) negative-right $ <_+-left _ a<c, transportInv (`< _) (+-comm *> +-assoc *> pmap (c +) negative-left *> zro-right) c<b)
    }
}

\func OBall {X : PseudoMetricSpace} (eps : Real) (x : X) : Set X
  => \lam y => dist x y < eps

\lemma OBall_s<=* {X : PseudoMetricSpace} {x : X} {eps delta : Real} (delta<eps : delta < eps) : OBall delta x s<=* OBall eps x
  => \let | d => eps - delta
          | d>0 : 0 < d => transport (`< _) negative-right $ <_+-left (negative delta) delta<eps
     \in unfolds $ uniform-refine (metricUniform $ half>0 $ half>0 d>0) $ later
          \lam {_} (inP (y,idp)) => \case real-located $ <_+-cancel-right (half (half d)) $ transport2 (<) (inv $ +-assoc *> pmap (_ +) half+half) (inv $ +-assoc *> pmap (_ +) negative-left *> zro-right) $ <_+-cancel-left (negative delta) $ transport2 (<) (inv (pmap (`+ _) negative-left *> zro-left) *> +-assoc) +-comm (half<id d>0) \with {
            | byLeft e => inP (_, byLeft idp, \lam {z} yz<d/4 xz<delta => <-irreflexive $ e <∘ dist-triang <∘r RealAbGroup.<_+ xz<delta (transport (`< _) dist-symm yz<d/4))
            | byRight e => inP (_, byRight idp, \lam {z} yz<d/4 => transport (_ <) (+-assoc *> pmap (_ +) negative-left *> zro-right) $ dist-triang <∘r RealAbGroup.<_+ e yz<d/4)
          }

\class MetricSpace \extends PseudoMetricSpace, ValuedMetricSpace

\record LocallyUniformMetricMap (V : MetricValueOrder) \extends LocallyUniformMap {
  \override Dom : ValuedPseudoMetricSpace V
  \override Cod : ValuedPseudoMetricSpace V

  | func-dist-locally-uniform : ∀ {eps : V} (0 < eps) ∃ (delta : V) (0 < delta) ∀ (x0 : Dom) ∃ (gamma : V) (0 < gamma) ∀ {x x' : Dom} (dist x0 x < delta -> dist x x' < gamma -> dist (func x) (func x') < eps)
  | func-locally-uniform Eu => \case dist-uniform.1 Eu \with {
    | inP (eps,eps>0,h) => \case func-dist-locally-uniform eps>0 \with {
      | inP (delta,delta>0,g) => inP (_, metricUniform delta>0, \lam (inP (x0,p)) => \case g x0 \with {
        | inP (gamma,gamma>0,g') => dist-uniform.2 $ inP (gamma, gamma>0, \lam x => \case h (func x) \with {
          | inP (W,EW,e) => inP (\lam x' => dist x x' < gamma, inP $ later (W, EW, \lam {x'} c =>
              e $ rewrite (dist-symm {Cod}) $ g' (rewrite p in c.1) $ rewrite (dist-symm {Dom}) c.2
          ), \lam d => d)
        })
      })
    }
  }
} \where {
  \lemma fromLocallyUniformMap {V : MetricValueOrder} {X Y : ValuedPseudoMetricSpace V} (f : LocallyUniformMap X Y) : LocallyUniformMetricMap V X Y f \cowith
    | func-dist-locally-uniform eps>0 =>
      \have | (inP (eps/2,eps/2>0,eps/2<eps,eps/2+eps/2<eps)) => V.shrink2 eps>0
            | (inP (C,Cu,h)) => f.func-locally-uniform (metricUniform eps/2>0)
            | (inP (delta,delta>0,g)) => dist-uniform.1 Cu
            | (inP (delta/2,delta/2>0,delta/2<delta,delta/2+delta/2<delta)) => V.shrink2 delta>0
      \in inP (delta/2, delta/2>0, \lam x0 => \case g x0 \with {
        | inP (U,CU,e) => \case dist-uniform.1 (h CU) \with {
          | inP (gamma,gamma>0,g') => inP (gamma ∧ delta/2, <_meet-univ gamma>0 delta/2>0, \lam {x} {x'} d1 d2 => \case g' x \with {
            | inP (V, inP (W, inP (y, q), p), r) => rewrite q at p $ dist-triang <∘r <=_+ (<=-less $ transport (`< _) dist-symm $ p (e $ d1 <∘ delta/2<delta, r $ transportInv (`< _) dist-refl gamma>0)) (<=-less $ p (e $ dist-triang <∘r <=_+ (<=-less d1) (<=-less d2 <=∘ meet-right) <∘r delta/2+delta/2<delta, r $ d2 <∘l meet-left)) <∘r eps/2+eps/2<eps
          })
        }
      })

  \lemma makeLocallyUniformMap2 {V : MetricValueOrder} {X Y Z : ValuedPseudoMetricSpace V} (f : X -> Y -> Z) (fc : ∀ {eps : V} (0 < eps) ∃ (delta : V) (0 < delta) ∀ x0 y0 ∃ (gamma : V) (0 < gamma) ∀ {x x'} {y y'} (dist x0 x < delta -> dist y0 y < delta -> dist x x' < gamma -> dist y y' < gamma -> dist (f x y) (f x' y') < eps))
    : LocallyUniformMap (X ⨯ Y) Z (\lam s => f s.1 s.2) \cowith
    | func-locally-uniform Eu => \case dist-uniform.1 Eu \with {
      | inP (eps,eps>0,h) => \case fc eps>0 \with {
        | inP (delta,delta>0,g) => inP (_, ProductUniformSpace.prodCover (metricUniform delta>0) (metricUniform delta>0), \lam {_} (inP (_, inP (x0,idp), _, inP (y0,idp), idp)) => \case g x0 y0 \with {
          | inP (gamma,gamma>0,g') => inP (_, metricUniform gamma>0, _, metricUniform gamma>0, \lam {_} (inP (_, inP (x,idp), _, inP (y,idp), idp)) => \case h (f x y) \with {
            | inP (W,EW,e) => inP (\lam s => \Sigma (dist x s.1 < gamma) (dist y s.2 < gamma), inP (W, EW, \lam {s} (c,d) => e $ rewrite Z.dist-symm $ g' c.1 c.2 (rewrite X.dist-symm d.1) (rewrite Y.dist-symm d.2)), \lam d => d)
          })
        })
      }
    }
}

\record UniformMetricMap \extends LocallyUniformMetricMap, UniformMap {
  | V => PseudoMetricSpace.RealMetricValueLinearOrder
  \override Dom : PseudoMetricSpace
  \override Cod : PseudoMetricSpace

  | func-dist-uniform : ∀ {eps : Real} (0 < eps) ∃ (delta : Real) (0 < delta) ∀ {x x' : Dom} (dist x x' < delta -> dist (func x) (func x') < eps)
  | func-dist-locally-uniform eps>0 => \case func-dist-uniform eps>0 \with {
    | inP (delta,delta>0,h) => inP (delta, delta>0, \lam x0 => inP (delta, delta>0, \lam _ => h))
  }
  | func-uniform Eu => \case dist-uniform.1 Eu \with {
    | inP (eps,eps>0,h) => \case func-dist-uniform eps>0 \with {
      | inP (delta,delta>0,g) => dist-uniform.2 $ inP (delta, delta>0, \lam x => \case h (func x) \with {
        | inP (U,EU,e) => inP (_, inP $ later (U, EU, idp), \lam d => e (g d))
      })
    }
  }
} \where {
  \lemma fromUniformMap {X Y : PseudoMetricSpace} (f : UniformMap X Y) : UniformMetricMap X Y f \cowith
    | func-dist-uniform eps>0 => \case dist-uniform.1 $ f.func-uniform (metricUniform $ half>0 eps>0) \with {
      | inP (delta,delta>0,h) => inP (delta, delta>0, \lam {x} d => \case h x \with {
        | inP (U, inP (V, inP (y, q), p), g) => rewrite (p,q) at g $ halving (g $ rewrite X.dist-refl delta>0) (g d)
      })
    }
}

\record MetricMap \extends UniformMetricMap
  | func-dist {x y : Dom} : dist (func x) (func y) <= dist x y
  | func-dist-uniform {eps} eps>0 => inP (eps, eps>0, \lam d => func-dist <∘r d)
  | func-cont {U} => defaultImpl PrecoverMap func-cont {_} {U}

\record IsometricMap \extends MetricMap {
  | func-isometry {x y : Dom} : dist (func x) (func y) = dist x y
  | func-dist => Preorder.=_<= func-isometry

  \lemma dense->uniformEmbedding (d : IsDense) : UniformMap.IsDenseUniformEmbedding
    => (d, \lam Cu => \case dist-uniform.1 Cu \with {
      | inP (eps,eps>0,h) => dist-uniform.2 $ inP (half eps, half>0 eps>0, \lam y => \case d {y} OBall-open (OBall-center (half>0 eps>0)) \with {
        | inP (_, inP (x,idp), yfx<eps/2) => \case h x \with {
          | inP (U,CU,g) => inP (OBall (half eps) y, inP $ later (U, CU, \lam {x'} yfx'<eps/2 => g $ rewrite func-isometry in halving yfx<eps/2 yfx'<eps/2), \lam d => d)
        }
      })
    })
}

\class CompleteMetricSpace \extends MetricSpace, StronglyCompleteUniformSpace

\lemma cauchyFilter-metric-char {X : PseudoMetricSpace} {F : SetFilter X} : ∀ {C : isCauchy} ∃ (U : C) (F U) <->
  (\Pi {eps : Real} -> 0 < eps -> ∃ (x : X) (F (OBall eps x)))
  => <->trans cauchyFilter-uniform-char $ later (\lam f eps>0 => \case f $ metricUniform eps>0 \with {
    | inP (_, inP (x, idp), FB) => inP (x, FB)
  }, \lam f Cu => \case dist-uniform.1 Cu \with {
    | inP (eps,eps>0,h) => \case f eps>0 \with {
      | inP (x,FB) => \case h x \with {
        | inP (U,CU,g) => inP (U, CU, filter-mono FB (g __))
      }
    }
  })

\func PseudoMetricTransfer {X : \Set} {Y : PseudoMetricSpace} (f : X -> Y) : PseudoMetricSpace X \cowith
  | TopSpace => TopTransfer f
  | dist x x' => dist (f x) (f x')
  | dist-refl => dist-refl
  | dist-symm => dist-symm
  | dist-triang => dist-triang
  | cauchy-open {S} => later (\lam (inP (V,Vo,p)) Sx => ClosurePrecoverSpace.closure \case dist_open.1 Vo (rewrite p in Sx) \with {
    | inP (eps,eps>0,q) => inP (half eps, half>0 eps>0, \lam x' => inP (\lam x'' => dist (f x') (f x'') < half eps, \lam d1 {x''} d2 => rewrite p $ q $ halving d1 d2, \lam e => e))
  }, \lam c => inP (Set.Union \lam V' => \Sigma (isOpen V') (f ^-1 V' ⊆ S), open-Union __.1, <=-antisymmetric (later \lam {x} Sx => \case ClosurePrecoverSpace.closure-filter (MetricSpace.NFilter {PseudoMetricTransfer' f} x) (\lam (inP (eps,eps>0,h)) => \case h x \with {
    | inP (U,CU,g) => inP (U, CU, inP (eps, eps>0, g __))
  }) (c Sx) \with {
    | inP (U, q, inP (eps,eps>0,p)) => inP (OBall eps (f x), (OBall-open, \lam {x'} d => q (p $ OBall-center eps>0) (p d)), OBall-center eps>0)
  }) (\lam (inP (U,(Uo,p),Ufx)) => p Ufx)))
  \where {
    \private \func PseudoMetricTransfer' {X : \Set} {Y : PseudoMetricSpace} (f : X -> Y) : PseudoMetricSpace X \cowith
      | dist x x' => dist (f x) (f x')
      | dist-refl => dist-refl
      | dist-symm => dist-symm
      | dist-triang => dist-triang
  }

\func MetricTransfer {X : \Set} {Y : MetricSpace} (f : X -> Y) (fi : IsInj f) : MetricSpace X \cowith
  | PseudoMetricSpace => PseudoMetricTransfer f
  | dist-ext p => fi (dist-ext p)
