\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Rat
\import Arith.Real
\import Arith.Real.Field
\import Arith.Real.InfReal
\import Arith.Real.UpperReal
\import Data.Or
\import Function.Meta
\import Logic
\import Meta
\import Operations
\import Order.Biordered
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Topology.CoverSpace.Complete
\import Topology.CoverSpace.Product
\import Topology.MetricSpace
\import Topology.NormedAbGroup
\import Topology.NormedAbGroup.Real
\import Topology.TopRing
\import Topology.UniformSpace
\import Topology.UniformSpace.Product
\open Monoid(pow)

\class ExPseudoNormedPseudoRing \extends ExPseudoNormedAbGroup, TopSemigroup, PseudoRing {
  | norm_*_<= {x y : E} : norm (x * y) <= norm x ExUpperReal.* norm y
  | *-cont => *-locally-uniform norm_*_<=
} \where {
  \protected \lemma *-locally-uniform {R : PseudoRing} {X : ExPseudoNormedAbGroup R { | zro => R.zro | + => + | negative => negative }} (norm_*_<= : \Pi {x y : R} -> norm (x * y) <= norm x ExUpperReal.* norm y) : LocallyUniformMap (X ⨯ X) X (\lam s => s.1 * s.2)
    => LocallyUniformMetricMap.makeLocallyUniformMap2 (*) \lam {eps} eps>0 => inP (1, zro<ide, \lam x0 y0 => {?} {- TODO[server2]:
     \case metric-div {_} {(norm x0 + 1) + (norm y0 + 1 + 1)} (zro<ide <∘l transport (`<= _) (zro-right *> zro-left) (<=_+ (<=_+ norm>=0 <=-refl) $ V.<=_+-positive (V.<=_+-positive norm>=0 (<=-less zro<ide)) (<=-less zro<ide))) eps'>0 \with {
      | inP (gamma,gamma>0,gamma-m) => inP (gamma ∧ 1, <_meet-univ gamma>0 zro<ide, \lam {x} {x'} {y} {y'} x0x<1 y0y<1 xx'<gamma yy'<gamma =>
        rewrite norm-dist at xx'<gamma $ rewrite norm-dist at yy'<gamma $ rewrite norm-dist at x0x<1 $ rewrite norm-dist at y0y<1 $ rewrite norm-dist $
        transport (norm __ < eps) (pmap2 (+) R.ldistr_- R.rdistr_- *> simplify : x * (y - y') + (x - x') * y' = x * y - x' * y') $ norm_+ <∘r
          <=_+ norm_*_<= norm_*_<= <∘r transport (_ + __ < eps) *-comm (<=_+ (<=_*_positive-right norm>=0 $ <=-less yy'<gamma) (<=_*_positive-right norm>=0 (<=-less xx'<gamma)) <∘r
          transport (`<= _) rdistr (<=_*_positive-right (transport (`<= _) zro-left $ <=_+ norm>=0 norm>=0) meet-left <=∘ transport2 (<=) *-comm *-comm (<=_*_positive-right (<=-less gamma>0)
            \have lem {x1 x2 : X} (d : norm (x1 - x2) < 1) : norm x2 <= norm x1 + 1 => transport (_ <= _ + __) norm_- (=_<= (pmap norm equation.abGroup) <=∘ norm_+) <=∘ <=_+ <=-refl (<=-less d)
            \in <=_+ (lem x0x<1) $ lem (yy'<gamma <∘l  meet-right) <=∘ <=_+ (lem y0y<1) <=-refl)) <∘r gamma-m <∘r eps'<eps))
    } -})
}

\lemma *-locally-uniform {X : ExPseudoNormedPseudoRing} : LocallyUniformMap (X ⨯ X) X (\lam s => s.1 * s.2)
  => ExPseudoNormedPseudoRing.*-locally-uniform norm_*_<=

\class PseudoNormedPseudoRing \extends ExPseudoNormedPseudoRing, PseudoNormedAbGroup

\lemma lnorm_*_<= {X : PseudoNormedPseudoRing} {x y : X} : lnorm (x * y) <= lnorm x * lnorm y
  => Real.<=-upper.2 $ transportInv (_ ExUpperReal.<=) (RealField.*-upper lnorm>=0 lnorm>=0) X.norm_*_<=

\class ExPseudoNormedRing \extends ExPseudoNormedPseudoRing, TopRing
  | norm_ide_<= : norm 1 <= ExUpperReal.fromRat 1

\lemma pow-cover {X : ExPseudoNormedRing} (n : Nat) : CoverMap X X (pow __ n) \elim n
  | 0 => CoverMap.const 1
  | suc n => *-locally-uniform CoverMap.∘ ProductCoverSpace.tuple (pow-cover n) CoverMap.id

\class PseudoNormedRing \extends ExPseudoNormedRing, PseudoNormedPseudoRing

\lemma lnorm_ide_<= {X : PseudoNormedRing} : X.norm 1 <= 1
  => Real.<=-upper.2 (later norm_ide_<=)

-- | If the norm of 1 is zero, then all bounded elements have zero norm.
\lemma norm_ide=0 {X : ExPseudoNormedRing} (p : X.norm 1 = 0) {x : X} (xb : X.IsBounded x) : norm x = 0 \elim xb
  | inP (B,x<B) => pmap norm (inv ide-right) *> <=-antisymmetric (norm_*_<= <=∘ ExUpperRealSemigroup.<=_*-left (ExUpperReal.<_<= x<B) <=∘ =_<= (pmap (B ExUpperRealSemigroup.*) p *> ExUpperReal.*-rat (<=-less $ norm>=0 x<B) <=-refl *> pmap ExUpperReal.fromRat RatField.zro_*-right)) norm>=0

-- | If the norm of 1 is less than 1, then it is zero.
\lemma norm_ide<1 {X : ExPseudoNormedRing} (|1|<1 : (X.norm 1).U 1) : X.norm 1 = 0
  => <=-antisymmetric (\case U-rounded |1|<1 \with {
    | inP (q,|1|<q,q<1) => \lam {eps} eps>0 =>
      \have R => rat_<1_pow-bound q<1 {eps} eps>0
      \in U-closed (aux (norm>=0 |1|<q) q<1 |1|<q) R.2
  }) norm>=0
  \where {
    \protected \lemma aux {q : Rat} (q>0 : q > 0) (q<1 : q < 1) (p : (X.norm 1).U q) {n : Nat} : (X.norm 1).U (pow q n) \elim n
      | 0 => U-closed p q<1
      | suc n => transport (norm __ <= _) ide-left X.norm_*_<= $ ExUpperReal.*_U_<=.2 $ inP (pow q n, aux q>0 q<1 p, RatField.pow>0 q>0, q, p, q>0, <=-refl)
  }

-- | If the norm of 1 is non-zero, then it equals 1.
\lemma norm_ide/=0 {X : ExPseudoNormedRing} (p : X.norm 1 /= 0) : X.norm 1 = 1
  => <=-antisymmetric norm_ide_<= \lam {b} |1|<b => \case LinearOrder.dec<_<= (1 : Rat) b \with {
    | inl r => r
    | inr b<=1 => absurd $ p $ norm_ide<1 $ ExUpperReal.U_<= |1|<b b<=1
  }

-- | The norm of 1 is either 0 or 1.
\lemma norm_zro_ide {X : PseudoNormedRing} : (X.norm 1 = (0 : Real)) || (X.norm 1 = (1 : Real))
  => \case LU-located {X.norm 1} {0} {1} idp \with {
    | byLeft p => byRight $ Real.=-upper.2 $ later $ norm_ide/=0 \lam q => \case rewrite ((Real.=-upper {X.norm 1} {0}).2 q) p
    | byRight p => byLeft $ Real.=-upper.2 $ later $ norm_ide<1 p
  }

\lemma lnorm_<=_pow {X : PseudoNormedRing} {x : X} {n : Nat} : lnorm (pow x n) <= pow (lnorm x) n \elim n
  | 0 => lnorm_ide_<=
  | suc n => lnorm_*_<= <=∘ RealField.<=_*_positive-left lnorm_<=_pow lnorm>=0

\class ExPseudoValuedPseudoRing \extends ExPseudoNormedPseudoRing
  | norm_* {x y : E} : norm (x * y) = norm x ExUpperReal.* norm y
  | norm_*_<= => =_<= norm_*

\lemma lnorm_* {X : PseudoValuedRing} {x y : X} : lnorm (x * y) = lnorm x * lnorm y
  => Real.=-upper.2 $ later norm_* *> {ExUpperReal} inv {ExUpperReal} (RealField.*-upper lnorm>=0 lnorm>=0)

\class ExPseudoValuedRing \extends ExPseudoValuedPseudoRing, ExPseudoNormedRing, Ring {
  | norm_ide : norm 1 = ExUpperReal.fromRat 1
  | norm_ide_<= => =_<= norm_ide

  {- TODO[server2]
  \lemma norm_Inv {x : E} (d : Monoid.Inv x) : Monoid.Inv (norm x) (norm d.inv) \cowith
    | inv-left => inv norm_* *> pmap norm d.inv-left *> norm_ide
    | inv-right => inv norm_* *> pmap norm d.inv-right *> norm_ide
  -}
}

\class PseudoValuedRing \extends PseudoNormedRing, ExPseudoValuedRing

\lemma lnorm_ide {X : PseudoValuedRing} : X.norm 1 = 1
  => (Real.=-upper {_} {1}).2 (later norm_ide)

\lemma lnorm_pow {X : PseudoValuedRing} {x : X} {n : Nat} : lnorm (pow x n) = pow (lnorm x) n \elim n
  | 0 => lnorm_ide
  | suc n => lnorm_* *> pmap (`* _) lnorm_pow

\func RatValue => ExPseudoValuedRing { | E => Rat | * => RatField.* | ide => RatField.ide | negative => RatField.negative }

\instance RatValuedRing : PseudoValuedRing Rat
  | PseudoNormedAbGroup => RatNormed
  | Ring => RatField
  | norm_* => pmap ExUpperReal.fromRat RatField.abs_* *> inv (ExUpperReal.*-rat RatField.abs>=0 RatField.abs>=0)
  | norm_ide => idp

\class CompleteValuedRing \extends PseudoValuedRing, CompleteNormedAbGroup

\class CompleteValuedCRing \extends CompleteValuedRing, CRing

\instance RealValuedRing : CompleteValuedCRing Real
  | CompleteNormedAbGroup => RealNormed
  | CRing => RealField
  | norm_* => Real.=-upper.1 RealField.abs_* *> {ExUpperReal} RealField.*-upper RealAbGroup.abs>=0 RealAbGroup.abs>=0
  | norm_ide => RealField.abs-ofPos $ LinearOrder.<_<= RealAbGroup.zro<ide
