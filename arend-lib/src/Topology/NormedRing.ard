\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Rat
\import Arith.Real
\import Arith.Real.Field
\import Arith.Real.InfReal
\import Arith.Real.UpperReal
\import Data.Or
\import Function.Meta
\import Logic
\import Meta
\import Operations
\import Order.Biordered
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Topology.CoverSpace.Complete
\import Topology.CoverSpace.Product
\import Topology.MetricSpace
\import Topology.NormedAbGroup
\import Topology.NormedAbGroup.Real
\import Topology.TopRing
\import Topology.UniformSpace
\import Topology.UniformSpace.Product
\open Monoid(pow)

\class ExPseudoNormedPseudoRing \extends ExPseudoNormedAbGroup, TopSemigroup, PseudoRing {
  | norm_*_<= {x y : E} : norm (x * y) <= norm x ExUpperReal.* norm y
  | *-cont => *-locally-uniform norm_*_<=
} \where {
  \protected \lemma *-locally-uniform {R : PseudoRing} {X : ExPseudoNormedAbGroup R { | zro => R.zro | + => + | negative => negative }} (norm_*_<= : \Pi {x y : R} -> norm (x * y) <= norm x ExUpperReal.* norm y) : LocallyUniformMap (X ⨯ X) X (\lam s => s.1 * s.2)
    => LocallyUniformMetricMap.makeLocallyUniformMap2 (*) \lam {eps} eps>0 => inP (1, zro<ide, \lam x0 y0 => {?} {- TODO[server2]:
     \case metric-div {_} {(norm x0 + 1) + (norm y0 + 1 + 1)} (zro<ide <∘l transport (`<= _) (zro-right *> zro-left) (<=_+ (<=_+ norm>=0 <=-refl) $ V.<=_+-positive (V.<=_+-positive norm>=0 (<=-less zro<ide)) (<=-less zro<ide))) eps'>0 \with {
      | inP (gamma,gamma>0,gamma-m) => inP (gamma ∧ 1, <_meet-univ gamma>0 zro<ide, \lam {x} {x'} {y} {y'} x0x<1 y0y<1 xx'<gamma yy'<gamma =>
        rewrite norm-dist at xx'<gamma $ rewrite norm-dist at yy'<gamma $ rewrite norm-dist at x0x<1 $ rewrite norm-dist at y0y<1 $ rewrite norm-dist $
        transport (norm __ < eps) (pmap2 (+) R.ldistr_- R.rdistr_- *> simplify : x * (y - y') + (x - x') * y' = x * y - x' * y') $ norm_+ <∘r
          <=_+ norm_*_<= norm_*_<= <∘r transport (_ + __ < eps) *-comm (<=_+ (<=_*_positive-right norm>=0 $ <=-less yy'<gamma) (<=_*_positive-right norm>=0 (<=-less xx'<gamma)) <∘r
          transport (`<= _) rdistr (<=_*_positive-right (transport (`<= _) zro-left $ <=_+ norm>=0 norm>=0) meet-left <=∘ transport2 (<=) *-comm *-comm (<=_*_positive-right (<=-less gamma>0)
            \have lem {x1 x2 : X} (d : norm (x1 - x2) < 1) : norm x2 <= norm x1 + 1 => transport (_ <= _ + __) norm_- (=_<= (pmap norm equation.abGroup) <=∘ norm_+) <=∘ <=_+ <=-refl (<=-less d)
            \in <=_+ (lem x0x<1) $ lem (yy'<gamma <∘l  meet-right) <=∘ <=_+ (lem y0y<1) <=-refl)) <∘r gamma-m <∘r eps'<eps))
    } -})
}

\lemma *-locally-uniform {X : ExPseudoNormedPseudoRing} : LocallyUniformMap (X ⨯ X) X (\lam s => s.1 * s.2)
  => ExPseudoNormedPseudoRing.*-locally-uniform norm_*_<=

\class PseudoNormedPseudoRing \extends ExPseudoNormedPseudoRing, PseudoNormedAbGroup

\lemma lnorm_*_<= {X : PseudoNormedPseudoRing} {x y : X} : lnorm (x * y) <= lnorm x * lnorm y
  => Real.<=-upper.2 $ transportInv (_ ExUpperReal.<=) RealField.*-upper X.norm_*_<=

\class ExPseudoNormedRing \extends ExPseudoNormedPseudoRing, TopRing
  | norm_ide_<= : norm 1 <= ExUpperReal.fromRat 1

\lemma pow-cover {X : ExPseudoNormedRing} (n : Nat) : CoverMap X X (pow __ n) \elim n
  | 0 => CoverMap.const 1
  | suc n => *-locally-uniform CoverMap.∘ ProductCoverSpace.tuple (pow-cover n) CoverMap.id

\class PseudoNormedRing \extends ExPseudoNormedRing, PseudoNormedPseudoRing

-- | If the norm of 1 is zero, then all bounded elements have zero norm.
\lemma norm_ide=0 {X : ExPseudoNormedRing} (p : X.norm 1 = 0) {x : X} (xb : X.IsBounded x) : norm x = 0 \elim xb
  | inP (B,x<B) => pmap norm (inv ide-right) *> <=-antisymmetric (norm_*_<= <=∘ ExUpperRealSemigroup.<=_*-left (ExUpperReal.<_<= x<B) <=∘ =_<= (pmap (B ExUpperRealSemigroup.*) p *> ExUpperReal.*-rat (<=-less $ norm>=0 x<B) <=-refl *> pmap ExUpperReal.fromRat RatField.zro_*-right)) norm>=0

-- | If the norm of 1 is less than 1, then it is zero.
\lemma norm_ide<1 {X : ExPseudoNormedRing} (|1|<1 : (X.norm 1).U 1) : X.norm 1 = 0
  => <=-antisymmetric (\case U-rounded |1|<1 \with {
    | inP (q,|1|<q,q<1) => \lam {eps} eps>0 =>
      \have R => rat_<1_pow-bound q<1 {eps} eps>0
      \in U-closed (aux (norm>=0 |1|<q) q<1 |1|<q) R.2
  }) norm>=0
  \where {
    \protected \lemma aux {q : Rat} (q>0 : q > 0) (q<1 : q < 1) (p : (X.norm 1).U q) {n : Nat} : (X.norm 1).U (pow q n) \elim n
      | 0 => U-closed p q<1
      | suc n => transport (norm __ <= _) ide-left X.norm_*_<= $ ExUpperReal.*_U_<=.2 $ inP (pow q n, aux q>0 q<1 p, RatField.pow>0 q>0, q, p, q>0, <=-refl)
  }

-- | If the norm of 1 is non-zero, then it equals 1.
\lemma norm_ide/=0 {X : ExPseudoNormedRing} (p : X.norm 1 /= 0) : X.norm 1 = 1
  => <=-antisymmetric norm_ide_<= \lam {b} |1|<b => \case LinearOrder.dec<_<= (1 : Rat) b \with {
    | inl r => r
    | inr b<=1 => absurd $ p $ norm_ide<1 $ ExUpperReal.U_<= |1|<b b<=1
  }

-- | The norm of 1 is either 0 or 1.
\lemma norm_zro_ide {X : PseudoNormedRing} : (X.norm 1 = (0 : Real)) || (X.norm 1 = (1 : Real))
  => \case LU-located {X.norm 1} {0} {1} idp \with {
    | byLeft p => byRight $ Real.=-upper.2 $ later $ norm_ide/=0 \lam q => \case rewrite ((Real.=-upper {X.norm 1} {0}).2 q) p
    | byRight p => byLeft $ Real.=-upper.2 $ later $ norm_ide<1 p
  }

-- TODO[server2]
\lemma norm_<=_pow {X : PseudoNormedRing} {x : X} {n : Nat} : lnorm (pow x n) <= pow (lnorm x) n \elim n
  | 0 => {?} -- norm_ide_<=
  | suc n => {?} -- norm_*_<= <=∘ RealField.<=_*_positive-left norm_<=_pow norm>=0

\class ExPseudoValuedPseudoRing \extends ExPseudoNormedPseudoRing
  | norm_* {x y : E} : norm (x * y) = norm x ExUpperReal.* norm y
  | norm_*_<= => =_<= norm_*

\class ExPseudoValuedRing \extends ExPseudoValuedPseudoRing, ExPseudoNormedRing, Ring {
  | norm_ide : norm 1 = ExUpperReal.fromRat 1
  | norm_ide_<= => =_<= norm_ide

  {- TODO[server2]
  \lemma norm_Inv {x : E} (d : Monoid.Inv x) : Monoid.Inv (norm x) (norm d.inv) \cowith
    | inv-left => inv norm_* *> pmap norm d.inv-left *> norm_ide
    | inv-right => inv norm_* *> pmap norm d.inv-right *> norm_ide
  -}
}

-- TODO[server2]
\lemma norm_pow {X : PseudoValuedRing} {x : X} {n : Nat} : lnorm (pow x n) = pow (lnorm x) n \elim n
  | 0 => {?} -- norm_ide
  | suc n => {?} -- norm_* *> pmap (`* _) norm_pow

\class PseudoValuedRing \extends PseudoNormedRing, ExPseudoValuedRing

\func RatValue => ExPseudoValuedRing { | E => Rat | * => RatField.* | ide => RatField.ide | negative => RatField.negative }
  \where {
    {- TODO[server2]: Just use RatValuedRing instead
    \protected \func Real : RatValue \cowith
      | Ring => RatField
      | norm q => ExUpperReal.fromRat (RatField.abs q)
      | norm_zro => idp
      | norm_negative => pmap PosUpperReal.fromRat RatField.abs_negative
      | norm_+ => transportInv (_ <=) (PosUpperRealSemiring.+-rat RatField.abs>=0 RatField.abs>=0) $ PosUpperReal.fromRat_<= RatField.abs>=0 RatField.abs_+
      | norm_* => pmap PosUpperReal.fromRat RatField.abs_* *> inv (PosUpperRealSemiring.*-rat RatField.abs>=0 RatField.abs>=0)
      | norm_ide => idp
    -}
  }

\class CompleteValuedRing \extends PseudoValuedRing, CompleteNormedAbGroup

\class CompleteValuedCRing \extends CompleteValuedRing, CRing

-- TODO[server2]:
\instance RatValuedRing : PseudoValuedRing Rat
  | PseudoNormedAbGroup => RatNormed
  | Ring => RatField
  | norm_* => {?}
  | norm_ide => {?}

\instance RealValuedRing : CompleteValuedCRing Real
  | CompleteNormedAbGroup => RealNormed
  | CRing => RealField
  | norm_* => {?} -- RealField.abs_*
  | norm_ide => RealField.abs-ofPos $ LinearOrder.<_<= RealAbGroup.zro<ide
