\import Category
\import Category.Functor
\import Category.Meta
\import Category.Sub
\import Data.Bool
\import Data.List
\import Equiv (ESEquiv, Embedding, Equiv, QEquiv)
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice \hiding (DistributiveLattice)
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Set.Category
\open Bounded(DistributiveLattice,top,top-univ)
\open MeetSemilattice(meet-comm,meet-idemp)

\class Locale \extends DistributiveLattice {
  | Join {J : \Set} : (J -> E) -> E
  | Join-cond {J : \Set} (j : J) {f : J -> E} : f j <= Join f
  | Join-univ {J : \Set} {f : J -> E} {e : E} : (\Pi (j : J) -> f j <= e) -> Join f <= e
  | Join-ldistr>= {J : \Set} {f : J -> E} {e : E} : e ∧ Join f <= Join (\lam (j : J) => e ∧ f j)

  | bottom => Join absurd
  | bottom-univ {x} => Join-univ (\case __)
  | join x y => Join (if __ x y)
  | join-left {x} {y} => Join-cond true
  | join-right {x} {y} => Join-cond false
  | join-univ x<=z y<=z => Join-univ (\case \elim __ \with {
    | true => x<=z
    | false => y<=z
  })
  | ldistr>= {x} {y} {z} =>
    \have t : (\lam b => if b (x ∧ y) (x ∧ z)) = (\lam b => x ∧ if b y z)
            => ext (\lam b => cases b idp)
    \in unfold (rewrite t Join-ldistr>=)

  \lemma Join-ldistr {J : \Set} {f : J -> E} {e : E} : e ∧ Join f = Join (\lam (j : J) => e ∧ f j)
    => <=-antisymmetric Join-ldistr>= (Join-univ (\lam j => meet-univ meet-left (<=-transitive meet-right (Join-cond j))))

  \lemma Join-rdistr {J : \Set} {f : J -> E} {e : E} : Join f ∧ e = Join (\lam (j : J) => f j ∧ e)
    => meet-comm *> Join-ldistr *> pmap Join (ext (\lam j => meet-comm))

  \lemma Join-double {I J : \Set} {f : I -> J -> E} : Join (\lam i => Join (\lam j => f i j)) = Join (\lam (p : \Sigma I J) => f p.1 p.2)
    => <=-antisymmetric (Join-univ (\lam i => Join-univ (\lam j => Join-cond (i,j)))) (Join-univ (\lam p => <=-transitive (Join-cond p.2) (Join-cond p.1)))

  \lemma Join-distr {I J : \Set} {f : I -> E} {g : J -> E} : Join f ∧ Join g = Join (\lam (p : \Sigma I J) => f p.1 ∧ g p.2)
    => Join-rdistr *> path (\lam i => Join (\lam i' => Join-ldistr {_} {J} {g} {f i'} @ i)) *> Join-double {_} {I} {J} {\lam i j => f i ∧ g j}

  \func SJoin (U : E -> \Prop) => Join (\lam (t : \Sigma (x : E) (U x)) => t.1)

  \type \infix 4 << (x y : E) => \Pi {J : \Set} (g : J -> E) -> y <= Join g -> ∃ (l : List J) (x <= Join (\lam i => g (l !! i)))

  \type isCompact => top << top

  \type isLocallyCompact => \Pi (x : E) -> x <= SJoin (`<< x)
}

\record FrameHom \extends SetHom {
  \override Dom : Locale
  \override Cod : Locale
  | func-top : func top = top
  | func-meet {x y : Dom} : func (x ∧ y) = func x ∧ func y
  | func-Join {J : \Set} {f : J -> Dom} : func (Join f) = Join (\lam j => func (f j))
  | func-Join>= {J : \Set} {f : J -> Dom} : func (Join f) <= Join (\lam j => func (f j))

  \default func-Join>= {J} {f} => transport (_ <=) func-Join <=-reflexive
  \default func-Join \as func-Join-impl {J} {f} => <=-antisymmetric func-Join>= (Join-univ (\lam j => func-<= (Join-cond j)))

  \lemma func-<= {x y : Dom} (x<=y : x <= y) : func x <= func y
    => rewrite (inv (pmap func (MeetSemilattice.meet_<= x<=y)) *> func-meet) meet-right
}

\func FrameCat : Cat Locale \cowith
  | Hom => FrameHom
  | id L => \new FrameHom {
    | func x => x
    | func-top => idp
    | func-meet => idp
    | func-Join => idp
  }
  | o g f => \new FrameHom {
    | func x => g (f x)
    | func-top => pmap g func-top *> func-top
    | func-meet {x} {y} => pmap g func-meet *> func-meet
    | func-Join {J} {h} => pmap g func-Join *> func-Join
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : FrameHom) (h2 : FrameHom) => exts Locale {
    | <= x y => ext (h1.func-<=, h2.func-<=)
    | meet x y => h1.func-meet
    | top => h1.func-top
    | Join f => h1.func-Join
  })

\instance LocaleCat => op FrameCat

{- | Presentation of frames.
 -   {conj} represents meets and {BasicCover} represents relation `__ <= Join __`.
 -}
\class FramePres \extends BaseSet {
  | conj : E -> E -> E
  | BasicCover {J : \Set} : E -> (J -> E) -> \Prop

  \type \infix 4 << (x y : E) => \Pi {J : \Set} (g : J -> E) -> Cover y g -> ∃ (l : List J) (Cover x (\lam i => g (l !! i)))

  \func SCover (x : E) (U : E -> \Prop) => Cover x (\lam (t : \Sigma (x : E) (U x)) => t.1)

  \type isLocallyCompact => \Pi (x : E) -> SCover x (`<< x)
} \where {
    \func Indexing {I X : \Set} (g : I -> \Sigma (J : \Set) X (J -> X)) {J : \Set} (e : X) (f : J -> X)
      => ∃ (i : I) (e = (g i).2)
  }

\truncated \data Cover {P : FramePres} (x : P) {J : \Set} (g : J -> P) : \Prop
  | cover-basic (BasicCover x g)
  | cover-inj (j : J) (g j = x)
  | cover-trans {I : \Set} {f : I -> P} (Cover x f) (\Pi (i : I) -> Cover (f i) g)
  | cover-proj1 {a b : P} (x = conj a b) (j : J) (g j = a)
  | cover-proj2 {a b : P} (x = conj a b) (j : J) (g j = b)
  | cover-idemp (j : J) (g j = conj x x)
  | cover-comm {a b : P} (x = conj a b) (j : J) (g j = conj b a)
  | cover-ldistr {a b : P} (x = conj a b) {f : J -> P} (Cover b f) (\Pi (j : J) -> g j = conj a (f j))
  \where {
    \lemma cover-ldistr' {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (x=ab : x = conj a b) {I : \Set} {h : I -> P} (ah : Cover b h) (f : \Pi (i : I) -> ∃ (j : J) (g j = conj a (h i))) : Cover x g
      => cover-trans (cover-ldistr {_} {_} {I} {\lam i => conj a (h i)} x=ab ah (\lam j => idp)) (\lam i => \case f i \with {
        | inP (j,p) => cover-inj j p
      })

    \lemma cover-rdistr' {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (x=ab : x = conj a b) {I : \Set} {h : I -> P} (ah : Cover a h) (f : \Pi (i : I) -> ∃ (j : J) (g j = conj (h i) b)) : Cover x g
      => \have t => cover-trans {P} {_} {I} {\lam j => conj b (h j)} (cover-comm {P} {x} {\Sigma} {\lam _ => conj b a} x=ab () idp) (\lam _ => cover-ldistr' idp ah (\lam j => inP (j,idp)))
         \in cover-trans t (\lam j => \case f j \with {
          | inP (i,p) => cover-comm idp i p
        })

    \lemma cover-rdistr {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (x=ab : x = conj a b) {h : J -> P} (ah : Cover a h) (f : \Pi (j : J) -> g j = conj (h j) b) : Cover x g
      => cover-rdistr' x=ab ah (\lam j => inP (j, f j))

    \lemma cover-conj {P : FramePres} {J : \Set} {g : J -> P} {a b : P} {I1 : \Set} {h1 : I1 -> P} (aV : Cover a h1) {I2 : \Set} {h2 : I2 -> P} (bW : Cover b h2) (f : \Pi {i1 : I1} {i2 : I2} -> ∃ (j : J) (g j = conj (h1 i1) (h2 i2))) : Cover (conj a b) g
      => cover-trans {P} {_} {J} {g} {_} {\lam i => conj a (h2 i)} (cover-ldistr' idp bW (\lam i => inP (i, idp))) (\lam i2 => cover-rdistr' idp aV (\lam i1 => f))

    \lemma map {F : FramePresHom} {x : F.Dom} {J : \Set} {g : J -> F.Dom} (c : Cover x g) : Cover (F x) (\lam j => F (g j)) \elim c
      | cover-basic b => cover-basic (func-cover b)
      | cover-inj j p => cover-inj j (pmap F p)
      | cover-trans c g => cover-trans (map c) (\lam i => map (g i))
      | cover-proj1 p j q => cover-proj1 (pmap F p *> func-conj) j (pmap F q)
      | cover-proj2 p j q => cover-proj2 (pmap F p *> func-conj) j (pmap F q)
      | cover-idemp j p => cover-idemp j (pmap F p *> func-conj)
      | cover-comm p j q => cover-comm (pmap F p *> func-conj) j (pmap F q *> func-conj)
      | cover-ldistr p c f => cover-ldistr (pmap F p *> func-conj) (map c) (\lam j => pmap F (f j) *> func-conj)
  }

\record FramePresHom \extends SetHom {
  \override Dom : FramePres
  \override Cod : FramePres
  | func-conj {x y : Dom} : func (conj x y) = conj (func x) (func y)
  | func-cover {J : \Set} {x : Dom} {f : J -> Dom} : BasicCover x f -> BasicCover (func x) (\lam j => func (f j))
  | func-image {y : Cod} : Cover y func
}

\instance FramePresCat : Cat FramePres
  | Hom => FramePresHom
  | id X => \new FramePresHom {
    | func x => x
    | func-conj => idp
    | func-cover c => c
    | func-image {x} => cover-inj x idp
  }
  | o g f => \new FramePresHom {
    | func x => g (f x)
    | func-conj => pmap g func-conj *> func-conj
    | func-cover c => func-cover (func-cover c)
    | func-image => cover-trans func-image (\lam y => Cover.map func-image)
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : FramePresHom) (h2 : FramePresHom) => exts FramePres {
    | conj x y => h1.func-conj
    | BasicCover x f => ext (h1.func-cover, h2.func-cover)
  })

{- | We can define the underlying set of {PresentedFrame} as the quotient of the set `P -> \Prop`
 -   under the relation `\Sigma (U <= V) (V <= U)`, where `U <= V` iff `\Pi (x : P) -> U x -> Cover x V`.
 -   Alternatively, we can define this set as a maximal element of an equivalence class.
 -   A subset is maximal if every element covered by it actually belongs to it.
 -   We use the second option.
 -}
\instance PresentedFrame (P : FramePres) : Locale
  | E => Opens P
  | <= => <=
  | <=-reflexive u => u
  | <=-transitive U<=V V<=W xU => V<=W (U<=V xU)
  | <=-antisymmetric U<=V V<=U => exts (\lam x => ext (U<=V, V<=U))
  | meet U V => closure (\lam (t : \Sigma (a b : P) (U.1 a) (V.1 b)) => conj t.1 t.2)
  | meet-left {U} {V} => closure<= (\lam t => cover-proj1 idp (t.1,t.3) idp)
  | meet-right {U} {V} => closure<= (\lam t => cover-proj2 idp (t.2,t.4) idp)
  | meet-univ {U} {V} {W} W<=U W<=V {x} xW => cover-trans (cover-idemp {P} {x} {\Sigma} {\lam _ => conj x x} () idp) (\lam _ => cover-inj (x, x, W<=U xW, W<=V xW) idp)
  | top => (\lam _ => \Sigma, \lam _ _ => ())
  | top-univ _ => ()
  | Join {J} f => closure {_} {\Sigma (j : J) (x : P) ((f j).1 x)} __.2
  | Join-cond j {_} {x} c => cover-inj (j,x,c) idp
  | Join-univ {J} {f} {U} d => closure<= (\lam t => cover-inj (t.2, d t.1 t.3) idp)
  | Join-ldistr>= => cover-trans __ (\lam t => Cover.cover-ldistr' idp t.4 (\lam s => inP ((s.1, conj t.1 s.2, cover-inj (t.1, s.2, t.3, s.3) idp), idp)))
  \where {
    \open FramePres(SCover)

    \func Opens (P : FramePres) => \Sigma (U : P -> \Prop) (\Pi (x : P) -> SCover x U -> U x)

    \func closure {P : FramePres} {J : \Set} (g : J -> P) : Opens P
      => (Cover __ g, \lam x c => cover-trans c __.2)

    \type \infix 4 <= {P : FramePres} (U V : Opens P) => \Pi {x : P} -> U.1 x -> V.1 x

    \lemma closure<= {P : FramePres} {J : \Set} {g : J -> P} {U : Opens P} (p : \Pi (j : J) -> SCover (g j) U.1) : closure g <= U
      => \lam {x} c => U.2 x (cover-trans c p)

    \func embed {P : FramePres} (x : P) : PresentedFrame P
      => closure {_} {\Sigma} (\lam _ => x)

    \lemma embed<= {P : FramePres} {x : P} {U : Opens P} (p : SCover x U.1) : embed x <= U
      => closure<= (\lam _ => p)
  }

{- | Unital presentation of frames.
 -   {unit} represents the top element.
 -}
\class FrameUnitalPres \extends FramePres
  | unit : E
  | isUnit {x : E} : Cover x {\Sigma} (\lam _ => unit)

\record FrameUnitalPresHom \extends FramePresHom {
  \override Dom : FrameUnitalPres
  \override Cod : FrameUnitalPres
  | func-unit : func unit = unit
  | func-image => cover-trans isUnit (\lam _ => cover-inj unit func-unit)
}

\instance FrameUnitalPresCat : Cat FrameUnitalPres
  | Hom => FrameUnitalPresHom
  | id X => \new FrameUnitalPresHom {
    | FramePresHom => FramePresCat.id X
    | func-unit => idp
  }
  | o g f => \new FrameUnitalPresHom {
    | FramePresHom => FramePresCat.o g f
    | func-unit => pmap g func-unit *> func-unit
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : FrameUnitalPresHom) (h2 : FrameUnitalPresHom) => exts FrameUnitalPres {
    | conj x y => h1.func-conj
    | BasicCover x f => ext (h1.func-cover, h2.func-cover)
    | unit => h1.func-unit
  })

\func FrameUnitalSubcat : FullyFaithfulFunctor FrameCat FrameUnitalPresCat \cowith
  | F (L : Locale) : FrameUnitalPres \cowith {
    | E => L
    | conj => meet
    | BasicCover x f => x <= Join f
    | unit => top
    | isUnit => cover-basic (<=-transitive top-univ (Join-cond ()))
  }
  | Func {X Y : Locale} (h : FrameHom X Y) : FrameUnitalPresHom (F X) (F Y) \cowith {
    | func => h
    | func-conj => func-meet
    | func-cover c => transport (_ <=) func-Join (FrameHom.func-<= c)
    | func-unit => func-top
  }
  | Func-id => idp
  | Func-o g f => idp
  | isFullyFaithful => \new QEquiv {
    | ret h => \new FrameHom {
      | func => h
      | func-top => func-unit
      | func-meet => func-conj
      | func-Join>= => func-cover {h} <=-reflexive
    }
    | ret_f h => idp
    | f_sec h => idp
  }

\func FrameReflectiveSubcat : ReflectiveSubPrecat FrameCat FramePresCat \cowith
  | F => F
  | Func => Func
  | Func-id => idp
  | Func-o g f => idp
  | isFullyFaithful => FrameUnitalSubcat.isFullyFaithful
  | reflector => PresentedFrame
  | reflectorMap (X : FramePres) : FramePresHom X (F (PresentedFrame X)) \cowith {
    | func => PresentedFrame.embed
    | func-conj {x} {y} => <=-antisymmetric
        (cover-trans __ (\lam _ => cover-inj (x, y, cover-inj () idp, cover-inj () idp) idp))
        (cover-trans __ (\lam t => Cover.cover-conj t.3 t.4 (\lam {_} {_} => inP ((),idp))))
    | func-cover {_} {_} {f} b c => cover-trans c (\lam _ => cover-trans (cover-basic b) (\lam j => cover-inj (j, f j, cover-inj () idp) idp))
    | func-image => cover-basic (\lam {x} _ => cover-inj (x, x, cover-inj () idp) idp)
  }
  | isReflective {X : FramePres} {Y : Locale} => ESEquiv.toEquiv (\new ESEquiv {
    | Embedding => Embedding.fromInjection (\lam {h} {h'} p => exts (\lam e =>
        \let | g (q : \Sigma (x : X) (e.1 x)) => reflectorMap X q.1
             | t : e = Join {PresentedFrame X} g => exts (\lam x => ext (\lam u => cover-inj ((x, u), x, cover-inj () idp) idp, closure<= (\lam t => cover-trans t.3 (\lam _ => cover-inj t.1 idp))))
        \in rewrite t (func-Join {h} {_} {g} *> path (\lam i => Join (\lam (j : \Sigma (x : X) (e.1 x)) => (p @ i) j.1)) *> inv (func-Join {h'} {_} {g}))))
    | isSurj f => inP (adjointMap f, exts (\lam x => unfold (<=-antisymmetric
        (Join-univ (\lam j => <=-transitive (locale_cover (Cover.map j.2)) (Join-univ (\lam _ => <=-reflexive))))
        (Join-cond (later (x, cover-inj () idp))))))
  })
  \where {
    \open PresentedFrame \hiding (<=)
    \open FrameUnitalSubcat

    \lemma locale_cover {L : Locale} {x : L} {J : \Set} {g : J -> L} (c : Cover {F L} x g) : x <= L.Join g \elim c
      | cover-basic b => b
      | cover-inj j p => rewriteI p (Join-cond j)
      | cover-trans c f => <=-transitive (locale_cover c) (Join-univ (\lam i => locale_cover (f i)))
      | cover-proj1 p j q => rewrite p (<=-transitive meet-left (rewriteI q (Join-cond j)))
      | cover-proj2 p j q => rewrite p (<=-transitive meet-right (rewriteI q (Join-cond j)))
      | cover-idemp j p => transport (`<= _) (p *> meet-idemp) (Join-cond j)
      | cover-comm p j q => transport (`<= _) (q *> meet-comm *> inv p) (Join-cond j)
      | cover-ldistr p c f => rewrite p (<=-transitive (meet-univ meet-left (<=-transitive meet-right (locale_cover c))) (<=-transitive Join-ldistr>= (Join-univ (\lam j => transport (`<= _) (f j) (Join-cond j)))))

    \func adjointMap {X : FramePres} {Y : Locale} (f : FramePresHom X (F Y)) : FrameHom (PresentedFrame X) Y \cowith
      | func U => Y.Join {\Sigma (x : X) (U.1 x)} (\lam j => f j.1)
      | func-top => <=-antisymmetric top-univ (<=-transitive (locale_cover f.func-image) (Join-univ (\lam x => Join-cond (x, ()))))
      | func-meet {U} {V} => <=-antisymmetric
          (Join-univ (unfold (\lam p => <=-transitive (locale_cover (Cover.map p.2)) (Join-univ (\lam t => rewrite f.func-conj (Join-cond (later ((t.1,t.3),(t.2,t.4)))))))))
          (Join-univ (\lam p => transport (`<= _) f.func-conj (Y.Join-cond (later (conj p.1.1 p.2.1, cover-inj (later (p.1.1, p.2.1, p.1.2, p.2.2)) idp))))) *> inv (Locale.Join-distr)
      | func-Join>= => Join-univ (\lam p => <=-transitive (locale_cover (Cover.map p.2)) (Join-univ (\lam t => <=-transitive (Join-cond (later (t.2,t.3))) (Join-cond t.1))))
  }

\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUnitalPresCat \cowith
  | FullyFaithfulFunctor => FrameUnitalSubcat
  | reflector X => FrameReflectiveSubcat.reflector X
  | reflectorMap X => \new FrameUnitalPresHom {
    | FramePresHom => FrameReflectiveSubcat.reflectorMap X
    | func-unit => exts (\lam e => ext (\lam _ => (), \lam _ => isUnit))
  }
  | isReflective {X} {Y} => \new QEquiv {
    | ret h => FrameReflectiveSubcat.isReflective.ret h
    | ret_f h => FrameReflectiveSubcat.isReflective.ret_f h
    | f_sec h => ext (pmap {FramePresHom X (FrameUnitalSubcat.F Y)} (func {__}) (FrameReflectiveSubcat.isReflective.f_ret h))
  }

\open PresentedFrame \hiding (<=)
\open Locale

\lemma <<-fromPres {P : FramePres} {x y : P} (x<<y : x FramePres.<< y) : embed x << {PresentedFrame P} embed y
  => \lam {J} g y<=Jg => \case x<<y {\Sigma (j : J) (z : P) ((g j).1 z)} __.2 (y<=Jg (cover-inj () idp)) \with {
       | inP (l,x<=l) => inP (map __.1 l, \lam c => cover-trans c (\lam _ => cover-trans x<=l (\lam i => cover-inj (transport Fin (inv (length_map __.1 l)) i, (l !! i).2, rewrite map_!! (l !! i).3) idp)))
     }

\lemma <<-left {L : Locale} {x y z : L} (x<<y : x << y) (y<=z : y <= z) : x << z
  => \lam {J} g z<=Jg => TruncP.map (x<<y g (<=-transitive y<=z z<=Jg)) (\lam t => t)

\lemma <<-right {L : Locale} {x y z : L} (x<=y : x <= y) (y<<z : y << z) : x << z
  => \lam {J} g z<=Jg => TruncP.map (y<<z g z<=Jg) (\lam t => (t.1, <=-transitive x<=y t.2))

\lemma locallyCompact-fromPres {P : FramePres} (lc : P.isLocallyCompact) : isLocallyCompact {PresentedFrame P}
  => \lam U {x} u => cover-trans (lc x) (\lam t => cover-inj ((embed t.1, <<-left (<<-fromPres t.2) (embed<= (cover-inj (x,u) idp))), t.1, cover-inj () idp) idp)
