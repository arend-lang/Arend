\import Algebra.Meta
\import Algebra.Ordered
\import Arith.Nat
\import Category
\import Category.Factorization
\import Category.Functor
\import Category.Limit
\import Category.Meta
\import Category.Sub
\import Category.Topos.Sheaf
\import Data.Array
\import Data.Bool
\import Data.Maybe
\import Data.Or
\import Equiv (ESEquiv, Embedding, Equiv, QEquiv, idEquiv)
\import Equiv.Univalence (Equiv-to-=)
\import Function (isSurj)
\import Function.Meta ($, repeat)
\import Homotopy.Fibration
\import Logic
\import Logic.Classical
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import Set.Category
\import Set.Fin
\open Bounded(top,top-univ,bottom,bottom-univ)
\open MeetSemilattice
\open JoinSemilattice
\open PresentedFrame \hiding (<=)
\open Locale
\open Preorder (=_<=)

\class Locale \extends Bounded.DistributiveLattice, SiteWithBasis, CompleteCat (\lp,\lp) {
  | Join {J : \Set} : (J -> E) -> E
  | Join-cond {J : \Set} (j : J) {f : J -> E} : f j <= Join f
  | Join-univ {J : \Set} {f : J -> E} {e : E} : (\Pi (j : J) -> f j <= e) -> Join f <= e
  | Join-ldistr>= {J : \Set} {f : J -> E} {e : E} : e ∧ Join f <= Join (\lam (j : J) => e ∧ f j)

  | bottom => Join absurd
  | bottom-univ {x} => Join-univ (\case __)
  | join x y => Join (if __ x y)
  | join-left {x} {y} => Join-cond true
  | join-right {x} {y} => Join-cond false
  | join-univ x<=z y<=z => Join-univ (\case \elim __ \with {
    | true => x<=z
    | false => y<=z
  })
  | ldistr>= {x} {y} {z} =>
    \have t : (\lam b => if b (x ∧ y) (x ∧ z)) = (\lam b => x ∧ if b y z)
            => ext (\lam b => cases b idp)
    \in unfold (rewrite t Join-ldistr>=)

  | Meet {J : \Set} : (J -> E) -> E
  | Meet {J} g => Join (\lam (t : Total (\Pi (j : J) -> __ <= g j)) => t.1)
  | Meet-cond {J : \Set} (j : J) {f : J -> E} : Meet f <= f j
  | Meet-cond {J} j {f} => Join-univ (__.2 j)
  | Meet-univ {J : \Set} {f : J -> E} {e : E} : (\Pi (j : J) -> e <= f j) -> e <= Meet f
  | Meet-univ {J} {f} {e} p => Join-cond (later (e,p))

  | limit {J} G => \new Limit {
    | apex => Meet (Total.proj (\lam x => ∃ (j : J) (G j = x)))
    | coneMap j => Meet-cond (later (G j, inP (j, idp)))
    | coneCoh _ => Path.inProp _ _
    | isLimit x => \new QEquiv {
      | ret (c : Cone) => Meet-univ (\lam (y, inP (j,p)) => transport (x <=) p (c.coneMap j))
      | ret_f h => Path.inProp _ _
      | f_sec c => exts (\lam j => Path.inProp _ _)
    }
  }
  | pullback {x} {y} f g => \new Pullback {
    | apex => x ∧ y
    | cone => (meet-left, meet-right, Path.inProp _ _)
    | pbMap c => meet-univ c.1 c.2
    | pbBeta1 => Path.inProp _ _
    | pbBeta2 => Path.inProp _ _
    | pbEta _ _ => Path.inProp _ _
  }
  | isBasicCover x g => x <= Join (\lam j => (g j).1)
  | basicCover-stable {x} {y} x<=y c => meet-univ <=-refl (x<=y <=∘ c) <=∘ Join-ldistr>=

  \lemma Join-ldistr {J : \Set} {f : J -> E} {e : E} : e ∧ Join f = Join (\lam (j : J) => e ∧ f j)
    => <=-antisymmetric Join-ldistr>= (Join-univ (\lam j => meet-monotone <=-refl (Join-cond j)))

  \lemma Join-rdistr {J : \Set} {f : J -> E} {e : E} : Join f ∧ e = Join (\lam (j : J) => f j ∧ e)
    => meet-comm *> Join-ldistr *> pmap Join (ext (\lam j => meet-comm))

  \lemma Join-rdistr>= {J : \Set} {f : J -> E} {e : E} : Join f ∧ e <= Join (\lam (j : J) => f j ∧ e)
    => =_<= Join-rdistr

  \lemma Join-double {I J : \Set} {f : I -> J -> E} : Join (\lam i => Join (\lam j => f i j)) = Join (\lam (p : \Sigma I J) => f p.1 p.2)
    => <=-antisymmetric (Join-univ (\lam i => Join-univ (\lam j => Join-cond (i,j)))) (Join-univ (\lam p => Join-cond p.2 <=∘ Join-cond p.1))

  \lemma Join-distr {I J : \Set} {f : I -> E} {g : J -> E} : Join f ∧ Join g = Join (\lam (p : \Sigma I J) => f p.1 ∧ g p.2)
    => Join-rdistr *> path (\lam i => Join (\lam i' => Join-ldistr {_} {J} {g} {f i'} @ i)) *> Join-double {_} {I} {J} {\lam i j => f i ∧ g j}

  \lemma Join-distr>= {I J : \Set} {f : I -> E} {g : J -> E} : Join f ∧ Join g <= Join (\lam (p : \Sigma I J) => f p.1 ∧ g p.2)
    => =_<= Join-distr

  \func SJoin (U : E -> \Prop) => Join (\lam (t : Total U) => t.1)

  \type \infix 4 << (x y : E) => \Pi {J : \Set} {g : J -> E} -> y <= Join g -> ∃ (l : Array J) (x <= Join (\lam i => g (l i)))

  \type isCompact => top << top

  \type isLocallyCompact => \Pi (x : E) -> x <= SJoin (`<< x)

  \func \infixr 5 --> (x y : E) => SJoin (__ ∧ x <= y)

  \lemma exponent {x y z : E} : (x ∧ y <= z) = (x <= y --> z)
    => ext (dir,conv)
    \where {
      \lemma dir {x y z : E} (p : x ∧ y <= z) : x <= y --> z
        => Join-cond (later (x,p))

      \lemma conv {x y z : E} (p : x <= y --> z) : x ∧ y <= z
        => meet-monotone p <=-refl <=∘ eval
    }

  \lemma eval {x y : E} : (x --> y) ∧ x <= y
    => rewrite Join-rdistr (Join-univ __.2)

  \lemma trueExponent {x y : E} (p : x <= y) : top <= x --> y
    => exponent.dir (meet-right <=∘ p)

  \func neg (x : E) => x --> bottom

  \lemma neg-inverse {x y : E} (p : x <= y) : neg y <= neg x
    => exponent.dir $ meet-monotone <=-refl p <=∘ eval

  -- | `x <=< y` if and only if the closure of {x} is contained in {y}.
  \type \infix 4 <=< (x y : E) => top <= neg x ∨ y

  \type isRegular => \Pi (x : E) -> x <= SJoin (`<=< x)

  \func open (a : E) : Nucleus (a --> __) \cowith
    | nucleus-meet => <=-antisymmetric
        (meet-univ (exponent.dir (eval <=∘ meet-left)) (exponent.dir (eval <=∘ meet-right)))
        (exponent.dir (meet-univ (meet-monotone meet-left <=-refl <=∘ eval) (meet-monotone meet-right <=-refl <=∘ eval)))
    | nucleus-unit => exponent.dir meet-left
    | nucleus-join => exponent.dir (transport (_ ∧ __ <= _) meet-idemp (transport (`<= _) meet-assoc (meet-monotone eval <=-refl <=∘ eval)))

  \func closed (a : E) : Nucleus (a ∨ __) \cowith
    | nucleus-meet => equation
    | nucleus-unit => join-right
    | nucleus-join => join-univ join-left <=-refl

  \lemma closed-isClosed (a : E) : Nucleus.isClosed {closed a}
    => \lam {x} => join-univ (join-left <=∘ join-left) join-right

  \func pHat (P : \Prop) => Join (\lam (_ : P) => top)

  \func isPositive (a : E) => \Pi (P : \Prop) -> a <= pHat P -> P

  \lemma positive_<= {a b : E} (a<=b : a <= b) (p : isPositive a) : isPositive b
    => \lam g q => p g (a<=b <=∘ q)

  \lemma positive_cover {a : E} (p : isPositive a) {J : \Set} (g : J -> E) (c : a <= Join g) : TruncP J
    => p _ $ c <=∘ Join-univ (\lam j => top-univ <=∘ Join-cond (inP j))

  \func isOvert => \Pi (a : E) -> a <= pHat (isPositive a)

  \lemma overt_cover (o : isOvert) {a : E} : a <= Join (\lam (_ : isPositive a) => a)
    => meet-univ <=-refl (o a) <=∘ Join-ldistr>= <=∘ Join-univ (\lam p => meet-left <=∘ Join-cond {_} {isPositive a} p)
}

\record FrameHom \extends SetHom {
  \override Dom : Locale
  \override Cod : Locale
  | func-<= {x y : Dom} : x <= y -> func x <= func y
  | func-top : func top = top
  | func-top>= : top <= func top
  | func-meet {x y : Dom} : func (x ∧ y) = func x ∧ func y
  | func-meet>= {x y : Dom} : func x ∧ func y <= func (x ∧ y)
  | func-Join {J : \Set} {f : J -> Dom} : func (Join f) = Join (\lam j => func (f j))
  | func-Join>= {J : \Set} {f : J -> Dom} : func (Join f) <= Join (\lam j => func (f j))

  \default func-Join>= {J} {f} => transport (_ <=) func-Join <=-refl
  \default func-Join \as func-Join-impl {J} {f} => <=-antisymmetric func-Join>= (Join-univ (\lam j => func-<= (Join-cond j)))
  \default func-top>= => transportInv (_ <=) func-top <=-refl
  \default func-top => <=-antisymmetric top-univ func-top>=
  \default func-<= x<=y => rewrite (inv (pmap func (meet_<= x<=y)) *> func-meet) meet-right
  \default func-meet>= => =_<= (inv func-meet)
  \default func-meet => <=-antisymmetric (meet-univ (func-<= meet-left) (func-<= meet-right)) func-meet>=

  \lemma func-join {x y : Dom} : func (x ∨ y) = func x ∨ func y
    => func-Join *> pmap Join (ext (\lam b => cases b idp))

  \lemma func-join>= {x y : Dom} : func (x ∨ y) <= func x ∨ func y
    => =_<= func-join

  \lemma func-bottom : func bottom = bottom
    => func-Join *> pmap Join (ext (\case __))

  \lemma func-bottom>= : func bottom <= bottom
    => =_<= func-bottom

  \lemma func-pHat {P : \Prop} : func (pHat P) = pHat P
    => func-Join *> path (\lam i => Join (\lam _ => func-top i))

  \lemma func-pHat<= {P : \Prop} : pHat P <= func (pHat P)
    => =_<= (inv func-pHat)

  \lemma func-pHat>= {P : \Prop} : func (pHat P) <= pHat P
    => =_<= func-pHat

  \func direct (y : Cod) : Dom => SJoin (func __ <= y)

  \lemma direct-<= {y z : Cod} (p : y <= z) : direct y <= direct z
    => Join-univ (\lam (x,q) => Join-cond (later (x, q <=∘ p)))

  \lemma direct-meet {y z : Cod} : direct (y ∧ z) = direct y ∧ direct z
    => <=-antisymmetric (meet-univ (direct-<= meet-left) (direct-<= meet-right)) (Join-cond (later (direct y ∧ direct z, meet-univ (func-<= meet-left <=∘ direct-counit) (func-<= meet-right <=∘ direct-counit))))

  \lemma direct-top : direct top = top
    => <=-antisymmetric top-univ (Join-cond (later (top, top-univ)))

  \lemma direct-unit {x : Dom} : x <= direct (func x)
    => Join-cond $ later (x,<=-refl)

  \lemma direct-counit {y : Cod} : func (direct y) <= y
    => func-Join>= <=∘ Join-univ __.2

  \lemma func_direct_func {x : Dom} : func (direct (func x)) = func x
    => <=-antisymmetric direct-counit (func-<= direct-unit)

  \func image : Nucleus (\lam x => direct (func x)) \cowith
    | nucleus-meet => pmap direct func-meet *> direct-meet
    | nucleus-unit => direct-unit
    | nucleus-join => direct-<= direct-counit

  -- | A map is dense if and only if its image is dense.
  \func isDense => \Pi {x : Dom} -> func x <= bottom -> x <= bottom

  \lemma dense_direct (d : isDense) : direct bottom <= bottom
    => Join-univ (\lam j => d j.2)

  \lemma direct_dense (d : direct bottom <= bottom) : isDense
    => \lam {x} p => Join-cond (later (x,p)) <=∘ d

  \func isStronglyDense => \Pi {P : \Prop} {x : Dom} -> func x <= pHat P -> x <= pHat P

  \func isWeaklyClosed => \Sigma (isSurj func) (\Pi (j : Nucleus) ->
      (\Pi {P : \Prop} {x : Dom} -> func x <= pHat P -> x <= j (pHat P)) -> \Pi {x : Dom} -> direct (func x) <= j x)

  -- | The weak closure of the image
  \func wclosed-image : Nucleus \cowith
    | nucleus x => Meet (\lam (j : \Sigma (j : Nucleus) (\Pi {P : \Prop} {x : Dom} -> func x <= pHat P -> x <= j (pHat P))) => j.1 x)
    | nucleus-<= p => Meet-univ (\lam j => Meet-cond j <=∘ nucleus-<= p)
    | nucleus-meet>= => Meet-univ (\lam j => meet-monotone (Meet-cond j) (Meet-cond j) <=∘ nucleus-meet>=)
    | nucleus-unit {x} => Join-cond $ later (x, \lam j => nucleus-unit)
    | nucleus-join => Meet-univ (\lam j => Meet-cond j <=∘ nucleus-<= (Meet-cond j) <=∘ nucleus-join)

  -- | A map is closed if and only if the image of a closed sublocale is closed.
  \func isClosed => \Pi {x : Cod} {y : Dom} -> direct (x ∨ func y) <= direct x ∨ y

  -- | The image of a closed map is closed.
  \lemma image_closed (c : isClosed) : image.isClosed
    => \lam {y} => direct-<= join-right <=∘ c <=∘ join-monotone (direct-<= bottom-univ) <=-refl

  -- | If the image of an embedding is closed, then it is a closed map.
  \lemma closed-embedding_image (s : isSurj func) (c : image.isClosed) : isClosed
    => \lam {x} {y} => \case s x \with {
      | inP (a,p) => rewriteI (p,func-join) (c <=∘ join-univ (direct-<= (func-<= bottom-univ) <=∘ join-left) (join-monotone direct-unit <=-refl))
    }

  \lemma surjective-split (s : isSurj func) (x : Cod) : func (direct x) = x
    => \case s x \with {
      | inP (y,p) => rewriteI p func_direct_func
    }

  \func factor : FrameHom image.locale Cod \cowith
    | func x => func x.1
    | func-top => func-top
    | func-meet => func-meet
    | func-Join>= => direct-counit <=∘ func-Join>=

  \lemma surj_nucleus (s : isSurj func) : Equiv factor => \new QEquiv {
    | ret y => (direct y, direct-<= direct-counit)
    | ret_f x => ext (<=-antisymmetric x.2 direct-unit)
    | f_sec y => surjective-split s y
  }
}

-- | Nuclei encode sublocales
\record Nucleus {L : Locale} (\coerce nucleus : L -> L) {
  | nucleus-meet {x y : L} : nucleus (x ∧ y) = nucleus x ∧ nucleus y
  | nucleus-meet>= {x y : L} : nucleus x ∧ nucleus y <= nucleus (x ∧ y)
  | nucleus-<= {x y : L} : x <= y -> nucleus x <= nucleus y
  | nucleus-unit {x : L} : x <= nucleus x
  | nucleus-join {x : L} : nucleus (nucleus x) <= nucleus x

  \default nucleus-<= p => rewrite (inv (pmap nucleus (meet_<= p)) *> nucleus-meet) meet-right
  \default nucleus-meet => <=-antisymmetric (meet-univ (nucleus-<= meet-left) (nucleus-<= meet-right)) nucleus-meet>=
  \default nucleus-meet>= => =_<= (inv nucleus-meet)

  \lemma nucleus-univ {x y : L} (p : x <= nucleus y) : nucleus x <= nucleus y
    => nucleus-<= p <=∘ nucleus-join

  \func locale : Locale (\Sigma (x : L) (nucleus x <= x)) \cowith
    | <= (x,_) (y,_) => x <= y
    | <=-refl => <=-refl
    | <=-transitive => <=-transitive
    | <=-antisymmetric p q => ext (<=-antisymmetric p q)
    | meet (x,p) (y,q) => (x ∧ y, rewrite nucleus-meet (meet-monotone p q))
    | meet-left => meet-left
    | meet-right => meet-right
    | meet-univ => meet-univ
    | top => (top, top-univ)
    | top-univ => top-univ
    | Join f => (nucleus (Join (f __).1), nucleus-join)
    | Join-cond j {f} => Join-cond j <=∘ nucleus-unit
    | Join-univ {J} {f} {e} h => nucleus-<= (Join-univ h) <=∘ e.2
    | Join-ldistr>= {J} {f} {e} => meet-monotone nucleus-unit <=-refl <=∘ transport (`<= _) nucleus-meet (nucleus-<= Join-ldistr>=)

  \func map : FrameHom L locale \cowith
    | func x => (nucleus x, nucleus-join)
    | func-top => ext (<=-antisymmetric top-univ nucleus-unit)
    | func-meet => ext nucleus-meet
    | func-Join>= => nucleus-<= (Join-univ (\lam j => nucleus-unit <=∘ Join-cond j))
    \where {
      \lemma surjective : isSurj map
        => \lam y => inP (y.1, ext $ <=-antisymmetric y.2 nucleus-unit)
    }

  \lemma map_direct (x : locale) : map.direct x = x.1
    => <=-antisymmetric (Join-univ (\lam j => nucleus-unit <=∘ j.2)) (Join-cond (later (x.1, x.2)))

  \func isClosed => \Pi {x : L} -> nucleus x <= nucleus bottom ∨ x

  \func isDense => nucleus bottom <= bottom
}

-- | The order of nuclei is inversed. That is, `n <= m` iff `m.locale` is a sublocale of `n.locale`.
\instance NucleusPoset (L : Locale) : Poset (Nucleus {L})
  | <= j j' => \Pi {x : L} -> j x <= j' x
  | <=-refl => <=-refl
  | <=-transitive p q {x} => <=-transitive p q
  | <=-antisymmetric p q => exts (\lam x => <=-antisymmetric p q)
  \where {
    \func <=-map {L : Locale} (j j' : Nucleus {L}) (j<=j' : j <= {NucleusPoset L} j') : FrameHom j.locale j'.locale \cowith
      | func x => (j' x.1, nucleus-join)
      | func-<= => nucleus-<=
      | func-top>= => nucleus-unit
      | func-meet>= => nucleus-meet>=
      | func-Join>= => unfold $ nucleus-<= j<=j' <=∘ nucleus-join <=∘ nucleus-<= (Join-univ (\lam j => nucleus-unit <=∘ Join-cond j))
  }

\lemma closed>=open {L : Locale} {c a : L} (p : top <= c ∨ a) : closed c >= open a
  => \lam {x} => meet-univ <=-refl (top-univ <=∘ p) <=∘ ldistr>= <=∘ join-monotone meet-right eval
  \where
    \lemma conv {L : Locale} {c a : L} (p : closed c >= open a) : top <= c ∨ a
      => trueExponent <=-refl <=∘ p

\lemma open<=closed {L : Locale} {c a : L} (p : c ∧ a <= bottom) : open a >= closed c
  => \lam {x} => unfold (join-univ (exponent.dir (p <=∘ bottom-univ)) (exponent.dir meet-left))
  \where
    \lemma conv {L : Locale} {c a : L} (p : open a >= closed c) : c ∧ a <= bottom
      => meet-monotone join-left <=-refl <=∘ exponent.conv p

-- | A closed and "bounded" sublocale is compact.
\lemma closed-compact {L : Locale} {N : Nucleus {L}} (c : N.isClosed) {a : L} (w : a << top) (b : N >= open a) : N.locale.isCompact
  => \lam {J} {g} top<=g =>
      \let | g' (j : Maybe J) : L => \case \elim j \with { | nothing => N bottom | just j => (g j).1 }
           | top<=g' : top <= Join g' => top<=g <=∘ c <=∘ join-univ (Join-cond nothing) (Join-univ (\lam j => Join-cond (just j)))
           | (inP (l,a<=g'l)) => w top<=g'
      \in inP (filterMap (\lam x => x) l, unfold (trueExponent a<=g'l <=∘ b <=∘ Nucleus.nucleus-univ (Join-univ (\lam j' => later (cases (l j' arg addPath) \with {
        | nothing, _ => Nucleus.nucleus-<= bottom-univ
        | just j, p => \have (k,q) => filterMap-index (\lam x => x) l p
                       \in rewriteI q (Join-cond k) <=∘ nucleus-unit
      })))))

\func FrameCat : Cat Locale \cowith
  | Hom => FrameHom
  | id L => \new FrameHom {
    | func x => x
    | func-top => idp
    | func-meet => idp
    | func-Join => idp
  }
  | o g f => \new FrameHom {
    | func x => g (f x)
    | func-top => pmap g func-top *> func-top
    | func-meet {x} {y} => pmap g func-meet *> func-meet
    | func-Join {J} {h} => pmap g func-Join *> func-Join
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : FrameHom) (h2 : FrameHom) => exts Locale {
    | <= x y => ext (h1.func-<=, h2.func-<=)
    | meet x y => h1.func-meet
    | top => h1.func-top
    | Join f => h1.func-Join
  })
  \where {
    \func equiv_iso {f : FrameHom} (e : Equiv f) : Iso {FrameCat} f \cowith
      | inv => \new FrameHom {
        | func => e.ret
        | func-top => pmap e.ret (inv func-top) *> e.ret_f top
        | func-meet {x} {y} => pmap e.ret (inv (func-meet *> pmap2 (∧) (e.f_ret x) (e.f_ret y))) *> e.ret_f _
        | func-Join {J} {g} => pmap e.ret (inv (func-Join *> path (\lam i => Join (\lam j => e.f_ret (g j) i)))) *> e.ret_f _
      }
      | inv_f => exts e.ret_f
      | f_inv => exts e.f_ret
  }

{- | Presentation of frames.
 -   {conj} represents meets and {BasicCover} represents relation `__ <= Join __`.
 -}
\class FramePres \extends BaseSet {
  | conj : E -> E -> E
  | BasicCover {J : \Set} : E -> (J -> E) -> \Prop

  \type \infix 4 << (x y : E) => \Pi {J : \Set} {g : J -> E} -> Cover y g -> ∃ (l : Array J) (Cover x (\lam i => g (l i)))

  \func SCover (x : E) (U : E -> \Prop) => Cover x (\lam (t : \Sigma (x : E) (U x)) => t.1)

  \type isLocallyCompact => \Pi (x : E) -> SCover x (`<< x)

  \func isPositive (a : E) => \Pi {J : \Set} (g : J -> E) -> Cover a g -> TruncP J

  \func isOvert => \Pi (a : E) -> Cover a (\lam (_ : isPositive a) => a)
} \where {
  \type Indexing {I X : \Set} (h : I -> \Sigma (J : \Set) X (J -> X)) {J : \Set} (e : X) (g : J -> X)
    => ∃ (i : I) (p : Equiv {(h i).1} {J}) ((h i).2 = e) (\Pi (j : (h i).1) -> (h i).3 j = g (p j))

  \lemma indexing-make {I X : \Set} {h : I -> \Sigma (J : \Set) X (J -> X)} (i : I) : Indexing h (h i).2 (h i).3
    => inP (i, idEquiv, idp, \lam j => idp)

  \lemma indexing-transport {I X : \Set} {g : I -> \Sigma (J : \Set) X (J -> X)}
                              (P : \Pi {J : \Set} (e : X) (f : J -> X) -> \Prop)
                              (p : \Pi (i : I) -> P (g i).2 (g i).3)
                              {J : \Set} {e : X} {f : J -> X} (b : Indexing g e f) : P e f \elim b
    | inP (i,q,s,t) =>
      \have r : ((g i).1, (g i).3) = {\Sigma (K : \Set) (K -> X)} (J,f) => exts (Equiv-to-= q, t)
      \in coe (\lam i => P {(r @ i).1} (s @ i) (r @ i).2) (p i) right
}

\truncated \data Cover {P : FramePres} (x : P) {J : \Set} (g : J -> P) : \Prop
  | cover-basic (BasicCover x g)
  | cover-inj (j : J) (g j = x)
  | cover-trans {I : \Set} {f : I -> P} (Cover x f) (\Pi (i : I) -> Cover (f i) g)
  | cover-proj1 {a b : P} (x = conj a b) (j : J) (g j = a)
  | cover-idemp (j : J) (g j = conj x x)
  | cover-comm {a b : P} (x = conj a b) (j : J) (g j = conj b a)
  | cover-ldistr {a b : P} (x = conj a b) {f : J -> P} (Cover b f) (\Pi (j : J) -> g j = conj a (f j))
  \where {
    \lemma cover-trans1 {P : FramePres} {x : P} {J : \Set} {g : J -> P} {y : P} (c : Cover1 x y) (d : Cover y g) : Cover x g
      => cover-trans c (\lam _ => d)

    \lemma cover-proj2 {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (p : x = conj a b) (j : J) (q : g j = b) : Cover x g
      => cover-trans (cover-comm {_} {_} {\Sigma} {\lam _ => conj b a} p () idp) (\lam _ => cover-proj1 idp j q)

    \lemma cover-index {P : FramePres} {x : P} {l : Array P} (i : Index x l) : Cover x l
      => cover-inj i.1 i.2

    \lemma cover-ldistr' {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (x=ab : x = conj a b) {I : \Set} {h : I -> P} (ah : Cover b h) (f : \Pi (i : I) -> ∃ (j : J) (g j = conj a (h i))) : Cover x g
      => cover-trans (cover-ldistr {_} {_} {I} {\lam i => conj a (h i)} x=ab ah (\lam j => idp)) (\lam i => \case f i \with {
        | inP (j,p) => cover-inj j p
      })

    \lemma cover-rdistr' {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (x=ab : x = conj a b) {I : \Set} {h : I -> P} (ah : Cover a h) (f : \Pi (i : I) -> ∃ (j : J) (g j = conj (h i) b)) : Cover x g
      => \have t => cover-trans {P} {_} {I} {\lam j => conj b (h j)} (cover-comm {P} {x} {\Sigma} {\lam _ => conj b a} x=ab () idp) (\lam _ => cover-ldistr' idp ah (\lam j => inP (j,idp)))
         \in cover-trans t (\lam j => \case f j \with {
          | inP (i,p) => cover-comm idp i p
        })

    \lemma cover-rdistr {P : FramePres} {x : P} {J : \Set} {g : J -> P} {a b : P} (x=ab : x = conj a b) {h : J -> P} (ah : Cover a h) (f : \Pi (j : J) -> g j = conj (h j) b) : Cover x g
      => cover-rdistr' x=ab ah (\lam j => inP (j, f j))

    \lemma cover-conj {P : FramePres} {J : \Set} {g : J -> P} {a b : P} {I1 : \Set} {h1 : I1 -> P} (aV : Cover a h1) {I2 : \Set} {h2 : I2 -> P} (bW : Cover b h2) (f : \Pi {i1 : I1} {i2 : I2} -> ∃ (j : J) (g j = conj (h1 i1) (h2 i2))) : Cover (conj a b) g
      => cover-trans {P} {_} {J} {g} {_} {\lam i => conj a (h2 i)} (cover-ldistr' idp bW (\lam i => inP (i, idp))) (\lam i2 => cover-rdistr' idp aV (\lam i1 => f))

    \lemma cover-conj1 {P : FramePres} {a a' b b' : P} (c : Cover1 a a') (d : Cover1 b b') : Cover1 (conj a b) (conj a' b')
      => cover-conj c d (\lam {_} {_} => inP ((), idp))

    \lemma cover-prod {P : FramePres} {x y z : P} (c : Cover1 x y) (d : Cover1 x z) : Cover1 x (conj y z)
      => cover-trans (cover-idemp {_} {_} {_} {\lam _ => conj x x} () idp) (\lam _ => cover-conj c d (\lam {i1} {i2} => inP ((),idp)))

    \lemma map {F : FramePresHom} {x : F.Dom} {J : \Set} {g : J -> F.Dom} (c : Cover x g) : Cover (F x) (\lam j => F (g j)) \elim c
      | cover-basic b => cover-basic (func-cover b)
      | cover-inj j p => cover-inj j (pmap F p)
      | cover-trans c g => cover-trans (map c) (\lam i => map (g i))
      | cover-proj1 p j q => cover-proj1 (pmap F p *> func-conj) j (pmap F q)
      | cover-idemp j p => cover-idemp j (pmap F p *> func-conj)
      | cover-comm p j q => cover-comm (pmap F p *> func-conj) j (pmap F q *> func-conj)
      | cover-ldistr p c f => cover-ldistr (pmap F p *> func-conj) (map c) (\lam j => pmap F (f j) *> func-conj)
  }

\func Cover1 {P : FramePres} (x y : P) => Cover x {\Sigma} (\lam _ => y)

\truncated \data Cover' {P : FramePres} (x : P) {J : \Set} (g : J -> P) : \Prop
  | cover-basic' {a b : P} (x = conj a b) {f : J -> P} (BasicCover b f) (\Pi (j : J) -> g j = conj a (f j))
  | cover-inj' (j : J) (g j = x)
  | cover-trans' {I : \Set} {f : I -> P} (Cover' x f) (\Pi (i : I) -> Cover' (f i) g)
  | cover-proj1-inj' {a b : P} (x = conj a b) (j : J) (g j = a)
  | cover-proj2-inj' {a b : P} (x = conj a b) (j : J) (g j = b)
  | cover-prod-inj' {a b : P} (Cover' x {\Sigma} (\lam _ => a)) (Cover' x {\Sigma} (\lam _ => b)) (j : J) (g j = conj a b)
  \where {
    \func Cover1' {P : FramePres} (x y : P) => Cover' x {\Sigma} (\lam _ => y)

    \lemma cover-prod' {P : FramePres} {x y z : P} (c : Cover1' x y) (d : Cover1' x z) : Cover1' x (conj y z)
      => cover-prod-inj' c d () idp

    \lemma cover-proj1' {P : FramePres} {x y : P} : Cover1' (conj x y) x
      => cover-proj1-inj' idp () idp

    \lemma cover-proj2' {P : FramePres} {x y : P} : Cover1' (conj x y) y
      => cover-proj2-inj' idp () idp

    \lemma cover-ldistr' {P : FramePres} {J : \Set} {g : J -> P} {a b : P} {f : J -> P} (c : Cover b f) (q : \Pi (j : J) -> g j = conj a (f j)) : Cover' (conj a b) g \elim c
      | cover-basic c => cover-basic' idp c q
      | cover-inj j idp => cover-inj' j (q j)
      | cover-trans c d => cover-trans' (cover-ldistr' c (\lam j => idp)) (\lam i => cover-ldistr' (d i) q)
      | cover-proj1 p j s => cover-prod-inj' cover-proj1' (cover-trans' cover-proj2' (\lam _ => cover-proj1-inj' p () s)) j (q j)
      | cover-idemp j p => cover-prod-inj' cover-proj1' (cover-prod' cover-proj2' cover-proj2') j (q j *> pmap (conj a) p)
      | cover-comm idp j p => cover-prod-inj' cover-proj1' (cover-trans' cover-proj2' (\lam _ => cover-prod' cover-proj2' cover-proj1')) j (q j *> pmap (conj a) p)
      | cover-ldistr idp c p => cover-trans' (cover-prod' (cover-prod' cover-proj1' (cover-trans' cover-proj2' (\lam _ => cover-proj1'))) (cover-trans' cover-proj2' (\lam _ => cover-proj2')))
          (\lam _ => cover-trans' (cover-ldistr' c (\lam j => idp)) (\lam j => cover-prod-inj' (cover-trans' cover-proj1' (\lam _ => cover-proj1')) (cover-prod' (cover-trans' cover-proj1' (\lam _ => cover-proj2')) cover-proj2') j (q j *> pmap (conj a) (p j))))

    \lemma cover-cover' {P : FramePres} {x : P} {J : \Set} {g : J -> P} (c : Cover x g) : Cover' x g
      => cover-trans' (cover-prod' (cover-inj' () idp) (cover-inj' () idp))
          (\lam _ => cover-trans' (cover-ldistr' c (\lam j => idp)) (\lam j => cover-proj2-inj' idp j idp))

    \lemma cover'-cover {P : FramePres} {x : P} {J : \Set} {g : J -> P} (c : Cover' x g) : Cover x g \elim c
      | cover-basic' p b q => cover-ldistr p (cover-basic b) q
      | cover-inj' j p => cover-inj j p
      | cover-trans' c d => cover-trans (cover'-cover c) (\lam i => cover'-cover (d i))
      | cover-proj1-inj' p j q => cover-proj1 p j q
      | cover-proj2-inj' p j q => Cover.cover-proj2 p j q
      | cover-prod-inj' c1 c2 j p => cover-trans (Cover.cover-prod (cover'-cover c1) (cover'-cover c2)) (\lam _ => cover-inj j p)
  }

\func framePresPreorder (P : FramePres) : Preorder P \cowith
  | <= => Cover1
  | <=-refl => cover-inj () idp
  | <=-transitive p q => cover-trans p (\lam _ => q)

\func framePresSite (P : FramePres) : SiteWithBasis \cowith
  | Precat => framePresPreorder P
  -- TODO: It works much slower if pullback is implement using \new instead of a coclause function. Why?
  | pullback {x y z : P} (f : Cover1 x z) (g : Cover1 y z) : Pullback {framePresPreorder P} f g \cowith {
    | apex => conj x y
    | cone => (cover-proj1 idp () idp, cover-proj2 idp () idp, Path.inProp _ _)
    | pbMap c => cover-prod c.1 c.2
    | pbBeta1 => Path.inProp _ _
    | pbBeta2 => Path.inProp _ _
    | pbEta _ _ => Path.inProp _ _
  }
  | isBasicCover x {J} g => ∃ (y : P) (Cover1 x y) (g' : J -> P) (BasicCover y g') (\Pi (j : J) -> \Sigma (Cover1 (g j).1 (g' j)) (Cover1 (conj x (g' j)) (g j).1))
  | basicCover-stable {x} {y} x<=y {J} {g} (inP (z,y<=z,g',c,d)) => inP (z, cover-trans x<=y (\lam _ => y<=z), g', c, \lam j => (cover-trans (cover-proj2 idp () idp) (\lam _ => (d j).1),
      cover-prod (cover-proj1 idp () idp) (cover-trans (cover-prod (cover-trans (cover-proj1 idp () idp) (\lam _ => x<=y)) (cover-proj2 idp () idp)) (\lam _ => (d j).2))))
  \where \open Cover

\record FramePresHom \extends SetHom {
  \override Dom : FramePres
  \override Cod : FramePres
  | func-conj {x y : Dom} : func (conj x y) = conj (func x) (func y)
  | func-cover {J : \Set} {x : Dom} {f : J -> Dom} : BasicCover x f -> BasicCover (func x) (\lam j => func (f j))
  | func-image {y : Cod} : Cover y func
}

\instance FramePresCat : Cat FramePres
  | Hom => FramePresHom
  | id X => \new FramePresHom {
    | func x => x
    | func-conj => idp
    | func-cover c => c
    | func-image {x} => cover-inj x idp
  }
  | o g f => \new FramePresHom {
    | func x => g (f x)
    | func-conj => pmap g func-conj *> func-conj
    | func-cover c => func-cover (func-cover c)
    | func-image => cover-trans func-image (\lam y => Cover.map func-image)
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : FramePresHom) (h2 : FramePresHom) => exts FramePres {
    | conj x y => h1.func-conj
    | BasicCover x f => ext (h1.func-cover, h2.func-cover)
  })

{- | We can define the underlying set of {PresentedFrame} as the quotient of the set `P -> \Prop`
 -   under the relation `\Sigma (U <= V) (V <= U)`, where `U <= V` iff `\Pi (x : P) -> U x -> Cover x V`.
 -   Alternatively, we can define this set as a maximal element of an equivalence class.
 -   A subset is maximal if every element covered by it actually belongs to it.
 -   We use the second option.
 -}
\instance PresentedFrame (P : FramePres) : Locale
  | E => Opens P
  | <= => <=
  | <=-refl u => u
  | <=-transitive U<=V V<=W xU => V<=W (U<=V xU)
  | <=-antisymmetric U<=V V<=U => exts (\lam x => ext (U<=V, V<=U))
  | meet U V => closure (\lam (t : \Sigma (a b : P) (U.1 a) (V.1 b)) => conj t.1 t.2)
  | meet-left {U} {V} => closure<= (\lam t => cover-proj1 idp (t.1,t.3) idp)
  | meet-right {U} {V} => closure<= (\lam t => Cover.cover-proj2 idp (t.2,t.4) idp)
  | meet-univ {U} {V} {W} W<=U W<=V {x} xW => cover-trans (cover-idemp {P} {x} {\Sigma} {\lam _ => conj x x} () idp) (\lam _ => cover-inj (x, x, W<=U xW, W<=V xW) idp)
  | top => (\lam _ => \Sigma, \lam _ _ => ())
  | top-univ _ => ()
  | Join {J} f => closure {_} {\Sigma (j : J) (x : P) ((f j).1 x)} __.2
  | Join-cond j {_} {x} c => cover-inj (j,x,c) idp
  | Join-univ {J} {f} {U} d => closure<= (\lam t => cover-inj (t.2, d t.1 t.3) idp)
  | Join-ldistr>= => cover-trans __ (\lam t => Cover.cover-ldistr' idp t.4 (\lam s => inP ((s.1, conj t.1 s.2, cover-inj (t.1, s.2, t.3, s.3) idp), idp)))
  \where {
    \open FramePres(SCover)
    \open Topology.Locale(PresentedFrame)

    \type Opens (P : FramePres) => \Sigma (U : P -> \Prop) (\Pi (x : P) -> SCover x U -> U x)

    \func closure {P : FramePres} {J : \Set} (g : J -> P) : Opens P
      => (Cover __ g, \lam x c => cover-trans c __.2)

    \type \infix 4 <= {P : FramePres} (U V : Opens P) => \Pi {x : P} -> U.1 x -> V.1 x

    \lemma closure<= {P : FramePres} {J : \Set} {g : J -> P} {U : Opens P} (p : \Pi (j : J) -> SCover (g j) U.1) : closure g <= U
      => \lam {x} c => U.2 x (cover-trans c p)

    \func embed {P : FramePres} (x : P) : PresentedFrame P
      => closure {_} {\Sigma} (\lam _ => x)

    \lemma embed<= {P : FramePres} {x : P} {U : Opens P} (p : SCover x U.1) : embed x <= U
      => closure<= (\lam _ => p)

    \lemma element_join {P : FramePres} {U : Opens P} : U = Join (\lam (q : \Sigma (x : P) (U.1 x)) => embed q.1)
      => <=-antisymmetric (\lam {x} Ux => cover-inj ((x,Ux), x, cover-inj () idp) idp) (\lam {x} c => U.2 x $ cover-trans c (\lam q => cover-trans q.3 (\lam _ => cover-inj q.1 idp)))

    \func surj-map {L : Locale} {P : FramePres} (f : FrameHom L (PresentedFrame P)) (p : \Pi (y : P) -> ∃ (x : L) (f x = embed y)) (U : PresentedFrame P) : \Sigma (x : L) (f x = U)
      => (SJoin (\lam x => f x <= U), func-Join *> exts (\lam y => ext (
          \lam c => U.2 y (cover-trans c (\lam i => cover-inj (i.2, i.1.2 i.3) idp)),
          \lam yU => \case p y \with {
            | inP (x,q) => cover-inj ((x, \lam {z} t => U.2 z $ rewrite q at t $ cover-trans t (\lam _ => cover-inj (y,yU) idp)), y, rewrite q (cover-inj () idp)) idp
          })))

    \lemma embed_<= {P : FramePres} {a b : P} (a<=b : Cover1 a b) : embed a <= embed b
      => Cover.cover-trans1 __ a<=b

    \lemma embed_meet {P : FramePres} {a b : P} : embed a ∧ embed b = embed (conj a b)
      => exts (\lam e => ext (cover-trans __ (\lam i => Cover.cover-conj1 i.3 i.4), Cover.cover-trans1 __ $ cover-inj (a, b, cover-inj () idp, cover-inj () idp) idp))
  }

{- | Unital presentation of frames.
 -   {unit} represents the top element.
 -}
\class FrameUPres \extends FramePres
  | unit : E
  | isUnit {x : E} : BasicCover x (\lam (_ : \Sigma) => unit)

\record FrameUPresHom \extends FramePresHom {
  \override Dom : FrameUPres
  \override Cod : FrameUPres
  | func-unit : func unit = unit
  | func-image => cover-trans (cover-basic isUnit) (\lam _ => cover-inj unit func-unit)
}

\instance FrameUPresCat : Cat FrameUPres
  | Hom => FrameUPresHom
  | id X => \new FrameUPresHom {
    | FramePresHom => FramePresCat.id X
    | func-unit => idp
  }
  | o g f => \new FrameUPresHom {
    | FramePresHom => FramePresCat.o g f
    | func-unit => pmap g func-unit *> func-unit
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : FrameUPresHom) (h2 : FrameUPresHom) => exts FrameUPres {
    | conj x y => h1.func-conj
    | BasicCover x f => ext (h1.func-cover, h2.func-cover)
    | unit => h1.func-unit
  })

\instance FrameUPresCocompleteCat : CocompleteCat FrameUPres
  | Cat => FrameUPresCat
  | colimit {J} G => \new Limit {
    | Cone => colimit-cone G
    | isLimit Z => \new QEquiv {
      | ret => colimit-univ G
      | ret_f h => exts (\lam t => inv (colimit-univ-eq G h t))
      | f_sec c => idp
    }
  }
  \where {
    \open FramePres

    \truncated \data FTerm {J : Precat} (G : Functor J FrameUPresCat) : \Set
      | finj {j : J} (G j)
      | fconj (FTerm G) (FTerm G)
      | funit
      | finj-eq {j j' : J} (h : Hom j j') (x : G j) (i : I) \elim i {
        | left => finj (G.Func h x)
        | right => finj x
      }
      | fconj-eq {j : J} (x y : G j) (i : I) \elim i {
        | left => finj (conj x y)
        | right => fconj (finj x) (finj y)
      }
      | funit-eq {j : J} (i : I) \elim i {
        | left => finj (unit {G j})
        | right => funit
      }

    \instance colimit-obj {J : Precat} (G : Functor J FrameUPresCat) : FrameUPres
      | E => FTerm G
      | conj => fconj
      | BasicCover {K} x f => (\Sigma (j : J) (y : G j) (g : K -> G j) (BasicCover y g) (x = finj y) (\Pi (k : K) -> f k = finj (g k))) || ((K,f) = {\Sigma (K : \Set) (K -> FTerm G)} (\Sigma, \lam _ => funit))
      | unit => funit
      | isUnit => byRight idp

    \func fpair {L M : Locale} (a : L) (b : M) : FTerm (Comp FrameUnitalReflectiveSubcat (Functor.op {Product.functor {Fin 2} {LocaleCat} ((L :: M :: nil) DArray.!!)}))
      => fconj (mkcon finj {0 : Fin 2} a) (mkcon finj {1 : Fin 2} b)

    \open Cover

    \lemma term-product {L M : Locale} (x : FTerm (Comp FrameUnitalReflectiveSubcat (Functor.op {Product.functor {Fin 2} {LocaleCat} ((L :: M :: nil) DArray.!!)})))
      : ∃ (a : L) (b : M) (Cover1 x (fpair a b)) (Cover1 (fpair a b) x) \elim x
      | finj {0} a => inP (a, top, cover-prod (cover-inj () idp) (transportInv (Cover1 _) funit-eq (cover-basic (byRight idp))), cover-proj1 idp () idp)
      | finj {1} b => inP (top, b, cover-prod (transportInv (Cover1 _) funit-eq (cover-basic (byRight idp))) (cover-inj () idp), cover-proj2 idp () idp)
      | fconj t1 t2 => \case term-product t1, term-product t2 \with {
        | inP (a1,b1,p1,q1), inP (a2,b2,p2,q2) => inP (a1 ∧ a2, b1 ∧ b2,
            cover-prod (transportInv (Cover1 _) (path (fconj-eq a1 a2)) (cover-prod (cover-trans1 (cover-proj1 idp () idp) (cover-trans1 p1 (cover-proj1 idp () idp))) (cover-trans1 (cover-proj2 idp () idp) (cover-trans1 p2 (cover-proj1 idp () idp)))))
                       (transportInv (Cover1 _) (path (fconj-eq b1 b2)) (cover-prod (cover-trans1 (cover-proj1 idp () idp) (cover-trans1 p1 (cover-proj2 idp () idp))) (cover-trans1 (cover-proj2 idp () idp) (cover-trans1 p2 (cover-proj2 idp () idp))))),
            cover-prod (cover-trans1 (cover-prod (cover-trans1 (cover-proj1 idp () idp) (transportInv (Cover1 __ _) (path (fconj-eq a1 a2)) (cover-proj1 idp () idp))) (cover-trans1 (cover-proj2 idp () idp) (transportInv (Cover1 __ _) (path (fconj-eq b1 b2)) (cover-proj1 idp () idp)))) q1)
                       (cover-trans1 (cover-prod (cover-trans1 (cover-proj1 idp () idp) (transportInv (Cover1 __ _) (path (fconj-eq a1 a2)) (cover-proj2 idp () idp))) (cover-trans1 (cover-proj2 idp () idp) (transportInv (Cover1 __ _) (path (fconj-eq b1 b2)) (cover-proj2 idp () idp)))) q2))
      }
      | funit => inP (top, top, cover-prod (transportInv (Cover1 funit) funit-eq (cover-inj () idp)) (transportInv (Cover1 funit) funit-eq (cover-inj () idp)), cover-basic (byRight idp))

    \func colimitMap {J : Precat} (G : Functor J FrameUPresCat) (j : J) : FrameUPresHom (G j) (colimit-obj G) \cowith
      | func => finj
      | func-conj => path (fconj-eq _ _)
      | func-cover b => byLeft (_, _, _, b, idp, \lam k => idp)
      | func-unit => path funit-eq

    \func colimit-func {J : Precat} (G : Functor J FrameUPresCat) {Z : FrameUPres} (c : Cone G.op Z) (t : FTerm G) : Z \elim t
      | finj x => c.coneMap _ x
      | fconj t1 t2 => conj (colimit-func G c t1) (colimit-func G c t2)
      | funit => unit
      | finj-eq h x i => (c.coneCoh h @ i) x
      | fconj-eq {j} x y i => func-conj {c.coneMap j} {x} {y} @ i
      | funit-eq {j} i => func-unit {c.coneMap j} @ i

    \func colimit-univ {J : Precat} (G : Functor J FrameUPresCat) {Z : FrameUPres} (c : Cone G.op Z) : FrameUPresHom (colimit-obj G) Z \cowith
      | func => colimit-func G c
      | func-conj => idp
      | func-cover => \case \elim __ \with {
        | byLeft (j,y,g,b,p,q) => rewrite p $ coe (\lam i => BasicCover _ (\lam k => colimit-func G c (inv (q k) @ i))) (func-cover {c.coneMap j} b) right
        | byRight p => transportInv (\lam q => BasicCover _ (\lam k => colimit-func G c (q.2 k))) p isUnit
      }
      | func-unit => idp

    \func colimit-cone {J : Precat} (G : Functor J FrameUPresCat) : Cone G.op \cowith
      | apex => colimit-obj G
      | coneMap => colimitMap G
      | coneCoh h => exts (\lam x => path (finj-eq h x))

    \lemma colimit-univ-eq {J : Precat} (G : Functor J FrameUPresCat) {Z : FrameUPres} (h : FrameUPresHom (colimit-obj G) Z) (t : FTerm G) : h t = colimit-univ G (conePullback {_} {_} {G.op} (colimit-cone G) Z h) t \elim t
      | finj e => idp
      | fconj t1 t2 => func-conj *> pmap2 conj (colimit-univ-eq G h t1) (colimit-univ-eq G h t2)
      | funit => func-unit
  }

\func FrameUnitalSubcat : FullyFaithfulFunctor FrameCat FrameUPresCat \cowith
  | F (L : Locale) : FrameUPres \cowith {
    | E => L
    | conj => meet
    | BasicCover x f => x <= Join f
    | unit => top
    | isUnit => top-univ <=∘ Join-cond ()
  }
  | Func {X Y : Locale} (h : FrameHom X Y) : FrameUPresHom (F X) (F Y) \cowith {
    | func => h
    | func-conj => func-meet
    | func-cover c => transport (_ <=) func-Join (FrameHom.func-<= c)
    | func-unit => func-top
  }
  | Func-id => idp
  | Func-o => idp
  | isFullyFaithful => \new QEquiv {
    | ret h => \new FrameHom {
      | func => h
      | func-top => func-unit
      | func-meet => func-conj
      | func-Join>= => func-cover {h} <=-refl
    }
    | ret_f h => idp
    | f_sec h => idp
  }
  \where {
    \lemma Func-inverse {L M : Locale} (f : FrameUPresHom (F L) (F M)) (x : L) : FrameUnitalSubcat.inverse f x = f x
      => path (\lam i => FrameUnitalSubcat.inverse-right i x)
  }

\func FrameReflectiveSubcat : ReflectiveSubPrecat FrameCat FramePresCat \cowith
  | F => F
  | Func => Func
  | Func-id => idp
  | Func-o => idp
  | isFullyFaithful {X} {Y} => \new QEquiv {
    | ret h => \new FrameHom {
      | func => h
      | func-top>= => locale_cover (func-image {h}) <=∘ Join-univ (\lam x => rewrite (inv (pmap (func {h}) (meet_<= top-univ)) *> func-conj) meet-right)
      | func-meet => func-conj
      | func-Join>= => func-cover {h} <=-refl
    }
    | ret_f h => idp
    | f_sec h => idp
  }
  | reflector => PresentedFrame
  | reflectorMap (X : FramePres) : FramePresHom X (F (PresentedFrame X)) \cowith {
    | func => PresentedFrame.embed
    | func-conj {x} {y} => <=-antisymmetric
        (cover-trans __ (\lam _ => cover-inj (x, y, cover-inj () idp, cover-inj () idp) idp))
        (cover-trans __ (\lam t => Cover.cover-conj t.3 t.4 (\lam {_} {_} => inP ((),idp))))
    | func-cover {_} {_} {f} b c => cover-trans c (\lam _ => cover-trans (cover-basic b) (\lam j => cover-inj (j, f j, cover-inj () idp) idp))
    | func-image => cover-basic (\lam {x} _ => cover-inj (x, x, cover-inj () idp) idp)
  }
  | isReflective {X : FramePres} {Y : Locale} => \new QEquiv {
    | ret => adjointMap
    | ret_f f => exts (\lam U =>
        \let | g (q : \Sigma (x : X) (U.1 x)) => reflectorMap X q.1
             | t : U = Join g => exts (\lam x => ext (\lam u => cover-inj ((x, u), x, cover-inj () idp) idp, closure<= (\lam t => cover-trans t.3 (\lam _ => cover-inj t.1 idp))))
        \in rewrite t $ func-Join {_} {_} {g} *> inv (pmap Join (ext (\lam j => pmap f PresentedFrame.element_join *> func-Join))) *> inv (func-Join {f} {_} {g}))
    | f_sec f => exts (\lam x => <=-antisymmetric
        (Join-univ (\lam j => locale_cover (Cover.map j.2) <=∘ Join-univ (\lam _ => <=-refl)))
        (Join-cond (later (x, cover-inj () idp))))
  }
  \where {
    \open PresentedFrame \hiding (<=)
    \open FrameUnitalSubcat

    \lemma locale_cover {L : Locale} {x : L} {J : \Set} {g : J -> L} (c : Cover {F L} x g) : x <= L.Join g \elim c
      | cover-basic b => b
      | cover-inj j p => rewriteI p (Join-cond j)
      | cover-trans c f => locale_cover c <=∘ Join-univ (\lam i => locale_cover (f i))
      | cover-proj1 p j q => rewrite p (meet-left <=∘ rewriteI q (Join-cond j))
      | cover-idemp j p => transport (`<= _) (p *> meet-idemp) (Join-cond j)
      | cover-comm p j q => transport (`<= _) (q *> meet-comm *> inv p) (Join-cond j)
      | cover-ldistr p c f => rewrite p (meet-monotone <=-refl (locale_cover c) <=∘ Join-ldistr>= <=∘ Join-univ (\lam j => transport (`<= _) (f j) (Join-cond j)))

    \func adjointMap {X : FramePres} {Y : Locale} (f : FramePresHom X (F Y)) : FrameHom (PresentedFrame X) Y \cowith
      | func U => Y.Join {\Sigma (x : X) (U.1 x)} (\lam j => f j.1)
      | func-top>= => locale_cover f.func-image <=∘ Join-univ (\lam x => Join-cond (x, ()))
      | func-meet {U} {V} => <=-antisymmetric
          (Join-univ (later (\lam p => locale_cover (Cover.map p.2) <=∘ Join-univ (\lam t => rewrite f.func-conj (Join-cond (later ((t.1,t.3),(t.2,t.4))))))))
          (Join-univ (\lam p => transport (`<= _) f.func-conj (Y.Join-cond (later (conj p.1.1 p.2.1, cover-inj (later (p.1.1, p.2.1, p.1.2, p.2.2)) idp))))) *> inv Locale.Join-distr
      | func-Join>= => Join-univ (\lam p => locale_cover (Cover.map p.2) <=∘ Join-univ (\lam t => Join-cond (later (t.2,t.3)) <=∘ Join-cond t.1))
  }

\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUPresCat \cowith
  | FullyFaithfulFunctor => FrameUnitalSubcat
  | reflector X => FrameReflectiveSubcat.reflector X
  | reflectorMap X => \new FrameUPresHom {
    | FramePresHom => FrameReflectiveSubcat.reflectorMap X
    | func-unit => exts (\lam e => ext (\lam _ => (), \lam _ => cover-basic isUnit))
  }
  | isReflective {X} {Y} => \new QEquiv {
    | ret h => FrameReflectiveSubcat.isReflective.ret h
    | ret_f h => FrameReflectiveSubcat.isReflective.ret_f h
    | f_sec h => ext (path (\lam i => func {FrameReflectiveSubcat.isReflective.f_ret h @ i}))
  }

\func FrameBicat : BicompleteCat \cowith
  | Cat => FrameCat
  | limit G => \new Limit {
    | apex => limit-obj G
    | coneMap j => \new FrameHom {
      | func P => P.1 j
      | func-top => idp
      | func-meet => idp
      | func-Join => idp
    }
    | coneCoh h => exts (\lam P => P.2 h)
    | isLimit Z => \new QEquiv {
      | ret (c : Cone) => \new FrameHom {
        | func z => (\lam j => c.coneMap j z, \lam h => path (\lam i => func {c.coneCoh h @ i} z))
        | func-top => exts (\lam j => func-top)
        | func-meet => exts (\lam j => func-meet)
        | func-Join => exts (\lam j => func-Join)
      }
      | ret_f f => exts (\lam z => exts (\lam j => idp))
      | f_sec c => idp
    }
  }
  | pullback {X} {Y} {Z} f g => \new Pullback {
    | apex => pullback-obj f g
    | cone => (proj1, proj2, exts __.3)
    | pbMap c => \new FrameHom {
      | func x => (c.1 x, c.2 x, path (\lam i => c.3 i x))
      | func-top => ext (func-top, func-top)
      | func-meet => ext (func-meet, func-meet)
      | func-Join => ext (func-Join, func-Join)
    }
    | pbBeta1 => idp
    | pbBeta2 => idp
    | pbEta p q => exts (\lam x => ext (path (\lam i => p i x), path (\lam i => q i x)))
  }
  | colimit G => reflectiveSubPrecatColimit FrameUnitalReflectiveSubcat G (FrameUPresCocompleteCat.colimit (Comp FrameUnitalReflectiveSubcat G))
  \where {
    \func limit-obj {J : Precat} (G : Functor J FrameCat) : Locale \cowith
      | E => \Sigma (P : \Pi (j : J) -> G j) (\Pi {j j' : J} (h : Hom j j') -> G.Func h (P j) = P j')
      | <= (P,_) (Q,_) => \Pi (j : J) -> P j <= Q j
      | <=-refl j => <=-refl
      | <=-transitive p q j => <=-transitive (p j) (q j)
      | <=-antisymmetric p q => exts (\lam j => <=-antisymmetric (p j) (q j))
      | meet (P,Pc) (Q,Qc) => (\lam j => P j ∧ Q j, \lam h => func-meet *> pmap2 (∧) (Pc h) (Qc h))
      | meet-left j => meet-left
      | meet-right j => meet-right
      | meet-univ p q j => meet-univ (p j) (q j)
      | top => (\lam j => top, \lam h => func-top)
      | top-univ j => top-univ
      | Join F => (\lam j => Join (\lam k => (F k).1 j), \lam {j} {j'} h => func-Join *> path (\lam i => Join (\lam k => (F k).2 h @ i)))
      | Join-cond k j => Join-cond k
      | Join-univ p j => Join-univ (\lam k => p k j)
      | Join-ldistr>= j => Join-ldistr>=

    \func pullback-obj {L M K : Locale} (f : FrameHom L K) (g : FrameHom M K) : Locale \cowith
      | E => \Sigma (x : L) (y : M) (f x = g y)
      | <= P Q => \Sigma (P.1 <= Q.1) (P.2 <= Q.2)
      | <=-refl => (<=-refl, <=-refl)
      | <=-transitive p q => (p.1 <=∘ q.1, p.2 <=∘ q.2)
      | <=-antisymmetric p q => ext (<=-antisymmetric p.1 q.1, <=-antisymmetric p.2 q.2)
      | meet P Q => (P.1 ∧ Q.1, P.2 ∧ Q.2, func-meet *> pmap2 (∧) P.3 Q.3 *> inv func-meet)
      | meet-left => (meet-left, meet-left)
      | meet-right => (meet-right, meet-right)
      | meet-univ p q => (meet-univ p.1 q.1, meet-univ p.2 q.2)
      | top => (top, top, func-top *> inv func-top)
      | top-univ => (top-univ, top-univ)
      | Join F => (Join (\lam j => (F j).1), Join (\lam j => (F j).2), func-Join *> pmap Join (ext (\lam j => (F j).3)) *> inv func-Join)
      | Join-cond j {f} => (Join-cond j, Join-cond j)
      | Join-univ p => (Join-univ (\lam j => (p j).1), Join-univ (\lam j => (p j).2))
      | Join-ldistr>= => (Join-ldistr>=, Join-ldistr>=)

    \func proj1 {L M K : Locale} {f : FrameHom L K} {g : FrameHom M K} : FrameHom (pullback-obj f g) L \cowith
      | func P => P.1
      | func-top => idp
      | func-meet => idp
      | func-Join>= => <=-refl

    \func proj2 {L M K : Locale} {f : FrameHom L K} {g : FrameHom M K} : FrameHom (pullback-obj f g) M \cowith
      | func P => P.2
      | func-top => idp
      | func-meet => idp
      | func-Join>= => <=-refl

    \lemma coneMap_finj {J : Precat} {G : Functor J FrameCat} (j : J) (x : G j)
      : coneMap {FrameBicat.colimit G} j x = embed (FrameUPresCocompleteCat.finj {J} {Comp FrameUnitalReflectiveSubcat G} x)
      => FrameUnitalSubcat.Func-inverse _ x
  }

\func discrete (X : \Set) : Locale (X -> \Prop) \cowith
  | <= U V => \Pi {x : X} -> U x -> V x
  | <=-refl u => u
  | <=-transitive p q u => q (p u)
  | <=-antisymmetric p q => ext (\lam e => ext (p,q))
  | meet U V x => \Sigma (U x) (V x)
  | meet-left => __.1
  | meet-right => __.2
  | meet-univ p q e => (p e, q e)
  | top _ => \Sigma
  | top-univ _ => ()
  | Join {J} F x => ∃ (j : J) (F j x)
  | Join-cond j u => inP (j,u)
  | Join-univ c => \case __ \with {
    | inP (j,u) => c j u
  }
  | Join-ldistr>= => \case __ \with {
    | (u, inP (j,v)) => inP (j,(u,v))
  }
  \where {
    \func functor : Functor SetCat LocaleCat \cowith
      | F => discrete
      | Func {X} {Y} f => \new FrameHom {
        | func U x => U (f x)
        | func-top>= _ => ()
        | func-meet => idp
        | func-Join => idp
      }
      | Func-id => idp
      | Func-o => idp
  }

\instance LocaleCat : BicompleteCat \cowith
  | Cat => Cat.op {FrameBicat}
  | limit (G : Functor) => FrameBicat.colimit G.op
  | colimit (G : Functor) => FrameBicat.limit G.op
  | terminal {
    | apex => discrete (\Sigma)
    | proj => \case __
    | tupleMap _ => \new FrameHom {
      | func P => pHat (P ())
      | func-<= x<=y => Join-univ (\lam xu => Join-cond (x<=y xu))
      | func-top>= => Join-cond ()
      | func-meet>= => rewrite Join-distr $ Join-univ (\lam p => meet-left <=∘ Join-cond p)
      | func-Join>= => Join-univ (\lam (inP (j,x)) => Join-cond x <=∘ Join-cond j)
    }
    | tupleBeta _ => \case __
    | tupleEq _ => exts (\lam P =>
        \have t : P = pHat {discrete (\Sigma)} (P ()) => ext (\lam _ => ext (\lam x => inP (x,()), \lam (inP (x,_)) => x))
        \in rewrite t $ func-Join *> path (\lam i => Join (\lam _ => (func-top *> inv func-top) i)) *> inv func-Join)
  }

\lemma regular_surj {L M : Locale} {f : Hom L M} (reg : isRegularMono {LocaleCat} f) : isSurj f \elim reg
  | inP (E : Equalizer) => \lam y =>
    \let | E' : Equalizer => LocaleCat.equalizer E.f E.g
         | s => PresentedFrame.surj-map E'.eql regular_surj-lemma
         | i : Iso => Equalizer.unique E E'
         | x => (s (i.inv y)).1
    \in inP (x, inv (path (\lam j => Equalizer.unique-map E E' j x)) *> pmap i.f (s (i.inv y)).2 *> path (\lam j => i.inv_f j y))
  \where {
    \open FrameUPresCocompleteCat

    \func regular_surj-lemma {L M : Locale} {f g : LocaleCat.Hom L M} (y : FTerm (Comp FrameUnitalReflectiveSubcat (Functor.op {Equalizer.functor {LocaleCat} f g})))
      : ∃ (x : L) (Equalizer.eql {LocaleCat.equalizer f g} x = embed y) \elim y
      | finj {j} x => \case \elim j, \elim x \with {
        | false, x => inP (x, FrameBicat.coneMap_finj false x)
        | true, x => inP (f x, FrameBicat.coneMap_finj false (f x) *> pmap embed (path (finj-eq {Equalizer.Shape.op} Equalizer.arrow1 x)))
      }
      | fconj t1 t2 => \case regular_surj-lemma t1, regular_surj-lemma t2 \with {
        | inP (x1,p1), inP (x2,p2) => inP (x1 ∧ x2, func-meet *> pmap2 (∧) p1 p2 *> unfold (unfold $ unfold embed $ unfold closure (exts (\lam e => ext (cover-trans __ (\lam i => Cover.cover-conj1 i.3 i.4), cover-trans __ (\lam _ => cover-inj (t1, t2, cover-inj () idp, cover-inj () idp) idp))))))
      }
      | funit => inP (top, func-top *> exts (\lam e => ext (\lam _ => cover-basic (byRight idp), \lam _ => ())))
  }

\lemma surj_regular {L M : Locale} {f : FrameHom M L} (sur : isSurj f) : isRegularMono {LocaleCat} f
  => \let | pb : Pullback => FrameBicat.pullback f f
          | cone => pb.cone
     \in inP (\new Equalizer {LocaleCat} {M} {pb} cone.1 cone.2 L f cone.3 {
       | isEqualizer Z => \new ESEquiv {
         | isSurj (h,p) =>
           \have lem (x : M) => path (\lam i => p i (f.direct (f x), x, FrameHom.surjective-split sur (f x)))
           \in inP (\new FrameHom {
             | func x => h (f.direct x)
             | func-top => pmap h f.direct-top *> func-top
             | func-meet => pmap h f.direct-meet *> func-meet
             | func-Join {J} {g} => inv (pmap (\lam z => h (f.direct z)) func-Join *> path (\lam i => h (f.direct (Join (\lam j => FrameHom.surjective-split sur (g j) i))))) *> lem _ *> func-Join
           }, ext (exts lem))
         | Embedding => Embedding.fromInjection (\lam {h} {h'} p => exts (\lam y => \case sur y \with {
           | inP (x,q) => inv (pmap h q) *> pmap (\lam z => z.1 x) p *> pmap h' q
         }))
       }
     })

\func surj_equiv {f : FrameHom} (sur : isSurj f) : Iso {FrameCat} {f.image.locale} {f.Cod}
  => FrameCat.equiv_iso {\new FrameHom f.image.locale f.Cod {
    | func x => f x.1
    | func-top => func-top
    | func-meet => func-meet
    | func-Join>= => f.direct-counit <=∘ func-Join>=
  }} (\new QEquiv {
    | ret x => (f.direct x, f.direct-<= $ =_<= $ f.surjective-split sur x)
    | ret_f x => ext (<=-antisymmetric x.2 f.direct-unit)
    | f_sec x => f.surjective-split sur x
  })
  \where {
    \lemma map-comm {f : FrameHom} (sur : isSurj f) (x : f.Dom) : Iso.f {surj_equiv sur} (f.image.map x) = f x
      => f.surjective-split sur (f x)
  }

\type isHausdorff (L : Locale) => generalized L (LocaleCat.Bprod L L) LocaleCat.proj1 LocaleCat.proj2
  \where {
    \open CartesianPrecat
    \open FrameUPresCocompleteCat
    \open Cover
    \open FrameReflectiveSubcat(locale_cover)
    \open FrameBicat(coneMap_finj)

    \func generalized (L M : Locale) (p1 p2 : Hom M L) => \Pi (a b : L) (y : M)
      -> a ∧ b <= SJoin (\lam x => p1 x ∧ p2 x <= y)
      -> p1 a ∧ p2 b <= extend p1 p2 y

    \func extend {L M : Locale} (p1 p2 : Hom M L) (y : M)
      => SJoin (\lam x => x <= y || (\Sigma (a b : L) (a ∧ b <= bottom) (x = p1 a ∧ p2 b)))

    \lemma diagonal_func {L : Locale} (U : LocaleCat.Bprod L L) : diagonal L U = SJoin (\lam x => U.1 (fpair x x))
      => <=-antisymmetric (Join-univ (\lam j => \case term-product j.1 \with {
        | inP (a,b,p,q) => locale_cover (map {colimit-univ (Comp FrameUnitalReflectiveSubcat (Functor.op {Product.functor (L :: L :: nil)})) (Cone.map FrameUnitalReflectiveSubcat.op (Product.fromLimit.cone {_} {_} {_} {Product.functor (L :: L :: nil)} (\case \elim __ \with { | 0 => id L | 1 => id L })))} p) <=∘
            Join-univ (\lam _ => Join-cond $ later (a ∧ b, U.2 _ $ cover-trans1 (cover-conj1 (transportInv (Cover1 __ _) (path (fconj-eq a b)) (cover-proj1 idp () idp)) (transportInv (Cover1 __ _) (path (fconj-eq a b)) (cover-proj2 idp () idp))) $ cover-trans1 q $ cover-inj j idp))
      })) (Join-univ (\lam j => meet-univ <=-refl <=-refl <=∘ Join-cond (later (_, j.2))))

    \lemma diagonal_direct {L : Locale} (a : L) : FrameHom.direct {diagonal L} a = PresentedFrame.closure (\lam (j : \Sigma (b c : L) (b ∧ c <= a)) => fpair j.1 j.2)
      => <=-antisymmetric (Join-univ (\lam (U,Up) {t} Ut => \case term-product t \with {
        | inP (x,y,p,q) => cover-trans1 p (cover-inj (x, y, Join-cond (later (_, U.2 _ $ unfold fpair $ repeat {2} (rewrite (path (fconj-eq x y))) $ cover-trans1 (cover-conj1 (cover-proj1 idp () idp) (cover-proj2 idp () idp)) $ cover-trans1 q $ cover-inj (t,Ut) idp)) <=∘ =_<= (inv (diagonal_func U)) <=∘ Up) idp)
      })) (closure<= (\lam j => cover-inj (_, unfold FrameHom.direct $ cover-inj (
            \let U => closure (\lam _ => fpair j.1 j.2)
            \in (U, =_<= (diagonal_func U) <=∘ Join-univ (\lam k =>
                \have m => colimit-univ _ (Product.fromLimit.cone (later (\case \elim __ \with { | 0 => id _ | 1 => id _ })))
                \in (meet-univ <=-refl <=-refl <=∘ locale_cover (map {m} k.2) <=∘ Join-univ (\lam _ => <=-refl)) <=∘ j.3)), _, cover-inj () idp) idp) idp))

    \lemma diagonal-isClosed {L : Locale} (h : isHausdorff L) : Nucleus.isClosed {FrameHom.image {diagonal L}}
      => \lam {U} => rewrite (diagonal_direct, diagonal_direct, diagonal_func, FrameHom.func-bottom {diagonal L}) $ closure<= $ later (\lam j =>
          \have t => h j.1 j.2 U (j.3 <=∘ Join-univ (\lam k => Join-cond $ later (_, \lam {x} c => U.2 x (cover-trans c (\lam (a,b,a<=k,b<=k) => run {
                       rewrite coneMap_finj at a<=k,
                       rewrite coneMap_finj at b<=k,
                       cover-trans1 (cover-conj1 a<=k b<=k),
                       cover-inj (_, k.2) idp
                     }))))) (cover-inj (_, _, rewrite coneMap_finj $ cover-inj () idp, rewrite coneMap_finj $ cover-inj () idp) idp)
          \in cover-trans t (\lam l => cover-inj (l.2, \case l.1.2 \with {
            | byLeft v => cover-inj (false, l.2, v l.3) idp
            | byRight v => cover-inj (true, l.2, cover-trans (transport (__.1 l.2) v.4 l.3) (\lam (a,b,a<=v1,b<=v2) => cover-trans1 (cover-conj1 (rewrite coneMap_finj at a<=v1 $ a<=v1) (rewrite coneMap_finj at b<=v2 $ b<=v2)) (cover-inj (v.1,v.2,v.3) idp))) idp
          }) idp))
  }

\lemma regular_Hausdorff {L : Locale} (reg : L.isRegular) : isHausdorff L
  => generalized reg (LocaleCat.Bprod L L) LocaleCat.proj1 LocaleCat.proj2
  \where {
    \open isHausdorff(extend)
    \open FrameHom

    \lemma generalized {L : Locale} (reg : L.isRegular) (M : Locale) (p1 p2 : LocaleCat.Hom M L) : isHausdorff.generalized L M p1 p2
      => \lam a b U p =>
         \have | lem1 {d x y : L} (p : d <=< x) (q : p1 (y ∧ x) ∧ p2 d <= extend p1 p2 U) : p1 y ∧ p2 d <= extend p1 p2 U
                 => meet-monotone (func-<= (meet-univ <=-refl (top-univ <=∘ later p) <=∘ ldistr>=) <=∘ func-Join>=) <=-refl <=∘ Join-rdistr>= <=∘ Join-univ (\case \elim __ \with {
                   | false => q
                   | true => Join-cond (later (p1 (y ∧ neg d) ∧ p2 d, byRight (y ∧ neg d, d, meet-monotone meet-right <=-refl <=∘ eval, idp)))
                 })
               | lem2 {d x y : L} (p : d <=< x) (q : p1 d ∧ p2 (y ∧ x) <= extend p1 p2 U) : p1 d ∧ p2 y <= extend p1 p2 U
                 => meet-monotone <=-refl (func-<= (meet-univ <=-refl (top-univ <=∘ later p) <=∘ ldistr>=) <=∘ func-Join>=) <=∘ Join-ldistr>= <=∘ Join-univ (\case \elim __ \with {
                   | false => q
                   | true => Join-cond (later (p1 d ∧ p2 (y ∧ neg d), byRight (d, y ∧ neg d, meet-monotone <=-refl meet-right <=∘ =_<= meet-comm <=∘ eval, idp)))
                 })
               | tu<=NU {t u : L} (q : p1 u ∧ p2 u <= extend p1 p2 U) : p1 t ∧ p2 u <= extend p1 p2 U
                 => meet-monotone <=-refl (func-<= (reg u) <=∘ func-Join>=) <=∘ Join-ldistr>= <=∘ Join-univ (\lam j => lem1 j.2 (meet-monotone (func-<= meet-right) (func-<= (<=<_<= j.2)) <=∘ q))
               | ss<=NU => meet-monotone <=-refl func-Join>= <=∘ Join-ldistr>= <=∘ Join-univ (\lam j => tu<=NU (Join-cond (later (p1 j.1 ∧ p2 j.1, byLeft j.2))))
         \in meet-monotone (func-<= (reg a) <=∘ func-Join>=) <=-refl <=∘ Join-rdistr>= <=∘ Join-univ (\lam j => lem2 j.2 (meet-monotone <=-refl (func-<= (=_<= meet-comm <=∘ p)) <=∘ tu<=NU ss<=NU))
  }

\func dense_closed_ofs : OFS {LocaleCat} \cowith
  | L f => isDense {f}
  | R (f : FrameHom) => \Sigma f.image.isClosed (isSurj f)
  | factors {L} {M} (h : FrameHom) =>
    \have n : Nucleus => closed (h.direct bottom)
    \in (n.locale,
         \new FrameHom {
           | func x => h.func x.1
           | func-top => func-top
           | func-meet => func-meet
           | func-Join>= => func-join>= <=∘ join-univ (direct-counit <=∘ bottom-univ) func-Join>=
         },
         n.map,
         exts (\lam x => func-join *> <=-antisymmetric (join-univ (direct-counit <=∘ bottom-univ) <=-refl) join-right),
         \lam {x} p => unfold $ direct-unit <=∘ direct-<= p <=∘ join-left,
         (\lam {x} => =_<= (n.map_direct (n.map x)) <=∘ join-univ (join-left <=∘ =_<= (inv (n.map_direct (n.map bottom))) <=∘ join-left) join-right, Nucleus.map.surjective {n}))
  | unique-lift f (g : FrameHom) Lf Rg => OFS.liftFromMono {LocaleCat} f g (regularMono_Mono (surj_regular Rg.2)) (\lam t s p =>
    \have lem x : s (g.direct (g x)) = s x => <=-antisymmetric (func-<= (Rg.1 {x}) <=∘ func-join>= <=∘ join-univ (Lf (=_<= (inv (path (\lam i => p i (g.direct (inv g.func-bottom i)))) *> pmap t (surjective-split Rg.2 bottom) *> func-bottom)) <=∘ bottom-univ) <=-refl) (func-<= direct-unit)
    \in (\new FrameHom {
       | func x => s (g.direct x)
       | func-top => pmap s g.direct-top *> func-top
       | func-meet => pmap s g.direct-meet *> func-meet
       | func-Join {J} {F} => inv (pmap (\lam x => s (g.direct x)) func-Join *> path (\lam i => s (g.direct (Join (\lam j => g.surjective-split Rg.2 (F j) i))))) *> lem _ *> func-Join
     }, exts lem))
  \where \open FrameHom

\func sdense_wclosed_ofs : OFS {LocaleCat} \cowith
  | L f => isStronglyDense {f}
  | R f => isWeaklyClosed {f}
  | factors {L} {M} (h : FrameHom) =>
    \have | left+right=h x : factor h (h.wclosed-image.map x) = h x => unfold $ <=-antisymmetric (func-<= (Meet-cond $ later (h.image, \lam {P} {y} hy<=P => direct-unit <=∘ direct-<= (hy<=P <=∘ func-pHat<=))) <=∘ direct-counit) (func-<= h.wclosed-image.nucleus-unit)
          | left-sdense : isStronglyDense {factor h} => \lam c => Meet-univ (\lam j => j.2 c)
    \in (h.wclosed-image.locale, factor h, h.wclosed-image.map, exts left+right=h, left-sdense,
        (Nucleus.map.surjective, \lam j p {x} => Join-univ (\lam k => nucleus-unit {h.wclosed-image} <=∘ k.2 <=∘
          Meet-cond (later (j, \lam {P} {y} t => p $ left-sdense {P} {h.wclosed-image.map y} $ rewrite left+right=h t)))))
  | unique-lift f (g : FrameHom) Lf Rg => OFS.liftFromMono {LocaleCat} f g (regularMono_Mono (surj_regular Rg.1)) (\lam t (s : FrameHom) gt=sf =>
      \have g<=s : g.image <= s.image => Rg.2 s.image (\lam {P} {x} gx<=P => direct-unit <=∘ direct-<= (Lf (rewriteI (path (gt=sf __ x)) $ func-<= gx<=P <=∘ func-pHat>=) <=∘ func-pHat<=))
      \in (Iso.inv {surj_equiv Rg.1} ∘ NucleusPoset.<=-map g.image s.image g<=s ∘ s.factor, exts (\lam x => func_direct_func *> <=-antisymmetric (func-<= g<=s <=∘ direct-counit) (func-<= direct-unit))))
  \where {
    \open FrameHom

    \func factor (h : FrameHom) : FrameHom h.wclosed-image.locale h.Cod \cowith
      | func x => func x.1
      | func-top => func-top
      | func-meet => func-meet
      | func-Join>= => func-<= (Meet-cond $ later (image, \lam hx<=P => direct-unit <=∘ direct-<= (hx<=P <=∘ func-pHat<=))) <=∘ direct-counit <=∘ func-Join>=
  }

\lemma overt-fromPres {P : FramePres} (o : P.isOvert) : isOvert {PresentedFrame P}
  => \lam U {x} Ux => cover-trans (o x) (\lam i => cover-inj (\lam Q p => TruncP.remove' $ TruncP.map (i _ (p Ux)) __.1, x, ()) idp)

\lemma sdense_positive {f : FrameHom} (d : f.isStronglyDense) {x : f.Dom} (p : isPositive x)
  => \lam P fx<=P => p P (d fx<=P)

\lemma func_positive {f : FrameHom} {x : f.Dom} (p : isPositive (f x)) : isPositive x
  => \lam P x<=P => p P (func-<= x<=P <=∘ func-Join>= <=∘ Join-univ (\lam q => top-univ <=∘ Join-cond q))

\lemma sdense_overt {f : FrameHom} (d : f.isStronglyDense) (o : isOvert {f.Cod}) : isOvert {f.Dom}
  => \lam a => d $ o _ <=∘ Join-univ (\lam h => Join-cond $ func_positive h)

\lemma sdense-fromPres {P : FramePres} {L : Locale} {f : FramePresHom P (FrameUnitalSubcat.F L)}
  (s : \Pi {Q : \Prop} {x : P} -> f x <= Join (\lam (_ : Q) => f x) -> Cover x (\lam (_ : Q) => x))
  : FrameHom.isStronglyDense {FrameReflectiveSubcat.isReflective.ret f}
  => \lam p {x} Ux => cover-trans (s (meet-univ <=-refl (Join-cond (later (x,Ux)) <=∘ p) <=∘ Join-ldistr>= <=∘ Join-univ (\lam q => meet-left <=∘ Join-cond q))) (\lam q => cover-inj (q,x,()) idp)

\lemma <<-fromPres {P : FramePres} {x y : P} (x<<y : x FramePres.<< y) : embed x << {PresentedFrame P} embed y
  => \lam {J} {g} y<=Jg => \case x<<y (y<=Jg (cover-inj () idp)) \with {
       | inP (l,x<=l) => inP (map __.1 l, \lam c => cover-trans c (\lam _ => cover-trans x<=l (\lam i => cover-inj (i, (l i).2, (l i).3) idp)))
     }

\lemma <<_<= {L : Locale} {x y : L} (x<<y : x << y) : x <= y
  => \case x<<y {\Sigma} {\lam _ => y} (Join-cond ()) \with {
       | inP (_,x<=Jy) => x<=Jy <=∘ Join-univ (\lam _ => <=-refl)
     }

\lemma <<-left {L : Locale} {x y z : L} (x<<y : x << y) (y<=z : y <= z) : x << z
  => \lam {J} {g} z<=Jg => TruncP.map (x<<y (y<=z <=∘ z<=Jg)) (\lam t => t)

\lemma <<-right {L : Locale} {x y z : L} (x<=y : x <= y) (y<<z : y << z) : x << z
  => \lam {J} {g} z<=Jg => TruncP.map (y<<z z<=Jg) (\lam t => (t.1, x<=y <=∘ t.2))

\lemma locallyCompact-fromPres {P : FramePres} (lc : P.isLocallyCompact) : isLocallyCompact {PresentedFrame P}
  => \lam U {x} u => cover-trans (lc x) (\lam t => cover-inj ((embed t.1, <<-left (<<-fromPres t.2) (embed<= (cover-inj (x,u) idp))), t.1, cover-inj () idp) idp)

\lemma <=<_<= {L : Locale} {x y : L} (x<=<y : x <=< y) : x <= y
  => meet-univ (top-univ <=∘ x<=<y) <=-refl <=∘ L.rdistr>= <=∘ join-univ (L.eval <=∘ bottom-univ) meet-left

\lemma <=<-left {L : Locale} {x y z : L} (x<=<y : x <=< y) (y<=z : y <= z) : x <=< z
  => unfold (<=<) $ x<=<y <=∘ join-univ join-left (y<=z <=∘ join-right)

\lemma <=<-right {L : Locale} {x y z : L} (x<=y : x <= y) (y<=<z : y <=< z) : x <=< z
  => unfold (<=<) $ y<=<z <=∘ join-univ (neg-inverse x<=y <=∘ join-left) join-right

\lemma regular-fromPres {P : FramePres} (reg : \Pi (x : P) -> FramePres.SCover x (embed __ <=< embed x)) : isRegular {PresentedFrame P}
  => \lam U {x} u => cover-trans (reg x) (\lam t => cover-inj ((embed t.1, <=<-left t.2 (embed<= (cover-inj (x,u) idp))), t.1, cover-inj () idp) idp)

-- | If {R} is a relation that satisfies conditions {basic}, {leq}, {dense}, and {comm}, then `R x y` implies `x << y`
\lemma wayBelowPredicate {P : FramePres} (R : P -> P -> \Prop) {x y : P} (Rxy : R x y) {J : \Set} {g : J -> P} (c : Cover y g)
                         (basic : \Pi {x y : P} -> R x y -> \Pi {J : \Set} {g : J -> P} -> BasicCover y g -> ∃ (l : Array J) (Cover x (\lam i => g (l i))))
                         (leq : \Pi {x y : P} -> R x y -> Cover1 x y)
                         (dense : \Pi {x z : P} -> R x z -> ∃ (y : P) (R x y) (R y z))
                         (comm : \Pi {x y : P} -> R x y -> \Pi (z : P) (l : Array P) -> Cover y (z :: l) -> ∃ (l' : Array P) (\Pi (j : Fin l'.len) -> R (l' j) z) (Cover x (l' ++ l)))
  : ∃ (l : Array J) (Cover x (\lam i => g (l i))) \elim c
  | cover-basic b => basic Rxy b
  | cover-inj j p => inP (j :: nil, cover-trans (leq Rxy) (\lam _ => cover-inj 0 p))
  | cover-trans {_} {f} c h =>
    \let | (inP (z,Rxz,Rzy)) => dense Rxy
         | (inP (l,z<=l)) => wayBelowPredicate R Rzy c basic leq dense comm
         | (inP (g',x<=g',Q,_)) => comm-lem R leq dense comm (DArray.len {l}) Rxz <=-refl z<=l
         | (inP S) => choice {finSum (finFin (DArray.len {l})) (\lam i => finFin (DArray.len {g' i}))} _ (\lam t => wayBelowPredicate R (Q t.1 (fin_< t.1) t.2) (h (l t.1)) basic leq dense comm)
    \in inP (Big (++) nil (\lam i => Big (++) nil (\lam j => (S (i,j)).1)), cover-trans x<=g' (\lam k =>
      \have (i,j,p) => split g' k
      \in rewrite p (cover-trans (S (i,j)).2 (\lam m =>
        \have p => unsplit2 (\lam i => DArray.len {g' i}) (\lam p => (S p).1) i j m
        \in cover-inj p.1 (pmap g p.2)))))
  | cover-proj1 p j q => inP (j :: nil, cover-trans (leq Rxy) (\lam _ => cover-proj1 p 0 q))
  | cover-idemp j p => inP (j :: nil, cover-trans (leq Rxy) (\lam _ => cover-idemp 0 p))
  | cover-comm p j q => inP (j :: nil, cover-trans (leq Rxy) (\lam _ => cover-comm p 0 q))
  | cover-ldistr {a} {b} p {f} c h =>
    \let | (inP (b',Rb'b,x<=b')) => comm Rxy b nil (Cover.cover-proj2 p 0 idp)
         | (inP k) => FinSet.finiteAC (\lam j => wayBelowPredicate R (Rb'b j) c basic leq dense comm)
         | l' => Big (++) nil (\lam i => (k i).1)
    \in inP (l', cover-trans (Cover.cover-prod (cover-trans (leq Rxy) (\lam _ => cover-proj1 p () idp)) (cover-inj () idp))
      (\lam _ => cover-ldistr idp {\lam i => f (l' i)}
        (cover-trans (transport (\lam (l : Array P) => Cover x l.at) ++_nil x<=b') (\lam i => cover-trans (k i).2 (\lam j => \have (m,r) => unsplit (\lam j => (k j).1) i j \in cover-inj m (pmap f r))))
        (\lam j => h (l' j))))
  \where {
    \lemma comm-lem {P : FramePres} (R : P -> P -> \Prop)
                    (leq : \Pi {x y : P} -> R x y -> Cover1 x y)
                    (dense : \Pi {x z : P} -> R x z -> ∃ (y : P) (R x y) (R y z))
                    (comm : \Pi {x y : P} -> R x y -> \Pi (z : P) (l : Array P) -> Cover y (z :: l) -> ∃ (l' : Array P) (\Pi (j : Fin l'.len) -> R (l' j) z) (Cover x (l' ++ l)))
                    (k : Nat) {x y : P} (Rxy : R x y) {n : Nat} {g : Fin n -> P} (k<=n : k <= n) (c : Cover y g)
                    : ∃ (g' : Fin n -> Array P) (Cover x (Big (++) nil g')) (\Pi (j : Fin n) -> (j : Nat) < k -> \Pi (i : Fin (DArray.len {g' j})) -> R (g' j i) (g j)) (\Pi (j : Fin n) -> k <= j -> g' j = g j :: nil) \elim k, n
      | 0, _ => inP (\lam i => g i :: nil, cover-trans (leq Rxy) (\lam _ => cover-trans c (\lam i => transportInv (\lam (l : Array P) => Cover (g i) (\lam j => l j)) (++_singleton g) (cover-inj i idp))), \lam _ => \case __ \with {}, \lam _ _ => idp)
      | _, 0 => inP (\case __ \with {}, cover-trans (leq Rxy) (\lam _ => cover-trans c (\case __)), \case __ \with {}, \case __)
      | suc k, suc n =>
        \let | (inP (z,Rxz,Rzy)) => dense Rxy
             | (inP (g',z<=g',Q,S)) => comm-lem R leq dense comm k Rzy (LinearlyOrderedSemiring.<=_+ (suc<=suc.conv k<=n) (zero<=_ {1})) c
             | l => Big (++) nil (\lam i => g' (sface k i))
             | kmod=k => mod_< (<-transitive-left id<suc k<=n)
             | (inP (l',Rl'gk,x<=l'+g')) => comm Rxz (g k) l (transport (\lam t => Cover z (t ++ l)) (S k (rewrite kmod=k <=-refl)) (cover-trans z<=g' (\lam m =>
                 \have (i,j,p) => split g' m
                 \in Cover.cover-index (rewrite p (transport (\lam (x : Array P) => \Pi (j : Fin x.len) -> Index (x j) (g' k ++ l))
                                                             (pmap g' (QEquiv.f_sec {cyclePerm k} i))
                                                             (\lam j' => unsplit (\lam i => g' (cyclePerm k i)) (QEquiv.ret {cyclePerm k} i) j') j)))))
             | F (j : Fin (suc n)) : Array P => \case decideEq k j \with { | yes _ => l' | no _ => g' j }
        \in inP (F,
              cover-trans x<=l'+g' (\case split_++ __ \with {
                | inl (m,p) =>
                  \have s : F (k Nat.mod suc n) = l' => unfold F (rewrite (decideEq=_reduce (inv kmod=k)) idp)
                  \in transportInv (Cover __ _) p (Cover.cover-index (rewriteF s (unsplit F (k Nat.mod suc n)) m))
                | inr (m,p) =>
                  \have | (i,j,q) => split (\lam i => g' (sface k i)) m
                        | s : F (sface k i) = g' (sface k i) => unfold F (rewrite (decideEq/=_reduce {_} {k} {sface k i} (\lam p => sface-skip k i (fin_nat-inj (inv (kmod=k *> p))))) idp)
                  \in transportInv (Cover __ _) (p *> q) (Cover.cover-index (rewriteF s (unsplit F (sface k i)) j))
              }),
              \lam j j<k+1 => unfold F (mcases \with {
                | yes k=j => rewriteF (fin_nat-inj (kmod=k *> k=j)) Rl'gk
                | no k/=j => Q j (\case LinearOrder.<=-dec (<_suc_<= j<k+1) \with {
                  | inl j<k => j<k
                  | inr j=k => absurd (k/=j (inv j=k))
                })
              }),
              \lam j k+1<=j => unfold F (rewrite (decideEq/=_reduce (\lam (k=j : k = j) => <-irreflexive (<-transitive-left id<suc (rewriteF (inv k=j) k+1<=j)))) (S j (<=-less id<suc <=∘ k+1<=j))))

    \func ++_singleton {A : \Type} (l : Array A) : Big (++) nil (map (`:: nil) l) = l \elim l
      | nil => idp
      | :: a l => pmap (a ::) (++_singleton l)

    \func split_++ {A : \Type} {l1 l2 : Array A} (k : Fin (DArray.len {l1 ++ l2}))
      : Or (\Sigma (i : Fin l1.len) ((l1 ++ l2) k = l1 i)) (\Sigma (i : Fin l2.len) ((l1 ++ l2) k = l2 i)) \elim l1, k
      | nil, k => inr (k,idp)
      | :: a l1, 0 => inl (0,idp)
      | :: a l1, suc k => \case split_++ k \with {
        | inl (i,p) => inl (suc i, p)
        | inr (i,p) => inr (i,p)
      }

    \func split {A : \Type} {n : Nat} (g : Fin n -> Array A) (k : Fin (DArray.len {Big (++) nil (mkArray g)}))
      : \Sigma (i : Fin n) (j : Fin (DArray.len {g i})) (Big (++) nil g k = g i j) \elim n
      | suc n => \case split_++ k \with {
        | inl (j,p) => (0,j,p)
        | inr (m,p) =>
          \have (i,j,q) => split (\lam i => g (suc i)) m
          \in (suc i, j, p *> q)
      }

    \func unsplit {A : \Type} {n : Nat} (S : Fin n -> Array A) (i : Fin n) (j : Fin (DArray.len {S i})) : Index (S i j) (Big (++) nil S) \elim n, i
      | suc n, 0 => index-left (j,idp)
      | suc n, suc i => index-right (unsplit (\lam k => S (suc k)) i j)

    \func unsplit2 {A : \Type} {n : Nat} (Q : Fin n -> Nat) (S : \Sigma (i : Fin n) (Fin (Q i)) -> Array A) (i : Fin n) (j : Fin (Q i)) (k : Fin (DArray.len {S (i,j)}))
      : Index (S (i,j) k) (Big (++) nil (\lam i => Big (++) nil (mkArray (\lam j => S (i,j))))) \elim n, i
      | suc n, 0 => index-left (unsplit (\lam j => S (0,j)) j k)
      | suc n, suc i => index-right (unsplit2 (\lam i => Q (suc i)) (\lam p => S (suc p.1, p.2)) i j k)

    \lemma indexing-basic {P : FramePres} {I : \Set} {h : I -> \Sigma (J : \Set) P (J -> P)} {x : P} (R : P -> P -> \Prop)
                          (p : \Pi (i : I) -> R x (h i).2 -> ∃ (l : Array (h i).1) (Cover x (\lam j => (h i).3 (l j))))
                          {y : P} (Rxy : R x y) {J : \Set} {g : J -> P} (ind : FramePres.Indexing h y g) : ∃ (l : Array J) (Cover x (\lam i => g (l i)))
      => FramePres.indexing-transport (\lam {J'} y' g' =>  R x y' -> ∃ (l : Array J') (Cover x (\lam j => g' (l j)))) p ind Rxy
  }