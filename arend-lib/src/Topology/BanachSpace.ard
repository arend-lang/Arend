\import Algebra.Group.GroupHom
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.QModule
\import Algebra.Semiring
\import Arith.Nat
\import Arith.Rat
\import Arith.Real.UpperReal
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Topology.MetricSpace
\import Topology.NormedAbGroup
\import Topology.NormedRing
\import Topology.TopAbGroup
\import Topology.TopAbGroup.Complete
\import Topology.UniformSpace

\class PreBanachSpace (A : RatValue) \extends ExPseudoNormedAbGroup, DivisibleGroup {
  | norm_*n {n : Nat} {x : E} : norm (n *n x) = A.norm n ExUpperReal.* norm x

  \lemma norm_*i {n : Int} {x : E} : norm (n *i x) = A.norm n ExUpperReal.* norm x \elim n
    | pos n => norm_*n
    | neg n => pmap norm *n_negative *> norm_negative *> norm_*n *> pmap (ExUpperReal.`* _) (inv A.norm_negative)
}

\class BanachSpace \extends PreBanachSpace, CompleteExNormedAbGroup, QModule {
  | noTorsion {a} {n} n/=0 na=0 => {?} -- TODO[server2]: norm-ext $ inv ide-left *> pmap (`* _) (inv (pmap A.norm (RatField.finv-left $ natRat/=0 n/=0) *> A.norm_ide) *> A.norm_*) *> *-assoc *> pmap (A.norm (RatField.finv n) *) (inv norm_*n *> pmap norm na=0 *> norm_zro) *> zro_*-right

  \lemma norm_*q {q : Rat} {x : E} : norm (q *q x) = A.norm q ExUpperReal.* norm x
    => {?}
      {- TODO[server2]
      Monoid.LInv.cancel (A.norm_Inv $ RatField.nonZero-Inv $ natRat/=0 $ ratDenom/=0 q) $
        inv norm_*n *> pmap norm (inv (*q-assoc *> *q_*n) *> pmap (`*q _) rat*denom-left *> *q_*i) *> norm_*i *> pmap (`* _) (inv (pmap A.norm rat*denom-left) *> A.norm_*) *> *-assoc
        -}
}

\class RealPreBanachSpace \extends PreBanachSpace
  | A => RatValuedRing

\class RealBanachSpace \extends RealPreBanachSpace, BanachSpace {
  \lemma norm_*q-ofPos {q : Rat} (q>=0 : 0 <= q) {x : E} : norm (q *q x) = q ExUpperReal.* norm x
    => norm_*q *> pmap (__ ExUpperReal.* _) (RatField.abs-ofPos q>=0)
}

\record BoundedLinearMap \extends UniformNormedAbGroupMap {
  \override Dom : RealBanachSpace
  \override Cod : RealBanachSpace

  | isBounded : ∃ (C : Rat) (0 RatField.< C) ∀ x (norm (func x) <= C ExUpperReal.* norm x)

  \default func-norm-uniform {eps} eps>0 => \case isBounded \with {
    | inP (C,C>0,h) => \case C.U-inh \with {
      | inP (delta,C<delta) => {?}
      {- TODO[server2]
        \have | delta>=0 => <=-less (U-pos C<delta)
              | delta1>=0 => <=-less $ RatField.finv>0 $ U-pos C<delta
        \in inP (fromRat (RatField.finv delta) * eps, PosUpperRealSemiring.<_*-positive (fromRat_< <=-refl $ RatField.finv>0 $ U-pos C<delta) eps>0, \lam {x} |x|<delta => h x <∘r transport (_ <) (inv *-assoc *> pmap (`* _) (PosUpperRealSemiring.*-rat delta>=0 delta1>=0 *> pmap fromRat (RatField.finv-right $ RatField.>_/= $ U-pos C<delta)) *> ide-left) (PosUpperRealSemiring.<_* (U_<_fromRat C<delta) |x|<delta))
      -}
    }
  }
  \default isBounded => {?}
  {- TODO[server2]
    \case func-norm-uniform PosUpperRealSemiring.zro<ide \with {
    | inP (delta, inP (delta',delta'>0,delta'<=delta), h) => inP (fromRat (RatField.finv delta'), U_<_fromRat $ RatField.finv>0 $ fromRat_U_< delta'>0, \lam x {q} p =>
        \have | q1>=0 => <=-less $ RatField.finv>0 $ U-pos p
              | |x|<delta'*q => PosUpperRealSemiring.finv_<-rotate-right (fromRat_U_< delta'>0) (U_<_fromRat p)
        \in <_U_fromRat (<=-less $ U-pos p) $ transport (_ <) ide-right $ PosUpperRealSemiring.finv_<-rotate-right (U-pos p) $ transport (`< _) (RealBanachSpace.norm_*q-ofPos q1>=0) $ transport (norm __ < _) (func-*q \this) $ h {RatField.finv q QModule.*q x} $ transportInv (`< _) (RealBanachSpace.norm_*q-ofPos q1>=0) $ PosUpperRealSemiring.finv_<-rotate-left (U-pos p) $ |x|<delta'*q <∘l =_<= *-comm <=∘ PosUpperRealSemiring.<=_* <=-refl (transportInv (UpperRealAbMonoid.`<= _) (fromRat-upper $ <=-less $ fromRat_U_< delta'>0) delta'<=delta))
  }
  -}
}