{- | Some of the definitions and proofs are taken from
     [1] Coquand, Spitters, Constructive Gelfand Duality for C*-algebras, 2009, https://arxiv.org/abs/0808.1518
 -}

\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.QModule
\import Algebra.Ring
\import Arith.Int
\import Arith.Nat
\import Arith.Rat
\import Arith.Real
\import Arith.Real.Root
\import Arith.Real.UpperReal
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import Topology.BanachAlgebra
\import Topology.BanachSpace
\import Topology.NormedAbGroup

\class RealPreC*Algebra \extends QAlgebra, PosetAddGroup {
  | c*-positive-div {n : Nat} (n/=0 : n /= 0) {a : E} : 0 <= n *n a -> 0 <= a
  | c*-archimedean (a : E) : ∃ (B : Nat) (a <= natCoef B)
  | c*-<=_* {a : E} : a <= 1 -> negative a <= 1 -> a * a <= 1
  | c*-<=-square {a : E} : a * a <= 1 -> a <= 1

  | noTorsion n/=0 na=0 => <=-antisymmetric (negative-to<=0 $ c*-positive-div n/=0 $ transportInv (0 <=) *n_negative $ negative>=0 $ =_<= na=0) (c*-positive-div n/=0 $ =_<= $ inv na=0)

  \lemma zro<=ide : 0 <= 1
    => c*-positive-div {_} {2} suc/=0 $ transport2 (__ <= __ + 1) negative-left (inv zro-left) $ <=_+ (c*-<=-square (=_<= $ negative_* *> ide-left)) <=-refl

  \lemma *q_>=0 {q : Rat} (q>=0 : RatField.zro RatField.<= q) {a : E} (a>=0 : 0 <= a) : 0 <= q *q a
    => c*-positive-div (ratDenom/=0 q) $ transport (0 <=) (pmap (`*i a) (iabs.ofPos $ <=_ratNom.conv q>=0) *> inv *q_*i *> pmap (`*q a) (inv rat*denom-left) *> *q-assoc *> *q_*n) (*n_>=0 a>=0)

  \lemma <=_*q-left {q r : Rat} (q<=r : q RatField.<= r) {a : E} (a>=0 : 0 <= a) : q *q a <= r *q a
    => from>=0 $ transport (0 <=) toRatModule.*c-rdistr_- $ *q_>=0 (RatField.to>=0 q<=r) a>=0

  \lemma <=_*q-right {q : Rat} (q>=0 : RatField.zro RatField.<= q) {a b : E} (a<=b : a <= b) : q *q a <= q *q b
    => from>=0 $ transport (_ <=) toRatModule.*c-ldistr_- $ *q_>=0 q>=0 (to>=0 a<=b)

  \lemma <=_*n-cancel-left {n : Nat} (n/=0 : n /= 0) {a b : E} (na<=nb : n *n a <= n *n b) : a <= b
    => from>=0 $ c*-positive-div n/=0 $ transportInv (0 <=) *n-ldistr_- (to>=0 na<=nb)

  \lemma <=_*q-cancel-left {q : Rat} (q>0 : 0 < q) {a b : E} (qa<=qb : q *q a <= q *q b) : a <= b
    => \have lem {x} => inv *q-assoc *> pmap (`*q x) (RatField.finv-left $ RatField.>_/= q>0) *> ide_*q
       \in transport2 (<=) lem lem $ <=_*q-right (<=-less $ RatField.finv>0 q>0) qa<=qb

  \func toBanach : RealPreBanachSpace \cowith
    | DivisibleGroup => \this
    | norm (a : E) : ExUpperReal \cowith {
      | U q => ∃ (r : `< q) (0 < r) (a <= r *q 1) (negative a <= r *q 1)
      | U-closed (inP (r,r<q,r>0,a<=r,-a<=r)) q<q' => inP (r, r<q <∘ q<q', r>0, a<=r, -a<=r)
      | U-rounded {q} (inP (r,r<q,r>0,a<=r,-a<=r)) => inP (RatField.mid r q, inP (r, RatField.mid>left r<q, r>0, a<=r, -a<=r), RatField.mid<right r<q)
    }
    | norm_zro => exts \lam q => ext (\lam (inP (r,r<q,r>0,r>=0,_)) => r>0 <∘ r<q, \lam q>0 =>
      \have q/2>=0 => *q_>=0 (<=-less $ RatField.half>0 q>0) zro<=ide
      \in inP (RatField.half q, RatField.half<id q>0, RatField.half>0 q>0, q/2>=0, transportInv (`<= _) negative_zro q/2>=0))
    | norm_negative => exts \lam q => ext
      (\lam (inP (r,r<q,r>0,-x<=r,x<=r)) => inP (r, r<q, r>0, transport (`<= _) negative-isInv x<=r, -x<=r),
       \lam (inP (r,r<q,r>0,x<=r,-x<=r)) => inP (r, r<q, r>0, -x<=r, transportInv (`<= _) negative-isInv x<=r))
    | norm_+ {x} {y} {d} p => \case ExUpperReal.+_U.1 p \with {
      | inP (a, inP (a',a'<a,a'>0,x<=a',-x<=a'), b, inP (b',b'<b,b'>0,y<=b',-y<=b'), a+b<d) =>
        inP (a' RatField.+ b', RatField.<_+ a'<a b'<b <∘ a+b<d, RatField.<_+ a'>0 b'>0,
             <=_+ x<=a' y<=b' <=∘ =_<= (inv toRatModule.*c-rdistr),
             transport2 (<=) (+-comm *> inv negative_+) (inv toRatModule.*c-rdistr) $ <=_+ -x<=a' -y<=b')
    }
    | norm_*n_>= {n} {x} (inP (a,a<b,a>0,nx<=a,-nx<=a)) => \case decideEq n 0 \with {
      | yes n=0 => rewrite (n=0, ExUpperRealSemigroup.zro_*-left \case c*-archimedean x, c*-archimedean (negative x) \with {
        | inP (B1,x<=B1), inP (B2,-x<=B2) => inP ((B1 ∨ B2) Nat.+ 2, inP $ later (suc (B1 ∨ B2), linarith, linarith, x<=B1 <=∘ transport (`<= _) (*q_*n *> inv natCoef_*n) (<=_*q-left (fromInt_<= $ pos<=pos $ join-left NatSemiring.<=∘ id<=suc) zro<=ide), -x<=B2 <=∘ transport (`<= _) (*q_*n *> inv natCoef_*n) (<=_*q-left (fromInt_<= $ pos<=pos $ join-right NatSemiring.<=∘ id<=suc) zro<=ide)))
      }) (a>0 <∘ a<b)
      | no n/=0 =>
        \let | a' => RatField.finv n RatField.* a
             | a'>0 : 0 < a' => RatField.<_*_positive_positive (RatField.finv>0 $ fromInt_< $ pos<pos $ nonZero>0 n/=0) a>0
             | lem => pmap (`*q 1) (inv RatField.ide-left *> pmap (RatField.`* a) (inv $ RatField.finv-right $ natRat/=0 n/=0) *> RatField.*-assoc) *> *q-assoc *> *q_*n
        \in ExUpperReal.*_U_<.2 $ inP (n, ExUpperRealAbMonoid.<=-refl, fromNat_>=0, a', \lam {d} a'<d => inP $ later (_, a'<d, a'>0, <=_*n-cancel-left n/=0 $ transport (_ <=) lem nx<=a, <=_*n-cancel-left n/=0 $ transport2 (<=) (inv *n_negative) lem -nx<=a), <=-less a'>0, =_<= (inv RatField.*-assoc *> pmap (RatField.`* a) (RatField.finv-right $ natRat/=0 n/=0) *> RatField.ide-left) <∘r a<b)
    }

  \lemma norm<=1 {x : E} (x<=1 : x <= 1) (-x<=1 : negative x <= 1) : toBanach.norm x ExUpperReal.<= ExUpperRealPointed.ide
    => \lam b>1 => inP (RatField.ide, b>1, idp, rewrite ide_*q x<=1, rewrite ide_*q -x<=1)
}

\class RealC*Algebra \extends RealBanachAlgebra, RealPreC*Algebra {
  | c*-sum {a b : E} : norm (a * a) ExUpperReal.<= norm (a * a + b * b)
  | c*-square {a : E} : norm a ExUpperReal.* norm a ExUpperReal.<= norm (a * a)

  | <= => RealC*Algebra.<=
  | <=-refl => inP (0, zro_*-right *> inv negative-right)
  | <=-transitive y-x-sq z-y-sq => transport IsSquare simplify (square-sum c*-sum z-y-sq y-x-sq)
  | <=-antisymmetric (inP (a,aa=y-x)) (inP (b,bb=x-y)) => inv $ fromZero $ inv aa=y-x *> norm-ext (ExUpperRealAbMonoid.<=-antisymmetric (c*-sum ExUpperRealAbMonoid.<=∘ =_<= {ExUpperRealAbMonoid} (pmap norm (simplify in pmap (_ +) bb=x-y *> pmap (`+ _) aa=y-x) *> norm_zro)) norm>=0)
  | <=_+ p q => transport IsSquare equation.abGroup (square-sum c*-sum p q)

  | c*-positive-div {n} n/=0 na>=0 => \case *n_>=0 na>=0 \with {
    | inP (b,bb=nna) => inP (RatField.finv n *q b, simplify $ simplify at bb=nna $ inv *q-comm-left *> pmap (_ *q) (inv *q-comm-right) *> pmap (RatField.finv n *q) (pmap (RatField.finv n *q) (bb=nna *> inv *q_*n) *> inv *q-assoc *> pmap (`*q _) (RatField.finv-left $ natRat/=0 n/=0) *> ide_*q *> inv *q_*n) *> inv *q-assoc *> pmap (`*q _) (RatField.finv-left $ natRat/=0 n/=0) *> ide_*q)
  }
  | c*-archimedean a => \case norm-bounded a \with {
    | inP (B,|a|<B) =>
      \let | (N,B<N) => rat_natBound B
           | NN>0 => RatField.<_*_positive_positive (norm>=0 |a|<B <∘ B<N) (norm>=0 |a|<B <∘ B<N)
           | a' => RatField.finv (N Nat.* N) *q a
           | |a'|<=1 : norm a' ExUpperReal.<= ExUpperRealPointed.ide => transportInv (ExUpperReal.`<= _) (norm_*q-ofPos $ <=-less $ RatField.finv>0 NN>0) $ ExUpperRealSemigroup.<=_* ExUpperRealAbMonoid.<=-refl (ExUpperReal.<_<= |a|<B) ExUpperRealAbMonoid.<=∘ transportInv (ExUpperReal.`<= _) (ExUpperReal.*-rat (<=-less $ RatField.finv>0 NN>0) (<=-less $ norm>=0 |a|<B)) (ExUpperReal.<=-rat.1 $ <=-less $ RatField.<_rotate-left NN>0 $ B<N <∘l transport2 (RatField.<=) RatField.ide-right (inv RatField.ide-right) (RatField.<=_*_positive-right fromNat_>=0 $ fromInt_<= $ pos<=pos $ suc_<_<= $ pos<pos.conv $ fromInt_<.conv $ norm>=0 |a|<B <∘ B<N))
           | (inP (b,bb=1-a')) => norm-square' |a'|<=1
      \in inP (N Nat.* N, inP (natCoef N * b, equation.monoid {inv $ natCoef-comm {_} {N} {b}, inv natCoef_*, bb=1-a'} $ ldistr_- *> pmap2 (-) ide-right (natCoef_*_*n *> inv *q_*n *> inv *q-assoc *> pmap (`*q a) (RatField.finv-right $ RatField.>_/= NN>0) *> ide_*q)))
  }
  | c*-<=_* {a} a<=1 -a<=1 =>
    \let | a1 => ratio 1 2 *q (1 - a)
         | a2 => ratio 1 2 *q (1 + a)
         | a2=1-a1 => pmap (_ *q) {_} {2 *q 1 - (1 - a)} (later $ rewrite *q_*n equation.abGroup) *> toRatModule.*c-ldistr_- *> pmap (`- a1) (inv *q-assoc *> ide_*q)
         | a1-square => *q_>=0-square rat_<=-dec a<=1
         | a2-square => *q_>=0-square rat_<=-dec (transport IsSquare simplify -a<=1)
         | |1-a1|<=1 => square-lem-aux c*-sum a1-square (transport IsSquare a2=1-a1 a2-square)
         | |1-a2|<=1 => square-lem-aux c*-sum a2-square $ rewrite a2=1-a1 (simplify a1-square)
         | s1 => sqrt a1 |1-a1|<=1
         | s2 => sqrt a2 |1-a2|<=1
         | s-comm : s2 * s1 = s1 * s2 => RealBanachAlgebra.sqrt.comm $ RealBanachAlgebra.sqrt.comm $ inv *q-comm-left *> pmap (_ *q) (inv *q-comm-right *> pmap (_ *q) (sum_diff (ide-left *> inv ide-right) *> inv (diff_sum $ ide-left *> inv ide-right)) *> *q-comm-right) *> *q-comm-left
    \in inP (2 * s1 * s2, equation.monoid {
          2 (natCoef-comm {_} {2} {s1}), s-comm, inv $ natCoef-comm {_} {2} {s2},
          RealBanachAlgebra.sqrt.isSquare, RealBanachAlgebra.sqrt.isSquare {_} {a2},
          natCoef_*_*q {_} {2} {a1}, inv *q-assoc, ide_*q,
          natCoef_*_*q {_} {2} {a2}, inv $ *q-assoc {_} {2} {ratio 1 2} {1 + a}, ide_*q {_} {1 + a}
        } $ diff_sum (ide-left *> inv ide-right) *> pmap (`+ _) ide-left)
  | c*-<=-square {a} (inP (b,bb=1-aa)) => norm-square' $ ExUpperRealSemigroup.square<=1 $ c*-square ExUpperRealAbMonoid.<=∘ transport (_ ExUpperReal.<= norm __) {_} {1} (equation.abGroup {bb=1-aa}) (c*-sum {_} {a} {b}) ExUpperRealAbMonoid.<=∘ norm_ide_<=

  \lemma <=_*q {x y : E} (x<=y : x <= y) {q : Rat} (q>=0 : RatField.zro RatField.<= q) : q *q x <= q *q y
    => transport IsSquare toRatModule.*c-ldistr_- (*q_>=0-square q>=0 x<=y)

  \lemma norm_<=_*q {x : E} {q : Rat} (|x|<=q : norm x ExUpperReal.<= q) : x <= q *q 1
    => \case LinearOrder.dec<_<= 0 q \with {
      | inl q>0 =>
        \let | y => RatField.finv q *q x
             | q'>=0 => <=-less (RatField.finv>0 q>0)
             | y<=1 : y <= 1 => norm-square' $ transport2 (ExUpperReal.<=) (inv $ norm_*q-ofPos q'>=0) (ExUpperReal.*-rat q'>=0 (<=-less q>0) *> pmap ExUpperReal.fromRat (RatField.finv-left $ RatField.>_/= q>0)) $ ExUpperRealSemigroup.<=_* ExUpperRealAbMonoid.<=-refl |x|<=q
        \in transport (`<= _) (inv *q-assoc *> pmap (`*q x) (RatField.finv-right $ RatField.>_/= q>0) *> ide_*q) $ <=_*q y<=1 (<=-less q>0)
      | inr q<=0 => \have x=0 => norm-ext (ExUpperRealAbMonoid.<=-antisymmetric (|x|<=q ExUpperRealAbMonoid.<=∘ ExUpperReal.<=-rat.1 q<=0) norm>=0)
                    \in transport2 (<=) (inv x=0) (inv toRatModule.*c_zro-left *> pmap (`*q 1) (RatField.<=-antisymmetric (ExUpperReal.<=-rat.2 $ norm>=0 ExUpperRealAbMonoid.<=∘ |x|<=q) q<=0)) <=-refl
    }

  -- | [1] Theorem 1
  \lemma norm-char {x : E} : norm x = toBanach.norm x
    => ExUpperRealAbMonoid.<=-antisymmetric (\lam (inP (a,a<b,a>0,x<=a,-x<=a)) =>
      \let | y => RatField.finv a *q x
           | yy<=1 =>
             \have lem {x} (x<=a : x <= a *q 1) => transport (_ <=) (inv *q-assoc *> pmap (`*q 1) (RatField.finv-left $ RatField.>_/= a>0) *> ide_*q) $ <=_*q x<=a (<=-less $ RatField.finv>0 a>0)
             \in c*-<=_* (lem x<=a) $ transport (`<= 1) toRatModule.*c_negative-right (lem -x<=a)
           | |yy|<=1 => simplify in square-lem-aux c*-sum yy<=1 (inP (y, simplify idp))
           | |y|<=1 => ExUpperRealSemigroup.square<=1 $ c*-square ExUpperRealAbMonoid.<=∘ |yy|<=1
           | |x|<=a => transport (norm __ ExUpperReal.<= a) (inv *q-assoc *> pmap (`*q x) (RatField.finv-right $ RatField.>_/= a>0) *> ide_*q) $ transport2 (ExUpperReal.<=) (inv $ norm_*q-ofPos $ <=-less a>0) (ExUpperRealSemigroup.ide-right $ ExUpperReal.<=-rat.1 $ <=-less a>0) $ ExUpperRealSemigroup.<=_* (ExUpperRealAbMonoid.<=-refl {a}) |y|<=1
      \in |x|<=a a<b) \lam |x|<b => \case U-rounded |x|<b \with {
      | inP (a,|x|<a,a<b) => inP (a, a<b, norm>=0 |x|<a, norm_<=_*q $ ExUpperReal.<_<= |x|<a, norm_<=_*q $ transportInv (ExUpperReal.`<= _) norm_negative $ ExUpperReal.<_<= |x|<a)
    }
} \where {
  \type \infix 4 <= {R : Ring} (x y : R) => R.IsSquare (y - x)

  \private \lemma square-lem-aux {X : RealBanachAlgebra} (c*-sum : \Pi {a b : X} -> X.norm (a * a) ExUpperReal.<= X.norm (a * a + b * b)) {x : X} (px : X.IsSquare x) (p1 : X.IsSquare (1 - x)) : X.norm (1 - x) ExUpperReal.<= ExUpperRealPointed.ide \elim px, p1
    | inP (a,pa), inP (b,pb) => rewriteI pb $ c*-sum {_} {a} <=∘ transportInv (X.norm __ ExUpperReal.<= _) (equation.abGroup {pa,pb}) X.norm_ide_<=

  \private \lemma square-sum1 {X : RealBanachAlgebra} (c*-sum : \Pi {a b : X} -> X.norm (a * a) ExUpperReal.<= X.norm (a * a + b * b)) {x y : X} (qx : X.norm x ExUpperReal.<= 1) (qy : X.norm y ExUpperReal.<= 1) (px : X.IsSquare x) (py : X.IsSquare y) : X.IsSquare (x + y)
    => \let | lem => transport (_ ExUpperReal.<=) (ExUpperReal.*-rat rat_<=-dec rat_<=-dec) $ ExUpperRealSemigroup.<=_* {ratio 1 2} ExUpperRealAbMonoid.<=-refl $ transport (_ ExUpperReal.<=) ExUpperReal.+-rat (X.norm_+ <=∘ ExUpperRealAbMonoid.<=_+ (square-lem-aux c*-sum px (X.norm-square' qx)) (square-lem-aux c*-sum py (X.norm-square' qy)))
            | sqrt[x+y]/2 => X.sqrt (ratio 1 2 X.*q (x + y)) $ =_<= (pmap X.norm (inv (X.toRatModule.*c-ldistr_- *> pmap (`- _) (pmap (_ X.*q) (inv $ X.*q_*n {2}) *> inv X.*q-assoc *> X.ide_*q)) *> pmap (_ X.*q) {2 X.*n 1 - (x + y)} equation.ring) *> X.norm_*q-ofPos rat_<=-dec) <=∘ lem
       \in inP (sqrt 2 X.*r sqrt[x+y]/2, inv (X.toRealModule.*c-assoc *> pmap (_ X.*r) X.*r-comm-right *> X.*r-comm-left) *> pmap (_ X.*r) RealBanachAlgebra.sqrt.isSquare *> pmap (X.`*r _) (pow_sqrt $ rat_real_<=.1 rat_<=-dec) *> X.*r_*q *> inv X.*q-assoc *> X.ide_*q)

  -- | [1] Proposition 2
  \private \lemma square-sum {X : RealBanachAlgebra} (c*-sum : \Pi {a b : X} -> X.norm (a * a) ExUpperReal.<= X.norm (a * a + b * b)) {x y : X} (px : X.IsSquare x) (py : X.IsSquare y) : X.IsSquare (x + y)
    => \case X.norm-bounded x, X.norm-bounded y \with {
      | inP (a,|x|<a), inP (b,|y|<b) =>
        \let | ab => (a ∨ b ∨ 1) * (a ∨ b ∨ 1)
             | ab>0 => RatField.<_*_positive_positive (zro<ide <∘l join-right) (zro<ide <∘l join-right)
             | ab' => RatField.finv ab
             | ab'>=0 => <=-less (RatField.finv>0 ab>0)
             | ab_<= : a ∨ b ∨ 1 RatField.<= ab => =_<= (inv ide-left) <=∘ RatField.<=_*_positive-left join-right (<=-less RatField.zro<ide <=∘ join-right)
             | ab'-square => RatField.finv-square $ inP (_,idp)
        \in \case square-sum1 c*-sum
                    (=_<= (X.norm_*q-ofPos ab'>=0) <=∘ ExUpperRealSemigroup.<=_* <=-refl (ExUpperReal.<_<= |x|<a) <=∘ transportInv (ExUpperReal.`<= _) (ExUpperReal.*-rat ab'>=0 $ <=-less $ norm>=0 |x|<a) (ExUpperReal.<=-rat.1 $ RatField.<=_*_positive-left (RatField.finv_<= (norm>=0 |x|<a) $ join-left <=∘ join-left <=∘ ab_<=) (<=-less $ norm>=0 |x|<a) <=∘ =_<= (RatField.finv-left $ RatField.>_/= $ norm>=0 |x|<a)))
                    (=_<= (X.norm_*q-ofPos ab'>=0) <=∘ ExUpperRealSemigroup.<=_* <=-refl (ExUpperReal.<_<= |y|<b) <=∘ transportInv (ExUpperReal.`<= _) (ExUpperReal.*-rat ab'>=0 $ <=-less $ norm>=0 |y|<b) (ExUpperReal.<=-rat.1 $ RatField.<=_*_positive-left (RatField.finv_<= (norm>=0 |y|<b) $ join-right <=∘ join-left <=∘ ab_<=) (<=-less $ norm>=0 |y|<b) <=∘ =_<= (RatField.finv-left $ RatField.>_/= $ norm>=0 |y|<b)))
                    (X.*q-square ab'-square px)
                    (X.*q-square ab'-square py)
        \with {
          | inP (z,p) => inP ((a ∨ b ∨ 1) X.*q z, inv X.*q-comm-left *> pmap (_ X.*q) (inv X.*q-comm-right) *> inv X.*q-assoc *> pmap (_ X.*q) (p *> inv X.toRatModule.*c-ldistr) *> inv X.*q-assoc *> pmap (X.`*q _) (RatField.finv-right $ RatField.>_/= ab>0) *> X.ide_*q)
        }
    }
}