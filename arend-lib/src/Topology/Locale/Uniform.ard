\import Category
\import Category.Meta
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Topology.Locale
\open Locale
\open Bounded(top,top-univ)

\record Covering (L : Locale) (\coerce U : L -> \Prop)
  | isCovering : top <= SJoin U

\record DCovering \extends Covering
  | isDownset {x y : L} : U y -> x <= y -> U x

\instance DCoveringPoset (L : Locale) : Bounded.MeetSemilattice (DCovering L)
  | <= U V => \Pi {x : L} -> U x -> V x
  | <=-refl u => u
  | <=-transitive p q u => q (p u)
  | <=-antisymmetric p q => exts (\lam e => ext (p,q))
  | meet U V => \new DCovering {
    | U x => \Sigma (U x) (V x)
    | isCovering => meet-univ (isCovering {U}) (isCovering {V}) <=∘ Join-distr>= <=∘ Join-univ (\lam j => Join-cond $ later (_, (isDownset j.1.2 meet-left, isDownset j.2.2 meet-right)))
    | isDownset p q => (isDownset p.1 q, isDownset p.2 q)
  }
  | meet-left => __.1
  | meet-right => __.2
  | meet-univ p q => \lam x => (p x, q x)
  | top => \new DCovering {
    | U _ => \Sigma
    | isCovering => Join-cond (top,())
    | isDownset _ _ => ()
  }
  | top-univ _ => ()

\func star {L : Locale} (x : L) (U : DCovering L) => SJoin (\lam y => \Sigma (U y) (isPositive (x ∧ y)))
  \where {
    \lemma star_<= {L : Locale} {x y : L} (x<=y : x <= y) (U : DCovering L) : star x U <= star y U
      => Join-univ (\lam j => Join-cond $ later (j.1, (j.2.1, positive_<= (MeetSemilattice.meet-monotone x<=y <=-refl) j.2.2)))
  }

\class PreuniformLocale \extends Locale
  | overt : isOvert
  | isUniform : DCovering \this -> \Prop
  | top-uniform : isUniform (top {DCoveringPoset _})
  | meet-uniform {U V : DCovering _} : isUniform U -> isUniform V -> isUniform (U ∧ {DCoveringPoset _} V)
  | <=-uniform {U V : DCovering _} : isUniform U -> U <= {DCoveringPoset _} V -> isUniform V
  | star-uniform {U : DCovering _} : isUniform U -> ∃ (V : DCovering _) (isUniform V) (\Pi (x : E) -> V x -> U (star x V))

\record UniformHom \extends FrameHom {
  \override Dom : PreuniformLocale
  \override Cod : PreuniformLocale
  | func-uniform (U : DCovering Dom) : isUniform U -> isUniform (covering-image U)
} \where {
  \func covering-image {f : FrameHom} (U : DCovering f.Dom) : DCovering f.Cod \cowith
    | U y => ∃ (x : f.Dom) (U x) (y <= f x)
    | isCovering => func-top>= <=∘ func-<= U.isCovering <=∘ func-Join>= <=∘ Join-univ (\lam j => Join-cond $ later (f j.1, inP (j.1, j.2, <=-refl)))
    | isDownset (inP (z,Uz,y<=fz)) x<=y => inP (z, Uz, x<=y <=∘ y<=fz)
}

\func \infix 4 <=u {L : PreuniformLocale} (a b : L) => ∃ (U : DCovering L) (isUniform U) (star a U <= b)
  \where {
    \lemma trans-left {L : PreuniformLocale} (a : L) {b c : L} (p : a <=u b) (b<=c : b <= c) : a <=u c \elim p
      | inP (U,uU,a*U<=b) => inP (U, uU, a*U<=b <=∘ b<=c)
  }

\class UniformLocale \extends PreuniformLocale
  | isAdmissible (b : E) : b <= SJoin (`<=u b)

\func UniformCat : Cat UniformLocale \cowith
  | Hom => UniformHom
  | id L => \new UniformHom {
    | FrameHom => FrameCat.id L
    | func-uniform U => <=-uniform {L} __ (\lam {x} Ux => inP (x,Ux,<=-refl))
  }
  | o {X} {Y} {Z} g f => \new UniformHom {
    | FrameHom => g FrameCat.∘ f
    | func-uniform U uU => <=-uniform {Z} (func-uniform {g} _ (func-uniform {f} U uU)) (\lam {x} (inP (y, inP (z,Uz,y<=fz), x<=gy)) => inP (z, Uz, x<=gy <=∘ func-<= y<=fz))
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : UniformHom) (h2 : UniformHom) => exts {?})

\func CompletionPres (L : UniformLocale) : FramePres L \cowith
  | conj => meet
  | BasicCover => FramePres.Indexing {\Sigma (j : Fin 4) ((L :: L :: (\Sigma (U : DCovering L) (isUniform U)) :: L.E :: nil) j)} (\case __ \with {
    | (0,a) => (\Sigma, a, \lam _ => top)
    | (1,a) => (isPositive a, a, \lam _ => a)
    | (2,(U,p)) => (\Sigma (x : L) (U x), top, __.1)
    | (3,a) => (\Sigma (b : L) (b <=u a), a, __.1)
  })
  \where {
    \lemma <=_cover {L : UniformLocale} {a b : L} (a<=b : a <= b) : Cover1 {CompletionPres L} a b
      => rewriteI (MeetSemilattice.meet_<= a<=b) (Cover.cover-proj2 idp () idp)
  }

\open CompletionPres
\open PresentedFrame \hiding (<=)

\func Completion (L : UniformLocale) => PresentedFrame (CompletionPres L)

\func completion {L : UniformLocale} : Hom L (Completion L)
  => FrameReflectiveSubcat.isReflective.ret completion.presentation
  \where {
    \open FrameHom

    \func presentation {L : UniformLocale} : FramePresHom (CompletionPres L) (FrameUnitalSubcat.F L) \cowith
      | func x => x
      | func-conj => idp
      | func-cover => FramePres.indexing-transport _ $ later (\case \elim __ \with {
        | (0,a) => top-univ <=∘ Join-cond ()
        | (1,a) => overt_cover overt
        | (2,(U,p)) => isCovering
        | (3,a) => isAdmissible a
      })
      | func-image {x} => cover-inj x idp

    \lemma sdense {L : UniformLocale} : isStronglyDense {completion {L}}
      => sdense-fromPres (\lam Q x x<=Q => Cover.cover-trans1 (<=_cover x<=Q) $ cover-trans (cover-basic $ FramePres.indexing-make $ later (1,_))
        (\lam p => \have (inP q) => positive_cover p _ <=-refl \in cover-inj q (<=-antisymmetric (Join-cond q) (Join-univ (\lam _ => <=-refl)))))

    \lemma completion_embed {L : UniformLocale} {a : L} : completion (embed a) = a
      => <=-antisymmetric (Join-univ (\lam j => FrameReflectiveSubcat.locale_cover (Cover.map {presentation} j.2) <=∘ Join-univ (\lam _ => <=-refl))) (Join-cond $ later (a, cover-inj () idp))
  }

\func CompletionUniform (L : UniformLocale) : UniformLocale \cowith
  | Locale => Completion L
  | overt => sdense_overt {completion} completion.sdense overt
  | isUniform (V : DCovering (Completion L)) : \Prop => ∃ (U : DCovering L) (L.isUniform U) (\Pi (a : L) -> U a -> V (embed a))
  | top-uniform => inP (top, top-uniform, \lam a _ => ())
  | meet-uniform (inP (U,uU,pU)) (inP (V,uV,pV)) => inP (U ∧ V, meet-uniform uU uV, \lam a p => (pU a p.1, pV a p.2))
  | <=-uniform (inP (U,uU,pU)) U<=V => inP (U, uU, \lam a Ua => U<=V (pU a Ua))
  | star-uniform {U} (inP (U',uU,pU)) => TruncP.map (star-uniform uU) (\lam (V',uV',sr) =>
      \let (V,uV,q) => make-covering V' uV'
      \in (V, uV, \lam s (inP (x,V'x,s<=x)) => isDownset (pU (star x V') (sr x V'x)) $ star.star_<= s<=x V <=∘ q x))
  | isAdmissible =>
    \have | embed_<=u {a b : L} (a<=b : a <=u b) : embed a <=u {\this} embed b => TruncP.map a<=b (\lam (U,uU,a*U<=b) =>
              \have (V,uV,q) => make-covering U uU
              \in (V, uV, q a <=∘ embed_<= (<=_cover a*U<=b)))
          | h x : FramePres.SCover x (embed __ <=u embed x) => cover-trans (cover-basic $ indexing-make $ later (3,x)) $ later (\lam (y,y<=x) => cover-inj (y, embed_<=u y<=x) idp)
    \in \lam U {x} Ux => cover-trans (h x) (\lam (y,y<=x) => cover-inj ((embed y, <=u.trans-left (embed y) y<=x $ embed<= $ cover-inj (x,Ux) idp), y, cover-inj () idp) idp)
  \where {
    \open FramePres(indexing-make)

    \func make-covering {L : UniformLocale} (U : DCovering L) (uU : L.isUniform U)
      : \Sigma (V : DCovering (Completion L)) (isUniform V)
               (\Pi (a : L) -> star (embed a) V <= embed (star a U))
      => \have V => \new DCovering (Completion L) {
           | U s => ∃ (x : L) (U x) (s <= embed x)
           | isCovering {x} _ => Cover.cover-trans1 (cover-basic $ indexing-make $ later (0,x)) $ cover-trans (cover-basic $ indexing-make $ later (2,(U,uU)))
                                   (\lam i => later $ cover-inj ((embed i.1, inP (i.1, i.2, <=-refl)), i.1, cover-inj () idp) idp)
           | isDownset (inP (z,U'z,y<=z)) x<=y => inP (z, U'z, x<=y <=∘ y<=z)
         } \in (V, inP (U, uU, \lam a V'a => inP (a, V'a, <=-refl)), \lam a =>
             Join-univ (\lam (t, (inP (y, V'y, t<=y), xt>0)) => t<=y <=∘ embed_<= (<=_cover $ Join-cond $ later (y, (V'y, transport isPositive completion.completion_embed $
               sdense_positive {completion} completion.sdense $ transport isPositive embed_meet $ positive_<= (MeetSemilattice.meet-monotone (<=-refl {_} {embed a}) t<=y) xt>0)))))
  }