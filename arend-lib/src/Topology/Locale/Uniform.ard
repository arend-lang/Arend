\import Category
\import Category.Meta
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Topology.Locale
\open Locale
\open Bounded(top,top-univ)
\open Nucleus
\open Preorder(=_<=)
\open MeetSemilattice \hiding (Meet)

\func star {L : Locale} (x : L) (U : L -> \Prop) => SJoin (\lam y => \Sigma (U y) (isPositive (x ∧ y)))
  \where {
    \lemma star_<= {L : Locale} {x y : L} (x<=y : x <= y) (U : L -> \Prop) : star x U <= star y U
      => Join-univ (\lam j => Join-cond $ later (j.1, (j.2.1, positive_<= (MeetSemilattice.meet-monotone x<=y <=-refl) j.2.2)))
  }

\func nucleus-star {L : Locale} (j : Nucleus {L}) (U : L -> \Prop) => SJoin (\lam y => \Sigma (U y) (j.locale.isPositive (j y, nucleus-join>=)))
  \where {
    \lemma star_open {L : Locale} (a : L) (U : L -> \Prop) : nucleus-star (open a) U = star a U
      => \have lem x P : (a --> x <= a --> pHat P) = (a ∧ x <= pHat P)
            => propExt (\lam c => =_<= meet-comm <=∘ exponent.2 (nucleus-unit {open a} <=∘ c))
                       (\lam c => nucleus-univ {open a} $ exponent.1 $ =_<= meet-comm <=∘ c)
         \in path (\lam i => SJoin (\lam x => \Sigma (U x) (\Pi (P : \Prop) -> lem x P i -> P)))
  }

\class PreuniformLocale \extends Locale
  | overt : isOvert
  | isUniform : (E -> \Prop) -> \Prop
  | isCovering {U : E -> \Prop} : isUniform U -> top <= SJoin U
  | isDownset {U : E -> \Prop} {x y : E} : isUniform U -> U y -> x <= y -> U x
  | top-uniform : isUniform (\lam _ => \Sigma)
  | meet-uniform {U V : E -> \Prop} : isUniform U -> isUniform V -> isUniform (\lam x => \Sigma (U x) (V x))
  | <=-uniform {U V : E -> \Prop} : isUniform U -> (\Pi {x : E} -> U x -> V x) -> (\Pi {x y : E} -> V y -> x <= y -> V x) -> isUniform V
  | star-uniform {U : E -> \Prop} : isUniform U -> ∃ (V : E -> \Prop) (isUniform V) (\Pi (x : E) -> V x -> U (star x V))
  \where {
    \lemma dClosure {L M : Preorder} {f : L -> M} {U : L -> \Prop} {x y : M} (p : ∃ (z : L) (U z) (y <= f z)) (x<=y : x <= y) : ∃ (z : L) (U z) (x <= f z) \elim p
      | inP (z,Uz,y<=fz) => inP (z, Uz, x<=y <=∘ y<=fz)
  }

\open PreuniformLocale(dClosure)

\record UniformHom \extends FrameHom {
  \override Dom : PreuniformLocale
  \override Cod : PreuniformLocale
  | func-uniform {U : Dom -> \Prop} : isUniform U -> isUniform (\lam y => ∃ (x : Dom) (U x) (y <= func x))
}

\func \infix 4 <=u {L : PreuniformLocale} (a b : L) => ∃ (U : L -> \Prop) (isUniform U) (star a U <= b)
  \where {
    \lemma trans-left {L : PreuniformLocale} (a : L) {b c : L} (p : a <=u b) (b<=c : b <= c) : a <=u c \elim p
      | inP (U,uU,a*U<=b) => inP (U, uU, a*U<=b <=∘ b<=c)
  }

\class UniformLocale \extends PreuniformLocale
  | isAdmissible (b : E) : b <= SJoin (`<=u b)
  \where {
    \open NucleusFrame

    \lemma star_wclosure {L : PreuniformLocale} {j : Nucleus {L}} {U : L -> \Prop} (uU : isUniform U) : nucleus-star j.map.wclosed-image U = nucleus-star j U
      => \have lem x P : (j.map.wclosed-image x <= j.map.wclosed-image (pHat P)) = (j x <= j (pHat P))
            => propExt (\lam c => nucleus-univ $ j.map.wclosed-image.nucleus-unit <=∘ c <=∘ wclosure_<=)
                       (\lam c => j.map.wclosed-image.nucleus-univ $ nucleus-unit <=∘ c <=∘ Meet-univ (\lam p => p.2 nucleus-join>=))
         \in path (\lam i => SJoin (\lam y => \Sigma (U y) (\Pi (P : \Prop) -> lem y P i -> P)))

    \lemma top>=star {L : PreuniformLocale} {j : Nucleus {L}} (o : j.locale.isOvert) {U : L -> \Prop} (uU : isUniform U) : open (nucleus-star j U) <= j
      => nucleus>=open $ isCovering uU <=∘ Join-univ (\lam y => j.nucleus-unit <=∘ overt_cover o {j y.1, nucleus-join>=} <=∘ nucleus-univ (Join-univ (\lam jy>0 => nucleus-<= $ Join-cond $ later (y.1, (y.2, jy>0)))))

    \lemma wclosure>=nucleus-star {L : PreuniformLocale} {j : Nucleus {L}} (o : j.locale.isOvert) {U : L -> \Prop} (uU : isUniform U) : open (nucleus-star j U) <= j.map.wclosed-image
      => =_<= (pmap open $ inv $ star_wclosure uU) <=∘ top>=star (sdense_overt {<=-map j.map.wclosed-image j wclosure_<=} wclosure-sdense o) uU

    \lemma wclosure>=star {L : PreuniformLocale} {a : L} {U : L -> \Prop} (uU : isUniform U) : open (star a U) <= FrameHom.wclosed-image {Nucleus.map {open a}}
      => \have a-overt : isOvert {locale {open a}} => overt=open.2 $ transport (FrameHom.isOpen {__}) (terminal-unique {_} {locale {open a}} {terminalMap {_} {locale {open a}}} {LocaleCat.terminalMap ∘ Nucleus.map {open a}}) $ open-comp (Nucleus.map {open a}) (open-isOpen a) (terminalMap {LocaleCat} {L}) $ overt=open.1 L.overt
         \in =_<= (pmap open $ inv $ nucleus-star.star_open a U) <=∘ wclosure>=nucleus-star a-overt uU
  }

\lemma uniform=>wregular (L : UniformLocale) : L.isWeaklyRegular
  => \lam x => L.isAdmissible x <=∘ Join-univ (\lam (b, inP (U,uU,b*U<=x)) => Join-cond $ later (b, unfold (<=<w) $ NucleusFrame.open_<= b*U<=x <=∘ UniformLocale.wclosure>=star uU))

\func UniformCat : Cat UniformLocale \cowith
  | Hom => UniformHom
  | id L => \new UniformHom {
    | FrameHom => FrameCat.id L
    | func-uniform => <=-uniform __ (\lam {x} Ux => inP (x,Ux,<=-refl)) dClosure
  }
  | o g f => \new UniformHom {
    | FrameHom => g FrameCat.∘ f
    | func-uniform uU => <=-uniform (func-uniform {g} (func-uniform {f} uU))
        (\lam {x} (inP (y, inP (z,Uz,y<=fz), x<=gy)) => inP (z, Uz, x<=gy <=∘ func-<= y<=fz)) dClosure
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {X} {S1} {S2} (h1 : UniformHom) (h2 : UniformHom) => exts UniformLocale {
    | <= x y => ext (h1.func-<=, h2.func-<=)
    | meet x y => h1.func-meet
    | top => h1.func-top
    | Join f => h1.func-Join
    | isUniform U => ext (\lam uU => uniform-lem (h1.func-uniform uU) (\lam Uy x<=y => isDownset uU Uy (h2.func-<= x<=y)),
                          \lam uU => uniform-lem (h2.func-uniform uU) (\lam Uy x<=y => isDownset uU Uy (h1.func-<= x<=y)))
  })
  \where {
    \lemma uniform-lem {L : UniformLocale} {U : L -> \Prop}
                       (u : isUniform (\lam y => ∃ (x : L) (U x) (y <= x)))
                       (d : \Pi {x y : L} -> U y -> x <= y -> U x)
      : isUniform U
      => <=-uniform u (\lam {x} (inP (y,Uy,x<=y)) => d Uy x<=y) d
  }

\func CompletionPres (L : UniformLocale) : FramePres L \cowith
  | conj => meet
  | BasicCover => FramePres.Indexing {\Sigma (j : Fin 4) ((L :: L :: (\Sigma (U : L -> \Prop) (isUniform U)) :: L.E :: nil) j)} (\case __ \with {
    | (0,a) => (\Sigma, a, \lam _ => top)
    | (1,a) => (isPositive a, a, \lam _ => a)
    | (2,U) => (\Sigma (x : L) (U.1 x), top, __.1)
    | (3,a) => (\Sigma (b : L) (b <=u a), a, __.1)
  })
  \where {
    \lemma <=_cover {L : UniformLocale} {a b : L} (a<=b : a <= b) : Cover1 {CompletionPres L} a b
      => rewriteI (MeetSemilattice.meet_<= a<=b) (Cover.cover-proj2 idp () idp)
  }

\open CompletionPres
\open PresentedFrame \hiding (<=)

\func Completion (L : UniformLocale) => PresentedFrame (CompletionPres L)

\func completion {L : UniformLocale} : LocaleCat.Hom L (Completion L)
  => FrameReflectiveSubcat.isReflective.ret completion.presentation
  \where {
    \open FrameHom

    \func presentation {L : UniformLocale} : FramePresHom (CompletionPres L) (FrameUnitalSubcat.F L) \cowith
      | func x => x
      | func-conj => idp
      | func-cover => FramePres.indexing-transport _ $ later (\case \elim __ \with {
        | (0,a) => top-univ <=∘ Join-cond ()
        | (1,a) => overt_cover overt
        | (2,(U,uU)) => isCovering uU
        | (3,a) => isAdmissible a
      })
      | func-image {x} => cover-inj x idp

    \lemma sdense {L : UniformLocale} : isStronglyDense {completion {L}}
      => sdense-fromPres (\lam x<=Q => Cover.cover-trans1 (<=_cover x<=Q) $ cover-trans (cover-basic $ FramePres.indexing-make $ later (1,_))
        (\lam p => \have (inP q) => positive_cover p _ <=-refl \in cover-inj q (<=-antisymmetric (Join-cond q) (Join-univ (\lam _ => <=-refl)))))

    \lemma completion_embed {L : UniformLocale} {a : L} : completion (embed a) = a
      => <=-antisymmetric (Join-univ (\lam j => FrameReflectiveSubcat.locale_cover (Cover.map {presentation} j.2) <=∘ Join-univ (\lam _ => <=-refl))) (Join-cond $ later (a, cover-inj () idp))
  }

\func CompletionUniform (L : UniformLocale) : UniformLocale \cowith
  | Locale => Completion L
  | overt => sdense_overt {completion} completion.sdense overt
  | isUniform (V : Completion L -> \Prop) : \Prop => ∃ (U : L -> \Prop) (L.isUniform U) (\Pi {a : L} -> U a -> V (embed a)) (\Pi {x y : Completion L} -> V y -> x <= y -> V x)
  | isCovering (inP (U,uU,U<=V,dV)) {x} _ => Cover.cover-trans1 (cover-basic $ indexing-make $ later (0,x)) $
      cover-trans (cover-basic $ indexing-make $ later (2,(U,uU))) (\lam i => later $ cover-inj ((embed i.1, U<=V i.2), i.1, cover-inj () idp) idp)
  | isDownset (inP (U,uU,U<=V,dV)) Vy x<=y => dV Vy x<=y
  | top-uniform => inP (\lam _ => \Sigma, top-uniform, \lam _ => (), \lam _ _ => ())
  | meet-uniform (inP (U,uU,lU,dU)) (inP (V,uV,lV,dV)) =>
      inP (\lam x => \Sigma (U x) (V x), meet-uniform uU uV, \lam p => (lU p.1, lV p.2), \lam p x<=y => (dU p.1 x<=y, dV p.2 x<=y))
  | <=-uniform (inP (U,uU,lU,dU)) U<=V dV => inP (U, uU, \lam Ua => U<=V (lU Ua), dV)
  | star-uniform {U} (inP (U',uU,lU,dU)) => TruncP.map (star-uniform uU) (\lam (V',uV',sr) =>
    \let (V,uV,q) => make-covering V' uV'
    \in (V, uV, \lam s (inP (x,V'x,s<=x)) => dU (lU (sr x V'x)) (star.star_<= s<=x V <=∘ q x)))
  | isAdmissible =>
    \have | embed_<=u {a b : L} (a<=b : a <=u b) : embed a <=u {\this} embed b => TruncP.map a<=b (\lam (U,uU,a*U<=b) =>
              \have (V,uV,q) => make-covering U uU
              \in (V, uV, q a <=∘ embed_<= (<=_cover a*U<=b)))
          | h x : FramePres.SCover x (embed __ <=u {\this} embed x) => cover-trans (cover-basic $ indexing-make $ later (3,x)) $ later (\lam (y,y<=x) => cover-inj (y, embed_<=u y<=x) idp)
    \in \lam U {x} Ux => cover-trans (h x) (\lam (y,y<=x) => cover-inj ((embed y, <=u.trans-left {\this} (embed y) y<=x $ embed<= $ cover-inj (x,Ux) idp), y, cover-inj () idp) idp)
  \where {
    \open FramePres(indexing-make)

    \func make-covering {L : UniformLocale} (U : L -> \Prop) (uU : L.isUniform U)
      : \Sigma (V : Completion L -> \Prop) (isUniform V) (\Pi (a : L) -> star (embed a) V <= embed (star a U))
      => (\lam s => ∃ (x : L) (U x) (s <= embed x),
          inP (U, uU, \lam {a} Ua => inP (a,Ua,<=-refl), dClosure),
          \lam a => Join-univ (\lam (t, (inP (y, V'y, t<=y), xt>0)) => t<=y <=∘ embed_<= (<=_cover $ Join-cond $ later (y, (V'y, transport isPositive completion.completion_embed $
              sdense_positive {completion} completion.sdense $ transport isPositive embed_meet $ positive_<= (MeetSemilattice.meet-monotone (<=-refl {_} {embed a}) t<=y) xt>0)))))
  }

\func completionUniform {L : UniformLocale} : UniformHom (CompletionUniform L) L \cowith
  | FrameHom => completion
  | func-uniform {U} (inP (V,uV,V<=U,dV)) => <=-uniform uV (\lam {x} Vx => inP (embed x, V<=U Vx, Join-cond $ later (x, cover-inj () idp))) dClosure
