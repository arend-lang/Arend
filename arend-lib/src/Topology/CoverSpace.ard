\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.TopSpace
\open Bounded(top,top-univ)
\open Set
\open ClosurePrecoverSpace

\class PrecoverSpace \extends TopSpace {
  | isCauchy : Set (Set E) -> \Prop
  | cauchy-cover {C : Set (Set E)} : isCauchy C -> \Pi (x : E) -> ∃ (U : C) (U x)
  | cauchy-top : isCauchy (single top)
  | cauchy-extend {C D : Set (Set E)} : isCauchy C -> (\Pi {U : Set E} -> C U -> ∃ (V : D) (U ⊆ V)) -> isCauchy D
  | cauchy-trans {C : Set (Set E)} {D : Set E -> Set (Set E)} : isCauchy C -> (\Pi {U : Set E} -> C U -> isCauchy (D U))
    -> isCauchy (\lam U => ∃ (V W : Set E) (C V) (D V W) (U = V ∧ W))

  | isOpen S => ∀ {x : S} (isCauchy \lam U => U x -> U ⊆ S)
  | open-top _ => cauchy-extend cauchy-top \lam {U} _ => inP (U, \lam _ _ => (), <=-refl)
  | open-inter Uo Vo => \lam {x} (Ux,Vx) => cauchy-extend (cauchy-trans (Uo Ux) (\lam _ => Vo Vx))
      \lam (inP (U',V',Uc,Vc,W=U'V')) => inP (U' ∧ V', \lam (U'x,V'x) {y} (U'y,V'y) => (Uc U'x U'y, Vc V'x V'y), Preorder.=_<= W=U'V')
  | open-Union So {x} (inP (U,SU,Ux)) => cauchy-extend (So U SU Ux) \lam {V} Vc => inP (V, \lam Vx => Vc Vx <=∘ Set.Union-cond SU, <=-refl)

  \lemma cauchy-trans-dep {C : Set (Set E)} {D : \Pi {U : Set E} -> C U -> Set (Set E)} (Cc : isCauchy C) (Dc : \Pi {U : Set E} (c : C U) -> isCauchy (D c))
    : isCauchy (\lam U => ∃ (V W : Set E) (c : C V) (D c W) (U = V ∧ W))
    => transport isCauchy (ext \lam U => ext (\lam (inP (V,W,CV,DW,p)) => inP (V, W, CV, transport (D __ W) prop-pi DW.2, p), \lam (inP (V,W,c,DW,p)) => inP (V, W, c, (c,DW), p))) $ cauchy-trans {_} {C} {\lam U V => \Sigma (c : C U) (D c V)} Cc \lam CU => transport isCauchy (ext \lam V => ext (\lam d => (CU,d), \lam s => transport (D __ V) prop-pi s.2)) (Dc CU)
}

\lemma cauchy-subset {X : PrecoverSpace} {C D : Set (Set X)} (Cc : isCauchy C) (e : \Pi {U : Set X} -> C U -> D U) : isCauchy D
  => cauchy-extend Cc \lam {U} CU => inP (U, e CU, <=-refl)

\lemma top-cauchy {X : PrecoverSpace} {C : Set (Set X)} (Ct : C top) : isCauchy C
  => cauchy-subset cauchy-top $ later \lam p => rewriteI p Ct

\lemma cauchy-inter {X : PrecoverSpace} {C D : Set (Set X)} (Cc : isCauchy C) (Dc : isCauchy D)
  : isCauchy (\lam U => ∃ (V W : Set X) (C V) (D W) (U = V ∧ W))
  => cauchy-trans Cc \lam _ => Dc

\record CoverMap \extends ContMap {
  \override Dom : PrecoverSpace
  \override Cod : PrecoverSpace
  | func-cover {D : Set (Set Cod)} : isCauchy D -> isCauchy \lam U => ∃ (V : D) (U = func ^-1 V)
  | func-cont Uo {x} Ufx => cauchy-extend (func-cover (Uo Ufx)) \lam (inP (W,c,d)) => inP (func ^-1 W, \lam a {_} => c a, Preorder.=_<= d)

  \func IsEmbedding : \Prop
    => \Pi {C : Set (Set Dom)} -> isCauchy C -> isCauchy \lam V => ∃ (U : C) (func ^-1 V ⊆ U)

  -- | A map is an embedding if and only if the structure on the domain is the smallest compatible with the map.
  \lemma embedding-char : TFAE (
    {- 0 -} IsEmbedding,
    {- 1 -} \Pi {X : PrecoverSpace Dom} -> CoverMap X Cod func -> \Pi {C : Set (Set Dom)} -> isCauchy C -> X.isCauchy C,
    {- 2 -} \Pi {C : Set (Set Dom)} -> isCauchy C -> isCauchy {PrecoverTransfer func} C,
    {- 3 -} Dom = {PrecoverSpace Dom} PrecoverTransfer func
  ) => TFAE.cycle (
    \lam p f Cc => cauchy-extend (func-cover {f} $ p Cc) \lam (inP (V, inP (U',CU',p), q)) => inP (U', CU', rewrite q p),
    \lam f => f PrecoverTransfer-map,
    \lam f => exts \lam C => ext (f, PrecoverTransfer-char),
    \lam p => unfolds $ rewrite p \lam (inP (D,Dc,f)) => cauchy-subset Dc f)

  \func IsDense : \Prop
    => \Pi {y : Cod} {U : Set Cod} -> single y <=< U -> ∃ (x : Dom) (U (func x))

  \func IsDenseEmbedding : \Prop
    => \Sigma IsDense IsEmbedding
}

\type \infix 4 <=< {X : PrecoverSpace} (V U : Set X) : \Prop
  => isCauchy \lam W => Given (V ∧ W) -> W ⊆ U

\lemma <=<_<= {X : PrecoverSpace} {V U : Set X} (p : V <=< U) : V <= U
  => unfolds at p $ \lam {x} Vx => \case cauchy-cover p x \with {
    | inP (W,f,Wx) => f (x, (Vx, Wx)) Wx
  }

\lemma <=<-left {X : PrecoverSpace} {W V U : Set X} (p : W <=< V) (q : V ⊆ U) : W <=< U
  => unfolds at p $ cauchy-subset p \lam {Z} f t => f t <=∘ q

\lemma <=<-right {X : PrecoverSpace} {W V U : Set X} (p : W ⊆ V) (q : V <=< U) : W <=< U
  => unfolds at q $ cauchy-subset q $ later \lam {Z} f (x,(Wx,Zx)) => f (x, (p Wx, Zx))

\lemma <=<_meet {X : PrecoverSpace} {U V U' V' : Set X} (U<=<U' : U <=< U') (V<=<V' : V <=< V') : U ∧ V <=< U' ∧ V'
  => unfolds at U<=<U' $ cauchy-subset (cauchy-inter U<=<U' V<=<V') $ later \lam (inP (U'', V'', t1, t2, p)) => rewrite p $
      \lam (x,((Ux,Vx),(U''x,V''x))) => MeetSemilattice.meet-monotone (t1 (x,(Ux,U''x))) (t2 (x,(Vx,V''x)))

\lemma <=<_single_meet {X : PrecoverSpace} {x : X} {U V : Set X} (p : single x <=< U) (q : single x <=< V) : single x <=< U ∧ V
  => <=<-right (\lam r => later $ rewrite r (idp,idp)) (<=<_meet p q)

\lemma <=<_top {X : PrecoverSpace} {U : Set X} : U <=< top
  => unfolds $ top-cauchy \lam _ => <=-refl

\lemma <=<_^-1 {X Y : PrecoverSpace} {f : CoverMap X Y} {U V : Set Y} (U<=<V : U <=< V) : f ^-1 U <=< f ^-1 V
  => cauchy-subset (f.func-cover U<=<V) \lam (inP (W,g,p)) => rewrite p $ later \lam (x,s) => g (f x, s) __

\class CoverSpace \extends PrecoverSpace {
  | isRegular {C : Set (Set E)} : isCauchy C -> isCauchy \lam V => ∃ (U : C) (V <=< U)

  \lemma cauchy-regular-cover {C : Set (Set E)} (Cc : isCauchy C) (x : E) : ∃ (U : C) (single x <=< U)
    => \case cauchy-cover (isRegular Cc) x \with {
      | inP (U, inP (V, CV, U<=<V), Ux) => inP (V, CV, <=<-right (single_<= Ux) U<=<V)
    }
}

\class InterCoverSpace \extends CoverSpace
  | isInterCoverSpace {C : Set (Set E)} : isCauchy C -> ∃ (D : isCauchy) (∀ {V : D} (∃ (U : C) (∀ {V' : D} (Given (V ∧ V') -> V' ⊆ U))))
  | isRegular Cc => \case isInterCoverSpace Cc \with {
    | inP (D,Dc,f) => cauchy-subset Dc $ later \case f __ \with {
      | inP (U,CU,g) => inP (U, CU, cauchy-subset Dc g)
    }
  }

\func AntiDiscreteCover (X : \Set) : InterCoverSpace X \cowith
  | isCauchy C => C top
  | cauchy-cover Ct x => inP (top, Ct, ())
  | cauchy-top => idp
  | cauchy-extend Ct e => \case e Ct \with {
    | inP (V,DV,t<=V) => rewrite (<=-antisymmetric t<=V top-univ) DV
  }
  | cauchy-trans Ct e => inP (top, top, Ct, e Ct, <=-antisymmetric (\lam _ => ((), ())) top-univ)
  | isInterCoverSpace Ct => inP (single top, idp, \lam _ => inP (top, Ct, \lam _ _ => top-univ))

\func DiscreteCover (X : \Set) : InterCoverSpace X \cowith
  | isCauchy C => \Pi (x : X) -> ∃ (U : C) (U x)
  | cauchy-cover c => c
  | cauchy-top x => inP (top, idp, ())
  | cauchy-extend c d x =>
    \have | (inP (U,CU,Ux)) => c x
          | (inP (V,DV,U<=V)) => d CU
    \in inP (V, DV, U<=V Ux)
  | cauchy-trans c d x =>
    \have | (inP (U,CU,Ux)) => c x
          | (inP (V,DV,Vx)) => d CU x
    \in inP (U ∧ V, inP (U, V, CU, DV, idp), (Ux,Vx))
  | isInterCoverSpace f => inP (\lam U => ∃ (x : X) (U = single x), \lam x => inP (single x, inP (x, idp), idp), later \lam (inP (x,p)) => \case f x \with {
    | inP (U,CU,Ux) => inP (U, CU, \lam (inP (x',p')) => rewrite (p,p') \lam (y,(q,q')) => \lam r => rewrite (inv r, q', inv q) Ux)
  })

\func PrecoverTransfer {X : \Set} {Y : PrecoverSpace} (f : X -> Y) : PrecoverSpace X \cowith
  | isCauchy C => ∃ (D : Set (Set Y)) (Y.isCauchy D) (\Pi {V : Set Y} -> D V -> ∃ (U : C) (f ^-1 V ⊆ U))
  | cauchy-cover (inP (D,Dc,d)) x =>
    \have | (inP (V,DV,Vfx)) => cauchy-cover Dc (f x)
          | (inP (U,CU,p)) => d DV
    \in inP (U, CU, p Vfx)
  | cauchy-top => inP (single top, cauchy-top, \lam p => rewriteI p $ inP (top,idp,<=-refl))
  | cauchy-extend (inP (D,Dc,d)) e => inP (D, Dc, \lam DV =>
      \have | (inP (U,CU,p)) => d DV
            | (inP (W,DW,q)) => e CU
      \in inP (W, DW, p <=∘ q))
  | cauchy-trans {C} {D} (inP (C',C'c,C'e)) d =>
    \have t => Y.cauchy-trans {C'} {\lam c' V => ∃ (c : Set X) (C c) (f ^-1 c' <= c) (D' : Set (Set Y)) (isCauchy D') (\Pi {W : Set Y} -> D' W -> ∃ (U' : D c) (f ^-1 W ⊆ U')) (D' V)} C'c \lam {V} C'V =>
                \have | (inP (U,CU,p)) => C'e C'V
                      | (inP (D',D'c,D'e)) => d CU
                \in cauchy-subset D'c \lam {V} D'V => later $ inP (U,CU,p,D',D'c,D'e,D'V)
    \in inP (_, t, \lam (inP (U, V, C'U, inP (c,Cc,q,D',D'c,D'e,D'V), W=UV)) => \case D'e D'V \with {
      | inP (d,Dd,s) => inP (c ∧ d, inP (c, d, Cc, Dd, idp), rewrite W=UV \lam e => (q e.1, s e.2))
    })

\lemma PrecoverTransfer-map {X : \Set} {Y : PrecoverSpace} {f : X -> Y} : CoverMap (PrecoverTransfer f) Y f \cowith
  | func-cover {D} Dc => inP (D, Dc, \lam {V} DV => inP (f ^-1 V, inP (V, DV, idp), <=-refl))

\lemma PrecoverTransfer-char {X Y : PrecoverSpace} {f : CoverMap X Y} {C : Set (Set X)} (c : isCauchy {PrecoverTransfer f} C) : X.isCauchy C \elim c
  | inP (D,Dc,De) => cauchy-extend (f.func-cover Dc) \lam {U} (inP (V,DV,p)) => \case De DV \with {
    | inP (U',CU',q) => inP (U', CU', rewrite p q)
  }

\func ClosurePrecoverSpace {X : \Set} (A : Set (Set X) -> \Prop) (CA : \Pi {C : Set (Set X)} -> A C -> \Pi (x : X) -> ∃ (U : C) (U x)) : PrecoverSpace X \cowith
  | isCauchy => Closure A
  | cauchy-cover => closure-covers CA
  | cauchy-top => closure-top idp
  | cauchy-extend => closure-extends
  | cauchy-trans => closure-trans __ __ idp
  \where {
    \truncated \data Closure (A : Set (Set X) -> \Prop) (C : Set (Set X)) : \Prop
      | closure (A C)
      | closure-top (C = single top)
      | closure-extends {D : Set (Set X)} (Closure A D) (\Pi {U : Set X} -> D U -> ∃ (V : Set X) (C V) (U ⊆ V))
      | closure-trans {D : Set (Set X)} (Closure A D) {E : \Pi (U : Set X) -> Set (Set X)} (\Pi {U : Set X} -> D U -> Closure A (E U))
                      (C = \lam U => ∃ (V W : Set X) (D V) (E V W) (U = V ∧ W))

    \lemma closure-covers {A : Set (Set X) -> \Prop} (CA : \Pi {C : Set (Set X)} -> A C -> \Pi (x : X) -> ∃ (U : C) (U x)) {C : Set (Set X)} (CC : Closure A C) (x : X) : ∃ (U : C) (U x) \elim CC
      | closure AC => CA AC x
      | closure-top idp => inP (top, idp, ())
      | closure-extends {D} CD e =>
        \have | (inP (U,DU,Ux)) => closure-covers CA CD x
              | (inP (V,CV,U<=V)) => e DU
        \in inP (V, CV, U<=V Ux)
      | closure-trans {D} CD {E} CE idp =>
        \have | (inP (U,DU,Ux)) => closure-covers CA CD x
              | (inP (V,EV,Vx)) => closure-covers CA (CE DU) x
        \in inP (U ∧ V, inP (U, V, DU, EV, idp), (Ux,Vx))

    \lemma closure-cauchy {S : PrecoverSpace X} {A : Set (Set X) -> \Prop} (AS : \Pi {C : Set (Set X)} -> A C -> S.isCauchy C) {C : Set (Set X)} (CC : Closure A C) : S.isCauchy C \elim CC
      | closure AC => AS AC
      | closure-top p => rewrite p cauchy-top
      | closure-extends CD e => cauchy-extend (closure-cauchy AS CD) e
      | closure-trans CD CE idp => S.cauchy-trans-dep (closure-cauchy AS CD) \lam DU => closure-cauchy AS (CE DU)
  }

\instance PrecoverLattice (X : \Set) : CompleteLattice (PrecoverSpace X)
  | <= A B => \Pi {C : Set (Set X)} -> isCauchy {A} C -> isCauchy {B} C
  | <=-refl c => c
  | <=-transitive f g c => g (f c)
  | <=-antisymmetric f g => exts \lam C => ext (f,g)
  | top => DiscreteCover X
  | top-univ {A} c => cauchy-cover {A} c
  | Join {J} f => ClosurePrecoverSpace (\lam C => (C = single top) || (\Sigma (j : J) (isCauchy {f j} C)))
      \lam e x => \case \elim e \with {
        | byLeft C=t => inP (top, transportInv {Set (Set X)} (__ top) C=t idp, ())
        | byRight (j,Cc) => cauchy-cover Cc x
      }
  | Join-cond j Cc => closure $ byRight (j,Cc)
  | Join-univ {J} {f} {A} e => closure-cauchy $ later \case \elim __ \with {
    | byLeft p => rewrite p cauchy-top
    | byRight (j,Cc) => e j Cc
  }

\func CoverTransfer {X : \Set} {Y : CoverSpace} (f : X -> Y) : CoverSpace X \cowith
  | PrecoverSpace => PrecoverTransfer f
  | isRegular (inP (D,Dc,De)) => inP (_, Y.isRegular Dc, \lam {V} (inP (U,DU,V<=<U)) => inP (f ^-1 V, \case De DU \with {
    | inP (U',CU',p) => inP (U', CU', <=<-left (later $ inP (_, V<=<U, \lam {W} g => inP (f ^-1 W, \lam (x,s) {_} => g (f x, s), <=-refl))) p)
  }, <=-refl))

\func ClosureCoverSpace {X : \Set} (A : Set (Set X) -> \Prop)
                        (CA : \Pi {C : Set (Set X)} -> A C -> \Pi (x : X) -> ∃ (U : C) (U x))
                        (AS : \Pi {C : Set (Set X)} -> A C -> Closure A \lam V => ∃ (U : C) (Closure A \lam W => Given (V ∧ W) -> W ⊆ U))
  : CoverSpace X \cowith
  | PrecoverSpace => ClosurePrecoverSpace A CA
  | isRegular => closure-regular \lam AC => closure-extends (AS AC) \lam {V} (inP (U,CU,c)) => inP (V, inP (U, CU, c), <=-refl)
  \where {
    \lemma closure-regular {S : PrecoverSpace X} {A : Set (Set X) -> \Prop} (AS : \Pi {C : Set (Set X)} -> A C -> Closure A \lam V => ∃ (U : C) (V <=< U)) {C : Set (Set X)} (CC : Closure A C)
      : Closure A (\lam V => ∃ (U : C) (V <=< U)) \elim CC
      | closure AC => AS AC
      | closure-top idp => closure-extends (closure-top idp) \lam p => inP (top, inP (top, idp, <=<_top), \lam _ => ())
      | closure-extends CD e => closure-extends (closure-regular AS CD) \lam {V} (inP (U,DU,V<=<U)) => \case e DU \with {
        | inP (W,CW,U<=W) => inP (V, inP (W, CW, <=<-left V<=<U U<=W), <=-refl)
      }
      | closure-trans {D} CD {E} CE idp => closure-extends
          (closure-trans (closure-regular AS CD) {\lam U V => ∃ (U' : Set X) (D U') (U <=< U') (V' : E U') (V <=< V')}
              (\lam (inP (U',DU',U<=<U')) => closure-extends (closure-regular AS (CE DU')) \lam {V} (inP (V',EV',V<=<V')) => inP (V, inP (U', DU', U<=<U', V', EV', V<=<V'), <=-refl)) idp)
          \lam {U} (inP (V, W, _, inP (V',DV',V<=<V',W',EW',W<=<W'), U=VW)) => inP (U, inP (V' ∧ W', inP (V',W',DV',EW',idp), rewrite U=VW $ <=<_meet V<=<V' W<=<W'), <=-refl)
  }

\func interClosureCoverSpace {X : \Set} (A : Set (Set X) -> \Prop)
                             (CA : \Pi {C : Set (Set X)} -> A C -> \Pi (x : X) -> ∃ (U : C) (U x))
                             (AI : \Pi {C : Set (Set X)} -> A C -> ∃ (D : A) (∀ {V : D} (∃ (U : C) (∀ {V' : D} (Given (V ∧ V') -> V' ⊆ U)))))
  => ClosureCoverSpace A CA \case AI __ \with {
    | inP (D,AD,f) => closure-extends (closure AD) \case f __ \with {
      | inP (V,CV,g) => inP (_, inP (V, CV, closure-extends (closure AD) \lam {W} DW => inP (W, g DW, <=-refl)), <=-refl)
    }
  }

\instance CoverLattice (X : \Set) : CompleteLattice (CoverSpace X)
  | <= A B => \Pi {C : Set (Set X)} -> isCauchy {A} C -> isCauchy {B} C
  | <=-refl c => c
  | <=-transitive f g c => g (f c)
  | <=-antisymmetric f g => exts \lam C => ext (f,g)
  | top => DiscreteCover X
  | top-univ {A} c => cauchy-cover {A} c
  | Join f => \new CoverSpace {
    | PrecoverSpace => Join {PrecoverLattice X} f
    | isRegular => closure-regular \lam {C} => later \case \elim __ \with {
      | byLeft p => rewrite p $ closure-extends (closure $ byLeft idp) \lam q => rewriteI q $ inP (top, inP (top, idp, <=<_top), <=-refl)
      | byRight (j,Cc) => closure $ byRight (j, cauchy-subset (isRegular {f j} Cc) $ later \lam {U} (inP (V,CV,U<=<V)) => inP (V, CV, Join-cond {PrecoverLattice X} j {f} U<=<V))
    }
  }
  | Join-cond j {f} => Join-cond {PrecoverLattice X} j
  | Join-univ => Join-univ {PrecoverLattice X}
  \where {
    \lemma closure-regular {S : PrecoverSpace X} {A : Set (Set X) -> \Prop} (AS : \Pi {C : Set (Set X)} -> A C -> Closure A \lam V => ∃ (U : C) (V <=< U)) {C : Set (Set X)} (CC : Closure A C)
      : Closure A (\lam V => ∃ (U : C) (V <=< U)) \elim CC
      | closure AC => AS AC
      | closure-top idp => closure-extends (closure-top idp) \lam p => inP (top, inP (top, idp, <=<_top), \lam _ => ())
      | closure-extends CD e => closure-extends (closure-regular AS CD) \lam {V} (inP (U,DU,V<=<U)) => \case e DU \with {
        | inP (W,CW,U<=W) => inP (V, inP (W, CW, <=<-left V<=<U U<=W), <=-refl)
      }
      | closure-trans {D} CD {E} CE idp => closure-extends
          (closure-trans (closure-regular AS CD) {\lam U V => ∃ (U' : Set X) (D U') (U <=< U') (V' : E U') (V <=< V')}
            (\lam (inP (U',DU',U<=<U')) => closure-extends (closure-regular AS (CE DU')) \lam {V} (inP (V',EV',V<=<V')) => inP (V, inP (U', DU', U<=<U', V', EV', V<=<V'), <=-refl)) idp)
          \lam {U} (inP (V, W, _, inP (V',DV',V<=<V',W',EW',W<=<W'), U=VW)) => inP (U, inP (V' ∧ W', inP (V',W',DV',EW',idp), rewrite U=VW $ <=<_meet V<=<V' W<=<W'), <=-refl)
  }

\func RegPrecoverSpace (X : PrecoverSpace) : CoverSpace X
  => CompleteLattice.SJoin {CoverLattice X} \lam A => A <= {PrecoverLattice X} X

\func regPrecoverSpace {X : PrecoverSpace} : CoverMap X (RegPrecoverSpace X) \cowith
  | func x => x
  | func-cover d => CompleteLattice.SJoin-univ {PrecoverLattice X} {\lam A => A <= {PrecoverLattice X} X} (\lam p => p) $
      transport (isCauchy {RegPrecoverSpace X}) (ext \lam U => ext (\lam DU => inP (U, DU, idp), \lam (inP (V,DV,U=V)) => rewrite U=V DV)) d

\lemma regPrecoverSpace-extend {X : PrecoverSpace} {Y : CoverSpace} (f : CoverMap X Y) : CoverMap (RegPrecoverSpace X) Y f \cowith
  | func-cover {D} Dc => CompleteLattice.SJoin-cond {CoverLattice X} {\lam A => A <= {PrecoverLattice X} X} {CoverTransfer f} PrecoverTransfer-char $
      inP (D, Dc, \lam {V} DV => inP (f ^-1 V, inP (V, DV, idp), <=-refl))