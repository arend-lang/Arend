\import Algebra.Meta
\import Arith.Nat
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Operations
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.CoverSpace
\import Topology.CoverSpace.Complete
\open Bounded(top)
\open Set

\instance NatCoverSpace : CompletelyRegularCoverSpace Nat
  => UniformlyCoverSpace {
      \new PrecoverSpace Nat {
        | isCauchy => Cover
        | cauchy-cover (inP (U,CU,N,f,g)) n => \case LinearOrder.dec<_<= n N \with {
          | inl n<N => g n<N
          | inr N<=n => inP (U, CU, f N<=n)
        }
        | cauchy-top => inP (top, idp, 0, \lam _ => (), \case __)
        | cauchy-extend (inP (U,CU,N,f,g)) e => \case e CU \with {
          | inP (V,DV,U<=V) => inP (V, DV, N, \lam N<=n => U<=V $ f N<=n, \lam n<N => \case g n<N \with {
            | inP (U',CU',U'n) => \case e CU' \with {
              | inP (V',DV',U'<=V') => inP (V', DV', U'<=V' U'n)
            }
          })
        }
        | cauchy-trans {C} (inP (U,CU,N,f,g)) e => \case e CU \with {
          | inP (V,DUV,N',f',g') => inP (U ∧ V, inP (U, V, CU, DUV, idp), N ∨ N', \lam p => (f $ join-left <=∘ p, f' $ join-right <=∘ p), \lam {n} _ =>
              \have (inP (U',CU',U'n)) : ∃ (U' : C) (U' n) => \case LinearOrder.dec<_<= n N \with {
                | inl p => g p
                | inr p => inP (U, CU, f p)
              }
              \in \case e CU' \with {
                | inP (V',DU'V',N',f',g') => \case LinearOrder.dec<_<= n N' \with {
                  | inl p => TruncP.map (g' p) \lam (V'',DU'V'',V''n) => (U' ∧ V'', inP (U', V'', CU', DU'V'', idp), (U'n, V''n))
                  | inr p => inP (U' ∧ V', inP (U', V', CU', DU'V', idp), (U'n, f' p))
                }
              })
        }
      }
    } \lam (inP (U,CU,N,f,g)) => inP (_, makeCover N, \lam {V} => \case \elim __ \with {
        | byLeft p => inP (U, CU, \case \elim __ \with {
          | byLeft q => \lam _ => rewrite q \lam N<=x => f N<=x
          | byRight (n,n<N,q) => rewrite (p,q) \lam (x,(p',q')) => absurd linarith
        })
        | byRight (n,n<N,p) => \case g n<N \with {
          | inP (U',CU',U'n) => inP (U', CU', \case \elim __ \with {
            | byLeft q => rewrite (p,q) \lam (x,(p',q')) => absurd linarith
            | byRight (n',n'<N,q) => rewrite (p,q) \lam (x,(p',q')) => rewrite (q', inv p') (single_<= U'n)
          })
        }
      })
\where {
  \func Cover (C : Set (Set Nat)) : \Prop
    => ∃ (U : C) (N : Nat) (\Pi {n : Nat} -> N <= n -> U n) (\Pi {n : Nat} -> n < N -> ∃ (V : C) (V n))

  \lemma makeCover (N : Nat) : Cover \lam U => (U = (N <=)) || (\Sigma (n : Nat) (n < N) (U = single n))
    => inP (N <=, byLeft idp, N, \lam p => p, \lam {n} p => inP (single n, byRight (n, p, idp), idp))

  \func atTop : CauchyFilter NatCoverSpace \cowith
    | F U => ∃ (N : Nat) ∀ {n} (N <= n -> U n)
    | filter-mono p (inP (N,f)) => inP (N, \lam q => p $ f q)
    | filter-top => inP (0, \lam _ => ())
    | filter-meet (inP (N,f)) (inP (M,g)) => inP (N ∨ M, \lam p => (f $ join-left <=∘ p, g $ join-right <=∘ p))
    | isProper (inP (N,f)) => inP (N, f <=-refl)
    | isCauchyFilter (inP (U,CU,N,f,g)) => inP (U, CU, inP (N, f))
}

\func IsConvergent {X : PrecoverSpace} (f : Nat -> X) : \Prop
  => CoverMap NatCoverSpace X f

\lemma convergent-char {X : PrecoverSpace} {f : Nat -> X} (p : ∀ {C : X.isCauchy} ∃ (U : C) (N : Nat) ∀ {n} (N <= n -> U (f n))) : IsConvergent f \cowith
  | func-cover Dc => \case p Dc \with {
    | inP (U,DU,N,g) => inP (_, inP (U, DU, idp), N, g, \lam {n} _ => \case cauchy-cover Dc (f n) \with {
      | inP (V,DV,Vfn) => inP (_, inP (V, DV, idp), Vfn)
    })
  }
  \where
    \protected \lemma conv {X : PrecoverSpace} {f : Nat -> X} (fc : IsConvergent f) : ∀ {C : X.isCauchy} ∃ (U : C) (N : Nat) ∀ {n} (N <= n -> U (f n))
      => \case fc.func-cover __ \with {
        | inP (U, inP (V,CV,p), N, f, g) => inP (V, CV, N, \lam q => rewriteF p (f q))
      }

\func seqLimit {X : CompleteCoverSpace} (f : CoverMap NatCoverSpace X) : X
  => X.filter-point $ CF-map f NatCoverSpace.atTop

\func IsUniFuncConvergent {X : \Set} {Y : PrecoverSpace} (f : Nat -> X -> Y) : \Prop
  => ∀ {D : Y.isCauchy} ∃ (V : D) (N : Nat) ∀ {n} {x} (N <= n -> V (f n x))

\func IsFuncConvergent {X Y : PrecoverSpace} (f : Nat -> X -> Y) : \Prop
  => CoverMap (NatCoverSpace ⨯ X) Y \lam s => f s.1 s.2

\lemma funcCovergent-cover {X Y : PrecoverSpace} (f : Nat -> CoverMap X Y)
                           (fc : ∀ {D : Y.isCauchy} (X.isCauchy \lam U => ∃ (N : Nat) (V : D) ∀ {n} {x} (N <= n -> U x -> V (f n x))))
  : IsFuncConvergent (\lam n => f n)
  => generalized (f __) \lam Dc => cauchy-subset (fc Dc) \lam (inP (N,V,DV,h)) => inP $ later (N, V, DV, h, \lam {n} _ => func-cover {f n} Dc)
  \where
    -- | A slightly more general version of the lemma
    \lemma generalized {X Y : PrecoverSpace} (f : Nat -> X -> Y) (fc : ∀ {D : Y.isCauchy} (X.isCauchy \lam U => ∃ (N : Nat) (V : D) (\Pi {n : Nat} {x : X} -> N <= n -> U x -> V (f n x)) (\Pi {n : Nat} -> n < N -> X.isCauchy \lam U => ∃ (V : D) (U = f n ^-1 V)))) : IsFuncConvergent f \cowith
      | func-cover {D} Dc =>
        \have t => cauchy-trans {ProductPrecoverSpace NatCoverSpace X} (ProductPrecoverSpace.prodCover cauchy-top (fc Dc))
                    {\lam U V => ∃ (U' : Set X) (N : Nat) (W : D) (\Pi {n : Nat} {x : X} -> N <= n -> U' x -> W (f n x)) (\Pi {n : Nat} -> n < N -> X.isCauchy \lam U => ∃ (V : D) (U = f n ^-1 V)) (U = (\lam s => s.2) ^-1 U') ((V = (\lam s => s.1) ^-1 (N <=)) || Given (n : Nat) (n < N) (V' : D) ∀ {s : V} (V' (f s.1 s.2)))}
                    \lam {W} => \case \elim __ \with {
                      | inP (_, idp, V, inP (N,V',DV',g,h), p) => cauchy-extend {ProductPrecoverSpace NatCoverSpace X} (ProductPrecoverSpace.prodCover (later $ NatCoverSpace.makeCover N) $ cauchy-array-inter \new Array _ N \lam j => later (_, h $ fin_< j)) \lam {W'} => later \case \elim __ \with {
                        | inP (U1, byLeft q, V1, inP (Us,Ush,Usp), q1) => inP (_, inP (V, N, V', DV', g, h, p *> ext \lam s => ext (__.2, \lam c => ((),c)), byLeft idp), rewrite (q1,q) __.1)
                        | inP (U1, byRight (n,n<N,q), V1, inP (Us,Ush,Usp), q1) => \case Ush (toFin n n<N) \with {
                          | inP (V'',DV'',p'') => inP (W', inP (V, N, V', DV', g, h, p *> ext \lam s => ext (__.2, \lam c => ((),c)), byRight (n, n<N, V'', DV'', rewrite (q1,q,Usp) \lam (c,d) => rewriteI c $ rewriteF (p'',toFin=id) $ MeetSemilattice.Big_meet-cond {_} {_} {top :: Us} {suc (toFin n n<N)} d)), <=-refl)
                        }
                      }
                    }
        \in cauchy-extend {ProductPrecoverSpace NatCoverSpace X} t \lam {W} => hiding t \case \elim __ \with {
              | inP (U, V, _, inP (U', N, V', DV', g, h, q1, byLeft q2), p) => inP (_, inP (V',DV',idp), rewrite (p,q1,q2) \lam (c,d) => g d c)
              | inP (U, V, _, inP (U', N, _, _, g, h, q1, byRight (n,n<N,V',DV',q2)), p) => inP (_, inP (V', DV', idp), rewrite (p,q1) \lam s => q2 s.2)
            }

\lemma funcCovergent-uni {X Y : PrecoverSpace} (f : Nat -> CoverMap X Y) (fc : IsUniFuncConvergent \lam n => f n) : IsFuncConvergent \lam n => f n
  => funcCovergent-cover f \lam Dc => \case fc Dc \with {
    | inP (V,DV,N,h) => top-cauchy $ inP $ later (N, V, DV, \lam p _ => h p)
  }

\func seqFuncLimit {X : CoverSpace} {Y : CompleteCoverSpace} (f : Nat -> X -> Y) (fc : IsFuncConvergent f) (x : X) : Y
  => Y.filter-point $ CF-map fc $ prodCF NatCoverSpace.atTop (pointCF x)