\import Algebra.Group
\import Arith.Nat
\import Arith.Rat
\import Arith.Real
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Operations
\import Order.Lattice
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Fin
\import Set.Subset
\import Topology.CoverSpace
\import Topology.CoverSpace.Complete
\import Topology.CoverSpace.Product
\import Topology.MetricSpace
\import Topology.MetricSpace.Nat
\import Topology.TopAbGroup
\import Topology.UniformSpace
\open Bounded(top)

\func IsConvergent {X : CoverSpace} (f : Nat -> X) : \Prop
  => CoverMap NatMetricSpace X f

\lemma convergent-char {X : CoverSpace} {f : Nat -> X} (p : ∀ {C : X.isCauchy} ∃ (U : C) (N : Nat) ∀ {n} (N <= n -> U (f n))) : IsConvergent f \cowith
  | func-cover Dc => \case p Dc \with {
    | inP (U,DU,N,g) => NatMetricSpace.cauchy-char.2 \case FinSet.finiteAC {N} (\lam j => cauchy-cover Dc (f j)) \with {
      | inP h => inP (_, inP $ later (U, DU, idp), N, g, \lam j => (_, inP $ later ((h j).1, (h j).2, idp), later (h j).3))
    }
  }
  \where
    \protected \lemma conv {X : CoverSpace} {f : Nat -> X} (fc : IsConvergent f) : ∀ {C : X.isCauchy} ∃ (U : C) (N : Nat) ∀ {n} (N <= n -> U (f n))
      => \lam Cc => \case NatMetricSpace.cauchy-char.1 $ fc.func-cover Cc \with {
        | inP (U, inP (V,CV,p), N, f, g) => inP (V, CV, N, \lam q => rewrite p in f q)
      }

\lemma convergent-uniform-char {X : UniformSpace} {f : Nat -> X} (p : ∀ {C : X.isUniform} ∃ (U : C) (N : Nat) ∀ {n} (N <= n -> U (f n))) : IsConvergent f
  => \new UniformMap {
    | func-uniform Eu => \case p Eu \with {
      | inP (U,DU,N,g) => NatMetricSpace.uniform-char.2 \case FinSet.finiteAC {N} (\lam j => uniform-cover Eu (f j)) \with {
        | inP h => inP (_, inP $ later (U, DU, idp), N, g, \lam j => (_, inP $ later ((h j).1, (h j).2, idp), later (h j).3))
      }
    }
  }
  \where
    \protected \lemma conv {X : UniformSpace} {f : Nat -> X} (fc : IsConvergent f) : ∀ {C : X.isUniform} ∃ (U : C) (N : Nat) ∀ {n} (N <= n -> U (f n))
      => \lam Cu => convergent-char.conv fc $ X.uniform-cauchy.2 $ ClosurePrecoverSpace.closure Cu

\lemma convergent-topAbGruop-char {X : TopAbGroup} {f : Nat -> X} : TFAE (
    IsConvergent f,
    ∀ {U : X.isOpen} (U 0) ∃ (x : X) (N : Nat) ∀ {n} (N <= n -> U (x - f n)),
    ∀ {U : X.isOpen} (U 0) ∃ (N : Nat) ∀ {n m} (N <= n -> N <= m -> U (f n - f m))
  ) => TFAE.cycle (
    \lam fc Uo U0 => \case convergent-uniform-char.conv fc (X.makeUniform Uo U0) \with {
      | inP (_, inP (x, idp), N, h) => inP (x, N, h)
    },
    \lam fc {U} Uo U0 => \case X.shrink Uo U0 \with {
      | inP (V,Vo,V0,g) => \case fc Vo V0 \with {
        | inP (x,N,h) => inP (N, \lam p q => transport U X.diff-cancel-left $ g (h q) (h p))
      }
    },
    \lam fc => convergent-uniform-char \lam Cu => \case neighborhood-uniform.1 Cu \with {
      | inP (U,Uo,U0,h) => \case fc Uo U0 \with {
        | inP (N,g) => \case h (f N) \with {
          | inP (V,CV,UV) => inP (V, CV, N, \lam p => UV $ g <=-refl p)
        }
      }
    }
)

\lemma convergent-metric-char {X : MetricSpace} {f : Nat -> X} : TFAE (
    {- 0 -} IsConvergent f,
    {- 1 -} ∀ {eps : Real} (0 < eps) ∃ (x : X) (N : Nat) ∀ {n} (N <= n -> dist x (f n) < eps),
    {- 2 -} ∀ {eps : Real} (0 < eps) ∃ (N : Nat) ∀ {n m} (N <= n -> N <= m -> dist (f n) (f m) < eps),
    {- 3 -} ∀ {eps : Rat} (0 < eps) ∃ (x : X) (N : Nat) ∀ {n} (N <= n -> dist x (f n) < eps),
    {- 4 -} ∀ {eps : Rat} (0 < eps) ∃ (N : Nat) ∀ {n m} (N <= n -> N <= m -> dist (f n) (f m) < eps)
  ) => TFAE.proof (
    ((0,1), \lam fc eps>0 => \case convergent-uniform-char.conv fc (X.makeUniform eps>0) \with {
      | inP (_, inP (x, idp), N, h) => inP (x, N, h)
    }),
    ((1,2), \lam fc eps>0 => \case fc (RealAbGroup.half>0 eps>0) \with {
      | inP (x,N,h) => inP (N, \lam p q => PseudoMetricSpace.halving (h p) (h q))
    }),
    ((2,0), \lam fc => convergent-uniform-char \lam Cu => \case dist-uniform.1 Cu \with {
      | inP (eps,eps>0,h) => \case fc eps>0 \with {
        | inP (N,g) => \case h (f N) \with {
          | inP (V,CV,dV) => inP (V, CV, N, \lam p => dV $ g <=-refl p)
        }
      }
    }),
    ((1,3), \lam fc eps>0 => fc $ real_<_L.2 eps>0),
    ((3,1), \lam fc eps>0 => \case real_<-char.1 eps>0 \with {
      | inP (eps',eps'>0,eps'<eps) => \case fc eps'>0 \with {
        | inP (x,N,h) => inP (x, N, \lam p => h p <∘ real_<_L.2 eps'<eps)
      }
    }),
    ((2,4), \lam fc eps>0 => fc $ real_<_L.2 eps>0),
    ((4,2), \lam fc eps>0 => \case real_<-char.1 eps>0 \with {
      | inP (eps',eps'>0,eps'<eps) => \case fc eps'>0 \with {
        | inP (N,g) => inP (N, \lam p q => g p q <∘ real_<_L.2 eps'<eps)
      }
    })
  )

\func seqLimit {X : CompleteCoverSpace} (f : CoverMap NatMetricSpace X) : X
  => X.filter-point $ f.func-cauchy atTop

\func IsUniFuncConvergent {X : \Set} {Y : CoverSpace} (f : Nat -> X -> Y) : \Prop
  => ∀ {D : Y.isCauchy} ∃ (V : D) (N : Nat) ∀ {n} {x} (N <= n -> V (f n x))

\func IsFuncConvergent {X Y : CoverSpace} (f : Nat -> X -> Y) : \Prop
  => CoverMap (NatMetricSpace ⨯ X) Y \lam s => f s.1 s.2

\lemma funcCovergent-cover {X Y : CoverSpace} (f : Nat -> CoverMap X Y)
                           (fc : ∀ {D : Y.isCauchy} (X.isCauchy \lam U => ∃ (N : Nat) (V : D) ∀ {n} {x} (N <= n -> U x -> V (f n x))))
  : IsFuncConvergent (\lam n => f n)
  => generalized (f __) \lam Dc => cauchy-subset (fc Dc) \lam (inP (N,V,DV,h)) => inP $ later (N, V, DV, h, \lam {n} _ => func-cover {f n} Dc)
  \where
    -- | A slightly more general version of the lemma
    \lemma generalized {X Y : CoverSpace} (f : Nat -> X -> Y) (fc : ∀ {D : Y.isCauchy} (X.isCauchy \lam U => ∃ (N : Nat) (V : D) (\Pi {n : Nat} {x : X} -> N <= n -> U x -> V (f n x)) (\Pi {n : Nat} -> n < N -> X.isCauchy \lam U => ∃ (V : D) (U = f n ^-1 V)))) : IsFuncConvergent f \cowith
      | func-cover {D} Dc =>
        \have t => cauchy-trans {ProductCoverSpace NatMetricSpace X} (ProductCoverSpace.prodCover cauchy-top (fc Dc))
                    {\lam U V => ∃ (U' : Set X) (N : Nat) (W : D) (\Pi {n : Nat} {x : X} -> N <= n -> U' x -> W (f n x)) (\Pi {n : Nat} -> n < N -> X.isCauchy \lam U => ∃ (V : D) (U = f n ^-1 V)) (U = (\lam s => s.2) ^-1 U') ((V = (\lam s => s.1) ^-1 (N <=)) || Given (n : Nat) (n < N) (V' : D) ∀ {s : V} (V' (f s.1 s.2)))}
                    \lam {W} => \case __ \with {
                      | inP (_, idp, V, inP (N,V',DV',g,h), p) => cauchy-refine {ProductCoverSpace NatMetricSpace X} (ProductCoverSpace.prodCover (later $ NatMetricSpace.makeCover N) $ cauchy-array-inter \new Array _ N \lam j => later (_, h $ fin_< j)) \lam {W'} => later \case __ \with {
                        | inP (U1, byLeft q, V1, inP (Us,Ush,Usp), q1) => inP (_, inP (V, N, V', DV', g, h, p *> ext \lam s => ext (__.2, \lam c => ((),c)), byLeft idp), rewrite (q1,q) __.1)
                        | inP (U1, byRight (n,n<N,q), V1, inP (Us,Ush,Usp), q1) => \case Ush (toFin n n<N) \with {
                          | inP (V'',DV'',p'') => inP (W', inP (V, N, V', DV', g, h, p *> ext \lam s => ext (__.2, \lam c => ((),c)), byRight (n, n<N, V'', DV'', rewrite (q1,q,Usp) \lam (c,d) => rewriteI c $ rewrite (p'',toFin=id) in MeetSemilattice.Big_meet-cond {_} {_} {top :: Us} {suc (toFin n n<N)} d)), <=-refl)
                        }
                      }
                    }
        \in cauchy-refine {ProductCoverSpace NatMetricSpace X} t \lam {W} => hiding t \case __ \with {
              | inP (U, V, _, inP (U', N, V', DV', g, h, q1, byLeft q2), p) => inP (_, inP (V',DV',idp), rewrite (p,q1,q2) \lam (c,d) => g d c)
              | inP (U, V, _, inP (U', N, _, _, g, h, q1, byRight (n,n<N,V',DV',q2)), p) => inP (_, inP (V', DV', idp), rewrite (p,q1) \lam s => q2 s.2)
            }

\lemma funcCovergent-uni {X Y : CoverSpace} (f : Nat -> CoverMap X Y) (fc : IsUniFuncConvergent \lam n => f n) : IsFuncConvergent \lam n => f n
  => funcCovergent-cover f \lam Dc => \case fc Dc \with {
    | inP (V,DV,N,h) => top-cauchy $ inP $ later (N, V, DV, \lam p _ => h p)
  }

\func seqFuncLimit {X : CoverSpace} {Y : CompleteCoverSpace} (f : Nat -> X -> Y) (fc : IsFuncConvergent f) (x : X) : Y
  => Y.filter-point $ fc.func-cauchy $ prodCF atTop (pointCF x)