\import Category
\import Category.Functor
\import Data.Bool
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set.Filter
\import Set.Subset
\import Topology.CoverSpace
\import Topology.CoverSpace.Category
\import Topology.Locale \hiding (<=<_<=, func-cover)
\import Topology.Locale.Points
\import Topology.RatherBelow
\open Bounded(top,top-univ,bottom,bottom-univ)
\open LocalePrecoverSpace
\open Set
\open RatherBelow

\func CoverSpaceLocale (X : PrecoverSpace) : Locale
  => PresentedFrame (framePres {X})
  \where {
    \open PresentedFrame

    \func framePres {X : PrecoverSpace} : FramePres (Set X) \cowith
      | conj => ∧
      | BasicCover {J} U f => Given (U = {Set X} top) (C : X.isCauchy) (∀ {V : C} ∃ (j : J) (f j = V)) || (\Pi {V : Set X} -> V s<=< U -> ∃ (j : J) (f j = V)) || (U = {Set X} bottom)

    \lemma cover-cauchy {X : PrecoverSpace} {C : Set (Set X)} (Cc : isCauchy C) : FramePres.SCover {framePres} top C
      => cover-basic $ byLeft (idp, C, Cc, \lam {V} CV => inP ((V,CV), idp))

    \lemma cover-reg {X : PrecoverSpace} {U : Set X} : FramePres.SCover U \lam V => V s<=< U
      => cover-trans (cover-basic {framePres} {U} {\Sigma (V : Set X) (V s<=< U)} $ byRight $ byLeft \lam p => inP ((_, p), idp)) \lam s => cover-inj s idp

    \lemma cover-creg {X : CompletelyStronglyRegularCoverSpace} {U : Set X} : FramePres.SCover {framePres} U \lam V => V <=<c U
      => cover-trans cover-reg \lam (V,V<=<U) => unfolds at V<=<U $ cover-trans (Cover.cover-trans1 (Cover.cover_<= $ meet-univ <=-refl top-univ) $ cover-ldistr idp (cover-cauchy $ isCompletelyStronglyRegular V<=<U) \lam _ => idp) \case \elim __ \with {
        | (W, inP (_, byLeft idp, W<=<nV)) => cover-inj (_, Interpolative.<=<-right (later \lam (Vx,Wx) => absurd $ s<=<_<= (<=<c_<=< W<=<nV) Wx Vx) $ <=<c_bottom s<=<_bottom) idp
        | (W, inP (_, byRight idp, W<=<U)) => cover-inj (_, Interpolative.<=<-right (later __.2) W<=<U) idp
      }

    \lemma cover-empty {X : PrecoverSpace} {U : Set X} (Ue : \Pi {x : X} -> Not (U x)) {J : \Set} {g : J -> Set X} : Cover {framePres} U g
      => cover-basic $ byRight $ byRight $ <=-antisymmetric (\lam Ux => absurd $ Ue Ux) bottom-univ

    \lemma embed_<=< {V U : Set X} (V<=<U : V s<=< U) : embed V Locale.<=< {CoverSpaceLocale X} embed U
      => \lam _ => Cover.cover-trans1 Cover.cover_top $ cover-basic $ byLeft
            (idp, _, V<=<U, \case \elim __ \with {
              | byLeft p => inP ((true, _, cover-inj ((embed $ Compl V, rewrite embed_meet $ embed<= $ cover-basic $ byRight $ byRight $ <=-antisymmetric (later \lam (nVx,Vx) => absurd $ nVx Vx) bottom-univ), _, rewrite p $ cover-inj () idp) idp), idp)
              | byRight p => inP ((false, _, rewrite p $ cover-inj () idp), idp)
            })

    \lemma regular : Locale.isRegular {CoverSpaceLocale X}
      => regular-fromPres \lam U => cover-basic $ byRight $ byLeft $ later \lam {V} V<=<U => inP ((V, embed_<=< V<=<U), idp)

    \lemma cover-char {X : StronglyRegularCoverSpace} {U : Set X} {J : \Set} {g : J -> Set X} (c : Cover {framePres} U g) {U' : Set X} (U'<=<U : U' s<=< U)
      : X.isCauchy \lam V => (V = Compl U') || (\Sigma (j : J) (g j = V)) \elim c
      | cover-basic (byLeft (p,C,Cc,h)) => cauchy-subset Cc \case h __ \with {
        | inP r => byRight r
      }
      | cover-basic (byRight (byLeft h)) => unfolds at U'<=<U $ cauchy-extend (isStronglyRegular U'<=<U) \lam {V'} (inP (V, e, V'<=<V)) => \case \elim e \with {
        | byLeft p => inP (_, byLeft idp, rewriteF p $ s<=<_<= V'<=<V)
        | byRight p => inP (V', \case h (rewriteF p V'<=<V) \with {
          | inP s => byRight s
        }, <=-refl)
      }
      | cover-basic (byRight (byRight h)) => top-cauchy $ byLeft $ <=-antisymmetric (later \lam _ U'x => \case s<=<_<= (rewriteF h U'<=<U) U'x \with {
        | inP ((),_)
      }) top-univ
      | cover-inj j p => unfolds at U'<=<U $ cauchy-subset U'<=<U \case \elim __ \with {
        | byLeft q => byLeft q
        | byRight q => byRight $ later (j, p *> inv q)
      }
      | cover-trans {I} {f} c d =>
        \have t => cauchy-trans (isStronglyRegular $ cover-char c U'<=<U)
            {\lam U1 V1 => U1 s<=< Compl U' || (\Sigma (i : I) (U1 s<=< f i) ((V1 = Compl U1) || (\Sigma (j : J) (g j = V1))))} \case \elim __ \with {
              | inP (W, byLeft e, W'<=<W) => top-cauchy $ byLeft $ rewriteF e W'<=<W
              | inP (W, byRight (i,fi=W), W'<=<W) => cauchy-subset (cover-char (d i) (rewriteF (inv fi=W) W'<=<W)) \lam e => byRight $ later (i, rewrite fi=W W'<=<W, e)
            }
        \in cauchy-extend t \case \elim __ \with {
          | inP (V, W, inP (U, byLeft e, V<=<U), _, Z=VW) => inP (_, byLeft idp, rewrite Z=VW $ meet-left <=∘ s<=<_<= V<=<U <=∘ Preorder.=_<= e)
          | inP (V, W, inP (U, _, V<=<U), byLeft e2, Z=VW) => inP (_, byLeft idp, rewrite Z=VW $ meet-left <=∘ s<=<_<= e2)
          | inP (V, W, inP (U, _, V<=<U), byRight (i, V<=<fi, byLeft e), Z=VW) => inP (_, byLeft idp, rewrite (Z=VW,e) \lam (Vx,nVx) => absurd $ nVx Vx)
          | inP (V, W, inP (U, _, V<=<U), byRight (i, V<=<fi, byRight (j,gj=W)), Z=VW) => inP (_, byRight (j,idp), rewrite (Z=VW,gj=W) meet-right)
        }
      | cover-proj1 {U1} {U2} p j q => unfolds at U'<=<U $ cauchy-extend U'<=<U \lam {V} => \case \elim __ \with {
        | byLeft r => inP (V, byLeft r, <=-refl)
        | byRight r => inP (U1, byRight (j,q), rewrite (r *> p) meet-left)
      }
      | cover-idemp j p => unfolds at U'<=<U $ cauchy-subset U'<=<U \case \elim __ \with {
        | byLeft r => byLeft r
        | byRight r => byRight $ later (j, p *> MeetSemilattice.meet-idemp *> inv r)
      }
      | cover-comm p j q => unfolds at U'<=<U $ cauchy-subset U'<=<U \case \elim __ \with {
        | byLeft r => byLeft r
        | byRight r => byRight $ later (j, q *> MeetSemilattice.meet-comm *> inv (r *> p))
      }
      | cover-ldistr {W} p c q =>
        \have | t1 => cover-char c (<=<-left U'<=<U $ later $ rewrite p meet-right)
              | t2 : U' s<=< W => <=<-left U'<=<U $ later $ rewrite p meet-left
        \in cauchy-extend (cauchy-inter t1 t2) \case \elim __ \with {
          | inP (V1, V2, byLeft e1, _, r) => inP (_, byLeft idp, rewrite (r,e1) meet-left)
          | inP (V1, V2, _, byLeft e2, r) => inP (_, byLeft idp, rewrite (r,e2) meet-right)
          | inP (_, _, byRight (j,idp), byRight idp, r) => inP (_, byRight (j, idp), rewrite (r, q j) $ Preorder.=_<= MeetSemilattice.meet-comm)
        }

    \lemma cover-point-char {X : StronglyRegularCoverSpace} {U : Set X} {J : \Set} {g : J -> Set X} (c : Cover {framePres} U g) {x : X} (x<=<U : single x <=< U) : ∃ (j : J) (single x <=< g j)
      => \case s<=<-inter x<=<U \with {
        | inP (V,x<=<V,V<=<U) => \case CoverSpace.cauchy-regular-cover (cover-char c V<=<U) x \with {
          | inP (W, byLeft p, x<=<W) => absurd $ <=<_<= (rewriteF p x<=<W) idp $ s<=<_<= x<=<V idp
          | inP (W, byRight (j,p), x<=<W) => inP (j, rewrite p x<=<W)
        }
      }

    \lemma hasDensePoints {X : StronglyRegularCoverSpace} (Xd : X.HasWeaklyDensePoints) : HasDensePoints (CoverSpaceLocale X)
      => hasDensePoints-fromPres \lam {U} p => cover-trans cover-reg \lam (V,V<=<U) => cover-empty \lam {x} Vx => \case p {CoverSpaceLocale-unit Xd x} $ inP (U, cover-inj () idp, <=<-right (single_<= Vx) $ s<=<_<=< V<=<U) \with {
        | inP ((),_)
      }
  }

\func LocalePrecoverSpace (L : Locale) : PrecoverSpace \cowith
  | E => CompleteFilter {L}
  | isCauchy C => top <= Join \lam (s : Given C) => points_* s.1
  | cauchy-cover t x => \case filter-Join $ filter-mono {x} t filter-top \with {
    | inP ((U,CU),c) => \case filter-Join c \with {
      | inP ((a,p),xa) => inP (U, CU, p xa)
    }
  }
  | cauchy-top => Join-cond (later (top,top-univ)) <=∘ Join-cond (later (top, idp))
  | cauchy-extend p e => p <=∘ Join-univ \lam (U,CU) => \case e CU \with {
    | inP (V,DV,U<=V) => points_*-mono U<=V <=∘ Join-cond (later (V,DV))
  }
  | cauchy-trans p e => p <=∘ Join-univ \lam (U,CU) => meet-univ <=-refl top-univ <=∘ MeetSemilattice.meet-monotone <=-refl (e CU) <=∘
      Join-ldistr>= <=∘ Join-univ \lam (V,DUV) => transport (`<= _) points_*_meet $ Join-cond $ later (U ∧ V, inP (U, V, CU, DUV, idp))
  \where {
    \lemma points_<=< {a : L} {U : Set (CompleteFilter {L})} (p : a L.<=< points_* U) : points^* a s<=< {LocalePrecoverSpace L} U
      => unfolds $ p <=∘ join-univ (points^*-points_* (\lam {x} xna xa => CompleteFilter.isProper {x} $ filter-mono L.eval $ filter-meet xna xa) <=∘ Join-cond (later (_, byLeft idp))) (Join-cond $ later (_, byRight idp))

    \lemma cover-cauchy {C : Set L} (p : top <= L.SJoin C) : isCauchy {LocalePrecoverSpace L} \lam U => ∃ (a : C) (points^* a = U)
      => p <=∘ Join-univ \lam (a,Ca) => points-unit <=∘ Join-cond (later (_, inP (a, Ca, idp)))
  }

\func CoverSpaceLocaleFunctor : Functor CompletelyStronglyRegularCoverSpaceCat LocaleCat \cowith
  | F X => CoverSpaceLocale X
  | Func f => adjointMap (framePresHom f)
  | Func-id {X} => func-equality_ext \lam V => adjointMap_embed (framePresHom (id X)) _ *> <=-antisymmetric
      (Join-univ {_} {_} {\lam s => embed s.1} \lam (V',V'<=<V) => embed<= $ cover-inj (_, Cover.cover_<= $ s<=<_<= $ <=<c_<=< V'<=<V) idp)
      (embed<= $ cover-trans cover-creg \lam (V',V'<=<V) => cover-inj (_, later $ cover-inj ((V', V'<=<V), _, cover-inj () idp) idp) idp)
  | Func-o {X} {Y} {Z} {g} {f} => func-equality_ext \lam V => adjointMap_embed (framePresHom (g ∘ f)) _ *> <=-antisymmetric
          (Join-univ {_} {_} {\lam s => embed (_ ^-1 s.1)} \lam (V'',V''<=<V) => \case <=<c-inter V''<=<V \with {
            | inP (V',V''<=<V',V'<=<V) => embed<= $ cover-inj (_, later $ cover-inj ((V',V'<=<V), _, cover-inj ((g ^-1 V'', <=<c_^-1 s<=<_^-1 V''<=<V'), _, cover-inj () idp) idp) idp) idp
          })
          (Join-univ {_} {_} {\lam j => framePresHom f (g ^-1 j.1)} $ later \lam (V',V'<=<V) => Join-univ {_} {_} {\lam s => embed (f ^-1 s.1)} \lam (V'',V''<=g'V') => embed<= $ cover-inj (_, later $ cover-inj ((V',V'<=<V), _, Cover.cover-inj_<= () $ func-<= {^-1_FrameHom f} {V''} {g ^-1 V'} $ s<=<_<= $ <=<c_<=< V''<=g'V') idp) idp) *>
      inv (path (\lam i => Join \lam j => adjointMap_embed (framePresHom f) (g ^-1 j.1) i)) *>
      inv (func-Join {adjointMap (framePresHom f)} {_} {\lam s => embed (g ^-1 s.1)}) *>
      inv (pmap (adjointMap (framePresHom f)) (adjointMap_embed (framePresHom g) _))
  \where {
    \open PresentedFrame
    \open CoverSpaceLocale
    \open FrameReflectiveSubcat

    \func framePresHom {X Y : CompletelyStronglyRegularCoverSpace} (f : CoverMap X Y) : FramePresHom (CoverSpaceLocale.framePres {Y}) (FrameUnitalSubcat.F (CoverSpaceLocale X)) \cowith
      | func V => Join {_} {\Sigma (V' : Set Y) (V' <=<c V)} \lam s => embed (f ^-1 s.1)
      | func-conj {U} {V} => <=-antisymmetric
          (Join-univ {_} {_} {\lam s => embed $ f ^-1 s.1} \lam (W,p) => meet-univ <=-refl <=-refl <=∘ Join-cond (later ((W, Interpolative.<=<-left p meet-left), (W, Interpolative.<=<-left p meet-right))) {later \lam s => embed (f ^-1 s.1.1) ∧ embed (f ^-1 s.2.1)})
          (Join-univ {_} {_} {later \lam s => embed (f ^-1 s.1.1) ∧ embed (f ^-1 s.2.1)} $ later \lam ((W1,W1<=<U),(W2,W2<=<V)) => Preorder.=_<= embed_meet <=∘ Join-cond (later (W1 ∧ W2, Interpolative.<=<_meet W1<=<U W2<=<V)) {\lam s => embed (f ^-1 s.1)})
        *> inv (Locale.Join-distr {_} {_} {_} {\lam s => embed $ f ^-1 s.1} {\lam s => embed $ f ^-1 s.1})
      | func-cover {J} {U} {g} => \case \elim __ \with {
        | byLeft (U=top,C,Cc,h) => \lam _ => Cover.cover-trans1 (Cover.cover_<= top-univ) $ cover-trans (cover-cauchy $ func-cover {f} $ isCompletelyStronglyRegular Cc) \lam (U, inP (V', inP (V,CV,V'<=<V), p)) => \case h CV \with {
          | inP (j,gj=V) => cover-inj (j, _, rewrite gj=V $ cover-inj ((V',V'<=<V), _, cover-inj () (inv p)) idp) idp
        }
        | byRight (byLeft e) => \lam {W} => cover-trans __ \lam ((U',U'<=<U),V,V<=f'U) => Cover.cover-trans1 V<=f'U $
            \have | c1 : Cover {framePres} top {\Sigma (U1 : Set Y) (U1 <=<c U || U1 <=<c Compl U')} \lam s => f ^-1 s.1
                       => cover-basic $ byLeft (idp, _, func-cover {f} $ isCompletelyStronglyRegular $ <=<c_<=< U'<=<U, \lam {V} (inP (U1, inP (U'',e,U1<=<U''), V=f'U1)) => \case \elim e \with {
                         | byLeft p => inP ((U1, byRight $ rewriteI p U1<=<U''), inv V=f'U1)
                         | byRight p => inP ((U1, byLeft $ rewriteI p U1<=<U''), inv V=f'U1)
                       })
                  | c2 : Cover {framePres} (f ^-1 U') {\Sigma (U1 : Set Y) (U1 <=<c U)} \lam s => f ^-1 s.1
                       => cover-trans (transport (Cover __ _) Bounded.MeetSemilattice.top-right $ cover-ldistr idp c1 \lam _ => idp) \case \elim __ \with {
                         | (U1, byLeft U1<=<U) => Cover.cover-inj_<= (U1,U1<=<U) __.2
                         | (U1, byRight e) => Cover.cover-inj_<= (U',U'<=<U) \lam s => absurd $ s<=<_<= (<=<c_<=< e) s.2 s.1
                       }
            \in cover-trans c2 \lam (U2,U2<=<U) => \case <=<c-inter U2<=<U \with {
              | inP (U1,U2<=<U1,U1<=<U) => \case e $ <=<c_<=< U1<=<U \with {
                | inP (j,gj=U1) => cover-inj (j, _, cover-inj ((U2, rewrite gj=U1 U2<=<U1), _, cover-inj () idp) idp) idp
              }
            }
        | byRight (byRight e) => cover-trans __ \lam ((V',V'<=<U),W,c) => Cover.cover-trans1 c $ cover-empty \case s<=<_<= (<=<c_<=< $ rewriteF e V'<=<U) __ \with {
          | inP ((),_)
        }
      }
      | func-image => Cover.cover-trans1 (Cover.cover_<= top-univ) $ Cover.cover-inj_<= top $ (\lam _ => Cover.cover_<= top-univ) <=∘ Join-cond (later (top, Interpolative.<=<_top)) {\lam s => embed (f ^-1 s.1)}
  }

\func LocaleCoverSpace {L : Locale} (Lr : L.isRegular) : StronglyRegularCoverSpace \cowith
  | PrecoverSpace => LocalePrecoverSpace L
  | isStronglyRegular => __ <=∘ Join-univ \lam (U,CU) => Lr _ <=∘ Join-univ \lam (a,a<=<_*U) => points-unit <=∘ Join-cond (later (points^* a, inP (U, CU, points_<=< a<=<_*U)))
  \where {
    \lemma hasDensePoints (Ld : HasDensePoints L) : PrecoverSpace.HasWeaklyDensePoints {LocaleCoverSpace Lr}
      => __ <=∘ Join-univ \lam s => \case s.2 \with {
        | byLeft e => rewrite e $ Ld <=∘ bottom-univ
        | byRight CU => Join-cond $ later (s.1,CU)
      }
  }

\func CoverSpaceLocale-unit {X : StronglyRegularCoverSpace} (Xo : X.HasWeaklyDensePoints) : CoverMap X (LocaleCoverSpace {CoverSpaceLocale X} CoverSpaceLocale.regular) \cowith
  | func x => framePres-point (\lam U => single x <=< U) (inP (top, <=<_top)) (\lam {a} {b} => (\lam p => (<=<-left p meet-left, <=<-left p meet-right), \lam (p,q) => <=<_meet-same p q)) (later \lam b x<=<U => \case \elim b \with {
    | byLeft (p,C,Cc,q) => \case cauchy-cover (isRegular Cc) x \with {
      | inP (U, inP (V, CV,U<=<V), Ux) => \case q CV \with {
        | inP (j,fj=V) => inP (j, rewrite fj=V $ <=<-right (single_<= Ux) U<=<V)
      }
    }
    | byRight (byLeft h) => \case s<=<-inter x<=<U \with {
      | inP (V,x<=<V,V<=<U) => \case h V<=<U \with {
        | inP (j,fj=V) => inP (j, rewrite fj=V $ s<=<_<=< x<=<V)
      }
    }
    | byRight (byRight h) => \case <=<_<= (rewriteF h x<=<U) idp \with {
      | inP ((),_)
    }
  })
  | func-cover Dc => Xo $ cauchy-extend (isRegular $ CoverSpaceLocale.cover-char (Dc ()) <=<_top) \lam {V} => \case \elim __ \with {
    | inP (_, byLeft idp, V<=<U) => inP (bottom, byLeft idp, <=<_<= V<=<U <=∘ \lam t => absurd $ t ())
    | inP (U, byRight (((W,DW),_,q),idp), V<=<U) => inP (_, byRight $ inP (W, DW, idp), \lam Ux => \case CoverSpaceLocale.cover-point-char q $ <=<-right (single_<= Ux) V<=<U \with {
      | inP (((W,p),U'',WU''),x<=<U'') => p $ inP $ later (U'', WU'', x<=<U'')
    })
  }

\func CoverSpaceLocale-counit {L : Locale} (Lr : L.isRegular) : FrameHom L (CoverSpaceLocale (LocalePrecoverSpace L)) \cowith
  | func a => closure {_} {\Sigma (b : L) (b L.<=< a)} $ \lam s => points^* s.1
  | func-<= {a} {b} a<=b => closure<= $ later \lam (c,c<=<a) => cover-inj (_, cover-inj (c, <=<-left c<=<a a<=b) idp) idp
  | func-top>= _ => Cover.cover-inj_<= (top,<=<_top) $ top-univ <=∘ points^*_top>=
  | func-meet>= {a} {b} => cover-trans __ \lam (U,V,Uc,Vc) => Cover.cover-conj Uc Vc \lam {(a',a'<=<a)} {(b',b'<=<b)} => inP ((a' ∧ b', <=<_meet a'<=<a b'<=<b), points^*_meet)
  | func-Join>= {J} {f} => closure<= $ later \lam (b,b<=<Jf) =>
      \have c => mkcon cover-ldistr {points^* b} idp (CoverSpaceLocale.cover-cauchy {LocalePrecoverSpace L} $ cover-cauchy {L} {\lam x => (x = L.neg b) || Given (j : J) (x L.<=< f j)} $ b<=<Jf <=∘ join-univ (L.SJoin-cond $ byLeft idp) (Join-univ \lam j => Lr (f j) <=∘ L.SJoin-univ \lam x<=<fj => L.SJoin-cond $ later $ byRight (j,x<=<fj))) \lam _ => idp
      \in Cover.cover-trans1 (Cover.cover_<= $ meet-univ <=-refl top-univ) $ cover-trans c \case \elim __ \with {
        | (_, inP (a, byLeft q, idp)) => CoverSpaceLocale.cover-empty $ later $ rewrite q \lam (xb,xnb) => absurd $ CompleteFilter.isProper $ filter-mono Locale.eval (filter-meet xnb xb)
        | (_, inP (a, byRight (j,a<=<fj), idp)) => cover-inj (_, cover-inj (j, _, Cover.cover-inj_<= (a,a<=<fj) meet-right) idp) idp
      }
  \where \open PresentedFrame