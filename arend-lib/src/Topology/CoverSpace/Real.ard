\import Algebra.Algebra
\import Algebra.Field
\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Rat
\import Arith.Real
\import Data.Or
\import Function (flip)
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Filter
\import Set.Subset
\import Topology.CoverSpace
\import Topology.CoverSpace.Complete
\import Topology.RatherBelow
\open Set
\open ProductPrecoverSpace
\open ProductCoverSpace
\open RatCoverSpace
\open LinearlyOrderedSemiring(<=_+)
\open LinearOrder \hiding (<=)
\open DiscreteOrderedField
\open LinearlyOrderedSemiring.Dec
\open MeetSemilattice
\open LinearlyOrderedSemiring \hiding (Dec)
\open OrderedSemiring
\open OrderedRing \hiding (Dec, denseOrder)
\open Real
\open RatField (mid,mid>left,mid<right,mid-between)

\instance RatCoverSpace : CoverSpace Rat
  => ClosureRegularCoverSpace Cover covers
      (\lam (inP (eps,eps>0,p)) => inP (\lam U => ∃ (a : Rat) (U = open-int a (a + eps * ratio 1 3)), inP (eps * ratio 1 3, linarith, idp),
        \lam (inP (a,q)) => inP (open-int (a - eps * ratio 1 3) (a + eps * ratio 2 3), rewrite p $ inP (a - eps * ratio 1 3, pmap (open-int _) linarith),
                                 \lam (inP (b,r)) => rewrite (q,r) \lam (x,((s,s'),(t,t'))) (u,v) => (linarith, linarith))))
  \where {
    \func Cover (C : Set (Set Rat)) => ∃ (eps : Rat) (0 < eps) (C = \lam U => ∃ (a : Rat) (U = open-int a (a + eps)))

    \lemma covers {C : Set (Set Rat)} (Cc : Cover C) (x : Rat) : ∃ (U : Set Rat) (C U) (U x) \elim Cc
      | inP (eps,eps>0,p) => rewrite p $ inP (_, inP (x - eps * ratio 1 3, idp), (linarith, linarith))

    \lemma makeCover (eps : Rat) (eps>0 : 0 < eps) : Closure Cover \lam U => ∃ (a : Rat) (U = open-int a (a + eps))
      => closure $ inP (eps, eps>0, idp)

    \func NFilter (x : Rat) : SetFilter Rat \cowith
      | F U => ∃ (a b : Rat) (a < x) (x < b) ∀ y (a < y -> y < b -> U y)
      | filter-mono p (inP (a,b,q,q',f)) => inP (a, b, q, q', \lam y r r' => p (f y r r'))
      | filter-top => inP (x - 1, x + 1, linarith, linarith, \lam _ _ _ => ())
      | filter-meet (inP (a,b,a<x,x<b,f)) (inP (c,d,c<x,x<d,g)) => inP
          (a ∨ c, b ∧ d, TotalOrder.join-prop (`< x) a<x c<x, TotalOrder.meet-prop (x <) x<b x<d,
           \lam y ac<y y<bd => (f y (join-left <∘r ac<y) (y<bd <∘l meet-left),
                                g y (join-right <∘r ac<y) (y<bd <∘l meet-right)))

    \lemma <=<-open {x : Rat} {U : Set Rat} (p : single x <=< {RatCoverSpace} U) : ∃ (a b : Rat) (a < x) (x < b) ∀ y (a < y -> y < b -> U y)
      => \case closure-filter (NFilter x) (\lam (inP (eps,eps>0,p)) => rewrite p \let a => x - eps * ratio 1 2 \in inP (_, inP (a, idp), inP (a, a + eps, linarith, linarith, \lam y p q => (p,q)))) p \with {
        | inP (V, f, inP (a,b,a<x,x<b,g)) => inP (a, b, a<x, x<b, \lam y a<y y<b => f (x, (idp, g x a<x x<b)) (g y a<y y<b))
      }
  }

\instance RealCoverSpace : CompleteCoverSpace Real
  | CoverSpace => coverSpace
  | isSeparatedCoverSpace p =>
    \let q => SeparatedCoverSpace.separated-char 6 3 p
    \in real_ext \lam {a} {b} => (
      \lam s => <=<_<= (q.1 (point_<=< s.1 s.2)) idp,
      \lam s => <=<_<= (q.2 (point_<=< s.1 s.2)) idp)
  | isCompleteCoverSpace => dense-regular-complete rat_real-dense \lam F => inP (fromCF F, \lam {U} => \case <=<-open __ \with {
    | inP (a, b, inP (c,Fac), inP (d,Fdb), f) => filter-mono {F} (later \lam {x} ((a<x,_),(_,x<b)) => f x a<x x<b) (filter-meet {F} Fac Fdb)
  })
  \where {
    \func open-rat-int (a b : Rat) : Set Real
      => \lam (x : Real) => \Sigma (x.L a) (x.U b)

    \lemma makeRealCover (eps : Rat) (eps>0 : 0 < eps) : Closure Cover \lam U => ∃ (a : Rat) (U = open-rat-int a (a + eps))
      => closure $ inP (eps, eps>0, idp)

    \func Cover (C : Set (Set Real)) => ∃ (eps : Rat) (0 < eps) (C = \lam U => ∃ (a : Rat) (U = open-rat-int a (a + eps)))

    \lemma covers {C : Set (Set Real)} (Cc : Cover C) (x : Real) : ∃ (U : Set Real) (C U) (U x) \elim Cc
      | inP (eps,eps>0,p) => TruncP.map (LU-focus {x} eps eps>0) \lam (a,a<x,x<a+eps) => rewrite p (_, inP (a,idp), (a<x, x<a+eps))

    \func NFilter (x : Real) : SetFilter Real \cowith
      | F U => ∃ (a b : Rat) (x.L a) (x.U b) ∀ (y : Real) (y.L a -> y.U b -> U y)
      | filter-mono p (inP (a,b,q,q',f)) => inP (a, b, q, q', \lam y r r' => p (f y r r'))
      | filter-top => \case x.L-inh, x.U-inh \with {
        | inP (a,p), inP (b,q) => inP (a, b, p, q, \lam _ _ _ => ())
      }
      | filter-meet (inP (a,b,a<x,x<b,f)) (inP (c,d,c<x,x<d,g)) => inP (a ∨ c, b ∧ d,
          TotalOrder.join-prop x.L a<x c<x, TotalOrder.meet-prop x.U x<b x<d,
          \lam (y : Real) l u => (f y (y.L_<= l join-left) (y.U_<= u meet-left), g y (y.L_<= l join-right) (y.U_<= u meet-right)))

    \instance coverSpace : CoverSpace Real
      => ClosureRegularCoverSpace Cover covers
          (\lam (inP (eps,eps>0,p)) => inP (
            \lam U => ∃ (a : Rat) (U = \lam (x : Real) => \Sigma (x.L a) (x.U (a + eps * ratio 1 3))),
            inP (eps * ratio 1 3, linarith, idp), \lam (inP (a,q)) => inP
                (_, rewrite p $ inP (a - eps * ratio 1 3, idp),
                 \lam (inP (b,r)) => rewrite (q,r) \lam (y : Real, ((a<y,y<a+eps/3),(b<y,y<b+eps/3))) {x : Real} V'x => (x.L-closed V'x.1 $ linarith (y.LU-less a<y y<b+eps/3), x.U-closed V'x.2 $ linarith (y.LU-less b<y y<a+eps/3)))))

    \lemma <=<-open {x : Real} {U : Set Real} (p : single x <=< U) : ∃ (a b : Rat) (x.L a) (x.U b) ∀ (y : Real) (y.L a -> y.U b -> U y)
      => \case closure-filter (NFilter x) (\lam (inP (eps,eps>0,p)) => TruncP.map (LU-focus {x} eps eps>0) \lam (a,a<y,y<a+eps) => (_, rewrite p $ inP (a, idp), inP (a, a + eps, a<y, y<a+eps, \lam x p q => (p,q)))) p \with {
        | inP (V, f, inP (a,b,a<x,x<b,g)) => inP (a, b, a<x, x<b, \lam y a<y y<b => f (x, (idp, g x a<x x<b)) (g y a<y y<b))
      }

    \lemma <=<_open-rat-int {a b a' b' : Rat} (a<a' : a < a') (b'<b : b' < b) : open-rat-int a' b' <=< open-rat-int a b
      => closure-subset (makeRealCover ((a' - a) ∧ (b - b')) $ <_meet-univ linarith linarith) \lam {U} (inP (c,p)) => rewrite p $ later \lam (e : Real, ((a'<e,e<b'),(c<e,e<c+eps))) (c<x,x<c+eps) => (L-closed c<x $ linarith (e.LU-less a'<e e<c+eps <∘l <=_+ <=-refl meet-left), U-closed x<c+eps $ <=_+ <=-refl meet-right <∘r linarith (e.LU-less c<e e<b'))

    \lemma point_<=< {x : Real} {a b : Rat} (a<x : x.L a) (x<b : x.U b) : single x <=< open-rat-int a b
      => \case x.L-rounded a<x, x.U-rounded x<b \with {
        | inP (a',a'<x,a<a'), inP (b',x<b',b'<b) => <=<-right (later \lam p => rewriteI p (a'<x,x<b')) (<=<_open-rat-int a<a' b'<b)
      }

    \func fromCF (F : RegularCauchyFilter RatCoverSpace) : Real \cowith
      | L a => ∃ (b : Rat) (F (open-int a b))
      | L-inh => \case F.isCauchyFilter (makeCover 1 idp) \with {
        | inP (U, inP (a,p), FU) => inP (a, inP (a + 1, rewrite p in FU))
      }
      | L-closed (inP (b,Fqb)) q'<q => inP (b, filter-mono (later \lam s => (q'<q <∘ s.1, s.2)) Fqb)
      | L-rounded {a} (inP (b,Fab)) => \case isRegularFilter Fab \with {
        | inP (V,V<=<ab,FV) => \case cauchy-cover (isRegular $ unfolds in V<=<ab) a \with {
          | inP (W', inP (W,f,W'<=<W), W'a) => \case RatCoverSpace.<=<-open (<=<-right (single_<= W'a) W'<=<W) \with {
            | inP (c,d,c<a,a<d,g) => inP (mid a d, inP (b, filter-mono (\lam {x} Vx => (\case dec<_<= x d \with {
              | inl x<d => absurd $ <-irreflexive {_} {a} (f (x, (Vx, g x (c<a <∘ (<=<_<= V<=<ab Vx).1) x<d)) $ <=<_<= W'<=<W W'a).1
              | inr d<=x => mid<right a<d <∘l d<=x
            }, (<=<_<= V<=<ab Vx).2)) FV), mid>left a<d)
          }
        }
      }
      | U b => ∃ (a : Rat) (F (open-int a b))
      | U-inh => \case F.isCauchyFilter (makeCover 1 idp) \with {
        | inP (U, inP (a,p), FU) => inP (a + 1, inP (a, rewrite p in FU))
      }
      | U-closed (inP (a,Faq)) q<q' => inP (a, filter-mono (later \lam s => (s.1, s.2 <∘ q<q')) Faq)
      | U-rounded {b} (inP (a,Fab)) => \case isRegularFilter Fab \with {
        | inP (V,V<=<ab,FV) => \case cauchy-cover (isRegular $ unfolds in V<=<ab) b \with {
          | inP (W', inP (W,f,W'<=<W), W'b) => \case RatCoverSpace.<=<-open (<=<-right (single_<= W'b) W'<=<W) \with {
            | inP (c,d,c<b,b<d,g) => inP (mid c b, inP (a, filter-mono (\lam {x} Vx => ((<=<_<= V<=<ab Vx).1, \case dec<_<= c x \with {
              | inl c<x => absurd $ <-irreflexive (f (x, (Vx, g x c<x $ (<=<_<= V<=<ab Vx).2 <∘ b<d)) $ <=<_<= W'<=<W W'b).2
              | inr x<=c => x<=c <∘r mid>left c<b
            })) FV), mid<right c<b)
          }
        }
      }
      | LU-disjoint (inP (b,Fqb)) (inP (a,Faq)) => \case isProper (filter-meet Faq Fqb) \with {
        | inP (x,((_,x<q),(q<x,_))) => linarith
      }
      | LU-focus eps eps>0 => \case F.isCauchyFilter (makeCover eps eps>0) \with {
        | inP (_, inP (a,idp), e) => inP (a, inP (a + eps, e), inP (a, e))
      }
  }

\lemma real-coverMap {X : PrecoverSpace} (f : X -> Real) (Ap : \Pi (eps : Rat) -> 0 < eps -> eps < 1 -> isCauchy \lam U => ∃ (a : Rat) (U = \lam x => \Sigma (Real.L {f x} a) (Real.U {f x} (a + eps)))) : CoverMap X RealCoverSpace f \cowith
  | func-cover Dc => flip closure-univ-cover Dc \lam (inP (eps,eps>0,p)) => cauchy-extend (Ap (eps ∧ ratio 1 2) (<_meet-univ eps>0 idp) $ meet-right <∘r idp)
                      \lam (inP (a,q)) => inP $ later (_, inP (_, rewrite p $ inP (a, idp), idp), rewrite q \lam (c,c') => (c, UpperReal.U_<= c' $ <=_+ <=-refl meet-left))

\lemma rat_real-uniMap (f : Rat -> Real) (Ap : \Pi (eps : Rat) -> 0 < eps -> eps < 1 -> ∃ (d : Rat) (0 < d) ∀ a ∃ (b : Rat) (open-int a (a + d) ⊆ \lam x => \Sigma (Real.L {f x} b) (Real.U {f x} (b + eps)))) : CoverMap RatCoverSpace RealCoverSpace f
  => real-coverMap f \lam eps eps>0 eps<1 => \case Ap eps eps>0 eps<1 \with {
    | inP (d,d>0,g) => closure-extends (makeCover d d>0) \lam (inP (a,p)) => \case g a \with {
      | inP (b,q) => inP (_, inP (b,idp), rewrite p q)
    }
  }

-- | A map is a cover map if, for every eps > 0, there exists e > 0 such that, for every open (w,w+e) of size e, there exists 0 < d <= e such that every open of size d inside (w,w+e) is mapped to a set of size eps.
\lemma rat_real-coverMap (f : Rat -> Real) (Ap : \Pi (eps : Rat) -> 0 < eps -> eps < 1 -> ∃ (e : Rat) (0 < e) ∀ w ∃ (d : Rat) (0 < d) (d <= e) ∀ a (\Sigma (w <= a) (a + d <= w + e) -> ∃ (b : Rat) (open-int a (a + d) ⊆ \lam x => \Sigma (Real.L {f x} b) (Real.U {f x} (b + eps))))) : CoverMap RatCoverSpace RealCoverSpace f
  => real-coverMap f \lam eps eps>0 eps<1 => \case Ap eps eps>0 eps<1 \with {
    | inP (e,e>0,g) => closure-extends (closure-trans (makeCover e e>0)
        {\lam U V => ∃ (w : Rat) (U = open-int w (w + e)) (a d : Rat) (0 < d) (d <= e) (\Pi (a : Rat) -> \Sigma (w <= a) (a + d <= w + e) -> ∃ (b : Rat) (open-int a (a + d) ⊆ (\lam x => \Sigma (LowerReal.L {f x} b) (UpperReal.U {f x} (b + eps))))) (V = open-int a (a + d))}
        (\lam (inP (w,p)) => \case g w \with {
          | inP (d,d>0,d<=e,h) => closure-subset (makeCover d d>0) \lam (inP (a,q)) => inP (w, p, a, d, d>0, d<=e, h, q)
        }) idp) \lam (inP (V, W, _, inP (w,Vp,a,d,d>0,d<=e,h,Wp), q)) => \case h ((a ∨ w) ∧ (w + e - d)) (meet-univ join-right linarith, <=_+ meet-right <=-refl <=∘ linarith) \with {
          | inP (b,r) => inP (_, inP (b,idp), rewrite (q,Vp,Wp) \lam ((w<x,x<w+e),(a<x,x<a+d)) => r (meet-left <∘r <_join-univ a<x w<x, rewrite meet_+-right $ <_meet-univ (linarith (join-left : a <= a ∨ w)) linarith))
        }
  }

\lemma rat2_real-uniMap (f : Rat -> Rat -> Real) (Ap : \Pi (eps : Rat) -> 0 < eps -> eps < 1 -> ∃ (d1 d2 : Rat) (0 < d1) (0 < d2) (\Pi (a b : Rat) -> ∃ (c : Rat) ∀ {x} {y} (\Sigma (a < x) (x < a + d1) -> \Sigma (b < y) (y < b + d2) -> \Sigma (Real.L {f x y} c) (Real.U {f x y} (c + eps))))) : CoverMap (ProductCoverSpace RatCoverSpace RatCoverSpace) RealCoverSpace (\lam s => f s.1 s.2)
  => real-coverMap {ProductCoverSpace _ _} (later \lam s => f s.1 s.2) \lam eps eps>0 eps<1 => \case Ap eps eps>0 eps<1 \with {
    | inP (d1,d2,d1>0,d2>0,g) => closure-extends (closure-inter (proj1.func-cover $ makeCover d1 d1>0) (proj2.func-cover $ makeCover d2 d2>0))
        \lam (inP (V1, V2, inP (W1, inP (a1,p1), q1), inP (W2, inP (a2,p2), q2), r)) => \case g a1 a2 \with {
          | inP (c,h) => inP (_, inP (c, idp), rewrite (r,q1,q2,p1,p2) \lam (s1,s2) => h s1 s2)
        }
  }

\lemma rat2_real-uniMap' (f : Rat -> Rat -> Real) (Ap : \Pi (eps : Rat) -> 0 < eps -> eps < 1 -> ∃ (d : Rat) (0 < d) ∀ a b ∃ (c : Rat) ∀ {x} {y} (\Sigma (a < x) (x < a + d) -> \Sigma (b < y) (y < b + d) -> \Sigma (Real.L {f x y} c) (Real.U {f x y} (c + eps)))) : CoverMap (ProductCoverSpace RatCoverSpace RatCoverSpace) RealCoverSpace (\lam s => f s.1 s.2)
  => rat2_real-uniMap f \lam eps eps>0 eps<1 => TruncP.map (Ap eps eps>0 eps<1) \lam (d,d>0,g) => (d,d,d>0,d>0,g)

-- | A map of two arguments is a cover map if, for every eps > 0, there exist e1,e2 > 0 such that, for every open U of size e1 ⨯ e2, there exist 0 < d1 < e1, 0 < d2 < e2 such that every open of size d1 ⨯ d2 inside U is mapped to a set of size eps.
\lemma rat2_real-coverMap (f : Rat -> Rat -> Real) (Ap : \Pi (eps : Rat) -> 0 < eps -> eps < 1 -> ∃ (e1 e2 : Rat) (0 < e1) (0 < e2) (\Pi (w1 w2 : Rat) -> ∃ (d1 d2 : Rat) (0 < d1) (d1 <= e1) (0 < d2) (d2 <= e2) (\Pi (a b : Rat) -> \Sigma (w1 <= a) (a + d1 <= w1 + e1) -> \Sigma (w2 <= b) (b + d2 <= w2 + e2) -> ∃ (c : Rat) (\Pi {x y : Rat} -> \Sigma (a < x) (x < a + d1) -> \Sigma (b < y) (y < b + d2) -> \Sigma (Real.L {f x y} c) (Real.U {f x y} (c + eps)))))) : CoverMap (ProductCoverSpace RatCoverSpace RatCoverSpace) RealCoverSpace (\lam s => f s.1 s.2)
  => real-coverMap {ProductCoverSpace _ _} (later \lam s => f s.1 s.2) \lam eps eps>0 eps<1 => \case Ap eps eps>0 eps<1 \with {
    | inP (e1,e2,e1>0,e2>0,g) => closure-extends (closure-trans (closure-inter (proj1.func-cover $ makeCover e1 e1>0) (proj2.func-cover $ makeCover e2 e2>0))
        {\lam U V => ∃ (w1 w2 : Rat) (U = \lam x => \Sigma (\Sigma (w1 < x.1) (x.1 < w1 + e1)) (\Sigma (w2 < x.2) (x.2 < w2 + e2))) (a1 a2 d1 d2 : Rat) (0 < d1) (d1 <= e1) (0 < d2) (d2 <= e2) (\Pi (a1 a2 : Rat) -> \Sigma (w1 <= a1) (a1 + d1 <= w1 + e1) -> \Sigma (w2 <= a2) (a2 + d2 <= w2 + e2) -> ∃ (c : Rat) (\Pi {x y : Rat} -> \Sigma (a1 < x) (x < a1 + d1) -> \Sigma (a2 < y) (y < a2 + d2) -> \Sigma (LowerReal.L {f x y} c) (UpperReal.U {f x y} (c + eps)))) (V = \lam x => \Sigma (\Sigma (a1 < x.1) (x.1 < a1 + d1)) (\Sigma (a2 < x.2) (x.2 < a2 + d2)))}
        (\lam (inP (V1, V2, inP (W1, inP (w1,p1), q1), inP (W2, inP (w2,p2), q2), r)) => \case g w1 w2 \with {
          | inP (d1,d2,d1>0,d1<=e1,d2>0,d2<=e2,h) => closure-subset (closure-inter (proj1.func-cover $ makeCover d1 d1>0) (proj2.func-cover $ makeCover d2 d2>0))
              \lam {W} (inP (V1', V2', inP (W1', inP (a1,p1'), q1'), inP (W2', inP (a2,p2'), q2'), r')) => inP (w1, w2, rewrite (r,q1,q2,p1,p2) idp, a1, a2, d1, d2, d1>0, d1<=e1, d2>0, d2<=e2, h, rewrite (r',q1',q2',p1',p2') idp)
        }) idp)
        \lam (inP (U', V', _, inP (w1, w2, p, a1, a2, d1, d2, d1>0, d1<=e1, d2>0, d2<=e2, h, r'), r)) => hiding (Ap,eps,eps>0,eps<1,g) \case h ((a1 ∨ w1) ∧ (w1 + e1 - d1)) ((a2 ∨ w2) ∧ (w2 + e2 - d2)) (meet-univ join-right linarith, <=_+ meet-right <=-refl <=∘ linarith) (meet-univ join-right linarith, <=_+ meet-right <=-refl <=∘ linarith) \with {
          | inP (c,k) => inP (_, inP (c,idp), rewrite (r,p,r') \lam (((w1<x,x<w1+e1),(w2<y,y<w2+e2)),((a1<x,x<a1+d1),(a2<y,y<a2+d2))) =>
              k (meet-left <∘r <_join-univ a1<x w1<x, rewrite meet_+-right $ <_meet-univ (linarith (join-left : a1 <= a1 ∨ w1)) linarith)
                (meet-left <∘r <_join-univ a2<y w2<y, rewrite meet_+-right $ <_meet-univ (linarith (join-left : a2 <= a2 ∨ w2)) linarith))
        }
  }

\open ClosurePrecoverSpace
\open CoverMap

\func rat_real : CoverMap RatCoverSpace RealCoverSpace.coverSpace
  => closure-univ (\lam c => c) Real.fromRat $ later
      \lam (inP (eps,eps>0,p)) => closure-subset (closure $ inP (eps, eps>0, idp)) \lam (inP (a,q)) => inP (_, rewrite p $ inP (a, idp), q)

\lemma rat_real-dense : rat_real.IsDenseEmbedding
  => (\lam {y : Real} y<=<U => \case RealCoverSpace.<=<-open y<=<U \with {
        | inP (a,b,a<y,y<b,f) => \have a<b => y.LU-less a<y y<b \in inP (mid a b, f _ (mid>left a<b) (mid<right a<b))
      }, closure-embedding (\lam c => c) rat_real (\lam (inP (eps,eps>0,p)) =>
          closure-subset (closure $ inP (eps, eps>0, idp)) \lam (inP (a,q)) => inP (_, rewrite p $ inP (a, idp), rewrite q \lam s => s)))

\instance RealRatAlgebra : OrderedFieldAlgebra RatField
  | OrderedField => RealField
  | *c a x => Real.fromRat a RealField.* x
  | *c-assoc => pmap (RealField.`* _) (inv RealField.*-rat) *> RealField.*-assoc
  | *c-ldistr => RealField.ldistr
  | *c-rdistr => pmap (RealField.`* _) (inv RealField.+-rat) *> RealField.rdistr
  | ide_*c => RealField.ide-left
  | *c-comm-left => inv RealField.*-assoc
  | coefMap => Real.fromRat
  | coefMap_*c => inv RealField.ide-right
  | coef_< p => RealField.<-char.2 (isDense p)
  | coef_<-inv p => \case RealField.<-char.1 p \with {
    | inP (a,x<a,a<y) => x<a <∘ a<y
  }

\instance RealField : OrderedField Real
  | zro => 0
  | + => +
  | zro-left => unique (+-cover ∘ tuple (const (0 : Real)) id) id \lam x => +-rat *> pmap Real.fromRat zro-left
  | +-assoc => unique3 (+-cover ∘ prod +-cover id) (+-cover ∘ tuple (proj1 ∘ proj1) (+-cover ∘ prod proj2 id)) \lam x y z => unfold $ unfold $ rewrite (+-rat,+-rat,+-rat,+-rat) $ pmap Real.fromRat +-assoc
  | negative => negative
  | negative-left => unique (+-cover ∘ tuple negative-cover id) (const (0 : Real)) \lam x => unfold $ unfold $ rewrite negative-rat $ +-rat *> pmap Real.fromRat negative-left
  | +-comm => unique2 +-cover (+-cover ∘ tuple proj2 proj1) \lam x y => +-rat *> pmap Real.fromRat +-comm *> inv +-rat
  | ide => 1
  | * => *
  | ide-left => unique (*-cover ∘ tuple (const (1 : Real)) id) id \lam x => *-rat *> pmap Real.fromRat ide-left
  | *-assoc => unique3 (*-cover ∘ prod *-cover id) (*-cover ∘ tuple (proj1 ∘ proj1) (*-cover ∘ prod proj2 id)) \lam x y z => unfold $ unfold $ rewrite (*-rat,*-rat,*-rat,*-rat) $ pmap Real.fromRat *-assoc
  | ldistr => unique3 (*-cover ∘ tuple (proj1 ∘ proj1) (+-cover ∘ prod proj2 id)) (+-cover ∘ tuple (*-cover ∘ tuple (proj1 ∘ proj1) (proj2 ∘ proj1)) (*-cover ∘ tuple (proj1 ∘ proj1) proj2)) \lam x y z => unfold $ unfold $ rewrite (+-rat,*-rat,*-rat,*-rat,+-rat) $ pmap Real.fromRat ldistr
  | *-comm => unique2 *-cover (*-cover ∘ tuple proj2 proj1) \lam x y => *-rat *> pmap Real.fromRat *-comm *> inv *-rat
  | isPos (x : Real) => x.L 0
  | zro/>0 => \case __
  | positive_+ x>0 y>0 => +-L.2 \case L-rounded x>0 \with {
    | inP (a,a<x,a>0) => inP (a, 0, a<x, y>0, rewrite zro-right a>0)
  }
  | ide>zro => idp
  | <_+-comparison x y x+y>0 => \case +-L.1 x+y>0 \with {
    | inP (a,b,a<x,b<y,a+b>0) => \case dec<_<= a 0 \with {
      | inl a<0 => byRight $ L-closed b<y linarith
      | inr a>=0 => byLeft $ LowerReal.L_<= a<x a>=0
    }
  }
  | <_+-connectedness {x} p q => <=-antisymmetric (\lam x>0 => p $ Real.real_<_L x>0) \lam x<0 => q \case L-inh {x} \with {
    | inP (l,l<x) => negative-L.2 (Real.real_<_U x<0)
  }
  | positive_* x>0 y>0 => (*_positive-L x>0 y>0).2 \case L-rounded x>0, L-rounded y>0 \with {
    | inP (a,a<x,a>0), inP (a',a'<y,a'>0) => inP (a, a', a>0, a'>0, a<x, a'<y, <_*_positive_positive a>0 a'>0)
  }
  | positive_*-cancel {x : Real} {y : Real} (xy>0 : LowerReal.L {x * y} 0) : (\Sigma (x.L 0) (y.L 0)) || (\Sigma (LowerReal.L {negative x} 0) (LowerReal.L {negative y} 0)) => \case U-inh {x * y} \with {
    | inP (u,xy<u) => \case (lift2-char 0 u).1 (rewrite (\peval x * y) in xy>0, rewrite (\peval x * y) in xy<u) \with {
      | inP (a',_,c1,d1,c2,d2,a'>0,_,c1<x,x<d1,c2<y,y<d2,h) => unfold at h $
        \have | c1<d1 => LU-less c1<x x<d1
              | c2<d2 => LU-less c2<y y<d2
        \in \case dec<_<= c1 0, dec<_<= 0 d1 \with {
          | inl c1<0, inl d1>0 => absurd $ <-irreflexive $ a'>0 <∘ (rewrite zro_*-left in (h {0} {mid c2 d2} (c1<0,d1>0) (mid-between c2<d2)).1)
          | inl c1<0, inr d1<=0 => byRight (negative-L.2 $ UpperReal.U_<= x<d1 d1<=0, negative-L.2 \case dec<_<= 0 d2 \with {
            | inl d2>0 => absurd $ <-irreflexive $ a'>0 <∘ (h {mid c1 d1} {(d2 *' ratio 1 2) ∨' mid c2 d2} (mid-between c1<d1) (mid>left c2<d2 <∘l join-right, <_join-univ linarith $ mid<right c2<d2)).1 <∘ <_*_negative_positive (mid<right c1<d1 <∘l d1<=0) (linarith <∘l join-left)
            | inr d2<=0 => UpperReal.U_<= y<d2 d2<=0
          })
          | inr c1>=0, inl d1>0 => byLeft (LowerReal.L_<= c1<x c1>=0, \case dec<_<= c2 0 \with {
            | inl c2<0 => absurd $ <-irreflexive $ a'>0 <∘ \have t => (h {mid c1 d1} {(c2 *' ratio 1 2) ∧' mid c2 d2} (mid-between c1<d1) (<_meet-univ linarith $ mid>left c2<d2, meet-right <∘r mid<right c2<d2)).1
                                                           \in t <∘l <=_*_positive_negative (c1>=0 <=∘ <_<= (mid>left c1<d1)) (meet-left <=∘ linarith)
            | inr c2>=0 => LowerReal.L_<= c2<y c2>=0
          })
          | inr c1>=0, inr d1<=0 => absurd $ <-irreflexive $ c1>=0 <∘r c1<d1 <∘l d1<=0
        }
    }
  }
  | meet => ∧
  | meet-left => <=_L-char.aux.2 (\lam l => (meet-L.1 l).1) __
  | meet-right => <=_L-char.aux.2 (\lam l => (meet-L.1 l).2) __
  | meet-univ z<=x z<=y => <=_L-char.aux.2 (\lam a<z => meet-L.2 (<=_L-char.aux.1 (z<=x __) a<z, <=_L-char.aux.1 (z<=y __) a<z)) __
  | join => ∨
  | join-left => <=_L-char.aux.2 (\lam a<x => join-L.2 $ byLeft a<x) __
  | join-right => <=_L-char.aux.2 (\lam a<y => join-L.2 $ byRight a<y) __
  | join-univ x<=z y<=z => <=_L-char.aux.2 (\lam l => \case join-L.1 l \with {
    | byLeft a<x => <=_L-char.aux.1 (\lam p => x<=z p) a<x
    | byRight a<y => <=_L-char.aux.1 (\lam p => y<=z p) a<y
  }) __
  | positive=>#0 {x : Real} x>0 => Monoid.Inv.lmake (pos-inv x>0) $ exts
      (\lam c => ext (\lam l => \case (*_positive-L (pos-inv>0 x>0) x>0).1 l \with {
        | inP (a, a', a>0, a'>0, byLeft a<=0, a'<x, c<aa') => absurd linarith
        | inP (a, a', a>0, a'>0, byRight x<a1, a'<x, c<aa') => c<aa' <∘ transport (_ <) (finv-right $ RatField.>_/= a>0) (<_*_positive-right a>0 $ LU-less a'<x x<a1)
      }, \lam c<1 => (*_positive-L (pos-inv>0 x>0) x>0).2 $ unfold LowerReal.L \case LU_*-focus-left x>0 c<1 \with {
        | inP (b,bc<x,x<b) => \case L-rounded bc<x, L-rounded x>0 \with {
          | inP (a',a'<x,bc<a'), inP (a'',a''<x,a''>0) =>
            \have b>0 => LU-less x>0 x<b
            \in inP (finv b, a' ∨' a'', finv>0 b>0, a''>0 <∘l join-right, byRight $ transportInv x.U RatField.finv_finv x<b, real_join_L a'<x a''<x, transport (`< _) (inv *-assoc *> pmap (`*' c) (RatField.finv-left $ RatField.>_/= b>0) *> ide-left) (RatField.<_*_positive-right (finv>0 b>0) bc<a') <∘l <=_*_positive-right (<_<= $ finv>0 b>0) join-left)
        }
      }),
       \lam d => ext (\lam u => \case (*_positive-U (pos-inv>0 x>0) x>0).1 u \with {
         | inP (b,b',(b>0,b1<x),x<b',bb'<d) => transport (`< _) (finv-right $ RatField.>_/= b>0) (RatField.<_*_positive-right b>0 $ LU-less b1<x x<b') <∘ bb'<d
       }, \lam d>1 => (*_positive-U (pos-inv>0 x>0) x>0).2 \case LU_*-focus-right x>0 d>1 \with {
         | inP (a,a>0,a<x,x<ad) => \case U-rounded x<ad \with {
           | inP (b',x<b',b'<ad) => inP (finv a, b', (finv>0 a>0, transportInv x.L RatField.finv_finv a<x), x<b', transport (_ <) (inv *-assoc *> pmap (`*' _) (RatField.finv-left $ RatField.>_/= a>0) *> ide-left) $ <_*_positive-right (finv>0 a>0) b'<ad)
         }
       }))
  | #0=>eitherPosOrNeg {x} (xi : Monoid.Inv x) => \case positive_*-cancel (rewrite xi.inv-right idp) \with {
    | byLeft (x>0,_) => byLeft x>0
    | byRight (-x>0,_) => byRight -x>0
  }
  \where {
    \open RealCoverSpace

    \lemma dense-lift-real-char {X Y : CoverSpace} {f : CoverMap X Y} (fd : f.IsDenseEmbedding) {g : CoverMap X RealCoverSpace} (y : Y) (a b : Rat)
      : open-rat-int a b (dense-lift f fd g y) <-> ∃ (a' b' : Rat) (a < a') (b' < b) (V : Set Y) (f ^-1 V ⊆ g ^-1 open-rat-int a' b') (single y <=< V)
      => (\lam (a<z,z<b) => \case L-rounded a<z, U-rounded z<b \with {
        | inP (a',a'<z,a<a'), inP (b',z<b',b'<b) => \case (dense-lift-neighborhood fd y (open-rat-int a' b')).1 (point_<=< a'<z z<b') \with {
          | inP (W,W<=<a'b',V,q,y<=<V) => inP (a', b', a<a', b'<b, V, q <=∘ <=<_<= (<=<_^-1 W<=<a'b'), y<=<V)
        }
      }, \lam (inP (a',b',a<a',b'<b,V,h,y<=<V)) => <=<_<= ((dense-lift-neighborhood fd y (\lam x => open-rat-int a b x)).2 $ inP (open-rat-int a' b', <=<_open-rat-int a<a' b'<b, V, h, y<=<V)) idp)

    \func lift {X : CompleteCoverSpace} (f : CoverMap RatCoverSpace X) : CoverMap RealCoverSpace X
      => dense-lift rat_real rat_real-dense f

    \lemma lift-rat {X : CompleteCoverSpace} {f : CoverMap RatCoverSpace X} {x : Rat} : lift f x = f x
      => dense-lift-char {_} {_} {_} {rat_real} {rat_real-dense} x

    \lemma lift-char {f : CoverMap RatCoverSpace RealCoverSpace} {y : Real} (a b : Rat)
      : open-rat-int a b (lift f y) <-> ∃ (a' b' c d : Rat) (a < a') (b' < b) (y.L c) (y.U d) (open-int c d ⊆ f ^-1 open-rat-int a' b')
      => <->trans (dense-lift-real-char rat_real-dense y a b) $ later
          (\lam (inP (a',b',a<a',b'<b,V,q,y<=<V)) => \case <=<-open y<=<V \with {
             | inP (c,d,c<y,y<d,h) => inP (a', b', c, d, a<a', b'<b, c<y, y<d, (\lam {x} (c<x,x<d) => h x c<x x<d) <=∘ q)
           }, \lam (inP (a',b',c,d,a<a',b'<b,c<y,y<d,q)) => inP (a', b', a<a', b'<b, open-rat-int c d, q, point_<=< c<y y<d))

    \func lift2 {X : CompleteCoverSpace} (f : CoverMap (ProductCoverSpace RatCoverSpace RatCoverSpace) X) : CoverMap (ProductCoverSpace RealCoverSpace RealCoverSpace) X
      => dense-lift (prod rat_real rat_real) (prod.isDenseEmbedding rat_real-dense rat_real-dense) f

    \lemma lift2-rat {X : CompleteCoverSpace} {f : CoverMap (ProductCoverSpace RatCoverSpace RatCoverSpace) X} {x y : Rat} : lift2 f (x,y) = f (x,y)
      => dense-lift-char {ProductCoverSpace _ _} {_} {_} {prod rat_real rat_real} {prod.isDenseEmbedding rat_real-dense rat_real-dense} (x,y)

    \lemma lift2-char {f : CoverMap (ProductCoverSpace RatCoverSpace RatCoverSpace) RealCoverSpace} {x y : Real} (a b : Rat)
      : open-rat-int a b (lift2 f (x,y)) <-> ∃ (a' b' c1 d1 c2 d2 : Rat) (a < a') (b' < b) (x.L c1) (x.U d1) (y.L c2) (y.U d2) (\Pi {x y : Rat} -> \Sigma (c1 < x) (x < d1) -> \Sigma (c2 < y) (y < d2) -> open-rat-int a' b' (f (x,y)))
      => <->trans (dense-lift-real-char {ProductCoverSpace _ _} (prod.isDenseEmbedding rat_real-dense rat_real-dense) (x,y) a b) $ later
          (\lam (inP (a',b',a<a',b'<b,V,q,xy<=<V)) => \case prod-neighborhood xy<=<V \with {
            | inP (U,V,x<=<U,y<=<V,h) => \case <=<-open x<=<U, <=<-open y<=<V \with {
              | inP (c1,d1,c1<x,x<d1,p1), inP (c2,d2,c2<y,y<d2,p2) => inP (a', b', c1, d1, c2, d2, a<a', b'<b, c1<x, x<d1, c2<y, y<d2, \lam {x'} {y'} (c1<x',x'<d1) (c2<y',y'<d2) => q $ h (p1 x' c1<x' x'<d1) (p2 y' c2<y' y'<d2))
            }
          }, \lam (inP (a',b',c1,d1,c2,d2,a<a',b'<b,c1<x,x<d1,c2<y,y<d2,q)) => inP (a', b', a<a', b'<b, \lam z => \Sigma (open-rat-int c1 d1 z.1) (open-rat-int c2 d2 z.2),
              \lam s => q s.1 s.2, RatherBelow.<=<_meet-same (<=<-right (later \lam s => pmap __.1 s) $ <=<_^-1 {_} {_} {proj1} $ RealCoverSpace.point_<=< c1<x x<d1) (<=<-right (later \lam s => pmap __.2 s) $ <=<_^-1 {_} {_} {proj2} $ RealCoverSpace.point_<=< c2<y y<d2)))

    \lemma unique {X : SeparatedCoverSpace} (f g : CoverMap RealCoverSpace X) (p : \Pi (x : Rat) -> f x = g x) {x : Real} : f x = g x
      => dense-lift-unique rat_real rat_real-dense.1 f g p x

    \lemma unique2 {X : SeparatedCoverSpace} (f g : CoverMap (ProductCoverSpace RealCoverSpace RealCoverSpace) X) (p : \Pi (x y : Rat) -> f (x,y) = g (x,y)) {x y : Real} : f (x,y) = g (x,y)
      => dense-lift-unique (prod rat_real rat_real) (prod.isDenseEmbedding rat_real-dense rat_real-dense).1 f g (\lam s => p s.1 s.2) (x,y)

    \lemma unique3 {X : SeparatedCoverSpace} (f g : CoverMap (ProductCoverSpace (ProductCoverSpace RealCoverSpace RealCoverSpace) RealCoverSpace) X) (p : \Pi (x y z : Rat) -> f ((x,y),z) = g ((x,y),z)) {x y z : Real} : f ((x,y),z) = g ((x,y),z)
      => dense-lift-unique (prod (prod rat_real rat_real) rat_real) (prod.isDenseEmbedding (prod.isDenseEmbedding rat_real-dense rat_real-dense) rat_real-dense).1 f g (\lam s => p s.1.1 s.1.2 s.2) ((x,y),z)

    \open AddMonoid(+ \as \infixl 6 +')
    \open Monoid(* \as \infixl 7 *')
    \open MeetSemilattice(∧ \as \infixl 7 ∧')
    \open JoinSemilattice(∨ \as \infixl 6 ∨')

    \sfunc \infixl 6 + (x y : Real) : Real
      => cover (x,y)
      \where \protected {
        \func cover => lift2 $ rat2_real-uniMap' (__ +' __) \lam eps _ _ => inP (eps *' ratio 1 2, linarith, \lam a b => inP (a +' b, \lam (s1,s2) (t1,t2) => (linarith, linarith)))

        \lemma def : (\lam s => s.1 + s.2) = cover
          => ext \lam s => later \peval s.1 + s.2
      }

    \lemma +-rat {x y : Rat} : x + y = {Real} x +' y
      => (\peval x + y) *> lift2-rat

    \lemma +-cover : CoverMap (ProductCoverSpace RealCoverSpace RealCoverSpace) RealCoverSpace (\lam s => s.1 + s.2)
      => rewrite +.def +.cover

    \lemma +-char {x y : Real} {c d : Rat} : open-rat-int c d (x + y) <-> ∃ (a b a' b' : Rat) (open-rat-int a b x) (open-rat-int a' b' y) (c < a +' a') (b +' b' < d)
      => rewrite (\peval x + y) $ <->trans (lift2-char c d) $ unfold (
          \lam (inP (a',b',c1,d1,c2,d2,c<a',b'<d,c1<x,x<d1,c2<y,y<d2,h)) => \case L-rounded c1<x, U-rounded x<d1, L-rounded c2<y, U-rounded y<d2 \with {
            | inP (c1',c1'<x,c1<c1'), inP (d1',x<d1',d1'<d1), inP (c2',c2'<y,c2<c2'), inP (d2',y<d2',d2'<d2) => inP (c1', d1', c2', d2', (c1'<x,x<d1'), (c2'<y,y<d2'), c<a' <∘ (h (c1<c1', LU-less c1'<x x<d1) (c2<c2', LU-less c2'<y y<d2)).1, (h (LU-less c1<x x<d1', d1'<d1) (LU-less c2<y y<d2', d2'<d2)).2 <∘ b'<d)
          }, \lam (inP (a,b,a',b',(a<x,x<b),(a'<y,y<b'),c<a+a',b+b'<d)) => \case isDense c<a+a', isDense b+b'<d \with {
            | inP (c',c<c',c'<a+a'), inP (d',b+b'<d',d'<d) => inP (c', d', a, b, a', b', c<c', d'<d, a<x, x<b, a'<y, y<b', \lam (a<x',x'<b) (a'<y',y'<b') => (c'<a+a' <∘ RatField.<_+ a<x' a'<y', RatField.<_+ x'<b y'<b' <∘ b+b'<d'))
          })

    \lemma +-L {x y : Real} {c : Rat} : LowerReal.L {x + y} c <-> ∃ (a b : Rat) (x.L a) (y.L b) (c < a +' b)
      => (\lam c<x+y => \case U-inh {x + y} \with {
        | inP (d,x+y<d) => \case +-char.1 (c<x+y, x+y<d) \with {
          | inP (a,_,a',_,(a<x,_),(a'<y,_),c<a+a',_) => inP (a, a', a<x, a'<y, c<a+a')
        }
      }, \lam (inP (a,a',a<x,a'<y,c<a+a')) => \case x.U-inh, y.U-inh \with {
        | inP (b,x<b), inP (b',y<b') => ((+-char {x} {y} {c} {b +' b' +' 1}).2 $ inP (a, b, a', b', (a<x,x<b), (a'<y,y<b'), c<a+a', linarith)).1
      })

    \lemma +-U {x y : Real} {d : Rat} : UpperReal.U {x + y} d <-> ∃ (a b : Rat) (x.U a) (y.U b) (a +' b < d)
      => (\lam x+y<d => \case L-inh {x + y} \with {
        | inP (c,c<x+y) => \case +-char.1 (c<x+y, x+y<d) \with {
          | inP (_,b,_,b',(_,x<b),(_,y<b'),_,b+b'<d) => inP (b, b', x<b, y<b', b+b'<d)
        }
      }, \lam (inP (b,b',x<b,y<b',b+b'<d)) => \case x.L-inh, y.L-inh \with {
        | inP (a,a<x), inP (a',a'<y) => ((+-char {x} {y} {a +' a' - 1}).2 $ inP (a, b, a', b', (a<x,x<b), (a'<y,y<b'), linarith, b+b'<d)).2
      })

    \sfunc negative (x : Real) : Real
      => cover x
      \where \protected {
        \func cover : CoverMap RealCoverSpace RealCoverSpace
          => lift $ rat_real-uniMap (RatField.negative __) \lam eps eps>0 _ => inP (eps, eps>0, \lam a => inP (RatField.negative a - eps, \lam (s1,s2) => (linarith, linarith)))

        \lemma def : negative = cover
          => ext \lam x => later \peval negative x
      }

    \lemma negative-rat {x : Rat} : negative x = {Real} RatField.negative x
      => (\peval negative x) *> lift-rat

    \lemma negative-cover : CoverMap RealCoverSpace RealCoverSpace negative
      => rewrite negative.def negative.cover

    \lemma negative-char {x : Real} {a b : Rat} : open-rat-int a b (negative x) <-> open-rat-int (AddGroup.negative b) (AddGroup.negative a) x
      => rewrite (\peval negative x) $ <->trans (lift-char a b) $ unfold (\lam (inP (a',b',c,d,a<a',b'<b,c<x,x<d,q)) =>
          (\case L-rounded c<x \with {
            | inP (c',c'<x,c<c') => L-closed c'<x $ linarith (q (c<c', LU-less c'<x x<d)).2
          }, \case U-rounded x<d \with {
            | inP (d',x<d',d'<d) => U-closed x<d' $ linarith (q (LU-less c<x x<d', d'<d)).1
          }), \lam (-b<x,x<-a) => \case L-rounded -b<x, U-rounded x<-a \with {
            | inP (b',b'<x,-b<b'), inP (a',x<a',a'<-a) => \case L-rounded b'<x, U-rounded x<a' \with {
              | inP (c,c<x,b'<c), inP (d,x<d,d<a') => inP (AddGroup.negative a', AddGroup.negative b', c, d, RatField.negative_<-right a'<-a, RatField.negative_<-left -b<b', c<x, x<d, \lam (c<x,x<d) => (linarith, linarith))
            }
      })

    \lemma negative-L {x : Real} {a : Rat} : Real.L {negative x} a <-> x.U (AddGroup.negative a)
      => (\lam a<-x => \case U-inh {negative x} \with {
        | inP (b,-x<b) => (negative-char.1 (a<-x,-x<b)).2
      }, \lam x<-a => \case x.L-inh \with {
        | inP (b,b<x) => (negative-char.2 (rewrite AddGroup.negative-isInv b<x, x<-a)).1
      })

    \lemma negative-U {x : Real} {a : Rat} : Real.U {negative x} a <-> x.L (AddGroup.negative a)
      => (\lam -x<a => \case L-inh {negative x} \with {
        | inP (b,b<-x) => (negative-char.1 (b<-x,-x<a)).1
      }, \lam x<-a => \case x.U-inh \with {
        | inP (b,x<b) => (negative-char.2 (x<-a, rewrite AddGroup.negative-isInv x<b)).2
      })

    \sfunc \infixl 7 * (x y : Real) : Real
      => cover (x,y)
      \where \protected {
        \func cover => lift2 $ rat2_real-coverMap (__ *' __) \lam eps eps>0 eps<1 => inP (1, 1, idp, idp,
          \let | d w => (eps *' finv (abs w +' 2)) *' finv 2
               | d<=1 w : d w <= 1 => rewrite (*-assoc, inv $ RatField.finv_* {2}) $ <_<= $ RatField.<_*_positive-right eps>0 (finv<1 $ linarith $ RatField.abs>=0) <∘ simplify eps<1
          \in \lam w1 w2 => inP (d w2, d w1,
            hiding d<=1 $ <_*_positive_positive (<_*_positive_positive eps>0 $ finv>0 $ linarith $ RatField.abs>=0) (RatField.finv>0 {2} idp), d<=1 w2,
            hiding d<=1 $ <_*_positive_positive (<_*_positive_positive eps>0 $ finv>0 $ linarith $ RatField.abs>=0) (RatField.finv>0 {2} idp), d<=1 w1,
            \lam a b (w1<=a,a+d1<=w1+1) (w2<=b,b+d2<=w2+1) => inP ((a *' b) ∧' (a *' (b +' d w1)) ∧' ((a +' d w2) *' b) ∧' ((a +' d w2) *' (b +' d w1)),
                \lam {x} {y} (a<x,x<a+d1) (b<y,y<b+d2) => (\case trichotomy y 0 \with {
                  | less y<0 => meet-monotone meet-right <=-refl <∘r \case dec<_<= (a +' d w2) 0 \with {
                    | inl a+d1<0 => meet-right <∘r RatField.<_*_negative-right a+d1<0 y<b+d2 <∘ RatField.<_*_negative-left x<a+d1 y<0
                    | inr a+d1>=0 => meet-left <∘r <=_*_positive-right a+d1>=0 (<_<= b<y) <∘r RatField.<_*_negative-left x<a+d1 y<0
                  }
                  | equals y=0 => meet-left <∘r meet-monotone meet-right <=-refl <∘r rewrite (y=0,Ring.zro_*-right) \case dec<_<= a 0 \with {
                    | inl a<0 => meet-left <∘r <_*_negative_positive a<0 (rewrite y=0 in y<b+d2)
                    | inr a>=0 => meet-right <∘r <_*_positive_negative (a>=0 <∘r a<x <∘ x<a+d1) (rewrite y=0 in b<y)
                  }
                  | greater y>0 => (meet-left <=∘ meet-left) <∘r \case dec<_<= a 0 \with {
                    | inl a<0 => meet-right <∘r RatField.<_*_negative-right a<0 y<b+d2 <∘ <_*_positive-left a<x y>0
                    | inr a>=0 => meet-left <∘r <=_*_positive-right a>=0 (<_<= b<y) <∘r <_*_positive-left a<x y>0
                  }
                }, \have | lem' {x'} {y'} (y'p : w2 <= y') (y'q : y' <= w2 +' 1) (p : abs (x - x') < d w2) (q : abs (y - y') < d w1) : x *' y < x' *' y' +' eps
                            => \have | lem {z} {w} (p : w <= z) (q : z <= w +' 1) : abs z < abs w +' 2 => <_join-univ (q <∘r linarith (RatField.abs>=id {w})) (RatField.negative_<= p <∘r abs>=neg <∘r linarith)
                                     | |w1|+2/=0 : abs w1 +' 2 /= 0 => RatField.>_/= $ <=_+-left {_} {_} {0} abs>=0 (later idp)
                                     | |w2|+2/=0 : abs w2 +' 2 /= 0 => RatField.>_/= $ <=_+-left {_} {_} {0} abs>=0 (later idp)
                                     | t : x *' (y - y') +' (x - x') *' y' < eps
                                        => rewrite *-comm $ abs>=id <∘r abs_+ <∘r rewrite (abs_*,abs_*) (transport (_ <) (
                                              equation {usingOnly (RatField.finv-left |w1|+2/=0, RatField.finv-left |w2|+2/=0)}
                                                       (ratio 1 2 *' eps +' ratio 1 2 *' eps)
                                                       {linarith})
                                              (RatField.<_+ (<=_*_positive-left (<_<= q) abs>=0 <∘r <_*_positive-right (abs>=0 <∘r q) (lem (w1<=a <=∘ <_<= a<x) (<_<= x<a+d1 <=∘ a+d1<=w1+1)))
                                                            (<=_*_positive-left (<_<= p) abs>=0 <∘r <_*_positive-right (abs>=0 <∘r p) (lem y'p y'q))))
                               \in linarith $ rewrite (Ring.ldistr_-, Ring.rdistr_-) in t
                         | lem1 : abs (x - a) < d w2 => rewrite (abs-ofPos linarith) linarith
                         | lem2 : abs (y - b) < d w1 => rewrite (abs-ofPos linarith) linarith
                         | lem3 : abs (x - (a +' d w2)) < d w2 => rewrite (abs-ofNeg linarith) linarith
                         | lem4 : abs (y - (b +' d w1)) < d w1 => rewrite (abs-ofNeg linarith) linarith
                         | b<=w2+1 : b <= w2 +' 1 => linarith
                         | w2<=b+d2 : w2 <= b +' d w1 => linarith
                   \in rewrite (meet_+-right,meet_+-right,meet_+-right) $ <_meet-univ (<_meet-univ (<_meet-univ (lem' w2<=b b<=w2+1 lem1 lem2) (lem' w2<=b+d2 b+d2<=w2+1 lem1 lem4)) (lem' w2<=b b<=w2+1 lem3 lem2)) (lem' w2<=b+d2 b+d2<=w2+1 lem3 lem4)))))

        \lemma def : (\lam s => s.1 * s.2) = cover
          => ext \lam s => later \peval s.1 * s.2
      }

    \lemma *-rat {x y : Rat} : x * y = {Real} x *' y
      => (\peval x * y) *> lift2-rat

    \lemma *-cover : CoverMap (ProductCoverSpace RealCoverSpace RealCoverSpace) RealCoverSpace (\lam s => s.1 * s.2)
      => rewrite *.def *.cover

    \lemma *_positive-char {x y : Real} (x>0 : x.L 0) (y>0 : y.L 0) {c d : Rat} : open-rat-int c d (x * y) <-> ∃ (a b a' b' : Rat) (0 < a) (0 < a') (open-rat-int a b x) (open-rat-int a' b' y) (c < a *' a') (b *' b' < d)
      => rewrite (\peval x * y) $ <->trans (lift2-char c d) $ unfold
          (\lam (inP (a',b',c1,d1,c2,d2,c<a',b'<d,c1<x,x<d1,c2<y,y<d2,h)) => \case L-rounded (real_join_L c1<x x>0), U-rounded x<d1, L-rounded (real_join_L c2<y y>0), U-rounded y<d2 \with {
            | inP (c1',c1'<x,c1_0<c1'), inP (d1',x<d1',d1'<d1), inP (c2',c2'<y,c2_0<c2'), inP (d2',y<d2',d2'<d2) =>
                inP (c1', d1', c2', d2', join-right <∘r c1_0<c1', join-right <∘r c2_0<c2', (c1'<x,x<d1'), (c2'<y,y<d2'),
                     c<a' <∘ (h (join-left <∘r c1_0<c1', LU-less c1'<x x<d1) (join-left <∘r c2_0<c2', LU-less c2'<y y<d2)).1,
                     (h (LU-less c1<x x<d1', d1'<d1) (LU-less c2<y y<d2', d2'<d2)).2 <∘ b'<d)
          }, \lam (inP (a,b,a',b',a>0,a'>0,(a<x,x<b),(a'<y,y<b'),c<aa',bb'<d)) => \case isDense c<aa', isDense bb'<d \with {
             | inP (c',c<c',c'<aa'), inP (d',bb'<d',d'<d) => inP (c', d', a, b, a', b', c<c', d'<d, a<x, x<b, a'<y, y<b', \lam (a<x',x'<b) (a'<y',y'<b') =>
                 (c'<aa' <∘ <_*_positive-left a<x' a'>0 <∘ <_*_positive-right (a>0 <∘ a<x') a'<y',
                  <_*_positive-left x'<b (a'>0 <∘ a'<y') <∘ <_*_positive-right (a>0 <∘ a<x' <∘ x'<b) y'<b' <∘ bb'<d'))
           })

    \lemma *_positive-L {x y : Real} (x>0 : x.L 0) (y>0 : y.L 0) {c : Rat} : LowerReal.L {x * y} c <-> ∃ (a a' : Rat) (0 < a) (0 < a') (x.L a) (y.L a') (c < a *' a')
      => (\lam c<xy => \case U-inh {x * y} \with {
            | inP (d,xy<d) => \case (*_positive-char x>0 y>0).1 (c<xy,xy<d) \with {
              | inP (a,_,a',_,a>0,a'>0,(a<x,_),(a'<y,_),c<aa',_) => inP (a, a', a>0, a'>0, a<x, a'<y, c<aa')
            }
          }, \lam (inP (a,a',a>0,a'>0,a<x,a'<y,c<aa')) => \case x.U-inh, y.U-inh \with {
            | inP (b,x<b), inP (b',y<b') => ((*_positive-char x>0 y>0 {c} {b *' b' +' 1}).2 $ inP (a, b, a', b', a>0, a'>0, (a<x,x<b), (a'<y,y<b'), c<aa', linarith)).1
          })

    \lemma *_positive-U {x y : Real} (x>0 : x.L 0) (y>0 : y.L 0) {d : Rat} : UpperReal.U {x * y} d <-> ∃ (b b' : Rat) (x.U b) (y.U b') (b *' b' < d)
      => (\lam xy<d => \case L-inh {x * y} \with {
            | inP (c,c<xy) => \case (*_positive-char x>0 y>0).1 (c<xy,xy<d) \with {
              | inP (_,b,_,b',_,_,(_,x<b),(_,y<b'),_,bb'<d) => inP (b, b', x<b, y<b', bb'<d)
            }
          }, \lam (inP (b,b',x<b,y<b',bb'<d)) => \case L-rounded x>0, L-rounded y>0 \with {
            | inP (a,a<x,a>0), inP (a',a'<y,a'>0) => ((*_positive-char x>0 y>0 {a *' a' - 1} {d}).2 $ inP (a, b, a', b', a>0, a'>0, (a<x,x<b), (a'<y,y<b'), linarith, bb'<d)).2
          })

    \lemma <-char {x y : Real} : x RealField.< y <-> ∃ (a : Rat) (x.U a) (y.L a)
      => (aux.1 __, aux.2 __)
      \where {
        \protected \lemma aux {x y : Real} : LowerReal.L {y + negative x} 0 <-> x < y
          => <->trans +-L $ later (\lam (inP (a,b,a<y,b<-x,a+b>0)) => inP (a, U-closed (negative-L.1 b<-x) linarith, a<y), \lam (inP (a,x<a,a<y)) => \case L-rounded a<y \with {
            | inP (a',a'<y,a<a') => inP (a', AddGroup.negative a, a'<y, negative-L.2 $ rewrite AddGroup.negative-isInv x<a, linarith)
          })
      }

    \lemma <=_L-char {x y : Real} : x RealField.<= y <-> (\Pi {a : Rat} -> x.L a -> y.L a)
      => (\lam p => aux.1 \lam q => p q, aux.2 __ __)
      \where {
        \protected \lemma aux {x y : Real} : Not (LowerReal.L {x + negative y} 0) <-> (\Pi {a : Rat} -> x.L a -> y.L a)
          => (\lam h a<x => \case L-rounded a<x \with {
                | inP (b,b<x,a<b) => \case y.LU-located a<b \with {
                  | byLeft a<y => a<y
                  | byRight y<b => absurd $ h $ <-char.aux.2 $ inP (b,y<b,b<x)
                }
              }, \lam f p => \case <-char.aux.1 p \with {
                | inP (a,y<a,a<x) => y.LU-disjoint (f a<x) y<a
              })
      }

    \sfunc meet \alias \infixl 7 ∧ (x y : Real) : Real
      => cover (x,y)
      \where \protected {
        \func cover => lift2 $ rat2_real-uniMap' (__ ∧' __) \lam eps eps>0 _ => inP (eps, eps>0, \lam a b => inP (a ∧' b, \lam {x} {y} (a<x,x<a+eps) (b<y,y<b+eps) => (<_meet-monotone a<x b<y, transportInv (_ <) meet_+-right $ <_meet-monotone x<a+eps y<b+eps)))

        \lemma def : (\lam s => s.1 ∧ s.2) = cover
          => ext \lam s => later \peval s.1 ∧ s.2
      }

    \lemma meet-rat {x y : Rat} : x ∧ y = {Real} x ∧' y
      => (\peval x ∧ y) *> lift2-rat

    \lemma meet-cover : CoverMap (ProductCoverSpace RealCoverSpace RealCoverSpace) RealCoverSpace (\lam s => s.1 ∧ s.2)
      => rewrite ∧.def ∧.cover

    \lemma meet-char {x y : Real} {a b : Rat} : open-rat-int a b (x ∧ y) <-> (\Sigma (\Sigma (x.L a) (y.L a)) (x.U b || y.U b))
      => rewrite (\peval x ∧ y) $ <->trans (lift2-char a b) $ unfold
          (\lam (inP (a',b',c1,d1,c2,d2,a<a',b'<b,c1<x,x<d1,c2<y,y<d2,h)) =>
               (\case L-rounded c1<x, L-rounded c2<y \with {
                 | inP (c1',c1'<x,c1<c1'), inP (c2',c2'<y,c2<c2') =>
                   \have t => (h (c1<c1', LU-less c1'<x x<d1) (c2<c2', LU-less c2'<y y<d2)).1
                   \in (L-closed c1'<x $ a<a' <∘ t <∘l meet-left, L-closed c2'<y $ a<a' <∘ t <∘l meet-right)
               }, \case U-rounded x<d1, U-rounded y<d2 \with {
                 | inP (d1',x<d1',d1'<d1), inP (d2',y<d2',d2'<d2) =>
                   \have t => (h (LU-less c1<x x<d1', d1'<d1) (LU-less c2<y y<d2', d2'<d2)).2
                   \in \case TotalOrder.meet-isMin d1' d2' \with {
                     | byLeft p => byLeft $ U-closed x<d1' $ (rewrite p in t) <∘ b'<b
                     | byRight p => byRight $ U-closed y<d2' $ (rewrite p in t) <∘ b'<b
                   }
               }),
           \case __ \with {
             | ((a<x,a<y), byLeft x<b) => \case L-rounded a<x, L-rounded a<y, U-rounded x<b, y.U-inh \with {
               | inP (a1,a1<x,a<a1), inP (a2,a2<y,a<a2), inP (b1,x<b1,b1<b), inP (b2,y<b2) => inP (a1 ∧' a2, b1, a1, b1, a2, b2, <_meet-univ a<a1 a<a2, b1<b, a1<x, x<b1, a2<y, y<b2, \lam (a1<x',x'<b1) (a2<y',y'<b2) => (<_meet-monotone a1<x' a2<y', meet-left <∘r x'<b1))
             }
             | ((a<x,a<y), byRight y<b) => \case L-rounded a<x, L-rounded a<y, x.U-inh, U-rounded y<b \with {
               | inP (a1,a1<x,a<a1), inP (a2,a2<y,a<a2), inP (b1,x<b1), inP (b2,y<b2,b2<b) => inP (a1 ∧' a2, b2, a1, b1, a2, b2, <_meet-univ a<a1 a<a2, b2<b, a1<x, x<b1, a2<y, y<b2, \lam (a1<x',x'<b1) (a2<y',y'<b2) => (<_meet-monotone a1<x' a2<y', meet-right <∘r y'<b2))
             }
           })

    \lemma meet-L {x y : Real} {a : Rat} : LowerReal.L {x ∧ y} a <-> (\Sigma (x.L a) (y.L a))
      => (\case U-inh {x ∧ y} \with {
            | inP (b,u) => \lam l => (meet-char.1 (l,u)).1
          }, \lam e => \case x.U-inh \with {
            | inP (b,x<b) => (meet-char.2 (e, byLeft x<b)).1
          })

    \lemma meet-U {x y : Real} {b : Rat} : UpperReal.U {x ∧ y} b <-> (x.U b || y.U b)
      => (\case L-inh {x ∧ y} \with {
            | inP (a,l) => \lam u => (meet-char.1 (l,u)).2
          }, \lam e => \case x.L-inh, y.L-inh \with {
            | inP (a,a<x), inP (a',a'<y) => ((meet-char {x} {y} {a ∧' a'}).2 ((x.L_<= a<x meet-left, y.L_<= a'<y meet-right), e)).2
          })

    \sfunc join \alias \infixl 6 ∨ (x y : Real) : Real
      => cover (x,y)
      \where \protected {
        \func cover => lift2 $ rat2_real-uniMap' (__ ∨' __) \lam eps eps>0 _ => inP (eps, eps>0, \lam a b => inP (a ∨' b, \lam {x} {y} (a<x,x<a+eps) (b<y,y<b+eps) => (<_join-monotone a<x b<y, transportInv (_ <) join_+-right $ <_join-monotone x<a+eps y<b+eps)))

        \lemma def : (\lam s => s.1 ∨ s.2) = cover
          => ext \lam s => later \peval s.1 ∨ s.2
      }

    \lemma join-rat {x y : Rat} : x ∨ y = {Real} x ∨' y
      => (\peval x ∨ y) *> lift2-rat

    \lemma join-cover : CoverMap (ProductCoverSpace RealCoverSpace RealCoverSpace) RealCoverSpace (\lam s => s.1 ∨ s.2)
      => rewrite ∨.def ∨.cover

    \lemma join-char {x y : Real} {a b : Rat} : open-rat-int a b (x ∨ y) <-> (\Sigma (x.L a || y.L a) (\Sigma (x.U b) (y.U b)))
      => rewrite (\peval x ∨ y) $ <->trans (lift2-char a b) $ unfold
            (\lam (inP (a',b',c1,d1,c2,d2,a<a',b'<b,c1<x,x<d1,c2<y,y<d2,h)) =>
                 (\case L-rounded c1<x, L-rounded c2<y \with {
                   | inP (c1',c1'<x,c1<c1'), inP (c2',c2'<y,c2<c2') =>
                     \have t => (h (c1<c1', LU-less c1'<x x<d1) (c2<c2', LU-less c2'<y y<d2)).1
                     \in \case TotalOrder.join-isMax c1' c2' \with {
                       | byLeft p => byLeft $ L-closed c1'<x $ a<a' <∘ (rewrite p in t)
                       | byRight p => byRight $ L-closed c2'<y $ a<a' <∘ (rewrite p in t)
                     }
                 }, \case U-rounded x<d1, U-rounded y<d2 \with {
                    | inP (d1',x<d1',d1'<d1), inP (d2',y<d2',d2'<d2) =>
                      \have t => (h (LU-less c1<x x<d1', d1'<d1) (LU-less c2<y y<d2', d2'<d2)).2
                      \in (U-closed x<d1' $ join-left <∘r t <∘ b'<b, U-closed y<d2' $ join-right <∘r t <∘ b'<b)
                  }),
             \case __ \with {
               | (byLeft a<x, (x<b,y<b)) => \case L-rounded a<x, y.L-inh, U-rounded x<b, U-rounded y<b \with {
                 | inP (a1,a1<x,a<a1), inP (a2,a2<y), inP (b1,x<b1,b1<b), inP (b2,y<b2,b2<b) => inP (a1, b1 ∨' b2, a1, b1, a2, b2, a<a1, <_join-univ b1<b b2<b, a1<x, x<b1, a2<y, y<b2, \lam (a1<x',x'<b1) (a2<y',y'<b2) => (a1<x' <∘l join-left, <_join-monotone x'<b1 y'<b2))
               }
               | (byRight a<y, (x<b,y<b)) => \case x.L-inh, L-rounded a<y, U-rounded x<b, U-rounded y<b \with {
                 | inP (a1,a1<x), inP (a2,a2<y,a<a2), inP (b1,x<b1,b1<b), inP (b2,y<b2,b2<b) => inP (a2, b1 ∨' b2, a1, b1, a2, b2, a<a2, <_join-univ b1<b b2<b, a1<x, x<b1, a2<y, y<b2, \lam (a1<x',x'<b1) (a2<y',y'<b2) => (a2<y' <∘l join-right, <_join-monotone x'<b1 y'<b2))
               }
             })

    \lemma join-L {x y : Real} {a : Rat} : LowerReal.L {x ∨ y} a <-> x.L a || y.L a
      => (\case U-inh {x ∨ y} \with {
            | inP (b,u) => \lam l => (join-char.1 (l,u)).1
          }, \lam e => \case x.U-inh, y.U-inh \with {
            | inP (b,x<b), inP (c,y<c) => (join-char.2 (e, (x.U_<= x<b join-left, y.U_<= y<c join-right))).1
          })

    \lemma join-U {x y : Real} {b : Rat} : UpperReal.U {x ∨ y} b <-> (\Sigma (x.U b) (y.U b))
      => (\case L-inh {x ∨ y} \with {
            | inP (a,l) => \lam u => (join-char.1 (l,u)).2
          }, \lam s => \case x.L-inh \with {
            | inP (a,a<x) => (join-char.2 (byLeft a<x, s)).2
          })

    \func pos-inv {x : Real} (x>0 : x.L 0) : Real \cowith
      | L a => a <= 0 || x.U (finv a)
      | L-inh => inP (0, byLeft <=-refl)
      | L-closed {a} {b} p b<a => \case dec<_<= 0 b, \elim p \with {
        | inl b>0, byLeft p => absurd linarith
        | inl b>0, byRight p => byRight $ U-closed p $ finv_< b>0 b<a
        | inr b<=0, _ => byLeft b<=0
      }
      | L-rounded {a} => \case dec<_<= a 0, __ \with {
        | inl a<0, _ => inP (a *' ratio 1 2, byLeft linarith, linarith)
        | inr a>=0, byLeft a<=0 => \case x.U-inh \with {
          | inP (b,x<b) => inP (finv b, byRight $ transportInv x.U RatField.finv_finv x<b, rewrite (<=-antisymmetric a<=0 a>=0) $ finv>0 $ LU-less x>0 x<b)
        }
        | inr a>=0, byRight x<a1 => \case U-rounded x<a1 \with {
          | inP (b,x<b,b<a1) => inP (finv b, byRight $ transportInv x.U RatField.finv_finv x<b, finv_<-right (LU-less x>0 x<b) b<a1)
        }
      }
      | U a => \Sigma (0 < a) (x.L (finv a))
      | U-inh => \case L-rounded x>0 \with {
        | inP (a,a<x,a>0) => inP (finv a, (finv>0 a>0, transportInv x.L RatField.finv_finv a<x))
      }
      | U-closed (q>0,r) q<q' => (q>0 <∘ q<q', L-closed r $ finv_< q>0 q<q')
      | U-rounded (q>0,q1<x) => \case L-rounded q1<x \with {
        | inP (r,r<x,q1<r) => inP (finv r, (finv>0 $ finv>0 q>0 <∘ q1<r, transportInv x.L RatField.finv_finv r<x), finv_<-left q>0 q1<r)
      }
      | LU-disjoint p (q>0,r) => \case \elim p \with {
        | byLeft p => p q>0
        | byRight p => LU-disjoint r p
      }
      | LU-located {a} {b} a<b => \case dec<_<= 0 a \with {
        | inl a>0 => \case x.LU-located (finv_< a>0 a<b) \with {
          | byLeft p => byRight (a>0 <∘ a<b, p)
          | byRight p => byLeft $ byRight p
        }
        | inr a<=0 => byLeft (byLeft a<=0)
      }

    \lemma pos-inv>0 {x : Real} (x>0 : x.L 0) : LowerReal.L {pos-inv x>0} 0
      => byLeft <=-refl
  }

\lemma real_<_L {a : Rat} {x : Real} : (a : Real) RealField.< x <-> x.L a
  => (\lam p => \case RealField.<-char.1 p \with {
        | inP (b,a<b,b<x) => L-closed b<x a<b
      }, \lam a<x => RealField.<-char.2 \case L-rounded a<x \with {
        | inP (b,b<x,a<b) => inP (b,a<b,b<x)
      })

\lemma real_<_U {a : Rat} {x : Real} : x RealField.< a <-> x.U a
  => (\lam p => \case RealField.<-char.1 p \with {
        | inP (b,x<b,b<a) => U-closed x<b b<a
      }, \lam x<a => RealField.<-char.2 $ U-rounded x<a)