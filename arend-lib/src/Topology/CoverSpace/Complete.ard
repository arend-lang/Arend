\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths.Meta
\import Relation.Equivalence
\import Set.Filter
\import Set.Subset
\import Topology.CoverSpace
\open Set
\open Bounded(top,top-univ)

\record CauchyFilter (S : CoverSpace) \extends ProperFilter
  | X => S
  | isCauchyFilter {C : Set (Set S)} : isCauchy C -> ∃ (U : C) (F U)

\instance CauchyFilterPoset (S : CoverSpace) : Poset (CauchyFilter { | S => S })
  | <= F G => F ⊆ G
  | <=-refl c => c
  | <=-transitive f g c => g (f c)
  | <=-antisymmetric f g => exts \lam U => ext (f,g)

\type \infix 4 CF~ {S : CoverSpace} (F G : CauchyFilter { | S => S }) : \Prop
  => \Pi {C : Set (Set S)} -> isCauchy C -> ∃ (U : C) (\Sigma (F U) (G U))

\lemma CF~-sym {S : CoverSpace} {F G : CauchyFilter { | S => S }} (p : F CF~ G) : G CF~ F
  => \case p __ \with {
    | inP (U,CU,(FU,GU)) => inP (U,CU,(GU,FU))
  }

\func CF~_meet {S : CoverSpace} {F G : CauchyFilter { | S => S }} (p : F CF~ G) : CauchyFilter { | S => S } \cowith
  | ProperFilter => F ∧ {ProperFilterSemilattice S} G
  | isCauchyFilter => p

\lemma CF~_<= {S : CoverSpace} {F G : CauchyFilter { | S => S }} (p : F ⊆ G) : F CF~ G
  => \lam c => \case isCauchyFilter c \with {
    | inP (U,CU,FU) => inP (U, CU, (FU, p FU))
  }

\lemma CF~_<=< {S : CoverSpace} {F G : CauchyFilter { | S => S }} (F~G : F CF~ G) {U V : Set S} (p : U <=< V) (FU : F U) : G V
  => \case F~G p \with {
    | inP (W, f, (FW, GW)) => filter-mono (f $ isProper $ filter-meet FU FW) GW
  }

\instance CauchyFilterEquivalence (S : CoverSpace) : Equivalence (CauchyFilter { | S => S })
  | ~ => CF~
  | ~-transitive p q c => \case p (isRegular c) \with {
    | inP (U, inP (V, CV, U<=<V), (FU, GU)) => inP (V, CV, (filter-mono (<=<_<= U<=<V) FU, CF~_<=< q U<=<V GU))
  }
  | ~-reflexive c => \case isCauchyFilter c \with {
    | inP (U,CU,FU) => inP (U,CU,(FU,FU))
  }
  | ~-symmetric => CF~-sym

\record MinCauchyFilter \extends CauchyFilter
  | isMinFilter {G : CauchyFilter { | S => S }} : G ⊆ F -> F ⊆ G
  \where {
    \lemma Min_CF~_<= {S : CoverSpace} {F : MinCauchyFilter { | S => S }} {G : CauchyFilter { | S => S }} (p : F CF~ G) : F ⊆ G
      => F.isMinFilter {CF~_meet p} meet-left <=∘ meet-right

    \lemma equality {S : CoverSpace} {F G : MinCauchyFilter { | S => S }} (p : F CF~ G) : F = G
      => exts \lam U => ext (Min_CF~_<= p {_}, Min_CF~_<= (CF~-sym p) {_})
  }

-- | The unique minimal Cauchy filter equivalent to the given one.
\func minCauchyFilter {S : CoverSpace} (F : CauchyFilter { | S => S }) : MinCauchyFilter { | S => S } \cowith
  | F U => \Pi {G : CauchyFilter { | S => S }} -> G ⊆ F -> G U
  | filter-mono p q c => filter-mono p (q c)
  | filter-top _ => filter-top
  | filter-meet p q c => filter-meet (p c) (q c)
  | isProper p => F.isProper (p <=-refl)
  | isCauchyFilter c => \case F.isCauchyFilter (isRegular c) \with {
    | inP (U, inP (V, CV, U<=<V), FU) => inP (V, CV, \lam p => CF~_<=< (CF~-sym $ CF~_<= p) U<=<V FU)
  }
  | isMinFilter p q => q \lam GU => p GU \lam c => c

\lemma minCauchyFilter_CF~ {S : CoverSpace} {F : CauchyFilter { | S => S }} : minCauchyFilter F CF~ F
  => CF~_<= {_} {minCauchyFilter F} \lam u => u <=-refl

\record RegularCauchyFilter \extends MinCauchyFilter
  | isRegularCauchyFilter {U : Set S} : F U -> ∃ (V : Set S) (V <=< U) (F V)
  | isMinFilter {G} p FU => \case isRegularCauchyFilter FU \with {
    | inP (V,V<=<U,FV) => CF~_<=< {_} {_} {G} (CF~-sym {_} {G} $ CF~_<= {S} p) V<=<U FV
  }

\func pointCauchyFilter {S : CoverSpace} (x : S) : RegularCauchyFilter { | S => S } \cowith
  | F U => single x <=< U
  | filter-mono p q => <=<-left q p
  | filter-top => _<=<top
  | filter-meet p q => <=<-right (meet-univ <=-refl <=-refl) (<=<_meet p q)
  | isProper p => inP (x, <=<_<= p idp)
  | isCauchyFilter c => \case cauchy-covers (isRegular c) x \with {
    | inP (U, inP (V,CV,U<=<V), Ux) => inP (V, CV, <=<-right (single_<= Ux) U<=<V)
  }
  | isRegularCauchyFilter p => unfolds at p $ \case cauchy-covers (isRegular (isRegular p)) x \with {
    | inP (V, inP (W, inP (Z, f, W<=<Z), V<=<W), Vx) => inP (W, <=<-left W<=<Z $ f $ inP (x, (idp, <=<_<= W<=<Z $ <=<_<= V<=<W Vx)), <=<-right (single_<= Vx) V<=<W)
  }

\class HausdorffCoverSpace \extends CoverSpace
  | isHausdorffCoverSpace {x y : E} : (\Pi {C : Set (Set E)} -> isCauchy C -> ∃ (U : C) (\Sigma (U x) (U y))) -> x = y

\func IsCompleteCoverSpace (S : CoverSpace) => \Pi (F : MinCauchyFilter { | S => S }) -> ∃ (x : S) (pointCauchyFilter x ⊆ F)

\class CompleteCoverSpace \extends HausdorffCoverSpace
  | isCompleteCoverSpace : IsCompleteCoverSpace \this

\instance CompletionCoverSpace (S : CoverSpace) : CompleteCoverSpace (MinCauchyFilter { | S => S })
  | isCauchy => isCCauchy
  | cauchy-covers {D} (inP (C,Cc,p)) F =>
    \have | (inP (U,CU,FU)) => isCauchyFilter Cc
          | (inP (V,DV,q)) => p CU
    \in inP (V, DV, q FU)
  | cauchy-top => inP (single top, cauchy-top, \lam _ => inP (top, idp, \lam _ => ()))
  | cauchy-extend (inP (E,Ec,g)) f => inP (E, Ec, \lam EU =>
      \have | (inP (V,CV,p)) => g EU
            | (inP (W,DW,q)) => f CV
      \in inP (W, DW, p <=∘ q))
  | cauchy-trans {C} {D} (inP (C',C'c,f)) Dc => inP (_, S.cauchy-trans {C'} {\lam U' V' => ∃ (U : C) (V : D U) (mkSet U' ⊆ U) (mkSet V' ⊆ V)} C'c \lam {U'} C'U' =>
      \have | (inP (U,CU,U'<=U)) => f C'U'
            | (inP (D',D'c,g)) => Dc CU
      \in cauchy-extend D'c \lam {V'} D'V' => \case g D'V' \with {
        | inP (V,DV,V'<=V) => inP (V', inP (U, CU, V, DV, U'<=U, V'<=V), <=-refl)
      }, \lam {W'} (inP (U', V', C'U', inP (U, CU, V, DV, U'<=U, V'<=V), W'=U'V')) => inP (U ∧ V, inP (U, V, CU, DV, idp), rewrite W'=U'V' \lam {F} FU'V' => (U'<=U $ filter-mono meet-left FU'V', V'<=V $ filter-mono meet-right FU'V')))
  | isRegular {D} (inP (C,Cc,f)) =>
    \have <=<_mkFilters {U' U : Set S} (p : U' <=< U) : mkSet U' <=< mkSet U
          => unfolds $ inP (_, p, \lam {W} g => inP (mkSet W, \lam (inP (F,(FU',FW))) => mkSet_<= $ g (isProper (filter-meet FU' FW)), <=-refl))
    \in inP (_, isRegular Cc, \lam {U'} (inP (U,CU,U'<=<U)) => \case f CU \with {
      | inP (V,DV,U<=V) => inP (mkSet U', inP (V, DV, <=<-left (<=<_mkFilters U'<=<U) U<=V), <=-refl)
    })
  | isHausdorffCoverSpace p => MinCauchyFilter.equality \lam Cc => \case p (mkCover-cauchy Cc) \with {
    | inP (_, inP (U,CU,idp), r) => inP (U,CU,r)
  }
  | isCompleteCoverSpace F => inP
      (\new MinCauchyFilter {
        | F U => F (mkSet U)
        | filter-mono p => filter-mono (mkSet_<= p)
        | filter-top => rewrite mkSet_top filter-top
        | filter-meet x y => rewrite mkSet_meet (filter-meet x y)
        | isProper x => \case isProper x \with {
          | inP s => isProper {s.1} s.2
        }
        | isCauchyFilter Cc => \case isCauchyFilter {F} (mkCover-cauchy Cc) \with {
          | inP (V, inP (U,CU,p), FV) => inP (U, CU, rewriteI p FV)
        }
        | isMinFilter {G} p c => \have (inP (U',GU',q)) => isMinFilter {F} {\new CauchyFilter {
                                                                              | F V => ∃ (U : Set S) (minCauchyFilter G U) (mkSet U ⊆ V)
                                                                              | filter-mono p (inP (U,GU,q)) => inP (U, GU, q <=∘ p)
                                                                              | filter-top => inP (top, \lam _ => filter-top, top-univ)
                                                                              | filter-meet (inP (U1,GU1,p1)) (inP (U2,GU2,p2)) => inP (U1 ∧ U2, filter-meet GU1 GU2, rewrite mkSet_meet $ MeetSemilattice.meet-monotone p1 p2)
                                                                              | isProper {V} (inP (U',GU',q)) => inP (minCauchyFilter G, q $ later GU')
                                                                              | isCauchyFilter {D} (inP (C,Cc,f)) =>
                                                                                \have | (inP (U',CU',GU')) => isCauchyFilter {minCauchyFilter G} Cc
                                                                                      | (inP (V,DV,q)) => f CU'
                                                                                \in inP (V, DV, inP (U',GU',q))
                                                                           }} (\lam {V} (inP (U',GU',q)) => filter-mono q $ p $ GU' <=-refl) c
                                 \in q {minCauchyFilter G} GU' <=-refl
       }, \lam {V} (inP (C,Cc,f)) =>
            \have | (inP (V', inP (U,CU,p), FV')) => isCauchyFilter {F} (mkCover-cauchy Cc)
                  | (inP (W,g,q)) => f CU
            \in filter-mono (g $ inP (_, (idp, q $ later $ rewriteF p FV'))) $ filter-mono q $ rewriteI p FV')
  \where {
    \func mkSet (U : Set S) : Set (MinCauchyFilter { | S => S })
      => \lam F => F U

    \lemma mkSet_<= {U V : Set S} (p : U ⊆ V) : mkSet U ⊆ mkSet V
      => \lam {F} => filter-mono p

    \lemma mkSet_top : mkSet top = \lam _ => \Sigma
      => ext \lam F => ext (\lam _ => (), \lam _ => filter-top)

    \lemma mkSet_meet {U V : Set S} : mkSet (U ∧ V) = mkSet U ∧ mkSet V
      => ext \lam F => ext (\lam x => (mkSet_<= (later __.1) x, mkSet_<= (later __.2) x), \lam s => filter-meet s.1 s.2)

    \func isCCauchy (D : Set (Set (MinCauchyFilter { | S => S })))
      => ∃ (C : Set (Set S)) (S.isCauchy C) (\Pi {U : Set S} -> C U -> ∃ (V : D) (mkSet U ⊆ V))

    \func mkCover (C : Set (Set S)) : Set (Set (MinCauchyFilter { | S => S }))
      => \lam V => ∃ (U : C) (V = mkSet U)

    \lemma mkCover-cauchy {C : Set (Set S)} (Cc : isCauchy C) : isCCauchy (mkCover C)
      => inP (C, Cc, \lam {U} CU => inP (mkSet U, inP (U,CU,idp), <=-refl))
  }