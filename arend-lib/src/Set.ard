\import Equiv
\import Equiv.Path
\import Logic
\import HLevel
\import Paths

\data \infixl 6 + (A B : \Type)
  | inl A
  | inr B

\class Dec (E : \Type)
  | decide : E + Not E

\func DecEq (A : \Type) => \Pi {a a' : A} -> Dec (a = a')

{-
\func Hedberg {A : \Type} (d : DecEq A) : isSet A => \lam x x' =>
  \let | R {a a' : A} (p : (a = a') + Not (a = a')) : \Prop => \case p \with { | inl _ => Unit | inr _ => Empty }
       | refl {a : A} (p : (a = a) + Not (a = a)) => \case p \as p' \return R p' \with { | inl _ => unit | inr q => q idp }
       | equiv : Equiv {x = x'} {R x x'} => propPathEquiv (\lam a a' => R {a} {a'} (decide {d {a} {a'}})) (\lam a => refl (decide {d {a} {a}})) {?} {x} {x'}
  \in \lam p p' => equiv.f p
  \where
    \func propPathEquiv {A : \Type} (R : A -> A -> \Prop) (refl : \Pi (a : A) -> R a a) (p : \Pi {a a' : A} -> R a a' -> a = a') {a a' : A} : QEquiv {a = a'} {R a a'}
      => pathEquiv R (\lam {a} {a'} => \new Retraction (\lam q => transport (R a) q (refl a)) p {?})
-}