\import Algebra.Ordered
\import Data.Or
\import Logic
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder \hiding (<=)
\import Order.StrictOrder
\import Paths
\open Nat

-- # Various operations

\func pred (x : Nat) : Nat
  | zero => 0
  | suc x' => x'

\func \infixl 6 -' (n m : Nat) : Nat
  | 0, _ => 0
  | suc n, 0 => suc n
  | suc n, suc m => n -' m

\lemma -'id (n : Nat) : n -' n = 0 \elim n
  | 0 => idp
  | suc n => -'id n

\func suc/=0 {n : Nat} (p : suc n = 0) {A : \Type} : A =>
  coe (\case p @ __ \with { suc _ => Nat | 0 => A }) 0 right

-- # Properties of <= and <

\instance NatLE : TotalOrder Nat
  | <= => <=
  | <=-reflexive {n : Nat} : n <= n \elim n {
    | 0 => zero<=_
    | suc n => suc<=suc <=-reflexive
  }
  | <=-transitive {n m k : Nat} (p : n <= m) (q : m <= k) : n <= k \with {
    | {0}, _, _ => zero<=_
    | {suc n}, {suc m}, {suc k}, suc<=suc p, suc<=suc q => suc<=suc (<=-transitive p q)
  }
  | <=-antisymmetric {n m : Nat} (p : n <= m) (q : m <= n) : n = m \elim n, m, p, q {
    | 0, 0, _, _ => idp
    | suc n, suc m, suc<=suc p, suc<=suc q => pmap suc (<=-antisymmetric p q)
  }
  | totality (n m : Nat) : n <= m || m <= n \with {
    | 0, _ => byLeft zero<=_
    | suc n, 0 => byRight zero<=_
    | suc n, suc m => ||.map suc<=suc suc<=suc (totality n m)
  }
  \where
    \lemma unsuc {n m : Nat} (p : suc n <= suc m) : n <= m
      | suc<=suc p => p

\instance NatBSemilattice : Bounded.JoinSemilattice
  | JoinSemilattice => NatLE
  | bottom => 0
  | bottom-univ => zero<=_

\lemma <=-suc {n : Nat} : n <= suc n \elim n
  | 0 => zero<=_
  | suc n => suc<=suc <=-suc

\lemma <=_0_+-left {n : Nat} (m : Nat) : n <= m + n \elim n
  | 0 => zero<=_
  | suc n => suc<=suc (<=_0_+-left m)

\lemma <=_0_+-right {n : Nat} (m : Nat) : n <= n + m \elim m
  | 0 => <=-reflexive
  | suc m => <=-transitive (<=_0_+-right m) <=-suc

\lemma <=-+ {n m : Nat} (p : n <= m) : n + (m -' n) = m \elim n, m, p
  | 0, 0, _ => idp
  | 0, suc m, _ => idp
  | suc n, suc m, suc<=suc p => pmap suc (<=-+ p)

\lemma <=_+ {n m k l : Nat} (n<=m : n <= m) (k<=l : k <= l) : n + k <= m + l \elim k, l, k<=l
  | 0, l, _ => <=-transitive n<=m (<=_0_+-right l)
  | suc k, suc l, suc<=suc k<=l => suc<=suc (<=_+ n<=m k<=l)

\lemma <-implies-<= {n m : Nat} (p : suc n <= m) : n <= m => <=-transitive <=-suc p

\lemma monotone-diagonal (f : Nat -> Nat) (mon : \Pi (n : Nat) -> suc (f n) <= f (suc n)) {n : Nat} : n <= f n \elim n
  | 0 => zero<=_
  | suc n => <=-transitive (suc<=suc (monotone-diagonal f mon)) (mon n)

-- # Properties of +, *, and <

\instance NatStrictPoset : StrictPoset Nat
  | < n m => suc n <= m
  | <-irreflexive {n : Nat} (p : suc n <= n) : Empty \elim n, p {
    | suc n, suc<=suc p => <-irreflexive p
  }
  | <-transitive p q => <=-transitive p (<=-transitive <=-suc q)

\instance NatSemiring : LinearlyOrderedCSemiring.Dec Nat
  | zro => 0
  | + => +
  | zro-left => idp
  | +-assoc {n m k : Nat} : (n + m) + k = n + (m + k) \elim k {
    | 0 => idp
    | suc k => pmap suc +-assoc
  }
  | +-comm {n m : Nat} : n + m = m + n \elim n, m {
    | 0, m => idp
    | n, 0 => idp
    | suc n, suc m => pmap (\lam x => suc (suc x)) +-comm
  }
  | ide => 1
  | * => *
  | ide-left {n : Nat} : 1 * n = n \elim n {
    | 0 => idp
    | suc n => pmap suc ide-left
  }
  | *-assoc {n m k : Nat} : (n * m) * k = n * (m * k) \elim k {
    | 0 => idp
    | suc k => pmap (`+ n * m) *-assoc *> inv ldistr
  }
  | ldistr {n m k : Nat} : n * (m + k) = n * m + n * k \elim k {
    | 0 => idp
    | suc k =>
        n * (m + k) + n     ==< pmap (`+ n) ldistr >==
        n * m + n * k + n   ==< +-assoc >==
        n * m + (n * k + n) `qed
  }
  | *-comm {n m : Nat} : n * m = m * n \elim n, m {
    | 0, 0 => idp
    | suc n, 0 => *-comm
    | 0, suc m => *-comm
    | suc n, suc m => pmap suc (
        suc n * m + n   ==< pmap (`+ n) *-comm >==
        m * n + m + n   ==< +-assoc >==
        m * n + (m + n) ==< pmap2 (+) (inv *-comm) +-comm >==
        n * m + (n + m) ==< inv +-assoc >==
        n * m + n + m   ==< pmap (`+ m) *-comm >==
        suc m * n + m   `qed)
  }
  | zro_*-left => *-comm
  | StrictPoset => NatStrictPoset
  | trichotomy n m => \case n - m \as d, idp : n - m = d \with {
    | pos 0, p => equals (triEquals p)
    | pos (suc d), p => greater (triGreater p)
    | neg (suc d), p => less (triLess p)
  }
  | <_+-left (n m k : Nat) (p : suc n <= m) : suc (n + k) <= m + k \elim k {
    | 0 => p
    | suc k => suc<=suc (<_+-left n m k p)
  }
  | zro<ide => suc<=suc zero<=_
  | <_*_positive-left {n m k : Nat} (p : suc n <= m) (q : 1 <= k) : suc (n * k) <= m * k \elim k, q {
    | 1, _ => p
    | suc (suc k), q => <=_+ (<=-transitive <=-suc (<_*_positive-left p (suc<=suc zero<=_))) p
  }
  | <_*_negative-left x<y z<0 => \case z<0 \with {}
  | natCoef n => n
  | natCoefZero => idp
  | natCoefSuc n => idp
  \where {
    \open LinearOrder \hiding (<=)

    \lemma triEquals {n m : Nat} (p : n - m = 0) : n = m \elim n, m
      | 0, 0 => idp
      | suc n, suc m => pmap suc (triEquals p)

    \lemma triGreater {n m d : Nat} (p : n - m = suc d) : suc m <= n \elim n, m, p
      | suc n, 0, p => suc<=suc zero<=_
      | suc n, suc m, p => suc<=suc (triGreater p)

    \lemma triLess {n m d : Nat} (p : n - m = neg (suc d)) : suc n <= m \elim n, m, p
      | 0, suc m, p => suc<=suc zero<=_
      | suc n, suc m, p => suc<=suc (triLess p)
  }
