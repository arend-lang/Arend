\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Rat
\import Arith.Real
\import Arith.Real.Field
\import Arith.Real.IVT
\import Arith.Real.LowerReal
\import Data.Or
\import Equiv
\import Function.Meta
\import Logic
\import Order.Biordered
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Set.Subset
\import Topology.Elem
\import Topology.NormedAbGroup.Real
\import Topology.TopRing
\import Topology.TopRing.Real
\import Topology.TopSpace
\open Monoid(pow)
\open ContMap

\sfunc rootR (n : Nat) (n/=0 : n /= 0) (x : Real) (\property x>=0 : 0 <= x) : Real
  => ((rootEquiv n/=0).ret (x,x>=0)).1
  \where {
    \func rootEquiv {n : Nat} (n/=0 : n /= 0) : Equiv {Elem {Real} (0 <=)} {Elem {Real} (0 <=)}
      => monotone-inverse (\lam s => pow s.1 n)
        (\lam {x} {y} p => RealField.pow_<-monotone n/=0 x.2 p)
        (TopMonoid.pow-cont ∘ elemCont)
        (\lam x => RealField.pow>=0 {x.1} x.2)
        (\lam {v} v>=0 => inP (0, v ∨ 1, zro<ide <∘l join-right, \lam p _ => p, transportInv (`<= v) (Semiring.pow_0 n/=0) v>=0, join-left <=∘ RealField.pow>=id join-right n/=0))
  }

\lemma rootR>=0 {n : Nat} {n/=0 : n /= 0} {x : Real} {x>=0 : 0 <= x} : 0 <= rootR n n/=0 x x>=0
  => transportInv (0 <=) (\peval rootR n n/=0 x x>=0) ((rootR.rootEquiv n/=0).ret (x,x>=0)).2

\lemma rootR_pow {n : Nat} {n/=0 : n /= 0} {x : Real} {x>=0 : 0 <= x} : rootR n n/=0 (pow x n) (RealField.pow>=0 x>=0) = x
  => (\peval rootR n n/=0 _ _) *> pmap __.1 ((rootR.rootEquiv n/=0).ret_f (x,x>=0))

\lemma pow_rootR {n : Nat} {n/=0 : n /= 0} {x : Real} {x>=0 : 0 <= x} : pow (rootR n n/=0 x x>=0) n = x
  => pmap (pow __ n) (\peval rootR n n/=0 x x>=0) *> pmap __.1 ((rootR.rootEquiv n/=0).f_ret _)