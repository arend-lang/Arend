\import Algebra.Group
\import Algebra.Module
\import Algebra.Module.LinearMap
\import Algebra.Monoid
\import Analysis.Limit
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Operations
\import Order.Lattice
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.TopAbGroup
\import Topology.TopModule
\import Topology.TopRing
\import Topology.TopSpace
\import Topology.TopSpace.Product
\open ContMap
\open ProductTopSpace
\open Monoid(Inv)

\func dquot {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (f : Set.Total S -> Y) {x : Set.Total S} (h : Inv {R}) {a : X} (\property s : S (x.1 + h.val *c a))
  => h.inv *c (f (_,s) - f x)
  \where {
    \lemma dquot_*c (S : Set X) {f : Set.Total S -> Y} {x : Set.Total S} {h : Inv {R}} (c : Inv {R}) (Sh : S (x.1 + h.val *c (c.val *c a)))
      : dquot f h Sh = c.val *c dquot f (Inv.prod h c) (transportInv S (pmap (_ +) *c-assoc) Sh)
      => inv (pmap2 (\lam y z => y *c (f z - _)) (inv *-assoc *> pmap (`* _) c.inv-right *> ide-left) (ext $ pmap (_ +) *c-assoc)) *> *c-assoc

    \lemma dquot_+ (S : Set X) {f g : Set.Total S -> Y} {x : Set.Total S} {h : Inv {R}} (Sh : S (x.1 + h.val *c a))
      : dquot (\lam x => f x + g x) h Sh = dquot f h Sh + dquot g h Sh
      => Y.*c-ldistr_- *> pmap2 (-) Y.*c-ldistr Y.*c-ldistr *> +-assoc *> pmap (_ +) (pmap (_ +) Y.negative_+ *> inv +-assoc *> +-comm) *> inv +-assoc *> inv (pmap2 (+) Y.*c-ldistr_- Y.*c-ldistr_-)

    \lemma dquot_bilinear {R : NearSkewField} {X X1 X2 Y : TopLModule R} (S : Set X) {f : Set.Total S -> X1} {g : Set.Total S -> X2} {x : Set.Total S} {a : X} (b : BilinearMap X1 X2 Y)
                          (h : Inv {R}) (Sh : S (x.1 + h.val *c a)) : dquot (\lam x => b (f x) (g x)) h Sh = b (dquot f h Sh) (g (x.1 + h.val *c a, Sh)) + b (f x) (dquot g h Sh)
      => pmap (_ *c) (simplify *> inv (pmap2 (+) b.linear-left.func-minus b.linear-right.func-minus)) *> *c-ldistr *> inv (pmap2 (+) b.linear-left.func-*c b.linear-right.func-*c)
  }

\func IsDirDerivAt {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (So : isOpen S) (f : Set.Total S -> Y) (x : Set.Total S) (a : X) (d : Y) : \Prop
  => Y.IsLimit {DirSet So} (\lam h => dquot f h.6.1 h.6.2) d
  \where {
    \private \lemma aux1 (So : isOpen S) => func-cont {+-cont ∘ tuple (const x.1) (*c-cont ∘ tuple id (const a))} So

    \private \lemma aux2 => transportInv S (pmap (x.1 +) (X.*c_zro-left {a}) *> zro-right) x.2

    \protected \func DirSet (So : isOpen S) => InvDirectedSet (aux1 So) aux2

    \lemma limit-id (So : isOpen S) => InvDirectedSet.limit-id (aux1 So) aux2

    \lemma limit-char (So : isOpen S)
      : IsDirDerivAt So f x a d <-> ∀ {V : Y.isOpen} (V 0) ∃ (W : R.isOpen) (W 0) ∀ {h : W} (hi : Inv h) (s : S (x.1 + h *c a)) (V (d - dquot f hi s))
      => <->trans (InvDirectedSet.limit-char (aux1 So) aux2 {dquot f __}) $ later
          (\lam fc {V} Vo V0 => \case fc (Y.UBall-open Vo) (Y.UBall-center {V} V0) \with {
            | inP (W,Wo,W0,g) => inP (W, Wo, W0, \lam Uh hi Sh => g Uh (hi,Sh))
          }, \lam fc {V} Vo Vd => \case fc (Y.UBall-open Vo) (Y.UBall-point {V} Vd) \with {
            | inP (W,Wo,W0,g) => inP (W, Wo, W0, \lam Wh s => simplify in g Wh s.1 s.2)
          })

    \protected \lemma unique {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} {S : Set X} (So : isOpen S) (f : Set.Total S -> Y)
                             (x : Set.Total S) (a : X) {d d' : Y} (dd : IsDirDerivAt So f x a d) (d'd : IsDirDerivAt So f x a d') : d = d'
      => Y.limit-unique dd d'd
  }

\func IsDerivAt {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (So : isOpen S) (f : Set.Total S -> Y) (x : Set.Total S) (Df : X -> Y) : \Prop
  => \Sigma (\Pi (a : X) -> IsDirDerivAt So f x a (Df a)) (IsContAt {TopSub S} f x)

\lemma deriv-linear {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} (S : Set X) (So : isOpen S) (f : Set.Total S -> Y) (x : Set.Total S) (Df : TopAbGroupMap X Y) (Dfd : IsDerivAt So f x Df) : LinearMap X Y Df \cowith
  | func-+ => Df.func-+
  | func-*c {_} {a} => denseSet-lift-unique R.inv-dense (Df ∘ *c-cont ∘ tuple id (const a)) (*c-cont ∘ tuple id (const _))
      \lam {c} ci => IsDirDerivAt.unique So f x (c *c a) (Dfd.1 _) $ dirDeriv-*c So (Dfd.1 a) ci
  \where {
    \lemma dirDeriv-*c (So : isOpen S) {a : X} {d : Y} (p : IsDirDerivAt So f x a d) (c : Inv {R})
      : IsDirDerivAt So f x (c.val *c a) (c.val *c d)
      => (IsDirDerivAt.limit-char So).2 \lam {V} Vo V0 => \case (IsDirDerivAt.limit-char So).1 p (func-cont {*c-cont ∘ tuple (const c.val) id} Vo) (transportInv V Y.*c_zro-right V0) \with {
        | inP (U,Uo,U0,g) => inP (_, func-cont {*-cont ∘ tuple id (const c.val)} Uo, transportInv U R.zro_*-left U0, \lam Uh hi Sh =>
            transport V (Y.*c-ldistr_- *> pmap (_ -) (inv $ dquot.dquot_*c S c Sh)) $ g Uh (Inv.prod hi c) _)
      }
  }

\lemma dirDeriv_+ {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (So : isOpen S) {f g : Set.Total S -> Y} {x : Set.Total S} {a : X}
                  (Df Dg : Y) (fd : IsDirDerivAt So f x a Df) (gd : IsDirDerivAt So g x a Dg) : IsDirDerivAt So (\lam x => f x + g x) x a (Df + Dg)
  => transportInv (Y.IsLimit __ _) (ext \lam h => dquot.dquot_+ S h.6.2) (cont2-limit fd gd +-cont)

\lemma deriv_+ {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (So : isOpen S) {f g : Set.Total S -> Y} {x : Set.Total S}
               (Df Dg : X -> Y) (fd : IsDerivAt So f x Df) (gd : IsDerivAt So g x Dg) : IsDerivAt So (\lam x => f x + g x) x (\lam a => Df a + Dg a)
  => (\lam a => dirDeriv_+ So (Df a) (Dg a) (fd.1 a) (gd.1 a), contAt-left {TopSub S} +-cont (contAt-tuple {TopSub S} fd.2 gd.2))

\lemma dirDeriv_bilinear {R : NearSkewField} {X X1 X2 Y : TopLModule R} {S : Set X} (So : isOpen S) {f : Set.Total S -> X1} {g : Set.Total S -> X2} {x : Set.Total S} (gc : IsContAt {TopSub S} g x) {a : X}
                         (b : BilinearMap X1 X2 Y) (bc : ContMap (X1 ⨯ X2) Y \lam s => b s.1 s.2) (Df : X1) (Dg : X2) (fd : IsDirDerivAt So f x a Df) (gd : IsDirDerivAt So g x a Dg)
  : IsDirDerivAt So (\lam x => b (f x) (g x)) x a (b Df (g x) + b (f x) Dg)
  => transportInv {IsDirDerivAt.DirSet So -> Y} (Y.IsLimit __ (b Df (g x) + b (f x) Dg)) {\lam h => dquot (\lam x => b (f x) (g x)) h.6.1 h.6.2} {\lam h => b (dquot f h.6.1 h.6.2) (g (x.1 + h.4 *c a, h.6.2)) + b (f x) (dquot g h.6.1 h.6.2)}
      (ext \lam h => dquot.dquot_bilinear S b h.6.1 h.6.2) $
      cont2-limit (cont2-limit fd (contAt-limit {_} {TopSub S} (TopSub-limit $ transport (X.IsLimit _) (pmap (_ +) X.*c_zro-left *> zro-right) $ cont-limit (IsDirDerivAt.limit-id So) (+-cont ∘ tuple (const x.1) (*c-cont ∘ tuple id (const a)))) gc) bc) (cont-limit gd (bc ∘ tuple (const _) id)) +-cont

\lemma deriv_bilinear {R : NearSkewField} {X X1 X2 Y : TopLModule R} {S : Set X} (So : isOpen S) {x : Set.Total S} {f : Set.Total S -> X1} {g : Set.Total S -> X2}
                      (b : BilinearMap X1 X2 Y) (bc : ContMap (X1 ⨯ X2) Y \lam s => b s.1 s.2) (Df : X -> X1) (Dg : X -> X2) (fd : IsDerivAt So f x Df) (gd : IsDerivAt So g x Dg)
  : IsDerivAt So (\lam x => b (f x) (g x)) x (\lam a => b (Df a) (g x) + b (f x) (Dg a))
  => (\lam a => dirDeriv_bilinear So gd.2 b bc (Df a) (Dg a) (fd.1 a) (gd.1 a), contAt-left {TopSub S} bc (contAt-tuple {TopSub S} fd.2 gd.2))

-- | Stronger versions of derivative
\module DerivVariations \where {
  \func IsDerivAtLocal {R : NearSkewField} {X Y : TopLModule R} (S : Set X) (f : Set.Total S -> Y) (x : Set.Total S) (Df : X -> Y) : \Prop
    => ∀ {V : Y.isOpen} (V 0) a0 ∃ (U : X.isOpen) (U 0) (W : R.isOpen) (W 0) ∀ {a : X.UBall U a0} (h : Inv {R}) (W h) (Sh : S (x.1 + h.val *c a)) (V (Df a - dquot f h Sh))

  \lemma derivLocal-isDirDeriv {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (So : isOpen S) {f : Set.Total S -> Y} {x : Set.Total S} {Df : X -> Y} (Dfd : IsDerivAtLocal S f x Df) (a : X) : IsDirDerivAt So f x a (Df a)
    => (IsDirDerivAt.limit-char So).2 \lam Vo V0 => \case Dfd Vo V0 a \with {
      | inP (U,Uo,U0,W,Wo,W0,g) => inP (W, Wo, W0, \lam Wh hi Sh => g (transportInv U negative-right U0) hi Wh Sh)
    }

  \lemma dirDeriv_zro {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} {S : Set X} (So : isOpen S) {f : Set.Total S -> Y} {x : Set.Total S} : IsDirDerivAt So f x 0 0
    => (IsDirDerivAt.limit-char So).2 \lam Vo V0 => inP (Bounded.top, open-top, (), \lam _ _ _ => unfold dquot $ rewrite (zro-left,X.*c_zro-right,zro-right,negative-right,Y.*c_zro-right,Y.negative_zro) V0)

  \lemma derivLocal-isDeriv {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} (S : Set X) (So : isOpen S) {f : Set.Total S -> Y} {x : Set.Total S} {Df : ContMap X Y} (Dfd : IsDerivAtLocal S f x Df) : IsDerivAt So f x Df
    => (derivLocal-isDirDeriv So Dfd, topAb-sub-contAt.2 \lam {V} Vo V0 => \case Y.*c-cont.func-cont Vo {0,0} $ transportInv V Y.*c_zro-left V0 \with {
          | inP (W,Wo,W0,V',V'o,V'0,g) =>
            \have | (inP (V'',V''o,V''0,V''<=<V')) => Y.shrink V'o V'0
                  | (inP (U,Uo,U0,U_V'')) => cont-char.1 Df 0 V''o (transport V'' (IsDirDerivAt.unique So f x 0 (dirDeriv_zro So) (derivLocal-isDirDeriv So Dfd 0)) V''0)
                  | (inP (U',U'o,U'0,W',W'o,W'0,g')) => Dfd V''o V''0 0
                  | (inP (h,hi : Inv,(Wh,W'h))) => R.inv-dense (open-inter Wo W'o) (W0,W'0)
            \in inP (_, func-cont {*c-cont ∘ tuple (const hi.inv) id} (open-inter (negative-cont.func-cont Uo) U'o),
                     (transportInv U (pmap negative X.*c_zro-right *> X.negative_zro) U0, transportInv U' X.*c_zro-right U'0),
                     \lam {x'} (Ux',U'x') => transport V (inv *c-assoc *> pmap (`*c _) hi.inv-right *> ide_*c) $ g Wh
                        \let | a => negative (hi.inv *c (x.1 - x'.1))
                             | q : x.1 + h *c a = x'.1 => rewrite (inv X.*c_negative-right, inv *c-assoc, hi.inv-right, ide_*c) simplify
                        \in transport (\lam z => V' (hi.inv *c (f x - f z))) (ext q) $ (simplify, rewriteI Y.*c_negative-right, simplify) in V''<=<V' (g' (simplify U'x') hi W'h $ transportInv S q x'.2) (U_V'' Ux'))
        })
}