\import Algebra.Group
\import Algebra.Module
\import Algebra.Module.LinearMap
\import Algebra.Monoid
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Paths
\import Paths.Meta
\import Set.Subset
\import Topology.TopAbGroup
\import Topology.TopModule
\import Topology.TopRing
\import Topology.TopSpace
\import Topology.TopSpace.Product
\open ContMap
\open ProductTopSpace
\open Monoid(Inv)
\open Bounded(top)

\func dquot {R : NearSkewField} {X Y : TopLModule R} {S : Set X} (f : Set.Total S -> Y) {x : Set.Total S} (h : Inv {R}) {a : X} (\property s : S (x.1 + h.val *c a))
  => h.inv *c (f (_,s) - f x)
  \where {
    \lemma dquot_*c (S : Set X) {f : Set.Total S -> Y} {x : Set.Total S} {h : Inv {R}} (c : Inv {R}) (Sh : S (x.1 + h.val *c (c.val *c a)))
      : dquot f h Sh = c.val *c dquot f (Inv.prod h c) (transportInv S (pmap (_ +) *c-assoc) Sh)
      => inv (pmap2 (\lam y z => y *c (f z - _)) (inv *-assoc *> pmap (`* _) c.inv-right *> ide-left) (ext $ pmap (_ +) *c-assoc)) *> *c-assoc
  }

\func IsDirDerivAt {R : NearSkewField} {X Y : TopLModule R} (S : Set X) (f : Set.Total S -> Y) (x : Set.Total S) (a : X) (d : Y) : \Prop
  => ∀ {V : Y.isOpen} (V 0) ∃ (W : R.isOpen) (W 0) ∀ {h : W} (hi : Inv h) (s : S (x.1 + h *c a)) (V (d - dquot f hi s))
  \where {
    \lemma dirDeriv-*c (S : Set X) {f : Set.Total S -> Y} {x : Set.Total S} (p : IsDirDerivAt S f x a d) (c : Inv {R})
      : IsDirDerivAt S f x (c.val *c a) (c.val *c d)
      => \lam {V} Vo V0 => \case p (func-cont {*c-cont ∘ tuple (const c.val) id} Vo) (transportInv V Y.*c_zro-right V0) \with {
        | inP (U,Uo,U0,g) => inP (_, func-cont {*-cont ∘ tuple id (const c.val)} Uo, transportInv U R.zro_*-left U0, \lam Uh hi Sh =>
                                  transport V (Y.*c-ldistr_- *> pmap (_ -) (inv $ dquot.dquot_*c S c Sh)) $ g Uh (Inv.prod hi c) _)
      }

    \protected \lemma unique {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} {S : Set X} (So : isOpen S) (f : Set.Total S -> Y)
                             (x : Set.Total S) (a : X) {d d' : Y} (dd : IsDirDerivAt S f x a d) (d'd : IsDirDerivAt S f x a d') : d = d'
      => Y.equals \lam {V} Vo V0 => \case Y.shrink Vo V0 \with {
        | inP (V',V'o,V'0,V'<=<V) => \case dd V'o V'0, d'd V'o V'0 \with {
          | inP (U,Uo,U0,g), inP (U',U'o,U'0,g') => \case inv-dense (open-inter (func-cont {+-cont ∘ tuple (const x.1) (*c-cont ∘ tuple id (const a))} So) (open-inter Uo U'o)) (transportInv S (pmap (_ +) X.*c_zro-left *> zro-right) x.2, (U0, U'0)) \with {
            | inP (h, hi, (Sh,(Uh,U'h))) => <=<ta-left {_} {_} {V} V'<=<V (g Uh hi Sh) (g' U'h hi Sh)
          }
        }
      }
  }

\func IsDerivAt {R : NearSkewField} {X Y : TopLModule R} (S : Set X) (f : Set.Total S -> Y) (x : Set.Total S) (Df : X -> Y) : \Prop
  => ∀ {V : Y.isOpen} (V 0) a0 ∃ (U : X.isOpen) (U 0) (W : R.isOpen) (W 0) ∀ {a : X.UBall U a0} (h : Inv {R}) (W h) (Sh : S (x.1 + h.val *c a)) (V (Df a - dquot f h Sh))

\lemma deriv-isDeriv {R : NearSkewField} {X Y : TopLModule R} (S : Set X) {f : Set.Total S -> Y} {x : Set.Total S} {Df : X -> Y} (Dfd : IsDerivAt S f x Df) {a : X} : IsDirDerivAt S f x a (Df a)
  => \lam Vo V0 => \case Dfd Vo V0 a \with {
    | inP (U,Uo,U0,W,Wo,W0,g) => inP (W, Wo, W0, \lam Wh hi Sh => g (transportInv U negative-right U0) hi Wh Sh)
  }

\lemma dirDeriv_zro {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} (S : Set X) {f : Set.Total S -> Y} {x : Set.Total S} : IsDirDerivAt S f x 0 0
  => \lam Vo V0 => inP (top, open-top, (), \lam _ _ _ => unfold dquot $ rewrite (zro-left,X.*c_zro-right,zro-right,negative-right,Y.*c_zro-right,Y.negative_zro) V0)

\lemma deriv-ofCont {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} (S : Set X) (So : isOpen S) {f : Set.Total S -> Y} {x : Set.Total S} {Df : ContMap X Y} (Dfd : IsDerivAt S f x Df) : IsContAt {TopSub S} f x
  => topAb-sub-contAt.2 \lam {V} Vo V0 => \case Y.*c-cont.func-cont Vo {0,0} $ transportInv V Y.*c_zro-left V0 \with {
    | inP (W,Wo,W0,V',V'o,V'0,g) =>
      \have | (inP (V'',V''o,V''0,V''<=<V')) => Y.shrink V'o V'0
            | (inP (U,Uo,U0,U_V'')) => cont-char.1 Df 0 V''o (transport V'' (IsDirDerivAt.unique So f x 0 (dirDeriv_zro S) (deriv-isDeriv S Dfd)) V''0)
            | (inP (U',U'o,U'0,W',W'o,W'0,g')) => Dfd V''o V''0 0
            | (inP (h,hi : Inv,(Wh,W'h))) => R.inv-dense (open-inter Wo W'o) (W0,W'0)
      \in inP (_, func-cont {*c-cont ∘ tuple (const hi.inv) id} (open-inter (negative-cont.func-cont Uo) U'o),
               (transportInv U (pmap negative X.*c_zro-right *> X.negative_zro) U0, transportInv U' X.*c_zro-right U'0),
               \lam {x'} (Ux',U'x') => transport V (inv *c-assoc *> pmap (`*c _) hi.inv-right *> ide_*c) $ g Wh
                  \let | a => negative (hi.inv *c (x.1 - x'.1))
                       | q : x.1 + h *c a = x'.1 => rewrite (inv X.*c_negative-right, inv *c-assoc, hi.inv-right, ide_*c) simplify
                  \in transport (\lam z => V' (hi.inv *c (f x - f z))) (ext q) $ (simplify, rewriteI Y.*c_negative-right, simplify) in V''<=<V' (g' (simplify U'x') hi W'h $ transportInv S q x'.2) (U_V'' Ux'))
  }

\lemma deriv-linear {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} (S : Set X) (So : isOpen S) (f : Set.Total S -> Y) (x : Set.Total S) (Df : TopAbGroupMap X Y) (Dfd : IsDerivAt S f x Df) : LinearMap X Y Df \cowith
  | func-+ => Df.func-+
  | func-*c {_} {a} => denseSet-lift-unique R.inv-dense (Df ∘ *c-cont ∘ tuple id (const a)) (*c-cont ∘ tuple id (const _))
      \lam {c} ci => IsDirDerivAt.unique So f x (c *c a) (deriv-isDeriv S Dfd) $ IsDirDerivAt.dirDeriv-*c S (deriv-isDeriv S Dfd) ci