\import Algebra.Group
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Ring
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\open DRing
\open isDiff

\class DRing \extends CRing
  | inv-dense {B : \Set} (U : E -> \Prop) (f g : \Sigma (z : E) (U z) -> B) : (\Pi (p : \Sigma (z : E) (u : U z)) -> Monoid.Inv p.1 -> f p = g p) -> \Pi (p : \Sigma (z : E) (u : U z)) -> f p = g p
  \where
    \lemma cancel-lem {R : DRing} {B : LModule' R} (U : R -> \Prop) (f g : \Sigma (z : R) (U z) -> B) (p : \Sigma (z : R) (u : U z)) (s : \Pi (p : \Sigma (z : R) (u : U z)) -> p.1 *c f p = p.1 *c g p) : f p = g p
      => R.inv-dense U f g (\lam p p-inv => B.cancel p-inv (s p)) p

\func isDiff {R : DRing} {A B : LModule' R} {U : A -> \Prop} (f : \Sigma (x : A) (U x) -> B) : \Set
  => \Pi (x : \Sigma (a : A) (U a)) (v : A) (t : R) (Ut : U (x.1 + t *c v)) -> \Sigma (y : B) (f (x.1 + t *c v, Ut) - f x = t *c y)
  \where {
    \use \level levelProp {R : DRing} {A B : LModule' R} {U : A -> \Prop} {f : \Sigma (x : A) (U x) -> B} (d d' : isDiff f) : d = d'
      => ext $ \lam x v t Ut => ext $ cancel-lem _ _ _ (t,Ut) $ \lam t => inv (d x v t.1 t.2).2 *> (d' x v t.1 t.2).2

    \lemma isDiff-eq {R : DRing} {A B : LModule' R} {U : A -> \Prop} {f : \Sigma (x : A) (U x) -> B} (d : isDiff f) {x x' : \Sigma (a : A) (U a)} (p : x.1 = x'.1) {v : A} {t t' : R} {Ut : U (x.1 + t *c v)} {Ut' : U (x'.1 + t' *c v)} (q : t = t') : (d x v t Ut).1 = (d x' v t' Ut').1
      => path (\lam i => (d (p i, pathInProp _ _ _ i) v (q i) (pathInProp _ _ _ i)).1)
  }

-- | The derivative is linear
\func deriv {R : DRing} {A B : LModule' R} {U : A -> \Prop} (f : \Sigma (x : A) (U x) -> B) (d : isDiff f) (x : \Sigma (x : A) (U x)) : LinearMap' A B \cowith
  | func a => (d x a 0 (sub-lem x)).1
  | func-+ a a' =>
    \have s => cancel-lem (\lam t => \Sigma (U (x.1 + t *c (a + a'))) (U (x.1 + t *c a)) (U (x.1 + t *c a + t *c a'))) (\lam t => (d x (a + a') t.1 t.2.1).1) (\lam t => (d (x.1 + t.1 *c a, t.2.2) a' t.1 t.2.3).1 + (d x a t.1 t.2.2).1) (0, (sub-lem x, sub-lem x, rewrite (A.zro_*c-left, zro-right) (sub-lem x))) $
                \lam t => inv (d _ _ _ _).2 *> pmap (`- _) (pmap f (ext $ rewrite *c-ldistr $ inv +-assoc) *> inv zro-right *> pmap (_ +) (inv negative-left) *> inv +-assoc) *> +-assoc *> pmap2 (+) (d _ _ _ _).2 (d _ _ _ _).2 *> inv B.*c-ldistr
    \in s *> +-comm *> pmap (_ +) (isDiff-eq d (pmap (x.1 +) A.zro_*c-left *> zro-right) idp)
  | func-*c r a =>
    \have s => cancel-lem (\lam t => \Sigma (U (x.1 + t *c (r *c a))) (U (x.1 + t * r *c a))) (\lam t => (d x (r *c a) t.1 t.2.1).1) (\lam t => r *c (d x a (t.1 * r) t.2.2).1) (0, (sub-lem x, rewrite *c-assoc $ sub-lem x)) $
                \lam t => later (rewriteI ((d x (r *c a) t.1 t.2.1).2, (d x a (t.1 * r) t.2.2).2) $ pmap (f __ - f x) $ ext $ pmap (x.1 +) $ inv *c-assoc) *> *c-assoc
    \in s *> pmap (r *c) (isDiff-eq d idp R.zro_*-left)
  \where
    \lemma sub-lem {A : LModule} {U : A -> \Prop} {a : A} (x : \Sigma (a : A) (U a)) : U (x.1 + 0 *c a)
      => transportInv U (pmap (x.1 +) A.zro_*c-left *> zro-right) x.2
