\import Algebra.Algebra
\import Algebra.Group
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Monoid
\import Algebra.Ordered.RieszSpace
\import Algebra.Pointed
\import Algebra.QModule
\import Algebra.Ring.Boolean
\import Arith.Rat
\import Data.Array
\import Data.Array.EPerm
\import Data.Fin
\import Data.Or
\import Equiv
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence \hiding (~)
\import Set
\import Set.Fin
\import Set.Fin.Instances

\type SFunc (V : AddMonoid) (B : BottomDistributiveLattice) => Quotient (~ {V} {B})
  \where {
    \truncated \data \infix 4 ~ (l l' : Array (\Sigma V B)) : \Prop
      | ~-perm (EPerm l l')
      | ~-sym (l' ~ l)
      | ~-trans {m : Array (\Sigma V B)} (l ~ m) (m ~ l')
      | ~-zro-left {b : B} (l = (0,b) :: l')
      | ~-zro-right {v : V} (l = (v,bottom) :: l')
      | ~-+-left {l'' : Array (\Sigma V B)} {u v : V} {b : B} (l = (u, b) :: (v, b) :: l'') (l' = (u + v, b) :: l'')
      | ~-+-right {l'' : Array (\Sigma V B)} {v : V} {a b : B} (l = (v, a ∨ b) :: (v, a ∧ b) :: l'') (l' = (v,a) :: (v,b) :: l'')

    \func inSF (l : Array (\Sigma V B)) : SFunc V B => in~ l

    \instance ~_Equivalence : Equivalence (Array (\Sigma V B)) (~)
      | ~-reflexive => ~-perm EPerm.eperm-refl
      | ~-symmetric => ~-sym
      | ~-transitive => ~-trans

    \lemma ~-sfequiv {l l' : Array (\Sigma V B)} (p : l ~ l') : inSF l = inSF l'
      => path \lam i => ~-equiv _ _ p i

    \lemma ~_++-left {l l' t : Array (\Sigma V B)} (l~l' : l ~ l') : l ++ t ~ l' ++ t \elim l~l'
      | ~-perm e => ~-perm $ EPerm.eperm-++ e EPerm.eperm-refl
      | ~-sym l~l' => ~-sym (~_++-left l~l')
      | ~-trans l~m m~l' => ~-trans (~_++-left l~m) (~_++-left m~l')
      | ~-zro-left p => ~-zro-left $ pmap (`++ t) p
      | ~-zro-right p => ~-zro-right $ pmap (`++ t) p
      | ~-+-left p p' => ~-+-left (pmap (`++ t) p) (pmap (`++ t) p')
      | ~-+-right p p' => ~-+-right (pmap (`++ t) p) (pmap (`++ t) p')

    \lemma ~_++-right {t l l' : Array (\Sigma V B)} (l~l' : l ~ l') : t ++ l ~ t ++ l'
      => ~-trans (~-perm EPerm.eperm-++-comm) $ ~-trans (~_++-left l~l') (~-perm EPerm.eperm-++-comm)

    \lemma ~_++ {l l' r r' : Array (\Sigma V B)} (l~l' : l ~ l') (r~r' : r ~ r') : l ++ r ~ l' ++ r'
      => ~-trans (~_++-left l~l') (~_++-right r~r')

    \lemma ~_:: {x : \Sigma V B} {l l' : Array (\Sigma V B)} (l~l' : l ~ l') : x :: l ~ x :: l'
      => ~_++-right {_} {_} {x :: nil} l~l'

    \lemma ~_::_= {x y : \Sigma V B} (p : x = y) {l l' : Array (\Sigma V B)} (l~l' : l ~ l') : x :: l ~ y :: l'
      => transport (_ ~ __ :: l') p (~_:: l~l')

    \lemma ~-swap {x y : \Sigma V B} {l : Array (\Sigma V B)} : x :: y :: l ~ y :: x :: l
      => ~-perm (eperm-swap idp idp idp)

    \lemma ~_+ (f g : V -> V) {l : Array (\Sigma V B)} : map (\lam s => (f s.1, s.2)) l ++ map (\lam s => (g s.1, s.2)) l ~ map (\lam s => (f s.1 + g s.1, s.2)) l \elim l
      | nil => ~_Equivalence.~-reflexive
      | a :: l => ~-trans (~-perm $ EPerm.EPerm_++-swap {_} {map (\lam s => (f s.1, s.2)) (a :: l)}) $ ~-trans ~-swap $ ~-trans (~-+-left idp idp) $ ~_:: (~_+ f g)

    \lemma ~-zros-left {l : Array (\Sigma V B)} (p : \Pi (i : Fin l.len) -> (l i).1 = 0) : l ~ nil \elim l
      | nil => ~_Equivalence.~-reflexive
      | a :: l => transportInv (\lam x => (x,a.2) :: l ~ nil) (p 0) $ ~-trans (~-zro-left idp) $ ~-zros-left \lam i => p (suc i)
  }

\open SFunc

\instance SFuncAbMonoid (V : AddMonoid) (B : BottomDistributiveLattice) : AbMonoid (SFunc V B)
  | zro => inSF nil
  | + (f g : SFunc V B) : SFunc V B \with {
    | in~ f, in~ g => inSF (f ++ g)
    | in~ f, ~-equiv g g' g~g' => ~-sfequiv (~_++-right g~g')
    | ~-equiv f f' f~f', in~ g => ~-sfequiv (~_++-left f~f')
  }
  | +-assoc {x} {y} {z} => \case \elim x, \elim y, \elim z \with {
    | in~ l1, in~ l2, in~ l3 => pmap inSF ++-assoc
  }
  | +-comm {x} {y} => \case \elim x, \elim y \with {
    | in~ l, in~ l' => ~-sfequiv (~-perm EPerm.eperm-++-comm)
  }
  | zro-left {x} => \case \elim x \with {
    | in~ l => idp
  }
  \where {
    \lemma *n-char {n : Nat} {l : Array (\Sigma V B)} : n AddMonoid.*n {SFuncAbMonoid V B} inSF l = inSF (map (\lam s => (n V.*n s.1, s.2)) l) \elim n
      | 0 => inv $ ~-sfequiv $ ~-zros-left \lam _ => idp
      | suc n => pmap (`+ _) *n-char *> ~-sfequiv (~_+ (n V.*n) (\lam x => x))
  }

\instance SFuncAbGroup (V : AddGroup) (B : BottomDistributiveLattice) : AbGroup (SFunc V B)
  | AbMonoid => SFuncAbMonoid V B
  | negative (f : SFunc V B) : SFunc V B \with {
    | in~ l => inSF $ map (\lam s => (V.negative s.1, s.2)) l
    | ~-equiv f g f~g => ~-sfequiv (~_negative f~g)
  }
  | negative-left {x} => \case \elim x \with {
    | in~ l => ~-sfequiv ~_negative-left
  }
  \where {
    \lemma ~_negative {l l' : Array (\Sigma V B)} (l~l' : l ~ l') : map (\lam s => (V.negative s.1, s.2)) l ~ map (\lam s => (V.negative s.1, s.2)) l' \elim l~l'
      | ~-perm e => ~-perm $ EPerm.EPerm_map (\lam s => (V.negative s.1, s.2)) e
      | ~-sym p => ~-sym (~_negative p)
      | ~-trans p p' => ~-trans (~_negative p) (~_negative p')
      | ~-zro-left {b} idp => transportInv (\lam x => ((x,b) :: _) ~ _) V.negative_zro (~-zro-left idp)
      | ~-zro-right idp => ~-zro-right idp
      | ~-+-left idp idp => ~-trans ~-swap $ ~-trans (~-+-left idp idp) $ ~-perm $ EPerm.eperm-= $ path (\lam i => (inv V.negative_+ i, _) :: _)
      | ~-+-right idp idp => ~-+-right idp idp

    \lemma ~_negative-left {l : Array (\Sigma V B)} : map (\lam s => (V.negative s.1, s.2)) l ++ l ~ nil \elim l
      | nil => ~-reflexive
      | a :: l => ~-trans (~-perm $ EPerm.EPerm_++-swap {_} {map (\lam s => (V.negative s.1, s.2)) (a :: l)}) $ ~-trans (~-+-left idp idp) $ ~-trans (~-perm $ EPerm.eperm-= $ path \lam i => (V.negative-right i, a.2) :: _) (~-trans (~-zro-left idp) ~_negative-left)

    \lemma *i-char {n : Int} {l : Array (\Sigma V B)} : n AddGroup.*i {SFuncAbGroup V B} inSF l = inSF (map (\lam s => (n V.*i s.1, s.2)) l) \elim n
      | pos n => SFuncAbMonoid.*n-char
      | neg n => AddGroup.*n_negative *> pmap negative SFuncAbMonoid.*n-char *> pmap inSF (exts \lam j => ext (inv V.*n_negative, idp))
  }

\instance SFuncQModule (V : QModule) (B : BottomDistributiveLattice) : QModule (SFunc V B)
  => QModule.fromRatModule module
  \where {
    \func module : LModule RatField \cowith
      | AbGroup => SFuncAbGroup V B
      | *c (q : RatField) (x : SFunc V B) : SFunc V B \elim x {
        | in~ l => inSF $ map (\lam s => (q V.*q s.1, s.2)) l
        | ~-equiv x y r => ~-sfequiv (~_*q r)
      }
      | *c-assoc {q} {r} {x} => \case \elim x \with {
        | in~ l => path \lam i => inSF (map (\lam s => (V.*q-assoc {q} {r} {s.1} i, s.2)) l)
      }
      | *c-ldistr {q} {x} {y} => \case \elim x, \elim y \with {
        | in~ l, in~ l' => pmap inSF $ map_++ \lam (s : \Sigma V B) => (q V.*q s.1, s.2)
      }
      | *c-rdistr {q} {r} {x} => \case \elim x \with {
        in~ l => ~-sfequiv $ ~-trans (~-perm $ EPerm.eperm-= $ path \lam i => map (\lam s => (V.toRatModule.*c-rdistr {q} {r} {s.1} i, s.2)) l) $ ~-sym (~_+ (q V.*q) (r V.*q))
      }
      | ide_*c {x} => \case \elim x \with {
        | in~ l => path \lam i => inSF (map (\lam s => (V.ide_*q {s.1} i, s.2)) l)
      }

    \lemma ~_*q {q : Rat} {l l' : Array (\Sigma V B)} (l~l' : l ~ l') : map (\lam s => (q V.*q s.1, s.2)) l ~ map (\lam s => (q V.*q s.1, s.2)) l' \elim l~l'
      | ~-perm e => ~-perm $ EPerm.EPerm_map (\lam s => (q V.*q s.1, s.2)) e
      | ~-sym p => ~-sym (~_*q p)
      | ~-trans p p' => ~-trans (~_*q p) (~_*q p')
      | ~-zro-left {b} idp => transportInv (\lam x => ((x,b) :: _) ~ _) V.toRatModule.*c_zro-right (~-zro-left idp)
      | ~-zro-right idp => ~-zro-right idp
      | ~-+-left idp idp => ~-trans (~-+-left idp idp) $ ~-perm $ EPerm.eperm-= $ path (\lam i => (inv V.toRatModule.*c-ldistr i, _) :: _)
      | ~-+-right idp idp => ~-+-right idp idp

    \lemma *q-char {q : Rat} {l : Array (\Sigma V B)} : q QModule.*q {SFuncQModule V B} inSF l = inSF (map (\lam s => (q V.*q s.1, s.2)) l)
      => (SFuncQModule V B).noTorsion-div (ratDenom/=0 {q}) $ inv QModule.*q_*n *> inv QModule.*q-assoc *> pmap (QModule.`*q _) rat*denom-left *> QModule.*q_*i *>
          SFuncAbGroup.*i-char *> pmap inSF (exts \lam j => ext (inv QModule.*q_*i *> pmap (QModule.`*q _) (inv rat*denom-left) *> QModule.*q-assoc *> QModule.*q_*n, idp)) *> inv SFuncAbMonoid.*n-char
  }

\instance SFuncPosetQModule (V : PosetQModule) (B : BooleanRing) : PosetQModule (SFunc V B)
  | QModule => SFuncQModule V B
  | <= => <=
  | <=-refl => inP (nil, negative-right, \case __)
  | <=-transitive (inP s) (inP s') => inP (s.1 ++ s'.1 , inv AddGroup.diff_+ *> +-comm *> pmap2 (+) s.2 s'.2, ++.++-all {_} {\lam s => 0 V.<= s.1} s.3 s'.3)
  | <=-antisymmetric (inP s) (inP s') => \case ~_=-unequals $ inv (pmap negative s.2) *> AddGroup.negative_- *> s'.2 \with {
    | inP (m,mr,m1,m2) => AddGroup.fromZero $ s'.2 *> ~-sfequiv (~-trans (~-sym reduce_~) $ ~-trans (~-sym $ SFRefines_~ mr reduce_IsReduced m2) $ ~-zros-left \lam i => <=-antisymmetric (SFRefines-closed (V.`<= 0) <=-refl m1 (reduce_<=0 \lam j => later $ V.negative<=0 (s.3 j)) i) $ SFRefines-closed (0 V.<=) <=-refl m2 (reduce_>=0 s'.3) i)
  }
  | <=_+ => \case \elim __, \elim __ \with {
    | inP (l,lp,lf), inP (l',l'p,l'f) => inP (l ++ l', equation.abGroup *> pmap2 (+) lp l'p, \lam k => \case ++.split-index k \with {
      | inl (i,ip) => rewrite (ip,++.++_index-left) (lf i)
      | inr (j,jp) => rewrite (jp,++.++_index-right) (l'f j)
    })
  }
  | <=_*n-div {n} n/=0 => \case \elim __ \with {
    | inP (l,lp,lf) => inP (map (\lam s => (RatField.finv n V.*q s.1, s.2)) l, AddGroup.minus_zro *> inv QModule.ide_*q *> pmap (QModule.`*q _) (inv $ RatField.finv-left $ natRat/=0 n/=0) *> QModule.*q-assoc *> pmap (_ QModule.*q) (QModule.*q_*n *> inv AddGroup.minus_zro *> lp) *> SFuncQModule.*q-char, \lam j => V.*q_>=0 (RatField.finv>=0 fromNat_>=0) (lf j))
  }
  \where {
    \type \infix 4 <= (x y : SFunc V B) : \Prop
      => ∃ (l : Array (\Sigma V B)) (y - x = inSF l) ∀ (s : l) (0 V.<= s.1)

    \sfunc add (v : V) (b : B) (l : Array (\Sigma V B)) : Array (\Sigma V B)
      => (v, B.diff b $ B.BigJoin $ map __.2 l) :: map (\lam s => (v + s.1, b * s.2)) l ++ map (\lam s => (s.1, B.diff s.2 b)) l

    \func reduce (l : Array (\Sigma V B)) : Array (\Sigma V B)
      | nil => nil
      | x :: l => add x.1 x.2 (reduce l)

    \lemma reduce-closed (P : V -> \Prop) (P0 : P 0) (P+ : ∀ {a b : P} (P (a + b))) {l : Array (\Sigma V B)} (Pl : ∀ (x : l) (P x.1)) : ∀ (x : reduce l) (P x.1) \elim l
      | nil => \case __
      | a :: l => add-closed (Pl 0) $ reduce-closed P P0 P+ \lam j => Pl (suc j)
      \where {
        \lemma add-closed {v : V} {b : B} (Pv : P v) {l : Array (\Sigma V B)} (Pl : ∀ (x : l) (P x.1)) : ∀ (x : add v b l) (P x.1)
          => rewrite (\peval add v b l) \case \elim __ \with {
            | 0 => Pv
            | suc k => \case ++.split-index k \with {
              | inl (i,ip) => rewrite (ip,++.++_index-left) $ P+ Pv (Pl i)
              | inr (j,jp) => rewrite (jp,++.++_index-right) (Pl j)
            }
          }
      }

    \lemma reduce_>=0 {l : Array (\Sigma V B)} (Pl : ∀ (x : l) (0 V.<= x.1)) : ∀ (x : reduce l) (0 V.<= x.1)
      => reduce-closed (0 V.<=) <=-refl V.<=_+-positive Pl

    \lemma reduce_<=0 {l : Array (\Sigma V B)} (Pl : ∀ (x : l) (x.1 V.<= 0)) : ∀ (x : reduce l) (x.1 V.<= 0)
      => reduce-closed (V.`<= 0) <=-refl (\lam a<=0 b<=0 => V.from>=0 $ rewrite (zro-left,V.negative_+) $ V.<=_+-positive (V.negative>=0 b<=0) (V.negative>=0 a<=0)) Pl

    \sfunc add_EPerm {v : V} {b : B} {l l' : Array (\Sigma V B)} (e : EPerm l l') : EPerm (add v b l) (add v b l') \elim l, l', e
      | nil, nil, eperm-nil => EPerm.eperm-refl
      | x :: l1, _ :: l2, eperm-:: idp e => rewrite (\peval add _ _ _, \peval add _ _ _) $ eperm-:: (pmap (\lam y => (v, B.diff b (_ ∨ y))) $ B.BigJoin_EPerm $ EPerm.EPerm_map __.2 e) $ eperm-:: idp $ EPerm.eperm-++ (EPerm.EPerm_map (\lam s => (v + s.1, b * s.2)) e) $ eperm-:: idp $ EPerm.EPerm_map (\lam s => (s.1, B.diff s.2 b)) e
      | (u,a) :: ((w,c) :: l), _ :: (_ :: l'), eperm-swap idp idp p2 => rewrite (\peval add _ _ _, \peval add _ _ _) $ eperm-:: (pmap (\lam y => (v, B.diff b y)) $ B.BigJoin_EPerm {a :: c :: map __.2 l} {c :: a :: map __.2 l'} $ eperm-swap idp idp $ pmap (map __.2) p2) $
        EPerm.eperm-swap-tail $ EPerm.eperm-++ (EPerm.EPerm_map (\lam s => (v + s.1, b * s.2)) $ EPerm.eperm-= p2) $ eperm-swap idp idp $ pmap (map \lam (s : \Sigma V B) => (s.1, B.diff s.2 b)) p2
      | l, l', eperm-trans e1 e2 => eperm-trans (add_EPerm e1) (add_EPerm e2)

    \lemma add_BigJoin {v : V} {b : B} {l : Array (\Sigma V B)} : B.BigJoin (map __.2 (add v b l)) = b ∨ B.BigJoin (map __.2 l)
      => rewrite (\peval add v b l) $ pmap (_ ∨) (pmap B.BigJoin (map_++ __.2) *> B.BigJoin_++ *> later (inv (B.BigJoin_join {_} {map (\lam s => b * s.2) l}) *> pmap B.BigJoin (exts \lam j => equation.bRing))) *> equation.bRing

    \sfunc add-double {u v : V} {a b : B} {l : Array (\Sigma V B)} : EPerm (add v b (add u a l))
      ((v + u, B.diff (b * a) (B.BigJoin (map __.2 l))) ::
       (v, B.diff b (a ∨ B.BigJoin (map __.2 l))) ::
       (u, B.diff a (b ∨ B.BigJoin (map __.2 l))) ::
       (map (\lam s => (v + u + s.1, (b * a) * s.2)) l ++
       map (\lam s => (v + s.1, B.diff (b * s.2) a)) l) ++
       map (\lam s => (u + s.1, B.diff (a * s.2) b)) l ++
       map (\lam s => (s.1, B.diff s.2 (a ∨ b))) l)
      => transportInv (EPerm __ _) (\peval add v b _) $ EPerm.eperm-sym $ EPerm.eperm-swap-trans $ eperm-:: (pmap (\lam x => (v, B.diff b x)) $ inv add_BigJoin) $
          mkcon eperm-trans {(v + u, B.diff _ _) :: _} (eperm-:: idp $ EPerm.eperm-sym $ EPerm.EPerm_++-swap) $ EPerm.eperm-++ {_} {(v + u, B.diff _ _) :: _}
            (EPerm.eperm-= $ later $ rewrite (\peval add u a l) $ cong_:: (pmap (v + u, __) equation.bRing) $ pmap2 (++) (exts \lam j => ext (+-assoc, *-assoc)) (exts \lam j => ext (idp, equation.bRing)) *> inv (map_++ \lam s => (v + s.1, b * s.2)))
            (EPerm.eperm-= $ later $ rewrite (\peval add u a l) $ cong_:: (pmap (u,__) equation.bRing) $ pmap (_ ++) (exts \lam j => ext (idp, equation.bRing)) *> inv (map_++ \lam (s : \Sigma V B) => (s.1, B.diff s.2 b)))

    \sfunc add-comm {u v : V} {a b : B} {l : Array (\Sigma V B)} : EPerm (add v b (add u a l)) (add u a (add v b l))
      => eperm-trans add-double $ eperm-trans (eperm-:: (pmap2 (\lam x y => (x, B.diff y _)) +-comm *-comm) $ EPerm.eperm-swap-tail $ transport2 EPerm (inv ++-assoc) (inv ++-assoc) $ EPerm.eperm-++ (EPerm.eperm-= $ later $ exts \lam j => ext (pmap (`+ _) +-comm, pmap (`* _) *-comm)) $ transport2 EPerm ++-assoc ++-assoc $ EPerm.eperm-++ EPerm.eperm-++-comm $ EPerm.eperm-= $ later $ exts \lam j => pmap (\lam x => ((l j).1, B.diff _ x)) B.join-comm) (EPerm.eperm-sym add-double)

    \sfunc reduce_EPerm {l l' : Array (\Sigma V B)} (e : EPerm l l') : EPerm (reduce l) (reduce l') \elim l, l', e
      | nil, nil, eperm-nil => eperm-nil
      | x :: l1, _ :: l2, eperm-:: idp e => add_EPerm (reduce_EPerm e)
      | x :: (y :: l1), _ :: (_ :: l2), eperm-swap idp idp p => eperm-trans add-comm $ add_EPerm $ add_EPerm $ EPerm.eperm-= (pmap reduce p)
      | l, l', eperm-trans e1 e2 => eperm-trans (reduce_EPerm e1) (reduce_EPerm e2)

    \type SFRefines (l l' : Array (\Sigma V B))
      => \Sigma (∀ (y : l') ((y.1 = 0) || y.2 B.<= B.BigJoin (map __.2 l))) (∀ (x : l) ∃ (y : l') (x.1 = y.1) (x.2 B.<= y.2))

    \lemma SFRefines-refl {l : Array (\Sigma V B)} : SFRefines l l
      => (\lam j => byRight (B.BigJoin-cond {map __.2 l} j), \lam j => inP (j, idp, <=-refl))

    \lemma SFRefines_++ {l l' r r' : Array (\Sigma V B)} (ll' : SFRefines l l') (rr' : SFRefines r r') : SFRefines (l ++ r) (l' ++ r')
      => (\lam j => \case ++.split-index j \with {
        | inl (k,p) => rewrite (p,++.++_index-left) \case ll'.1 k \with {
          | byLeft p => byLeft p
          | byRight p => byRight $ p <=∘ join-left <=∘ =_<= (inv $ pmap B.BigJoin (map_++ __.2) *> B.BigJoin_++)
        }
        | inr (k,p) => rewrite (p,++.++_index-right) \case rr'.1 k \with {
          | byLeft p => byLeft p
          | byRight p => byRight $ p <=∘ join-right <=∘ =_<= (inv $ pmap B.BigJoin (map_++ __.2) *> B.BigJoin_++)
        }
      }, \lam j => \case ++.split-index j \with {
        | inl (k,p) => rewrite (p,++.++_index-left) \case ll'.2 k \with {
          | inP (i,p,q) => inP (++.index-left i, rewrite ++.++_index-left p, rewrite ++.++_index-left q)
        }
        | inr (k,p) => rewrite (p,++.++_index-right) \case rr'.2 k \with {
          | inP (i,p,q) => inP (++.index-right i, rewrite ++.++_index-right p, rewrite ++.++_index-right q)
        }
      })

    \lemma SFRefines_:: {x : \Sigma V B} {l l' : Array (\Sigma V B)} (r : SFRefines l l') : SFRefines (x :: l) (x :: l')
      => SFRefines_++ {_} {_} {x :: nil} SFRefines-refl r

    \lemma SFRefines_::-merge {v : V} {a b c : B} (c=ab : c = a ∨ b) {l l' : Array (\Sigma V B)} (r : SFRefines l l') : SFRefines ((v,a) :: (v,b) :: l) ((v, c) :: l')
      => (\case \elim __ \with {
        | 0 => byRight $ =_<= c=ab <=∘ B.join-monotone <=-refl join-left
        | suc j => \case r.1 j \with {
          | byLeft p => byLeft p
          | byRight p => byRight $ p <=∘ join-right <=∘ join-right
        }
      }, \case \elim __ \with {
        | 0 => inP (0, idp, join-left <=∘ =_<= (inv c=ab))
        | 1 => inP (0, idp, join-right <=∘ =_<= (inv c=ab))
        | suc (suc j) => \case r.2 j \with {
          | inP (k,p,q) => inP (suc k, p, q)
        }
      })

    \lemma SFRefines_++-merge (f g h : B -> B) (p : \Pi (b : B) -> h b = f b ∨ g b) {l : Array (\Sigma V B)} : SFRefines (map (\lam s => (s.1, f s.2)) l ++ map (\lam s => (s.1, g s.2)) l) (map (\lam s => (s.1, h s.2)) l)
      => (\lam j => byRight $ =_<= (p _) <=∘ B.join-monotone (B.BigJoin-cond {map (\lam s => f s.2) l} j) (B.BigJoin-cond {map (\lam s => g s.2) l} j) <=∘ =_<= (inv $ later $ pmap B.BigJoin (map_++ __.2) *> B.BigJoin_++),
          \lam j => \case ++.split-index j \with {
            | inl (k,q) => rewrite (q,++.++_index-left) $ inP (k, idp, join-left <=∘ =_<= (inv (p _)))
            | inr (k,q) => rewrite (q,++.++_index-right) $ inP (k, idp, join-right <=∘ =_<= (inv (p _)))
          })

    \lemma SFRefines-trans {l1 l2 l3 : Array (\Sigma V B)} (l3r : IsReduced l3) (r1 : SFRefines l1 l2) (r2 : SFRefines l2 l3) : SFRefines l1 l3
      => (\lam k => \case r2.1 k \with {
        | byLeft p => byLeft p
        | byRight p =>
          \have r => FinSet.||-finiteAC {_} {(l3 k).1 = 0} {\lam j => (l2 j).2 ∧ (l3 k).2 B.<= B.BigJoin (map __.2 l1)} (\lam j => \case r1.1 j, r2.2 j \with {
                 | byLeft p, inP (k',p',q') => \case decideEq k k' \with {
                   | yes e => byLeft $ pmap (\lam x => (l3 x).1) e *> inv p' *> p
                   | no q => byRight $ B.meet-monotone q' <=-refl <=∘ =_<= (l3r $ /=-sym q) <=∘ bottom-univ
                 }
                 | byRight p, _ => byRight (meet-left <=∘ p)
               })
          \in \case \elim r \with {
            | byLeft p => byLeft p
            | byRight f => byRight $ meet-univ p <=-refl <=∘ =_<= B.BigJoin-rdistr <=∘ B.BigJoin-univ \lam j => later (f j)
          }
      }, \lam i => \case r1.2 i \with {
        | inP (j,p,q) => \case r2.2 j \with {
          | inP (k,p',q') => inP (k, p *> p', q <=∘ q')
        }
      })

    \lemma SFRefines-swap {x y : \Sigma V B} {l l' : Array (\Sigma V B)} (r : SFRefines l l') : SFRefines (x :: y :: l) (y :: x :: l')
      => (\case \elim __ \with {
        | 0 => byRight $ join-left <=∘ join-right
        | 1 => byRight join-left
        | suc (suc j) => \case r.1 j \with {
          | byLeft p => byLeft p
          | byRight p => byRight $ p <=∘ join-right <=∘ join-right
        }
      }, \case \elim __ \with {
        | 0 => inP (1, idp, <=-refl)
        | 1 => inP (0, idp, <=-refl)
        | suc (suc j) => \case r.2 j \with {
          | inP (k,p,q) => inP (suc (suc k), p, q)
        }
      })

    \lemma SFRefines_EPerm {l l' : Array (\Sigma V B)} (e : EPerm l l') : SFRefines l l'
      => \have (f,g) => EPerm.eperm_equiv e
         \in (\lam j => byRight $ =_<= (pmap __.2 $ g j) <=∘ B.BigJoin-cond {map __.2 l} (f j),
              \lam j => inP (f.ret j, pmap __.1 $ inv $ g (f.ret j) *> pmap l (f.f_ret j), =_<= $ pmap __.2 $ inv $ g (f.ret j) *> pmap l (f.f_ret j)))

    \lemma SFRefines_++-left {l r r' : Array (\Sigma V B)} (lr : SFRefines l r) (r'l : ∀ (y : r') ((y.1 = 0) || y.2 B.<= B.BigJoin (map __.2 l))) : SFRefines l (r ++ r')
      => (\lam j => \case ++.split-index j \with {
        | inl (k,p) => rewrite (p,++.++_index-left) (lr.1 k)
        | inr (k,p) => rewrite (p,++.++_index-right) (r'l k)
      }, \lam j => \case lr.2 j \with {
        | inP (k,p,q) => inP (++.index-left k, p *> pmap __.1 (inv $ ++.++_index-left k), q <=∘ =_<= (pmap __.2 $ inv $ ++.++_index-left k))
      })

    \lemma SFRefines_++-right {l r r' : Array (\Sigma V B)} (lr' : SFRefines l r') (rl : ∀ (y : r) ((y.1 = 0) || y.2 B.<= B.BigJoin (map __.2 l))) : SFRefines l (r ++ r')
      => (\lam j => \case ++.split-index j \with {
        | inl (k,p) => rewrite (p,++.++_index-left) (rl k)
        | inr (k,p) => rewrite (p,++.++_index-right) (lr'.1 k)
      }, \lam j => \case lr'.2 j \with {
        | inP (k,p,q) => inP (++.index-right k, p *> pmap __.1 (inv $ ++.++_index-right {_} {_} {_} {k}), q <=∘ =_<= (pmap __.2 $ inv $ ++.++_index-right {_} {_} {_} {k}))
      })

    \lemma SFRefines_::-right {x : \Sigma V B} {l r : Array (\Sigma V B)} (rl : x.2 B.<= B.BigJoin (map __.2 l)) (lr : SFRefines l r) : SFRefines l (x :: r)
      => SFRefines_++-right {_} {_} {_} {x :: nil} lr $ \lam (0) => byRight rl

    \lemma SFRefines_add_0 {l : Array (\Sigma V B)} {v : V} : SFRefines l (add v 0 l)
      => rewrite (\peval add v 0 l) $ SFRefines_::-right (B.meet_<=' equation.bRing) $ SFRefines_++-right (transport (SFRefines l) (exts \lam j => ext (idp,equation.bRing)) SFRefines-refl) \lam j => byRight $ meet-left <=∘ bottom-univ

    \type IsReduced (l : Array (\Sigma V B)) => \Pi {i j : Fin l.len} -> i /= j -> (l i).2 * (l j).2 = 0

    \lemma SFRefines-closed (P : V -> \Prop) (P0 : P 0) {l l' : Array (\Sigma V B)} (r : SFRefines l l') (Pl : ∀ (x : l') (P x.1)) : ∀ (x : l) (P x.1)
      => \lam i => \case r.2 i \with {
        | inP (j,p,_) => transportInv P p (Pl j)
      }

    \lemma add_IsReduced {v : V} {b : B} {l : Array (\Sigma V B)} (lr : IsReduced l) : IsReduced (add v b l)
      => transportInv IsReduced (\peval add v b l) \lam {i} {j} => \case \elim i, \elim j \with {
        | 0, 0 => \lam p => absurd (p idp)
        | 0, suc j => \lam _ => \case ++.split-index j \with {
          | inl (k,p) => rewrite (p,++.++_index-left) $ <=-antisymmetric (B.meet-monotone (B.diff-mono <=-refl $ B.BigJoin-cond {map __.2 l} k) <=-refl <=∘ =_<= equation.bRing) bottom-univ
          | inr (k,p) => rewrite (p,++.++_index-right) equation.bRing
        }
        | suc i, 0 => \lam _ => \case ++.split-index i \with {
          | inl (k,p) => rewrite (p,++.++_index-left) $ <=-antisymmetric (B.meet-monotone <=-refl (B.diff-mono <=-refl $ B.BigJoin-cond {map __.2 l} k) <=∘ =_<= equation.bRing) bottom-univ
          | inr (k,p) => rewrite (p,++.++_index-right) equation.bRing
        }
        | suc i, suc j => \case ++.split-index i, ++.split-index j \with {
          | inl (k1,p1), inl (k2,p2) => rewrite (p1,p2,++.++_index-left,++.++_index-left) \lam p => equation.bRing {lr {k1} {k2} \lam q => p (cong q)}
          | inl (k1,p1), inr (k2,p2) => \lam _ => rewrite (p1,p2,++.++_index-left,++.++_index-right) equation.bRing
          | inr (k1,p1), inl (k2,p2) => \lam _ => rewrite (p1,p2,++.++_index-left,++.++_index-right) equation.bRing
          | inr (k1,p1), inr (k2,p2) => rewrite (p1,p2,++.++_index-right,++.++_index-right) \lam p => equation.bRing {lr {k1} {k2} \lam q => p (cong q)}
        }
      }

    \lemma reduce_IsReduced {l : Array (\Sigma V B)} : IsReduced (reduce l) \elim l
      | nil => \lam {i} => \case i
      | x :: l => add_IsReduced reduce_IsReduced

    \lemma ~-unequals {l l' : Array (\Sigma V B)} (l~l' : l ~ l') : ∃ (m : IsReduced) (SFRefines m (reduce l)) (SFRefines m (reduce l')) \elim l~l'
      | ~-perm e => inP (reduce l, reduce_IsReduced, SFRefines-refl, SFRefines_EPerm $ reduce_EPerm e)
      | ~-sym l~l' => \case ~-unequals l~l' \with {
        | inP (m,mr,ml',ml) => inP (m,mr,ml,ml')
      }
      | ~-trans l~m m~l' => \case ~-unequals l~m, ~-unequals m~l' \with {
        | inP (d1,d1r,d1<l,d1<m), inP (d2,d2r,d2<m,d2<l') => \case FinSet.finiteAC d1<m.2, FinSet.finiteAC d2<m.2 \with {
          | inP f1, inP f2 =>
            \let P => SigmaFin (ProdFin (FinFin d1.len) (FinFin d2.len)) \lam s => DecFin (decideEq (f1 s.1).1 (f2 s.2).1)
            \in \case P.finEq \with {
              | inP Pe => inP (\new Array (\Sigma V B) P.finCard \lam j => ((d1 (Pe j).1.1).1, (d1 (Pe j).1.1).2 * (d2 (Pe j).1.2).2),
                               \lam {i} {j} i/=j => \case decideEq (Pe i).1.1 (Pe j).1.1, decideEq (Pe i).1.2 (Pe j).1.2 \with {
                                 | yes e, yes e' => absurd $ i/=j $ Pe.isInj $ ext $ ext (e,e')
                                 | no q, _ => equation.bRing {d1r q}
                                 | _, no q => equation.bRing {d2r q}
                               },
                               SFRefines-trans reduce_IsReduced (later (\lam i => \case d2<m.1 (f1 i).1 \with {
                                 | byLeft q => byLeft $ (f1 i).2 *> q
                                 | byRight q => byRight $ meet-univ <=-refl ((f1 i).3 <=∘ q) <=∘ =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam j => later \case decideEq (f1 i).1 (f2 j).1 \with {
                                   | yes e => B.FinJoin-cond {P} ((i,j),e) {\lam s => (d1 s.1.1).2 * (d2 s.1.2).2} <=∘ =_<= (B.FinJoin_Equiv {_} {P} Pe *> B.FinJoin=BigJoin)
                                   | no c => B.meet-monotone (f1 i).3 (f2 j).3 <=∘ =_<= (reduce_IsReduced c) <=∘ bottom-univ
                                 }
                               }, \lam k => inP ((Pe k).1.1, idp, meet-left))) d1<l,
                               SFRefines-trans reduce_IsReduced (later \lam j => \case d1<m.1 (f2 j).1 \with {
                                 | byLeft q => byLeft $ (f2 j).2 *> q
                                 | byRight q => byRight $ meet-univ ((f2 j).3 <=∘ q) <=-refl <=∘ =_<= B.BigJoin-rdistr <=∘ B.BigJoin-univ \lam i => later \case decideEq (f1 i).1 (f2 j).1 \with {
                                   | yes e => B.FinJoin-cond {P} ((i,j),e) {\lam s => (d1 s.1.1).2 * (d2 s.1.2).2} <=∘ =_<= (B.FinJoin_Equiv {_} {P} Pe *> B.FinJoin=BigJoin)
                                   | no c => B.meet-monotone (f1 i).3 (f2 j).3 <=∘ =_<= (reduce_IsReduced c) <=∘ bottom-univ
                                 }
                               }, \lam k => inP $ later ((Pe k).1.2, (f1 _).2 *> pmap (\lam x => (reduce _ x).1) (Pe k).2 *> inv (f2 _).2, meet-right)) d2<l')
            }
        }
      }
      | ~-zro-left {b} idp => inP (split b (reduce l'), split_IsReduced reduce_IsReduced, split_add_SFRefines, split_SFRefines)
      | ~-zro-right idp => inP (reduce l', reduce_IsReduced, SFRefines_add_0, SFRefines-refl)
      | ~-+-left {l''} {u} {v} {b} idp idp => inP (add (u + v) b (reduce l''), add_IsReduced reduce_IsReduced, add_+_SFRefines reduce_IsReduced, SFRefines-refl)
      | ~-+-right {l''} {v} {a} {b} idp idp => inP (add v a $ add v b $ reduce l'', add_IsReduced $ add_IsReduced reduce_IsReduced, add-modularity_SFRefines reduce_IsReduced, SFRefines-refl)
      \where {
        \func split (b : B) (l : Array (\Sigma V B))
          => map (\lam s => (0 + s.1, b * s.2)) l ++ map (\lam s => (s.1, B.diff s.2 b)) l

        \lemma split_IsReduced {b : B} {l : Array (\Sigma V B)} (lr : IsReduced l) : IsReduced (split b l)
          => \lam {i} {j} => \case ++.split-index i, ++.split-index j \with {
            | inl (k1,p1), inl (k2,p2) => rewrite (p1,p2,++.++_index-left,++.++_index-left) \lam p => equation.bRing {lr {k1} {k2} \lam q => p (cong q)}
            | inl (k1,p1), inr (k2,p2) => \lam _ => rewrite (p1,p2,++.++_index-left,++.++_index-right) equation.bRing
            | inr (k1,p1), inl (k2,p2) => \lam _ => rewrite (p1,p2,++.++_index-left,++.++_index-right) equation.bRing
            | inr (k1,p1), inr (k2,p2) => rewrite (p1,p2,++.++_index-right,++.++_index-right) \lam p => equation.bRing {lr {k1} {k2} \lam q => p (cong q)}
          }

        \lemma split_SFRefines {b : B} {l : Array (\Sigma V B)} : SFRefines (split b l) l
          => (\lam j => byRight $ =_<= equation.bRing <=∘ B.BigJoin-cond {\lam i => b * (l i).2 ∨ B.diff (l i).2 b} j <=∘ =_<= (inv $ pmap B.BigJoin (map_++ __.2) *> B.BigJoin_++ *> inv (later $ B.BigJoin_join {_} {map (\lam s => b * s.2) l})), \lam j => \case ++.split-index j \with {
            | inl (k,p) => rewrite (p,++.++_index-left) $ inP (k, zro-left, meet-right)
            | inr (k,p) => rewrite (p,++.++_index-right) $ inP (k, idp, B.diff_<=)
          })

        \lemma split_add_SFRefines {b : B} {l : Array (\Sigma V B)} : SFRefines (split b l) (add 0 b l)
          => rewrite (\peval add 0 b l) (\case \elim __ \with {
            | 0 => byLeft idp
            | suc j => byRight \case ++.split-index j \with {
              | inl (k,p) => later (rewrite (p,++.++_index-left) <=-refl) <=∘ B.BigJoin-cond {map __.2 _} j
              | inr (k,p) => later (rewrite (p,++.++_index-right) <=-refl) <=∘ B.BigJoin-cond {map __.2 _} j
            }
          }, \lam j => inP (suc j, idp, <=-refl))

        \sfunc add-double1 {u v : V} {b : B} {l : Array (\Sigma V B)} : EPerm (add v b (add u b l))
          ((v + u, B.diff b (B.BigJoin (map __.2 l))) :: (v, bottom) :: (u, bottom) ::
          (map (\lam s => (v + u + s.1, b * s.2)) l ++ map (\lam s => (v + s.1, bottom)) l) ++
          map (\lam s => (u + s.1, bottom)) l ++ map (\lam s => (s.1, B.diff s.2 b)) l)
          => transport (EPerm _) (
            cong_:: (pmap (\lam x => (v + u, B.diff x _)) isBooleanRing) $
            cong_:: (pmap (v,__) equation.bRing) $
            cong_:: (pmap (u,__) equation.bRing) $ pmap2 (++)
            (pmap2 (++) (exts \lam j => ext (idp, pmap (`* _) isBooleanRing)) (exts \lam j => ext (idp, equation.bRing)))
            (pmap2 (++) (exts \lam j => ext (idp, equation.bRing)) (exts \lam j => ext (idp, equation.bRing)))) add-double

        \lemma add_+_SFRefines {u v : V} {b : B} {l : Array (\Sigma V B)} (lr : IsReduced l) : SFRefines (add (u + v) b l) (add u b (add v b l))
          => transportInv (SFRefines __ _) (\peval add _ b l) $ SFRefines-trans (add_IsReduced $ add_IsReduced lr) (SFRefines_:: $ SFRefines_::-right bottom-univ $ SFRefines_::-right bottom-univ $ SFRefines_++ (SFRefines_++-left SFRefines-refl \lam j => byRight bottom-univ) (SFRefines_++-right SFRefines-refl \lam j => byRight bottom-univ)) (SFRefines_EPerm $ EPerm.eperm-sym add-double1)

        \sfunc add-double2 {v : V} {a b : B} {l : Array (\Sigma V B)} : EPerm (add v (a ∨ b) (add v (a * b) l))
          ((v + v, B.diff (a * b) (B.BigJoin (map __.2 l))) :: (v, B.diff (a ∨ b) (a * b ∨ B.BigJoin (map __.2 l))) :: (v, bottom) ::
          (map (\lam s => (v + v + s.1, (a * b) * s.2)) l ++ map (\lam s => (v + s.1, B.diff ((a ∨ b) * s.2) (a * b))) l) ++
          map (\lam s => (v + s.1, bottom)) l ++ map (\lam s => (s.1, B.diff s.2 (b ∨ a))) l)
          => transport (EPerm _) (
            cong_:: (pmap (v + v, __) equation.bRing) $ cong_:: idp $ cong_:: (pmap (v,__) equation.bRing) $ pmap2 (++)
            (pmap (`++ _) (exts \lam j => pmap (_ + _, __) equation.bRing))
            (pmap2 (++) (exts \lam j => pmap (_ + _, __) equation.bRing) (exts \lam j => pmap ((l j).1, __) equation.bRing))) add-double

        \lemma add-modularity_SFRefines {v : V} {a b : B} {l : Array (\Sigma V B)} (lr : IsReduced l) : SFRefines (add v a (add v b l)) (add v (a ∨ b) (add v (a * b) l))
          => SFRefines-trans (add_IsReduced $ add_IsReduced lr) (SFRefines_EPerm add-double) $ SFRefines-trans (add_IsReduced $ add_IsReduced lr)
              (SFRefines_:: $ SFRefines_::-merge equation.bRing $ SFRefines_::-right bottom-univ $ transport2 (SFRefines __ __) (inv ++-assoc) (inv ++-assoc) $ SFRefines_++ SFRefines-refl $ transport2 (SFRefines __ __) ++-assoc ++-assoc $ SFRefines_++ (SFRefines_++-left (later $ SFRefines_++-merge (\lam x => B.diff (a * x) b) (\lam x => B.diff (b * x) a) (\lam x => B.diff (_ * x) (a * b)) (\lam c => equation.bRing) {map (\lam s => (v + s.1, s.2)) l}) \lam j => byRight bottom-univ) SFRefines-refl)
              (SFRefines_EPerm $ EPerm.eperm-sym add-double2)
      }

    \lemma ~_=-unequals {l l' : Array (\Sigma V B)} (p : inSF l = inSF l') => ~-unequals $ Quotient.equalityEquiv ~_Equivalence (path \lam i => p i)

    \lemma split1 (c : B) {v : V} {b : B} {l : Array (\Sigma V B)} : (v,b) :: l ~ (v, c * b) :: (v, B.diff b c) :: l
      => ~-trans (transport2 (\lam x y => _ ~ (v,x) :: (v,y) :: l) equation.bRing equation.bRing $ ~_:: (~-sym $ ~-zro-right idp)) (~-+-right idp idp)

    \lemma reduced-tail {x : \Sigma V B} {l : Array (\Sigma V B)} (lr : IsReduced (x :: l)) : IsReduced l
      => \lam {i} {j} i/=j => lr \lam p => i/=j (unfsuc p)

    \lemma add_~ {v : V} {b : B} {l : Array (\Sigma V B)} (lr : IsReduced l) : add v b l ~ (v,b) :: l \elim l
      | nil => transportInv (`~ _) (\peval add v b nil) $ ~-perm $ EPerm.eperm-= $ pmap (\lam x => (v,x) :: nil) equation.bRing
      | a :: l => transportInv (`~ _) (\peval add v b _) $ ~-trans (~-trans (later $ ~_:: $ ~_:: $ ~-perm EPerm.EPerm_++-swap) $
        ~-trans ~-swap $ ~-trans (~_:: ~-swap) $ ~-trans (~-sym $ ~-+-left idp idp) $ ~-trans (~_:: $ ~-sym $ split1 b) $ ~-trans ~-swap $ ~_:: $
        transportInv (_ ~) (\peval add v b l) $ ~-trans (~-perm $ EPerm.eperm-= $ cong_:: (pmap (v,__) $ <=-antisymmetric (meet-univ meet-right $ B.diff-univ meet-left $ <=-antisymmetric (B.meet-monotone meet-right <=-refl <=∘ =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam j => =_<= $ lr $ /=-sym fsuc/=0) bottom-univ) $ B.meet_<=' equation.bRing) $ cong_:: (pmap (v,__) equation.bRing) idp) (~-sym $ split1 a.2)) (~-trans (~_:: $ add_~ $ reduced-tail lr) ~-swap)

    \lemma reduce_~ {l : Array (\Sigma V B)} : reduce l ~ l \elim l
      | nil => ~-reflexive
      | a :: l => ~-trans (add_~ reduce_IsReduced) (~_:: reduce_~)

    \lemma ~-+s-left {l : Array (\Sigma V B)} (lr : IsReduced l) {x : \Sigma V B} (p : \Pi (i : Fin l.len) -> (l i).1 = x.1) (q : B.BigJoin (map __.2 l) = x.2) : l ~ x :: nil \elim l
      | nil => ~-sym $ transport (\lam y => (x.1,y) :: nil ~ nil) q (~-zro-right idp)
      | a :: l => ~-trans (~_::_= (ext (p 0, <=-antisymmetric (meet-univ <=-refl $ B.BigJoin-cond {map __.2 (a :: l)} 0 <=∘ =_<= q) meet-left)) $ later $ ~-+s-left (reduced-tail lr) (\lam i => p (suc i)) $ <=-antisymmetric (B.BigJoin-univ \lam j => B.diff-univ (B.BigJoin-cond {map __.2 (a :: l)} (suc j)) $ lr fsuc/=0) (B.meet_<=' equation.bRing) *> pmap (B.diff __ a.2) q) (~-sym $ split1 a.2 {_} {_} {nil})

    \lemma SFRefines_~ {l l' : Array (\Sigma V B)} (lr : IsReduced l) (l'r : IsReduced l') (r : SFRefines l l') : l ~ l' \elim l'
      | nil => ~-perm $ EPerm.eperm-= $ inv $ exts (cases (l arg addPath) \with {
        | nil, _ => idp
        | a :: l, q => \case r.2 (rewrite q 0) \with {
          | inP ((),_,_)
        }
      }, \case __)
      | a :: l' => \case FinSet.finiteAC r.2 \with {
        | inP f =>
          \let | D i => decideEq (f i).1 0
               | indices => \new Array (Fin l.len) l.len \lam i => i
          \in ~-trans (~-perm $ EPerm.EPerm_map l $ keep_remove-split {_} {_} {D} {indices}) $ transportInv (`~ _) (map_++ l) $ ~_++ (\case r.1 0 \with {
            | byLeft a=0 => ~-trans (~-zros-left \lam i => later $ (f _).2 *> rewrite (keep.satisfies D) a=0) $ ~-sym $ ~-zro-left $ pmap (\lam x => (x,a.2) :: nil) a=0
            | byRight p => ~-+s-left
              (\lam i/=j => lr \lam q => i/=j $ later $ keep.no-repeats (\lam p => later p) q)
              (\lam i => (f _).2 *> rewrite (keep.satisfies D) idp)
              $ <=-antisymmetric (B.BigJoin-univ \lam j => (f _).3 <=∘ rewrite (keep.satisfies D) <=-refl) $
                meet-univ <=-refl p <=∘ =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam i => later \case D i \with {
                  | yes e => \have (k,ki) => keep.element {_} {_} {D} {indices} e
                             \in meet-right <=∘ later (rewrite ki <=-refl) <=∘ B.BigJoin-cond {map (\lam j => (l j).2) _} k
                  | no q => B.meet-monotone <=-refl (f i).3 <=∘ =_<= (l'r {0} $ /=-sym q) <=∘ bottom-univ
                }
          }) $ SFRefines_~ (\lam i/=j => lr \lam q => i/=j $ later $ remove.no-repeats (\lam p => later p) q) (reduced-tail l'r)
            (\lam j => \case r.1 (suc j) \with {
              | byLeft p => byLeft p
              | byRight p => byRight $ meet-univ <=-refl p <=∘ =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam i => later \case D i \with {
                | yes e => B.meet-monotone <=-refl (f i).3 <=∘ =_<= (later $ rewrite e $ l'r fsuc/=0) <=∘ bottom-univ
                | no q => \have (k,ki) => remove.element {_} {_} {D} {indices} q
                          \in later (rewrite ki meet-right) <=∘ B.BigJoin-cond {map (\lam j => (l j).2) _} k
              }
            }, \lam i' => later
              \let | (i,i'=i) => remove.preimage i'
                   | fi/=0 : (f i).1 /= 0 => rewriteI i'=i (remove.no-element D)
              \in inP (fpredP (f i).1 fi/=0, (f _).2 *> later (rewrite {1} (i'=i, inv $ fsuc_fpredP fi/=0) idp), rewrite i'=i $ (f i).3 <=∘ later (rewriteI {1} (fsuc_fpredP fi/=0) <=-refl)))
      }

    \lemma makeReduced (a : SFunc V B) : ∃ (l : IsReduced) (a = inSF l)
      | in~ l => inP (reduce l, reduce_IsReduced, inv $ ~-sfequiv reduce_~)
  }

{-
\open SFuncPosetQModule \hiding (<=)

\instance SFuncRieszSpace (V : RieszSpace) (B : BooleanRing) : RieszSpace (SFunc V B)
  => RieszSpace.fromAbs \lam a => \case makeReduced a \with {
    | inP (l,lr,lp) => rewrite lp $ inP (inSF $ map (\lam s => (V.abs s.1, s.2)) l, {?}, {?}, {?})
  }
-}