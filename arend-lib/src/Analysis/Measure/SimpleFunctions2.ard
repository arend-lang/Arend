\import Algebra.Monoid
\import Algebra.Pointed
\import Data.Array
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set.Fin
\import Set.Fin.Instances
\import Set.Partial

-- TODO: Move to a separate file
\instance ProductAddPointed (A B : AddPointed) : AddPointed (\Sigma A B)
  | zro => (0, 0)

\record PreSFunc (V : AddPointed) (B : BottomDistributiveLattice) (\coerce pfunc : B -> Partial V) {
  | pfunc-coh {a b : B} (ad : (pfunc a).isDefined) (bd : (pfunc b).isDefined) : a ∧ b <= bottom || (pfunc a ad = pfunc b bd)
  | pfunc-bottom-coh (bd : (pfunc bottom).isDefined) : pfunc bottom bd = 0

  \lemma pfunc-bottom-coh-eq {b : B} (b=0 : b = bottom) {d : (pfunc b).isDefined} : pfunc b d = 0
    => pmap {\Sigma (b : B) ((pfunc b).isDefined)} (\lam s => pfunc s.1 s.2) {b,d} {bottom,_} (ext b=0) *> pfunc-bottom-coh (rewriteI b=0 d)
}

\record SFunc2 \extends PreSFunc {
  | pfunc-<= {a b : B} {v : V} : a <= b -> (pfunc b).HasValue v -> (a = bottom -> v = 0) -> (pfunc a).HasValue v
  | pfunc-bottom : (pfunc bottom).HasValue 0
  | pfunc-join {a b : B} {v : V} : (pfunc a).HasValue v -> (pfunc b).HasValue v -> (pfunc (a ∨ b)).HasValue v
  | pfunc-bottom-coh bd => partial-value {_} {pfunc bottom} idp *> pfunc-bottom.2

  \lemma pfunc-BigJoin {l : Array B} {v : V} (ld : ∀ (x : l) ((pfunc x).HasValue v)) (bt : l = nil -> v = 0) : (pfunc (B.BigJoin l)).HasValue v \elim l
    | nil => transportInv Partial.HasValue (bt idp) pfunc-bottom
    | a :: nil => transportInv (\lam x => (pfunc x).HasValue v) B.bottom-right (ld 0)
    | a :: a' :: l => pfunc-join (ld 0) $ pfunc-BigJoin (\lam j => ld (suc j)) (\case __)
} \where {
    \func closure {V : AddPointed} {B : BottomDistributiveLattice} (f : PreSFunc V B) : SFunc2 V B \cowith
      | pfunc (b : B) : Partial V => Partial.make (TruncP (Witness b)) \lam tw => (wRec tw).1
      | pfunc-coh (inP (l,v,al,ld,av)) (inP (l',v',bl',l'd,bv')) => \case FinSet.||-search {ProdFin (FinFin l.len) (FinFin l'.len)} (\lam s => \case f.pfunc-coh (ld s.1).1 (l'd s.2).1 \with {
        | byLeft p => byRight p
        | byRight p => byLeft $ inv (ld s.1).2 *> p *> (l'd s.2).2
      }) \with {
        | byLeft v=v' => byRight $ wRec_inP *> v=v' *> inv wRec_inP
        | byRight d => byLeft $ B.meet-monotone al bl' <=∘ =_<= B.BigJoin-rdistr <=∘ B.BigJoin-univ \lam i => =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam i' => later $ d (i,i')
      }
      | pfunc-<= {a} {b} {v} a<=b bv at => \case getWitness bv \with {
        | inP (l,bl,ld,bt) => (inP (l, v, a<=b <=∘ bl, ld, at), wRec_inP)
      }
      | pfunc-bottom => (inP (nil, 0, <=-refl, \case __ \with {}, \lam _ => idp), wRec_inP)
      | pfunc-join {a} {b} {v} av bv => \case getWitness av, getWitness bv \with {
        | inP (l,al,ld,at), inP (l',bl',l'd,bt) => (inP (l ++ l', v, B.join-monotone al bl' <=∘ =_<= (inv B.BigJoin_++), ++.++-all {_} {\lam a => (f a).HasValue v} ld l'd, \lam ab=0 => at $ <=-antisymmetric (join-left <=∘ =_<= ab=0) bottom-univ), wRec_inP)
      }
      \where {
        \func Witness (b : B) => \Sigma (l : Array B) (v : V) (b <= B.BigJoin l) (∀ (x : l) ((f x).HasValue v)) (b = bottom -> v = 0)

        \lemma witness-fin {b : B} (A : FinSet) (l : A -> B) (v : V) (p : b <= B.FinJoin l) (q : \Pi (a : A) -> (f (l a)).HasValue v) (bt : b = bottom -> v = 0) : TruncP (Witness b)
          => \case A.finEq \with {
            | inP e => inP (\lam j => l (e j), v, p <=∘ =_<= (B.FinJoin_Equiv e *> B.FinJoin=BigJoin), \lam j => q (e j), bt)
          }

        \lemma witness-coh {b : B} {w w' : Witness b} : w.2 = w'.2 \elim w, w'
          | (l,v,bl,ld,bv), (l',v',bl',l'd,bv') => \case FinSet.||-search {ProdFin (FinFin l.len) (FinFin l'.len)} (\lam s => \case f.pfunc-coh (ld s.1).1 (l'd s.2).1 \with {
            | byLeft p => byRight p
            | byRight p => byLeft $ inv (ld s.1).2 *> p *> (l'd s.2).2
          }) \with {
            | byLeft r => r
            | byRight d =>
              \have b=0 => <=-antisymmetric (meet-univ bl bl' <=∘ =_<= B.BigJoin-rdistr <=∘ B.BigJoin-univ \lam i => =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam i' => later $ d (i,i')) bottom-univ
              \in bv b=0 *> inv (bv' b=0)
          }

        \lemma wRec {b : B} (tw : TruncP (Witness b)) : \Sigma (v : V) (∃ (w : Witness b) (w.2 = v))
          => TruncP.rec-set tw __.2 \lam w w' => witness-coh

        \lemma wRec_inP {b : B} {w : Witness b} : (wRec (inP w)).1 = w.2
          => \case (wRec (inP w)).2 \with {
            | inP (w',p) => inv p *> witness-coh
          }

        \lemma getWitness {b : B} {v : V} (p : (pfunc {_} {_} {f} b).HasValue v)
          : ∃ (l : Array B) (b <= B.BigJoin l) (∀ (x : l) ((f x).HasValue v)) (b = bottom -> v = 0) \elim p
          | (inP (l,v',bl,ld,bt), bv) =>
            \have v=v' => inv bv *> wRec_inP
            \in inP (l, bl, \lam j => rewrite v=v' (ld j), \lam b=0 => v=v' *> bt b=0)
      }

    \lemma closure-id {V : AddPointed} {B : BottomDistributiveLattice} {f : SFunc2 V B} : closure f = f
      => exts \lam b => partial-ext-right {_} {closure f b}
        (\lam (inP (l,v,bl,ld,bt)) => (pfunc-<= bl (f.pfunc-BigJoin ld \lam l=nil => bt $ <=-antisymmetric (bl <=∘ rewrite l=nil <=-refl) bottom-univ) bt).1,
         \lam fd => inP (b :: nil, f b fd, join-left, \lam _ => (fd,idp), \lam b=0 => partial-value (pmap f b=0) *> f.pfunc-bottom.2))
        \lam p => closure.wRec_inP

    \func const0 {V : AddPointed} {B : BottomDistributiveLattice} : SFunc2 V B \cowith
      | pfunc _ => defined 0
      | pfunc-coh _ _ => byRight idp
      | pfunc-<= _ t _ => ((), t.2)
      | pfunc-bottom => ((), idp)
      | pfunc-join t _ => ((), t.2)

    \func pre-lift2 {V : AddPointed} {B : BottomDistributiveLattice} (op : V -> V -> V) (op0 : op 0 0 = 0) (f g : PreSFunc V B) : PreSFunc V B \cowith
      | pfunc b => plift2 op (f b) (g b)
      | pfunc-coh ad bd => \case f.pfunc-coh ad.1 bd.1, g.pfunc-coh ad.2 bd.2 \with {
        | byLeft r, _ => byLeft r
        | _, byLeft r => byLeft r
        | byRight p, byRight q => byRight $ pmap2 op p q
      }
      | pfunc-bottom-coh bd => pmap2 op (pfunc-bottom-coh bd.1) (pfunc-bottom-coh bd.2) *> op0

    \func lift2 {V : AddPointed} {B : BottomDistributiveLattice} (op : V -> V -> V) (op0 : op 0 0 = 0) (f g : PreSFunc V B) : SFunc2 V B
        => closure (pre-lift2 op op0 f g)

{-
    \lemma lift2_closure-right {V : AddPointed} {B : BottomDistributiveLattice} (op : V -> V -> V) (op0 : op 0 0 = 0) {f : PreSFunc V B} (g : PreSFunc V B) : lift2 op op0 f (closure g) = lift2 op op0 f g
      => exts \lam b => partial-ext-right {_} {closure.pfunc b}
        (\lam (inP (l,v,bl,ld,bt)) => \case FinSet.finiteAC (\lam j => (ld j).1.2) \with {
          | inP h => closure.witness-fin {V} {B} {pre-lift2 op op0 f g} (SigmaFin (FinFin l.len) (\lam i => FinFin (h i).1.len)) (\lam s => (h s.1).1 s.2) v (bl <=∘ B.BigJoin-univ \lam i => (h i).3 <=∘ B.BigJoin-univ \lam j => B.FinJoin-cond $ later (i,j))
            (\lam s => \have (t1,t2) => ld s.1 \in ((unfold at t1 $ unfold at t2 $ {?}, ((h s.1).4 s.2).1), unfold {?})) bt
        }, \lam (inP (l,v,bl,ld,bt)) => inP (l, v, bl, \lam j => (((ld j).1.1, inP (l j :: nil, _, join-left, \lam _ => ((ld j).1.2,idp), \lam lj=0 => g.pfunc-bottom-coh-eq lj=0)), pmap (op _) closure.wRec_inP *> (ld j).2), bt))
        \lam (inP w) => closure.wRec_inP *> inv closure.wRec_inP

  \lemma lift2_closure-right' {V : AddPointed} {B : BottomDistributiveLattice} (op : V -> V -> V) (op0 : op 0 0 = 0) {f : PreSFunc V B} (g : PreSFunc V B) : lift2 op op0 f (closure g) = lift2 op op0 f g
    => exts \lam b => partial-ext-right {_} {closure.pfunc b}
      (\lam (inP (l,v,bl,ld,bt)) => \case FinSet.finiteAC (\lam i => (ld i).1.2) \with {
        | inP h => closure.witness-fin {V} {B} {pre-lift2 op op0 f g} (SigmaFin (FinFin l.len) (\lam i => FinFin (h i).1.len)) (\lam s => l s.1 ∧ (h s.1).1 s.2) v (bl <=∘ B.BigJoin-univ \lam i => meet-univ <=-refl (h i).3 <=∘ =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam j => B.FinJoin-cond $ later (i,j))
          (\lam s => unfold ({?}, {?})) bt
      }, \lam (inP (l,v,bl,ld,bt)) => inP (l, v, bl, \lam j => (((ld j).1.1, inP (l j :: nil, _, join-left, \lam _ => ((ld j).1.2,idp), \lam lj=0 => g.pfunc-bottom-coh-eq lj=0)), pmap (op _) closure.wRec_inP *> (ld j).2), bt))
      \lam (inP w) => closure.wRec_inP *> inv closure.wRec_inP

    \lemma lift2_closure {V : AddPointed} {B : BottomDistributiveLattice} (op : V -> V -> V) (op0 : op 0 0 = 0) (f g : PreSFunc V B) : lift2 op op0 (closure f) (closure g) = lift2 op op0 f g
      => exts \lam b => partial-ext-right {_} {closure.pfunc b}
        (\lam (inP (l,v,bl,ld,bt)) => \case FinSet.finiteAC (\lam i => (ld i).1.1), FinSet.finiteAC (\lam i => (ld i).1.2) \with {
          | inP h1, inP h2 => closure.witness-fin {V} {B} {pre-lift2 op op0 f g} (SigmaFin (FinFin l.len) (\lam i => ProdFin (FinFin (h1 i).1.len) (FinFin (h2 i).1.len))) (\lam s => (h1 s.1).1 s.2.1 ∧ (h2 s.1).1 s.2.2) v (bl <=∘ B.BigJoin-univ \lam i => meet-univ (h1 i).3 (h2 i).3 <=∘ =_<= B.BigJoin-rdistr <=∘ B.BigJoin-univ \lam j1 => =_<= B.BigJoin-ldistr <=∘ B.BigJoin-univ \lam j2 => B.FinJoin-cond $ later (i,(j1,j2)))
            (\lam s => (({?}, {?}), {?})) bt
        }, \lam (inP (l,v,bl,ld,bt)) => inP (l, v, bl, \lam j => ((inP (l j :: nil, _, join-left, \lam (0) => ((ld j).1.1,idp), \lam lj=0 => f.pfunc-bottom-coh-eq lj=0), inP (l j :: nil, _, join-left, \lam (0) => ((ld j).1.2,idp), \lam lj=0 => g.pfunc-bottom-coh-eq lj=0)), pmap2 op closure.wRec_inP closure.wRec_inP *> (ld j).2), bt))
        \lam (inP w) => closure.wRec_inP *> inv closure.wRec_inP
 -}
  }

{-
\open SFunc2

\instance SFuncAbMonoid (V : AbMonoid) (B : BottomDistributiveLattice) : AbMonoid (SFunc2 V B)
  | zro => const0
  | + f g => lift2 (+) zro-left f g
  | +-assoc {f} {g} {h} => {?} -- exts \lam b => partial-ext {_} {SFunc2.closure _ b} {?} {?}
  | +-comm {f} {g} => pmap closure $ exts \lam b =>
    partial-ext {_} {plift2 (+) (f b) (g b)} (\lam s => (s.2,s.1), \lam s => (s.2,s.1)) \lam p q => +-comm
  | zro-left => pmap closure (exts \lam b => partial-ext-right {_} {plift2 (+) (const0 b) _} (\lam d => d.2, \lam d => ((),d)) \lam d => zro-left) *> closure-id
  \where {
    \func \infixl 6 p+ (f g : PreSFunc V B) : PreSFunc V B \cowith
      | pfunc b => plift2 (+) (f b) (g b)
      | pfunc-coh ad bd => \case f.pfunc-coh ad.1 bd.1, g.pfunc-coh ad.2 bd.2 \with {
        | byLeft r, _ => byLeft r
        | _, byLeft r => byLeft r
        | byRight p, byRight q => byRight $ pmap2 (+) p q
      }
      | pfunc-bottom-coh => {?}
  }
 -}