\import Category
\import Function.Meta
\import HLevel
\import Paths
\import Order.PartialOrder
\import Order.Lattice
\open Preorder
\open Lattice
\open JoinSemilattice (join_<=, join-comm)
\open MeetSemilattice (meet-assoc, meet_<=)
\open Precat(>>)

\class MeetSemilattice \extends Poset {
  | meet \alias \infixl 7 ∧ : E -> E -> E
  | meet-left {x y : E} : x ∧ y <= x
  | meet-right {x y : E} : x ∧ y <= y
  | meet-univ {x y z : E} : z <= x -> z <= y -> z <= x ∧ y

  \lemma meet-idemp {x : E} : x ∧ x = x =>
    <=-antisymmetric meet-left (meet-univ <=-reflexive <=-reflexive)

  \lemma meet-comm {x y : E} : x ∧ y = y ∧ x =>
    <=-antisymmetric (meet-univ meet-right meet-left)
                     (meet-univ meet-right meet-left)

  \lemma meet-assoc {x y z : E} : (x ∧ y) ∧ z = x ∧ (y ∧ z) =>
    <=-antisymmetric (meet-univ (<=-transitive meet-left meet-left)
                                (meet-univ (<=-transitive meet-left meet-right)
                                            meet-right))
                     (meet-univ (meet-univ meet-left
                                           (<=-transitive meet-right meet-left))
                                (<=-transitive meet-right meet-right))

  \lemma meet_<= {x y : E} (x<=y : x <= y) : x ∧ y = x =>
    <=-antisymmetric meet-left (meet-univ <=-reflexive x<=y)
} \where {
  -- | ``Meet x y`` is the type of elements which are meets of {x} and {y}.
  \func Meet {E : Poset} (x y : E) =>
    \Sigma (j : E) (\Sigma (j <= x) (j <= y) (\Pi (z : E) -> z <= x -> z <= y -> z <= j))

  \lemma Meet-isProp {E : Poset} {x y : E} : isProp (Meet x y) => \lam p1 p2 =>
      SigmaPropExt (\lam j => \Sigma (j <= x) (j <= y) (\Pi (z : E) -> z <= x -> z <= y -> z <= j)) p1 p2
                   (<=-antisymmetric (p2.2.3 p1.1 p1.2.1 p1.2.2) (p1.2.3 p2.1 p2.2.1 p2.2.2))
}

\class JoinSemilattice \extends Poset {
  | join \alias \infixl 6 ∨ : E -> E -> E
  | join-left {x y : E} : x <= x ∨ y
  | join-right {x y : E} : y <= x ∨ y
  | join-univ {x y z : E} : x <= z -> y <= z -> x ∨ y <= z

  \lemma join-idemp {x : E} : x ∨ x = x =>
    <=-antisymmetric (join-univ <=-reflexive <=-reflexive) join-left

  \lemma join-comm {x y : E} : x ∨ y = y ∨ x =>
    <=-antisymmetric (join-univ join-right join-left)
                     (join-univ join-right join-left)

  \lemma join-assoc {x y z : E} : (x ∨ y) ∨ z = x ∨ (y ∨ z) =>
    <=-antisymmetric (join-univ (join-univ join-left (join-left >> join-right))
                                (join-right >> join-right))
                     (join-univ (join-left >> join-left)
                                (join-univ (join-right >> join-left) join-right))

  \lemma join_<= {x y : E} (x<=y : x <= y) : x ∨ y = y =>
    <=-antisymmetric (join-univ x<=y <=-reflexive) join-right

} \where {
  -- | ``Join x y`` is the type of elements which are joins of {x} and {y}.
  \func Join {E : Poset} (x y : E) =>
    \Sigma (m : E) (\Sigma (x <= m) (y <= m) (\Pi (z : E) -> x <= z -> y <= z -> m <= z))

  \lemma Join-isProp {E : Poset} {x y : E} : isProp (Join x y) => \lam p1 p2 =>
      SigmaPropExt (\lam m => \Sigma (x <= m) (y <= m) (\Pi (z : E) -> x <= z -> y <= z -> m <= z)) p1 p2
                   (<=-antisymmetric (p1.2.3 p2.1 p2.2.1 p2.2.2) (p2.2.3 p1.1 p1.2.1 p1.2.2))
}

\class Lattice \extends MeetSemilattice, JoinSemilattice {
  \lemma distrib<= {x y z : E} : x ∨ (y ∧ z) <= (x ∨ y) ∧ (x ∨ z) =>
    join-univ (meet-univ join-left join-left)
              (meet-univ (meet-left >> join-right) (meet-right >> join-right))
}

\class DistributiveLattice \extends Lattice {
  \property distrib>= {x y z : E} : x ∨ (y ∧ z) >= (x ∨ y) ∧ (x ∨ z)

  \lemma distrib {x y z : E} : x ∨ (y ∧ z) = (x ∨ y) ∧ (x ∨ z) =>
    <=-antisymmetric distrib<= distrib>=

  \lemma codistrib {x y z : E} : x ∧ (y ∨ z) = (x ∧ y) ∨ (x ∧ z) => inv $
    distrib *>
    pmap2 (∧) (join_<= meet-left) (join-comm *> distrib)  *>
    inv meet-assoc *> pmap2 (∧) (meet_<= join-right) join-comm
}

\module Bounded \where {
  \class MeetSemilattice \extends Order.Lattice.MeetSemilattice
    | top : E
    | top-univ {x : E} : x <= top

  \class JoinSemilattice \extends Order.Lattice.JoinSemilattice
    | bottom : E
    | bottom-univ {x : E} : bottom <= x

  \class Lattice \extends Order.Lattice.Lattice, MeetSemilattice, JoinSemilattice
}
