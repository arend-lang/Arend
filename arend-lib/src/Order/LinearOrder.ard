\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\open JoinSemilattice
\open MeetSemilattice

\class TotalOrder \extends DistributiveLattice {
  | totality (x y : E) : x <= y || y <= x

  | ∧ x y => (tjoin (totality x y)).1
  | meet-left {x} {y} => (tjoin (totality x y)).2.1
  | meet-right {x} {y} => (tjoin (totality x y)).2.2
  | meet-univ {x} {y} {z} => (tjoin (totality x y)).2.3 z

  | ∨ x y => (tmeet (totality x y)).1
  | join-left {x} {y} => (tmeet (totality x y)).2.1
  | join-right {x} {y} => (tmeet (totality x y)).2.2
  | join-univ {x} {y} {z} => (tmeet (totality x y)).2.3 z

  | ldistr>= => rewriteI (total-distrib totality) <=-reflexive
} \where {
  \func tjoin {E : Poset} {x y : E} => ||.rec MeetSemilattice.Meet-isProp
                                              (\lam x<=y => (x, (E.<=-reflexive, x<=y, \lam z z<=x _ => z<=x)))
                                              (\lam y<=x => (y, (y<=x, E.<=-reflexive, \lam z _ z<=y => z<=y)))

  \func tmeet {E : Poset} {x y : E} => ||.rec JoinSemilattice.Join-isProp
                                              (\lam x<=y => (y, (x<=y, E.<=-reflexive, \lam z _ y<=z => y<=z)))
                                              (\lam y<=x => (x, (E.<=-reflexive, y<=x, \lam z z<=x _ => z<=x)))

  \lemma total-distrib {E : Lattice} (totality : \Pi (x y : E) -> x <= y || y <= x) {x y z : E} : x ∧ (y ∨ z) = (x ∧ y) ∨ (x ∧ z) =>
    \case totality y z \with {
      | byLeft y<=z => distrib-x-y totality y<=z
      | byRight z<=y => transport2 (x ∧ __ = __) join-comm join-comm (distrib-x-y totality z<=y)
    } \where {
    \lemma distrib-x-y {E : Lattice} (totality : \Pi (x y : E) -> x <= y || y <= x)
                       {x y z : E} (y<=z : y <= z) : x ∧ (y ∨ z) = (x ∧ y) ∨ (x ∧ z) =>
      pmap (x ∧) (join_<= y<=z) *> (\case totality (x ∧ y) (x ∧ z) \with {
        | byLeft xy<=xz => inv (join_<= xy<=xz)
        | byRight xz<=xy =>
          \have xz=xy => <=-antisymmetric xz<=xy (meet-univ meet-left (<=-transitive meet-right y<=z))
          \in rewriteI xz=xy (inv join-idemp)
      })
  }
}

-- | A linearly ordered set.
\class LinearOrder \extends StrictPoset, Poset {
  | <-comparison (y : E) {x z : E} : x < z -> x < y || y < z
  | <-connectedness {x y : E} : Not (x < y) -> Not (y < x) -> x = y

  | <= => <=
  | <=-reflexive => notGreater <-irreflexive
  | <=-transitive {x} {y} {z} x<=y y<=z => notGreater (\case <-comparison y __ \with {
    | byLeft z<y => notLess y<=z z<y
    | byRight y<x => notLess x<=y y<x
  })
  | <=-antisymmetric x<=y y<=x => <-connectedness (notLess y<=x) (notLess x<=y)
} \where {
  \class With# \extends LinearOrder, Set#
    | # x y => x < y || y < x
    | #-irreflexive x#x => \case x#x \with {
      | byLeft x<x => <-irreflexive x<x
      | byRight x<x => <-irreflexive x<x
    }
    | #-symmetric x#y => \case x#y \with {
      | byLeft x<y => byRight x<y
      | byRight y<x => byLeft y<x
    }
    | #-comparison x y z x#z => \case x#z \with {
      | byLeft x<z => \case <-comparison y x<z \with {
        | byLeft x<y => byLeft (byLeft x<y)
        | byRight y<z => byRight (byLeft y<z)
      }
      | byRight z<x => \case <-comparison y z<x \with {
        | byLeft z<y => byRight (byRight z<y)
        | byRight y<x => byLeft (byRight y<x)
      }
    }
    | tightness x/#y => <-connectedness (\lam x<y => x/#y (byLeft x<y)) (\lam y<x => x/#y (byRight y<x))

  \data \infix 4 <= {A : StrictPoset} (a a' : A)
    | notGreater (Not (a' < a))

  \lemma notLess {A : StrictPoset} {a a' : A} (p : a <= a') (q : a' < a) : Empty \elim p
    | notGreater p => p q

  -- | A linearly ordered set with decidable inequality.
  \class Dec \extends LinearOrder, DecSet, TotalOrder {
    \field trichotomy (x y : E) : Tri x y

    | <-comparison y {x} {z} x<z => \case trichotomy x y \with {
      | less x<y => byLeft x<y
      | equals x=y => byRight (transport (`< z) x=y x<z)
      | greater y<x => byRight (<-transitive y<x x<z)
    }
    | <-connectedness {x} {y} x/<y y/<x => \case trichotomy x y \with {
      | less x<y => absurd (x/<y x<y)
      | equals x=y => x=y
      | greater y<x => absurd (y/<x y<x)
    }
    | totality x y => \case trichotomy x y \with {
      | less x<y => byLeft (<=-less x<y)
      | equals x=y => byLeft (rewrite x=y (notGreater <-irreflexive))
      | greater y<x => byRight (<=-less y<x)
    }

    \default decideEq x y => \case trichotomy x y \with {
      | less x<y => no (\lam x=y => <-irreflexive (transport (`< y) x=y x<y))
      | equals x=y => yes x=y
      | greater y<x => no (\lam x=y => <-irreflexive (transport (y <) x=y y<x))
    }
  }

  \func <=-dec {A : Dec} {a a' : A} (p : a <= a') : (a < a') `Or` (a = a') => \case trichotomy a a' \with {
    | less a<a' => inl a<a'
    | equals a=a' => inr a=a'
    | greater a'<a => absurd (notLess p a'<a)
  }

  \func dec<_<= {A : Dec} (a a' : A) : (a < a') `Or` (a' <= a) => \case trichotomy a a' \with {
    | less a<a' => inl a<a'
    | equals a=a' => inr (notGreater (rewrite a=a' <-irreflexive))
    | greater a'<a => inr (<=-less a'<a)
  }

  \lemma dec<_reduce {A : Dec} {a a' : A} (p : a < a') : dec<_<= a a' = inl p
    => unfold dec<_<= (mcases contradiction \with {
      | less a<a' => pmap inl (Path.inProp a<a' p)
    })

  \lemma dec<=_reduce {A : Dec} {a a' : A} (p : a' <= a) : dec<_<= a a' = inr p
    => unfold dec<_<= (mcases (pmap inr (Path.inProp _ _)) \with {
      | less a<a' => contradiction
    })
}

\open LinearOrder(notGreater)

\data Tri {A : StrictPoset} (a a' : A)
  | less (a < a')
  | equals (a = a')
  | greater (a > a')
  \where
    \use \level levelProp : \Prop

\lemma \fixr 4 <-transitive-right {A : LinearOrder} {a1 a2 a3 : A} (p : a1 LinearOrder.<= a2) (q : a2 < a3) : a1 < a3 \elim p
  | notGreater a2/<a1 => \case <-comparison a1 q \with {
    | byLeft a2<a1 => absurd (a2/<a1 a2<a1)
    | byRight a1<a3 => a1<a3
  }

\lemma \fixl 4 <-transitive-left {A : LinearOrder} {a1 a2 a3 : A} (p : a1 < a2) (q : a2 LinearOrder.<= a3) : a1 < a3 \elim q
  | notGreater a3/<a2 => \case <-comparison a3 p \with {
    | byLeft a1<a3 => a1<a3
    | byRight a3<a2 => absurd (a3/<a2 a3<a2)
  }

\lemma <=-less {A : StrictPoset} {a1 a2 : A} (p : a1 < a2) : a1 LinearOrder.<= a2
  => notGreater (\lam q => <-irreflexive (<-transitive p q))
