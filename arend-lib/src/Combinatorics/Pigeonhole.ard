\import Arith.Fin
\import Arith.Nat
\import Data.Or
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Order.LinearOrder
\import Order.StrictOrder
\import Set
\import Set.Fin
\open FinLinearOrder

\lemma pigeonhole {n m : Nat} (f : Fin m -> Fin n) (p : n < m) : ∃ (i j : Fin m) (f i = f j)
  => aux f $ \lam inj => <-irreflexive $ <-transitive-left p $ FinSet.FinCardInj f inj
  \where {
    \lemma search-pair {n : Nat} {A : DecSet} (f : Fin n -> A) : Dec (∃ (i j : Fin n) (f i = f j))
      => \have t i : Dec (∃ (j : Fin n) (f i = f j)) => \case FinSet.search (\lam j => f i = f j) (\lam j => decideEq _ _) \with {
           | inl (j,p,_) => yes (inP (j,p))
           | inr q => no $ \lam (inP (j,p)) => q j p
         }
         \in \case FinSet.search (\lam i => ∃ (j : Fin n) (f i = f j)) t \with {
          | inl (i,p,_) => yes $ TruncP.map p (\lam q => (i,q.1,q.2))
          | inr q => no $ \lam (inP (i,j,p)) => q i (inP (j,p))
        }

    \lemma aux {n : Nat} {A : DecSet} (f : Fin n -> A) (p : Not (\Pi (x y : Fin n) -> f x = f y -> x = y)) : ∃ (i j : Fin n) (f i = f j)
      => \case search-pair f \with {
        | yes e => e
        | no q => absurd $ p $ \lam i j p => absurd $ q $ inP (i,j,p)
      }
  }