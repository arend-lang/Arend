\import AG.Scheme
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring.Category
\import Algebra.Ring.Graded
\import Algebra.Ring.Graded.Localization
\import Algebra.Ring.Ideal
\import Algebra.Ring.Localization
\import Algebra.Ring.Sub
\import Algebra.Semiring
\import Arith.Int
\import Arith.Nat
\import Category
\import Category.Functor
\import Category.Topos.Sheaf
\import Data.Array
\import Data.Bool
\import Data.Maybe
\import Data.Or
\import Equiv \hiding (Map)
\import Function.Meta
\import HLevel
\import Logic
\import Logic.Meta
\import Meta
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set.Category
\import Set.Fin
\import Topology.Locale
\open Ideal
\open AddMonoid
\open Monoid(pow)

\func ProjPres (R : GradedCRing) : FramePres (Carrier R) \cowith
  | conj => h*
  | BasicCover => FramePres.Indexing {Or (\Sigma (n : Nat) (a b : R) (isHomogen a (suc n)) (isHomogen b (suc n))) Nat} $ later $
      \case \elim __ \with {
        | inl (n,a,b,ah,bh) => (Bool, (a + b, n, homogen-+ ah bh), if {Carrier R} __ (a,n,ah) (b,n,bh))
        | inr n => (Empty, (0, n, homogen-zro), absurd)
      }
  \where {
    \func Carrier (R : GradedCRing) => \Sigma (a : R) (n : Nat) (isHomogen a (suc n))
      \where {
        \func ext {R : GradedCRing} (x y : Carrier R) (p : x.1 = y.1) : Or (x = y) (x.1 = 0)
          => \case y.1 \as a, \elim p : x.1 = a, y.3 \as y3 : isHomogen a (suc y.2) \return Or (x = (a,y.2,y3)) (x.1 = 0)\with {
            | _, idp, y3 => \case R.degree-unique x.3 y3 \with {
              | inl x=0 => inr x=0
              | inr q => inl $ Paths.Meta.ext (idp, pmap pred q)
            }
          }
      }

    \func h* {R : GradedCRing} (x y : Carrier R) : Carrier R
      => (x.1 * y.1, suc (x.2 Nat.+ y.2), homogen-* x.3 y.3)

    \lemma cover_spec {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} (c : Cover {ProjPres R} x g) : Cover {SpecPres R} x.1 (\lam j => (g j).1) \elim c
      | cover-basic bc => FramePres.indexing-transport _ (later (\case \elim __ \with {
        | inl (n,a,b,ah,bh) => cover-basic $ inP (just (a,b), idEquiv, idp, cases __ idp)
        | inr n => cover-basic $ inP (nothing, idEquiv, idp, \case __)
      })) bc
      | cover-inj j p => cover-inj j (pmap __.1 p)
      | cover-trans c h => cover-trans (cover_spec c) $ \lam i => cover_spec (h i)
      | Cover.cover-proj1 idp j idp => Cover.cover-proj1 idp j idp
      | cover-idemp j p => cover-idemp j (pmap __.1 p)
      | cover-comm idp j q => cover-comm idp j (pmap __.1 q)
      | cover-ldistr idp c h => cover-ldistr idp (cover_spec c) (\lam j => pmap __.1 (h j))

    \lemma cover_zro {R : GradedCRing} {x : Carrier R} (p : x.1 = 0) {J : \Set} {g : J -> Carrier R} : Cover {ProjPres R} x g
      => cover-trans (cover-basic {_} {x} {Empty} {absurd} $ later $ inP (inr x.2, idEquiv, ext (inv p, idp), \case __)) (\case __)

    \lemma cover-proj1 {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} {a : Carrier R} {b : R} {n : Nat} (bh : isHomogen b n) (p : x.1 = a.1 * b) (j : J) (q : g j = a) : Cover {ProjPres R} x g
      => \case R.degree-unique {_} {_} {suc a.2 + n} x.3 $ rewrite p $ homogen-* a.3 bh \with {
        | inl x=0 => cover_zro x=0
        | inr de => Cover.cover-trans1 (cover-idemp {ProjPres R} {x} {\Sigma} {\lam _ => h* x x} () idp) $
          \let | c : Carrier R => (b * a.1 * b, n + a.2 + n, homogen-* (homogen-* bh a.3) bh)
               | xx=ac : h* x x = h* a c => ext (equation, linarith)
          \in rewrite xx=ac $ mkcon Cover.cover-proj1 {a} {c} idp j q
      }

    \lemma cover-proj2 {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} {a : R} {n : Nat} (ah : isHomogen a n) {b : Carrier R} (p : x.1 = a * b.1) (j : J) (q : g j = b) : Cover {ProjPres R} x g
      => cover-proj1 ah (p *> *-comm) j q

    \lemma ideal_cover {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} (c : Ideal.radical {closure (\lam j => (g j).1)} x.1) : Cover {ProjPres R} x g \elim c
      | inP (0, inP (l,p)) => \case homogen-bigSum {R} {0} (mkArray $ \lam i => ((l i).1, g (l i).2)) (rewriteI p R.homogen-ide) \with {
        | inP (l', q) =>
          \have t => R.BigSum_zro {mkArray (\lam j => (l' j).1 * (g (l j).2).1)} $ \lam j =>
                       \case R.degree-unique (l' j).4 (R.homogen-* (l' j).3 (g (l j).2).3) \with {
                         | inl p => p
                         | inr ()
                       }
          \in cover_zro equation
      }
      | inP (suc n, inP (l : Array, p)) => \case homogen-bigSum (mkArray $ \lam i => ((l i).1, g (l i).2)) $ rewriteI p $ R.homogen-pow {x.1} {suc x.2} {suc n} x.3 \with {
        | inP (l',q) => Cover.cover-trans1 (cover_hpow n) $
          \let l'' => mkArray $ \lam j => (l' j).1 * (g (l j).2).1
          \in rewrite (hpow-lem (R.homogen-BigSum {l''} $ \lam j => (l' j).4) (hpow_pow *> p *> q) hpow-degree) $
              cover-trans (cover_bigSum {R} {l''} _) $ \lam j => cover-proj2 (l' j).3 idp (l j).2 idp
      }
      \where {
        \func hpow {R : GradedCRing} (x : Carrier R) (n : Nat) : Carrier R \elim n
          | 0 => x
          | suc n => h* (hpow x n) x

        \lemma hpow_pow {R : GradedCRing} {x : Carrier R} {n : Nat} : (hpow x n).1 = Monoid.pow x.1 (suc n) \elim n
          | 0 => inv ide-left
          | suc n => pmap (`* x.1) hpow_pow

        \lemma hpow-degree {R : GradedCRing} {x : Carrier R} {n : Nat} : (hpow x n).2 = suc x.2 * n + x.2 \elim n
          | 0 => idp
          | suc n => pmap (\lam y => suc (y + x.2)) hpow-degree

        \lemma hpow-lem {R : GradedCRing} {x : Carrier R} {n : Nat} {a : R} {m : Nat} (ah : isHomogen a (suc m)) (p : (hpow x n).1 = a) (q : (hpow x n).2 = m) : hpow x n = (a, m, ah)
          => ext (p,q)

        \lemma cover_hpow {R : GradedCRing} {x : Carrier R} (n : Nat) : Cover1 {ProjPres R} x (hpow x n) \elim n
          | 0 => cover-inj () idp
          | suc n => Cover.cover-prod (cover_hpow n) (cover-inj () idp)

        \lemma homogen-bigSum {R : GradedCRing} {n : Nat} (l : Array (\Sigma R (Carrier R))) (lh : isHomogen (BigSum $ map (\lam p => p.1 * p.2.1) l) n)
          : ∃ (l' : DArray {l.len} (\lam j => \Sigma (a : R) (m : Nat) (isHomogen a m) (isHomogen (a * (l j).2.1) n))) (BigSum (map (\lam p => p.1 * p.2.1) l) = BigSum (mkArray (\lam j => (l' j).1 * (l j).2.1)))
          => \have | lem1 {n m : Nat} (p : suc m <= n) : suc (n -' suc m Nat.+ m) = n => pmap iabs $ transportInv (\lam x => x + m + 1 = n) (-'=- p) linarith
                   | lem2 {n m k : Nat} (p : m <= n) (q : n < m + k) : n -' m < k => pos<pos.conv $ transportInv (`< _) (-'=- p) linarith
             \in TruncP.map (FinSet.finiteAC (\lam j => homogen-decomp (l j).1)) $ \lam f => (\new DArray { | at j => later $ \case LinearOrder.dec<_<= n (suc (l j).2.2), LinearOrder.dec<_<= n (suc (l j).2.2 + DArray.len {(f j).1}) \with {
               | inl p, _ => (0, 0, homogen-zro, rewrite R.zro_*-left homogen-zro)
               | _, inr p => (0, 0, homogen-zro, rewrite R.zro_*-left homogen-zro)
               | inr p, inl q =>
                 \let index => toFin {n -' suc (l j).2.2} (lem2 p q)
                 \in ((f j).1 index, index, (f j).2 index, transport (\lam x => R.isHomogen _ x) (lem1 p) $ homogen-* (transport (isHomogen ((f j).1 index)) (toFin=id _) ((f j).2 index)) (l j).2.3)
             } }, unfold_let {?})

        \lemma cover_bigSum {R : GradedCRing} {l : Array R} {n : Nat} (p : \Pi (j : Fin l.len) -> isHomogen (l j) (suc n))
          : Cover {ProjPres R} (BigSum l, n, R.homogen-BigSum p) (mkArray $ later $ \lam j => (l j, n, p j)) \elim l
          | nil => cover-basic $ inP (inr n, \new QEquiv (\case __) (\case __) (\case __) (\case __), ext (idp,idp), \case __)
          | a :: l => cover-trans (cover-basic $ FramePres.indexing-make $ later $ inl (n, a, BigSum l, p 0, R.homogen-BigSum (\lam j => p (suc j)))) $ later $ \case \elim __ \with {
            | false => cover-trans (cover_bigSum (\lam j => p (suc j))) (\lam i => cover-inj (suc i) idp)
            | true => cover-inj 0 idp
          }
      }
  }

\func Proj (R : GradedCRing) => PresentedFrame (ProjPres R)

\func projRingedPres (R : GradedCRing) : Scheme (Proj R) \cowith
  | R => sheafOnPresentedFrame {_} {CRingBicat} $ sheaf-reflect CRingCat.forgetful CRingCat.forgetful.reflectsLimit functor {?}
  | isScheme => {?}
  \where {
    \open SubMonoid
    \open Monoid
    \open HomogenLocRing
    \open CMonoid
    \open functorial

    \func functor => \new Functor (Precat.op {framePresSite (ProjPres R)}) CRingBicat {
      | F a => HomogenLocRing (powers a.1)
      | Func {a} {b} c => (functorial a.3 b.3 suc/=0 (ProjPres.cover_spec c)).1
      | Func-id {a} => \case (functorial a.3 a.3 suc/=0 (ProjPres.cover_spec (cover-inj () idp))).2 \with {
        | inP (t,p) => inv p *> exts (\lam e => \case (smap a.3 a.3 t.1 t.2 t.3 t.4 t.5 t.6 e).2 \with {
          | inP (s,q) => inv q *> ext (~-pequiv (rewrite (pow_*,t.5,pow_*-comm) equation) *> inv (pmap __.1 s.4))
        })
      }
      | Func-o {a} {b} {c} {g} {f} => \case (functorial a.3 c.3 suc/=0 (ProjPres.cover_spec (g ∘ {Precat.op {framePresSite (ProjPres R)}} f))).2, (functorial b.3 c.3 suc/=0 (ProjPres.cover_spec g)).2, (functorial a.3 b.3 suc/=0 (ProjPres.cover_spec f)).2 \with {
        | inP (t1,p1), inP (t2,p2), inP (t3,p3) => inv p1 *> exts (\lam e => unfold $ unfold $
          \case (smap a.3 c.3 t1.1 t1.2 t1.3 t1.4 t1.5 t1.6 e).2, (smap b.3 c.3 t2.1 t2.2 t2.3 t2.4 t2.5 t2.6 (smap a.3 b.3 t3.1 t3.2 t3.3 t3.4 t3.5 t3.6 e).1).2, (smap a.3 b.3 t3.1 t3.2 t3.3 t3.4 t3.5 t3.6 e).2 \with {
            | inP (s1,q1), inP (s2,q2), inP (s3,q3) => inv q1 *> unfold sfunc (unfold fromSType $ ext $ \case LocRing.unequals (powers a.1) $ pmap __.1 $ inv s1.4 *> s3.4, LocRing.unequals (powers b.1) $ pmap __.1 $ q3 *> s2.4 \with {
              | inP (_, inP (m1, idp), d1), inP (_, inP (m2, idp), d2) => LocRing.equals-lem (powers c.1) (pow c.1 (t1.1 * (s3.2 + m1) + t2.1 * (t3.1 * s3.2 + m2))) (inP (_, idp)) $
                  later $ repeat (rewrite pow_* <|> rewrite pow_*-comm <|> rewrite pow_+ <|> rewrite t1.5 <|> rewrite t2.5 <|> rewrite t3.5) $ rewrite (pow_*,t3.5,pow_*-comm) at d2 $ equation
            }) *> q2
          }
        ) *> pmap2 (∘) p2 p3
      }
    }

    \lemma functorial {R : GradedCRing} {a b : R} {ad bd : Nat} (ah : isHomogen a ad) (bh : isHomogen b bd) (bd/=0 : bd /= 0) (r : Cover1 {SpecPres R} b a)
      : \Sigma (f : RingHom (HomogenLocRing (powers a)) (HomogenLocRing (powers b))) (∃ (t : \Sigma (n : Nat) (c : R) (cd : Nat) (ch : isHomogen c cd) (pow b n = a * c) (bd * n = ad + cd)) (shom t.1 t.2 t.3 t.4 t.5 t.6 = f))
        \level TruncP.rec-set.level _ shom-coh
      => \have | (inP (n,c)) => SpecPres.cover_ideal r
               | (inP (c,b^n=ac)) => closure1-lem.1 c
               | (inP (c,cd,ch,b^n=ac)) => R.homogen-factor b^n=ac (R.homogen-pow bh) ah
         \in \case R.degree-unique (R.homogen-pow bh) (rewrite b^n=ac $ homogen-* ah ch) \with {
               | inl b^n=0 =>
                   \have c : Contr => RingHom.contr-isTerm $ SubRing.comm-isContr $ LocRing.nilpotent-contr (powers b) b (inP (1, ide-left)) n b^n=0
                   \in (c.center, inP ((n + ad, 0, bd * (n + ad) -' ad, homogen-zro, pow_+ *> later (rewrite b^n=0 zro_*-left) *> inv zro_*-right,
                     unpos $ inv $ pmap (pos ad +) (-'=- $ transportInv (ad <=) ldistr $ NatSemiring.<=_+ zero<=_ $ \case \elim bd, \elim bd/=0 \with {
                       | 0, bd/=0 => absurd (bd/=0 idp)
                       | suc bd, _ => later $ rewrite NatSemiring.*-comm $ NatSemiring.<=_+ zero<=_ <=-refl
                     }) *> equation), inv (c.contraction _)))
               | inr bd*n=ad+cd => (shom n c cd ch b^n=ac bd*n=ad+cd, inP ((n, c, cd, ch, b^n=ac, bd*n=ad+cd), idp))
             }
      \where {
        \func sfunc (n : Nat) (c : R) (cd : Nat) (ch : isHomogen c cd) (bd*n=ad+cd : bd * n = ad + cd) (k : Nat) {y : R} (yh : isHomogen y (ad * k)) : HomogenLocRing (powers b)
          => fromSType (y * pow c k, pow b (n * k), later $ inP (n * k, idp)) {bd * (n * k)} (rewrite (inv *-assoc, bd*n=ad+cd, rdistr) $ homogen-* yh (R.homogen-pow ch)) (R.homogen-pow bh)

        \lemma shom-coh (t s : \Sigma (n : Nat) (c : R) (cd : Nat) (ch : isHomogen c cd) (pow b n = a * c) (bd * n = ad + cd))
          : shom t.1 t.2 t.3 t.4 t.5 t.6 = {RingHom (HomogenLocRing (powers a)) (HomogenLocRing (powers b))} shom s.1 s.2 s.3 s.4 s.5 s.6
          => exts $ \lam e => unfold $ \case (smap t.1 t.2 t.3 t.4 t.5 t.6 e).2, (smap s.1 s.2 s.3 s.4 s.5 s.6 e).2 \with {
            | inP (u,p), inP (v,q) => \case LocRing.unequals (powers a) $ pmap __.1 $ inv u.4 *> v.4 \with {
              | inP (_, inP (w, idp), d) => inv p *> ext (LocRing.equals-lem (powers b) (pow b (t.1 * w)) (inP (t.1 * w, idp)) $
                  later $ rewrite (pow_*,pow_*,pow_*,t.5,s.5,pow_*-comm,pow_*-comm,pow_*-comm) equation) *> q
            }
          }

        \lemma smap (n : Nat) (c : R) (cd : Nat) (ch : isHomogen c cd) (p : pow b n = a * c) (bd*n=ad+cd : bd * n = ad + cd) (x : HomogenLocRing (powers a))
          : \Sigma (z : HomogenLocRing (powers b)) (∃ (t : \Sigma (y : R) (k : Nat) (yh : isHomogen y (ad * k)) (x = fromSType (y, pow a k, later $ inP (k,idp)) yh (R.homogen-pow ah))) (sfunc n c cd ch bd*n=ad+cd t.2 t.3 = z))
          => TruncP.rec-set (\case x.2 \with {
            | inP ((y1, _, inP (k, idp)),x=[y],yd,y1h,y2h) => later $ inP $ \case R.degree-unique y2h (R.homogen-pow ah) \with {
              | inl a^k=0 => (0, 0, homogen-zro, ext $ isContr=>isProp (LocRing.nilpotent-contr (powers a) a (inP (1,ide-left)) k a^k=0) _ _)
              | inr yd=ad*k => (y1, k, rewriteF yd=ad*k y1h, ext x=[y])
            }
          }) (\lam t => sfunc n c cd ch bd*n=ad+cd t.2 {t.1} t.3) $ \lam q1 q2 => ext $
                \case LocRing.unequals (powers a) $ pmap __.1 $ inv q1.4 *> q2.4 \with {
                  | inP (_, inP (s, idp), e) => LocRing.equals-lem (powers b) (pow b (n * s)) (inP (n * s, idp)) $
                      later $ rewrite (pow_*,pow_*,pow_*,p,pow_*-comm,pow_*-comm,pow_*-comm) equation
                }

        \func shom (n : Nat) (c : R) (cd : Nat) (ch : isHomogen c cd) (p : pow b n = a * c) (bd*n=ad+cd : bd * n = ad + cd) : RingHom (HomogenLocRing (powers a)) (HomogenLocRing (powers b)) \cowith
          | func x => (smap n c cd ch p bd*n=ad+cd x).1
          | func-+ {x} {y} => \case (smap n c cd ch p bd*n=ad+cd x).2, (smap n c cd ch p bd*n=ad+cd y).2, (smap n c cd ch p bd*n=ad+cd (x + y)).2 \with {
            | inP (t1,q1), inP (t2,q2), inP (t3,q3) => inv q3 *> ext (
              \case LocRing.unequals (powers a) $ pmap __.1 $ inv t3.4 *> pmap2 (+) t1.4 t2.4 \with {
                | inP (_, inP (s, idp), e) => LocRing.equals-lem (powers b) (pow b (n * s)) (inP (n * s, idp)) $
                    later $ rewrite (pow_*,pow_*,pow_*,pow_*,p,pow_*-comm,pow_*-comm,pow_*-comm,pow_*-comm) equation
              }) *> pmap2 (+) q1 q2
          }
          | func-ide => \case (smap n c cd ch p bd*n=ad+cd ide).2 \with {
            | inP (t,q) => inv q *> ext (\case LocRing.unequals (powers a) $ pmap __.1 $ t.4 \with {
              | inP (_, inP (s, idp), e) => LocRing.equals-lem (powers b) (pow b (n * s)) (inP (n * s, idp)) $
                  later $ rewrite (pow_*,pow_*,p,pow_*-comm,pow_*-comm) equation
            })
          }
          | func-* {x} {y} =>\case (smap n c cd ch p bd*n=ad+cd x).2, (smap n c cd ch p bd*n=ad+cd y).2, (smap n c cd ch p bd*n=ad+cd (x * y)).2 \with {
            | inP (t1,q1), inP (t2,q2), inP (t3,q3) => inv q3 *> ext (
              \case LocRing.unequals (powers a) $ pmap __.1 $ inv t3.4 *> pmap2 (*) t1.4 t2.4 \with {
                | inP (_, inP (s, idp), e) => LocRing.equals-lem (powers b) (pow b (n * s)) (inP (n * s, idp)) $
                    later $ rewrite (pow_*,pow_*,pow_*,pow_*,p,pow_*-comm,pow_*-comm,pow_*-comm,pow_*-comm) equation
              }) *> pmap2 (*) q1 q2
          }
      }
  }