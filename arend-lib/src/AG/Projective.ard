\import AG.Scheme
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ring.Graded
\import Algebra.Ring.Ideal
\import Arith.Int
\import Arith.Nat
\import Data.Array
\import Data.Bool
\import Data.Maybe
\import Data.Or
\import Equiv \hiding (Map)
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Fin
\import Topology.Locale
\open Ideal
\open AddMonoid

\func ProjPres (R : GradedCRing) : FramePres (Carrier R) \cowith
  | conj => h*
  | BasicCover => FramePres.Indexing {Or (\Sigma (n : Nat) (a b : R) (isHomogen a (suc n)) (isHomogen b (suc n))) Nat} $ later $
      \case \elim __ \with {
        | inl (n,a,b,ah,bh) => (Bool, (a + b, n, homogen-+ ah bh), if {Carrier R} __ (a,n,ah) (b,n,bh))
        | inr n => (Empty, (0, n, homogen-zro), absurd)
      }
  \where {
    \func Carrier (R : GradedCRing) => \Sigma (a : R) (n : Nat) (isHomogen a (suc n))
      \where {
        \func ext {R : GradedCRing} (x y : Carrier R) (p : x.1 = y.1) : Or (x = y) (x.1 = 0)
          => \case y.1 \as a, \elim p : x.1 = a, y.3 \as y3 : isHomogen a (suc y.2) \return Or (x = (a,y.2,y3)) (x.1 = 0)\with {
            | _, idp, y3 => \case R.degree-unique x.3 y3 \with {
              | inl x=0 => inr x=0
              | inr q => inl $ Paths.Meta.ext (idp, pmap pred q)
            }
          }
      }

    \func h* {R : GradedCRing} (x y : Carrier R) : Carrier R
      => (x.1 * y.1, suc (x.2 Nat.+ y.2), homogen-* x.3 y.3)

    \lemma cover_spec {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} (c : Cover {ProjPres R} x g) : Cover {SpecPres R} x.1 (\lam j => (g j).1) \elim c
      | cover-basic bc => FramePres.indexing-transport _ (later (\case \elim __ \with {
        | inl (n,a,b,ah,bh) => cover-basic $ inP (just (a,b), idEquiv, idp, cases __ idp)
        | inr n => cover-basic $ inP (nothing, idEquiv, idp, \case __)
      })) bc
      | cover-inj j p => cover-inj j (pmap __.1 p)
      | cover-trans c h => cover-trans (cover_spec c) $ \lam i => cover_spec (h i)
      | Cover.cover-proj1 idp j idp => Cover.cover-proj1 idp j idp
      | cover-idemp j p => cover-idemp j (pmap __.1 p)
      | cover-comm idp j q => cover-comm idp j (pmap __.1 q)
      | cover-ldistr idp c h => cover-ldistr idp (cover_spec c) (\lam j => pmap __.1 (h j))

    \lemma cover_zro {R : GradedCRing} {x : Carrier R} (p : x.1 = 0) {J : \Set} {g : J -> Carrier R} : Cover {ProjPres R} x g
      => cover-trans (cover-basic {_} {x} {Empty} {absurd} $ later $ inP (inr x.2, idEquiv, ext (inv p, idp), \case __)) (\case __)

    \lemma cover-proj1 {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} {a : Carrier R} {b : R} {n : Nat} (bh : isHomogen b n) (p : x.1 = a.1 * b) (j : J) (q : g j = a) : Cover {ProjPres R} x g
      => \case R.degree-unique {_} {_} {suc a.2 + n} x.3 $ rewrite p $ homogen-* a.3 bh \with {
        | inl x=0 => cover_zro x=0
        | inr de => Cover.cover-trans1 (cover-idemp {ProjPres R} {x} {\Sigma} {\lam _ => h* x x} () idp) $
          \let | c : Carrier R => (b * a.1 * b, n + a.2 + n, homogen-* (homogen-* bh a.3) bh)
               | xx=ac : h* x x = h* a c => ext (equation, pmap suc $ pmap2 (+) (pmap pred de) (pmap pred de) *> +-assoc *> pmap (a.2 +) (inv +-assoc))
          \in rewrite xx=ac $ mkcon Cover.cover-proj1 {a} {c} idp j q
      }

    \lemma cover-proj2 {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} {a : R} {n : Nat} (ah : isHomogen a n) {b : Carrier R} (p : x.1 = a * b.1) (j : J) (q : g j = b) : Cover {ProjPres R} x g
      => cover-proj1 ah (p *> *-comm) j q

    \lemma ideal_cover {R : GradedCRing} {x : Carrier R} {J : \Set} {g : J -> Carrier R} (c : Ideal.radical {closure (\lam j => (g j).1)} x.1) : Cover {ProjPres R} x g \elim c
      | inP (0, inP (l,p)) => \case homogen-bigSum {R} {0} (mkArray $ \lam i => ((l i).1, g (l i).2)) (rewriteI p R.homogen-ide) \with {
        | inP (l', q) =>
          \have t => R.BigSum_zro {mkArray (\lam j => (l' j).1 * (g (l j).2).1)} $ \lam j =>
                       \case R.degree-unique (l' j).4 (R.homogen-* (l' j).3 (g (l j).2).3) \with {
                         | inl p => p
                         | inr ()
                       }
          \in cover_zro equation
      }
      | inP (suc n, inP (l : Array, p)) => \case homogen-bigSum (mkArray $ \lam i => ((l i).1, g (l i).2)) $ rewriteI p $ R.homogen-pow {x.1} {suc x.2} {suc n} x.3 \with {
        | inP (l',q) => Cover.cover-trans1 (cover_hpow n) $
          \let l'' => mkArray $ \lam j => (l' j).1 * (g (l j).2).1
          \in rewrite (hpow-lem (R.homogen-BigSum {l''} $ \lam j => (l' j).4) (hpow_pow *> p *> q) hpow-degree) $
              cover-trans (cover_bigSum {R} {l''} _) $ \lam j => cover-proj2 (l' j).3 idp (l j).2 idp
      }
      \where {
        \func hpow {R : GradedCRing} (x : Carrier R) (n : Nat) : Carrier R \elim n
          | 0 => x
          | suc n => h* (hpow x n) x

        \lemma hpow_pow {R : GradedCRing} {x : Carrier R} {n : Nat} : (hpow x n).1 = Monoid.pow x.1 (suc n) \elim n
          | 0 => inv ide-left
          | suc n => pmap (`* x.1) hpow_pow

        \lemma hpow-degree {R : GradedCRing} {x : Carrier R} {n : Nat} : (hpow x n).2 = suc x.2 * n + x.2 \elim n
          | 0 => idp
          | suc n => pmap (\lam y => suc (y + x.2)) hpow-degree

        \lemma hpow-lem {R : GradedCRing} {x : Carrier R} {n : Nat} {a : R} {m : Nat} (ah : isHomogen a (suc m)) (p : (hpow x n).1 = a) (q : (hpow x n).2 = m) : hpow x n = (a, m, ah)
          => ext (p,q)

        \lemma cover_hpow {R : GradedCRing} {x : Carrier R} (n : Nat) : Cover1 {ProjPres R} x (hpow x n) \elim n
          | 0 => cover-inj () idp
          | suc n => Cover.cover-prod (cover_hpow n) (cover-inj () idp)

        \lemma homogen-bigSum {R : GradedCRing} {n : Nat} (l : Array (\Sigma R (Carrier R))) (lh : isHomogen (BigSum $ map (\lam p => p.1 * p.2.1) l) n)
          : âˆƒ (l' : DArray {l.len} (\lam j => \Sigma (a : R) (m : Nat) (isHomogen a m) (isHomogen (a * (l j).2.1) n))) (BigSum (map (\lam p => p.1 * p.2.1) l) = BigSum (mkArray (\lam j => (l' j).1 * (l j).2.1)))
          => \have | lem1 {n m : Nat} (p : suc m <= n) : suc (n -' suc m Nat.+ m) = n => pmap iabs $ transportInv (\lam x => x + m + 1 = n) (-'=- p) linarith
                   | lem2 {n m k : Nat} (p : m <= n) (q : n < m + k) : n -' m < k => pos<pos.conv $ transportInv (`< _) (-'=- p) linarith
             \in TruncP.map (FinSet.finiteAC (\lam j => homogen-decomp (l j).1)) $ \lam f => (\new DArray { | at j => later $ \case LinearOrder.dec<_<= n (suc (l j).2.2), LinearOrder.dec<_<= n (suc (l j).2.2 + DArray.len {(f j).1}) \with {
               | inl p, _ => (0, 0, homogen-zro, rewrite R.zro_*-left homogen-zro)
               | _, inr p => (0, 0, homogen-zro, rewrite R.zro_*-left homogen-zro)
               | inr p, inl q =>
                 \let index => toFin {n -' suc (l j).2.2} (lem2 p q)
                 \in ((f j).1 index, index, (f j).2 index, transport (\lam x => R.isHomogen _ x) (lem1 p) $ homogen-* (transport (isHomogen ((f j).1 index)) (toFin=id _) ((f j).2 index)) (l j).2.3)
             } }, unfold_let {?})

        \lemma cover_bigSum {R : GradedCRing} {l : Array R} {n : Nat} (p : \Pi (j : Fin l.len) -> isHomogen (l j) (suc n))
          : Cover {ProjPres R} (BigSum l, n, R.homogen-BigSum p) (mkArray $ later $ \lam j => (l j, n, p j)) \elim l
          | nil => cover-basic $ inP (inr n, \new QEquiv (\case __) (\case __) (\case __) (\case __), ext (idp,idp), \case __)
          | a :: l => cover-trans (cover-basic $ FramePres.indexing-make $ later $ inl (n, a, BigSum l, p 0, R.homogen-BigSum (\lam j => p (suc j)))) $ later $ \case \elim __ \with {
            | false => cover-trans (cover_bigSum (\lam j => p (suc j))) (\lam i => cover-inj (suc i) idp)
            | true => cover-inj 0 idp
          }
      }
  }

\func Proj (R : GradedCRing) => PresentedFrame (ProjPres R)
