\import Logic
\import Paths
\import Relation.PartialOrder
\import Set

\class TotalOrder \extends Poset {
  | totality (x y : E) : x <= y || y <= x
}

\class LinearOrder \extends StrictPoset {
  | <-comparison (x y z : E) : x < z -> x < y || y < z
  | <-connectedness (x y : E) : Not (x < y) -> Not (y < x) -> x = y
}

\class DecLinearOrder \extends LinearOrder, DecideEq {
  | trichotomy {x y : E} : (x = y) || x < y || y < x

  | <-comparison x y z x<z => \case trichotomy {x} {y} \with {
    | byLeft x=y => byRight (transport (\lam w => w < z) x=y x<z)
    | byRight (byLeft x<y) => byLeft x<y
    | byRight (byRight y<x) => byRight (<-transitive y x z y<x x<z)
  }
  | <-connectedness x y x/<y y/<x => \case trichotomy {x} {y} \return x = y \with {
    | byLeft x=y => x=y
    | byRight (byLeft x<y) => absurd (x/<y x<y)
    | byRight (byRight y<x) => absurd (y/<x y<x)
  }

  | DecideEq.E => E
  | decideEq {x} {y} => \case trichotomy {x} {y} \with {
    | byLeft x=y => yes x=y
    | byRight (byLeft x<y) => no (\lam x=y => irreflexive y (transport (\lam z => z < y) x=y x<y))
    | byRight (byRight y<x) => no (\lam x=y => irreflexive y (transport (\lam z => y < z) x=y y<x))
  }
}
