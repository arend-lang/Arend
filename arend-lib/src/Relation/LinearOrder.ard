\import Data.Or
\import Logic
\import Paths
\import Relation.Lattice
\import Relation.PartialOrder
\import Set

\class TotalOrder \extends Lattice {
  | totality (x y : E) : x <= y || y <= x

  | join x y => (tjoin x y).1
  | join-left x y => (tjoin x y).2.1
  | join-right x y => (tjoin x y).2.2
  | join-univ x y => (tjoin x y).2.3
} \where {
  \open JoinSemilattice(Join,Join-isProp)
  \open MeetSemilattice(Meet,Meet-isProp)
  \func tjoin {E : TotalOrder} (x y : E) => ||.rec (Join-isProp x y)
                                                   (\lam x<=y => (x, (E.reflexive x, x<=y, \lam z z<=x _ => z<=x)))
                                                   (\lam y<=x => (y, y<=x, E.reflexive y, \lam z _ z<=y => z<=y))
                                                   (E.totality x y)
}

\class LinearOrder \extends StrictPoset {
  | <-comparison (x y z : E) : x < z -> x < y || y < z
  | <-connectedness (x y : E) : Not (x < y) -> Not (y < x) -> x = y
}

\class DecLinearOrder \extends LinearOrder, DecideEq, TotalOrder {
  | trichotomy {x y : E} : (x = y) `Or` (x < y) `Or` (y < x)

  | <-comparison x y z x<z => \case trichotomy {x} {y} \with {
    | inl x=y => byRight (transport (\lam w => w < z) x=y x<z)
    | inr (inl x<y) => byLeft x<y
    | inr (inr y<x) => byRight (<-transitive y x z y<x x<z)
  }
  | <-connectedness x y x/<y y/<x => \case trichotomy {x} {y} \with {
    | inl x=y => x=y
    | inr (inl x<y) => absurd (x/<y x<y)
    | inr (inr y<x) => absurd (y/<x y<x)
  }

  | DecideEq.E => E
  | decideEq {x} {y} => \case trichotomy {x} {y} \with {
    | inl x=y => yes x=y
    | inr (inl x<y) => no (\lam x=y => irreflexive y (transport (\lam z => z < y) x=y x<y))
    | inr (inr y<x) => no (\lam x=y => irreflexive y (transport (\lam z => y < z) x=y y<x))
  }
}
