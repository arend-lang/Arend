\import Algebra.Meta
\import Category
\import Category.CartesianClosed
\import Category.Limit
\import Equiv (QEquiv)
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\open PrecatWithBprod

\class ToposPrecat \extends FinCompletePrecat, CartesianClosedPrecat {
  -- subobject classifier map
  | subobj-classifier \alias omega : Ob
  | true : Hom terminal omega
  -- characteristic maps
  | char {S B : Ob} (m : Mono {\this} {S} {B}) : Hom B omega
  | char-pullback {S B : Ob} (m : Mono {\this} {S} {B}) : Pullback {\this} (char m) true S m terminalMap
  | char-unique {S B : Ob} {m : Mono {\this} {S} {B}} {phi : Hom B omega}
                (phi-pull : Pullback phi true S m terminalMap) : phi = char m
  -- universal property stating that omega is exponentiable
  | power \alias P (B : Ob) : Ob
  | belongs {B : Ob} : Hom (Bprod B (P B)) omega
  | p-transpose {A B : Ob} (f : Hom (Bprod B A) omega) : Hom A (P B)
  | transpose-univ {A B : Ob} (f : Hom (Bprod B A) omega) : f = belongs ∘ (prodMap (id B) (p-transpose f))
  | transpose-unique {A B : Ob} {f : Hom (Bprod B A) omega} {g : Hom A (P B)} (comm : f = belongs ∘ prodMap (id B) g)
  : g = p-transpose f

  \func sub-from-char {B : Ob} (ch : Hom B omega) : Pullback {\this} ch true => pullback ch true

  \func anti-transpose  {A B : Ob} (g : Hom A (P B)) : Hom (Bprod B A) omega =>
    belongs ∘ (prodMap (id B) g)

  \func antitranspose-eq {A B : Ob} (f : Hom (Bprod B A) omega) : f = anti-transpose (p-transpose f)
    => transpose-univ f

  \func transpose-inj {A B : Ob} {f g : Hom (Bprod B A) omega} (e : p-transpose f = p-transpose g)
    : f = g => transpose-univ f *> pmap (belongs ∘ prodMap (id B) __) e *> (inv $ transpose-univ g)

  \func internal-equality \alias eq (B : Ob) : Hom (Bprod B B) omega =>
    char (diagonal.isSplitMono B)

  \func singleton  (B : Ob) : Hom B (P B) => p-transpose (eq B)

  \func singleton-mono (B : Ob) : Mono (singleton B)
  \cowith
    | isMono {X} {b} {b'} sb=sb' =>
      \let
        c : eq B ∘ prodMap (id B) b = eq B ∘ prodMap (id B) b' => transpose-inj ((inv $ s-eq b) *> sb=sb' *> s-eq b')
        | b-square => full-square b
        | b'-square : Pullback {\this} (eq B ∘ prodMap (id B) b) true X (pair b' (id X)) =>
          transport (Pullback {\this} __ true X (pair b' (id X))) (inv c) (full-square b')
        | h-iso : Iso {\this} {X} {X} => Pullback.unique (eq B ∘ prodMap (id B) b) true b-square b'-square
        | pb~pb*h : pair b (id X) = pair b' (id X) ∘ h-iso => inv (Pullback.unique.p-beta1 b'-square b-square)
        | c' : proj2 ∘ (pair b' (id X) ∘ h-iso.f) = h-iso => rewriteI o-assoc $ rewrite (beta2 _ _) id-left
        | h~1 : id X = h-iso.f => inv (beta2 _ _) *> pmap (proj2 ∘ __) pb~pb*h *> c'
        | b~b'h : b = b' ∘ h-iso.f => inv (beta1 _ _) *> pmap (proj1 ∘ __) pb~pb*h *> (rewriteI o-assoc $ rewrite (beta1 _ _) idp)
      \in
        b~b'h *> rewriteI h~1 id-right
    \where {
      \func s-eq {X : Ob} (b : Hom X B) : singleton B ∘ b = p-transpose (eq B ∘ (prodMap (id B) b)) =>
        transpose-unique $ rewrite (prod-id-left _ _) $ rewriteI o-assoc $ rewriteI transpose-univ idp

      \func full-square {X : Ob} (b : Hom X B)
        : Pullback {\this} (eq B ∘ prodMap (id B) b) true X (pair b (id X)) => pullback-lemma right-square left-square

      \func right-square
        : Pullback {\this} {Bprod B B} {terminal} {omega} (eq B) true B (diagonal B) terminalMap =>
        char-pullback (diagonal.isSplitMono B)

      \func left-square{X : Ob} {b : Hom X B}
        : Pullback (prodMap (id B) b) (diagonal B) X (pair b (id X)) b
      \cowith
        | pbCoh => pair-unique
            (run {
              rewriteI o-assoc,
              rewrite (beta1 _ _, id-left),
              rewriteI o-assoc,
              rewrite (beta1 _ _, beta1 _ _) equation
            })
            (run {
              rewriteI o-assoc,
              rewrite (beta2 _ _),
              rewriteI o-assoc, rewrite (beta2 _ _, o-assoc, beta2 _ _) equation
            })
        | pbMap p1 _ _ => proj2 ∘ p1
        | pbBeta1 {w} {p1} {p2} {c} =>
          \let
            left : proj1 ∘ (diagonal B ∘ p2) = p2
            => rewriteI o-assoc $ rewrite (beta1 _ _) equation
            | right : proj1 ∘ (prodMap (id B) b ∘ p1) = proj1 ∘ p1 => rewriteI o-assoc $ rewrite (beta1 _ _) equation  \in
            pair-unique
                (run {
                  rewriteI o-assoc,
                  rewrite (beta1 _ _ ),
                  pbBeta2' w p1 p2 c *> inv left *> pmap (proj1 ∘ __ ) (inv c) *> right
                })
                (rewriteI o-assoc $ rewrite (beta2 _ _) equation)
        | pbBeta2 {w} {p1} {p2} {c} => pbBeta2' w p1 p2 c
        | pbEta {_} {h1} {h2} c _ =>
          \let p2 : h1 = proj2 ∘ (pair b (id X) ∘ h1) => rewriteI o-assoc $ rewrite (beta2 _ _) equation
               | p1 : proj2 ∘ (pair b (id X) ∘ h2) = h2  => rewriteI o-assoc $ rewrite (beta2 _ _) equation
          \in p2 *> pmap (proj2 ∘ __) c *> p1

      \func pbBeta2' {B X : Ob} {b : Hom X B} (w : Ob) (p1 : Hom w (Bprod B X))
                     (p2 : Hom w B) (c : prodMap (id B) b ∘ p1 = diagonal B ∘ p2) :  b ∘ (proj2 ∘ p1) = p2 =>
        \let left : proj2 ∘ (diagonal B ∘ p2) = p2 => rewriteI o-assoc $ rewrite (beta2 _ _) equation
             | right : proj2 ∘ (prodMap (id B) b ∘ p1) = b ∘ (proj2 ∘ p1)  =>
               rewriteI o-assoc $ rewrite (beta2 _ _) o-assoc
        \in
          inv right *> pmap (proj2 ∘ __) c *> left
    }

  \func is-singleton {B : Ob} : Hom (P B) omega => char (singleton-mono B)

  \func true-over-obj {B : Ob} : Hom B omega => true ∘ terminalMap

  \func true-over-obj-is-char {B : Ob} : true-over-obj = char (idIso {\this} {B}) =>
    char-unique (\new Pullback {
      | pbCoh => rewrite id-right idp
      | pbMap p1 _ _ => p1
      | pbBeta1 => rewrite id-left idp
      | pbBeta2 => terminal-unique
      | pbEta c _ => rewriteF (id-left, id-left) c
    })

  \func monic+epi=iso{X Y : Ob} (m : Mono {\this} {X} {Y}) (m-is-epi : isEpi {\this} {X} {Y} m)
    : Iso {\this} {X} {Y} m =>
    \let equalizer => monic-is-regular m
         | true=char-m : true-over-obj = char m => m-is-epi (Equalizer.equal {equalizer} : true-over-obj ∘ m.f = char m ∘ m)
         | equalizer-f : Equalizer (char m) (char m) => transport (Equalizer __ (char m) X m) true=char-m equalizer
    \in
      Equalizer.equalizer-iso equalizer-f

  \func monic-is-regular  {X Y : Ob} (m : Mono {\this} {X} {Y}) : Equalizer true-over-obj (char m) X m =>
    \new Equalizer {
      | equal =>
        rewrite (pbCoh {char-pullback m}, o-assoc) $
        rewrite terminal-unique idp
      | isEqualizer _ => \new QEquiv {
        | ret (h, com) => pbMap {char-pullback m} h terminalMap
            (rewriteI com $ rewrite o-assoc $ rewrite terminal-unique idp)
        | ret_f _ => pbEta {char-pullback m} (rewrite (pbBeta1 {char-pullback m}) $ idp)
            (rewrite (pbBeta2 {char-pullback m}) terminal-unique)
        | f_sec (h, com) => exts $ rewrite (pbBeta1 {char-pullback m}) idp
      }
    }

  \func global (X : Ob) => Hom terminal X

  \func name {A : Ob} (phi : Hom A omega) : global (P A) => p-transpose (phi ∘ terminal-prod-left.hinv)

  \func v {B C : Ob} : Hom (Bprod B (P $ Bprod C B)) (P C) =>
    p-transpose $ belongs ∘ associator-iso.hinv

  \func u' {B C : Ob} : Hom (Bprod B (P $ Bprod C B)) omega => is-singleton ∘ v

  \func u {B C : Ob} : Hom (P $ Bprod C B) (P B) => p-transpose u'

  \func graphs {B C : Ob} : Pullback (name (true-over-obj {\this} {B})) (u {\this} {B} {C})
    => pullback (name (true-over-obj {\this} {B})) (u {\this} {B} {C})

  \func pow (B C : Ob) : Ob => Pullback.apex {graphs {_} {B} {C} }
  \func m {B C : Ob} : Hom (pow B C) (P $ Bprod C B)  => Pullback.pbProj2 {graphs {_} {B} {C}}

  \lemma terminate {B C : Ob} {f : Hom B C} : terminalMap ∘ f = terminalMap
    => terminal-unique

  \func eval {B C : Ob} : Hom (Bprod (pow B C) B) C =>
    \let s : char (singleton-mono C) ∘ v = belongs ∘ prodMap (id B) u => antitranspose-eq _
    | eq : char (singleton-mono C) ∘ (v ∘ prodMap (id B) m ∘ change) = true ∘ terminalMap =>
      run {
        rewriteI (o-assoc, o-assoc),
        rewrite s,
        rewrite {2} o-assoc,
        rewriteI (prod-id-left, pbCoh {graphs}),
        rewrite prod-id-left,
        rewriteI (o-assoc, antitranspose-eq _),
        rewrite (o-assoc, o-assoc, o-assoc, terminate) idp
      }
    \in
    pbMap {char-pullback $ singleton-mono C} (v ∘ prodMap (id B) m ∘ change) terminalMap (unfold (Pullback.f, Pullback.g) eq)

\func ss0 {A B C : Ob} (f : Hom (Bprod B A) C) : Hom (Bprod C (Bprod B A)) omega => eq C ∘ prodMap (id C) f
\func vv0 {A B C : Ob} (f : Hom (Bprod B A) C) : p-transpose (ss0 f) = v ∘ prodMap (id B) (p-transpose (ss0 f ∘ associator))
  => unfold ss0 $ inv $ transpose-unique $ unfold $ rewrite {2} prod-id-left $ rewriteI (o-assoc, antitranspose-eq _) $
                                                                  rewrite (o-assoc, associtor-prod _ _ _, inv o-assoc, prod-id, inv $ antitranspose-eq _) $ Iso.adjoint' idp

\func last {A B C : Ob} (f : Hom (Bprod A B) C) : Mono.f {singleton-mono C} ∘ (f ∘ change) = v ∘ prodMap (id B) (m {_} {B} {C} ∘ transpose' f)
  => rewrite (pbBeta2 {graphs {_} {B} {C}}, inv (singleton-eq _)) (vv0 _)

\func singleton-eq {A B C : Ob} (f : Hom (Bprod B A) C) : p-transpose (ss0 f) = singleton C ∘ f
  => unfold ss0 $ inv (transpose-unique (rewrite (prod-id-left _ _) $ rewrite (transpose-univ (eq C)) o-assoc))

  -- single C o f' = v o <id B, s0>
\func transpose' {A B C : Ob} (f : Hom (Bprod A B) C) : Hom A (graphs {\this} {B} {C}) =>
      \let
       f' : Hom (Bprod B A) C => f ∘ change
      | s0 : Hom (Bprod C (Bprod B A)) omega => eq C ∘ prodMap (id C) f'
      | s : Hom (Bprod (Bprod C B) A) omega => s0 ∘ associator
      | h : Hom A (P $ Bprod C B) => p-transpose s
      | s-eq : s = belongs ∘ prodMap (id (Bprod C B)) h => antitranspose-eq _
      | new-s : Hom (Bprod B A) (P C) => p-transpose s0
      | new-s-eq : p-transpose s0 = singleton C ∘ f' => singleton-eq _
      | right : Hom (Bprod B A) (P C) => v ∘ prodMap (id B) h
      | lem : hinv {associator-iso} ∘ prodMap (id C) (prodMap (id B) h) = prodMap (prodMap (id C) (id B)) h ∘ associator-iso.hinv => associtor-prod _ _ _
      | eq1 : p-transpose s0 = right => inv $ transpose-unique $ unfold $ rewrite {2} prod-id-left $ rewriteI (o-assoc, antitranspose-eq _) $
            rewrite (o-assoc, lem, inv o-assoc, prod-id, inv $ antitranspose-eq _) $ Iso.adjoint' idp
      | eq2 : is-singleton ∘ (singleton C ∘ f') = true-over-obj ∘ f' => rewriteI o-assoc $ rewrite (pbCoh {char-pullback (singleton-mono C)}) idp
      | eq3 : is-singleton {_} {C} ∘ right = u' ∘ prodMap (id B) h => rewriteI o-assoc $ rewrite (idp : is-singleton {_} {C} ∘ v = u') idp
      | eq4 : p-transpose (u' ∘ prodMap (id B) h) = u ∘ h => inv (transpose-unique $ unfold $ rewrite prod-id-left $ rewriteI (o-assoc, antitranspose-eq _) idp)
      | eq5 : true-over-obj ∘ f' = true-over-obj {_} {B} ∘ proj1 {_} {B} {A} => unfold true-over-obj $ rewrite (o-assoc, terminate, o-assoc, terminate) idp
      | eq6 : p-transpose (true-over-obj {_} {B} ∘ proj1 {_} {B} {A}) = name (true-over-obj {_} {B}) ∘ terminalMap
      => inv (transpose-unique $ rewrite (prod-id-left, inv o-assoc, inv $ antitranspose-eq _) $ unfold true-over-obj $
                rewrite (o-assoc, terminate, o-assoc, o-assoc, terminate) idp)
      \in
         pbMap terminalMap h (unfold (Pullback.f, Pullback.g) (rewriteI (eq6, eq4, eq5, eq2, eq3, new-s-eq, eq1) idp))

\default exp (B : Ob) : hasExponential {\this} B => RightAdjoint-Univ.toAdjoint (\new RightAdjoint-Univ {
    | L => bprod-functor B
    | R Y => Pullback.apex {graphs {_} {B} {Y}}
    | eval {C} => eval
    | transpose => transpose'
    | transpose-univ {A} {C} f =>
      unfold $ pbEta {char-pullback (singleton-mono C)} (rewrite (inv o-assoc, pbBeta1 {char-pullback (singleton-mono C)}, o-assoc, change-prod, inv o-assoc) $ change-iso.adjoint' (rewrite {2} o-assoc $ rewriteI (prod-id-left _ _) $ rewrite o-assoc (last _)))
                   (unfold Pullback.pbProj2 $ terminal-unique)
    | transpose-unique => {?}
  })
}