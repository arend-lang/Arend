\import Algebra.Meta
\import Category
\import Category.Limit
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\open CartesianPrecat

\class ElementaryTopos \extends FinCompletePrecat, Cat
  | subobj-classifier \alias omega : Ob
  | true : Hom terminal omega

  | char {S B : Ob} (m : Mono {\this} {S} {B}) : Hom B omega
  | char-pullback {S B : Ob} (m : Mono {\this} {S} {B})
  : Pullback {\this} (char m) true  S {| pbProj2 => terminalMap | pbProj1 => m}
  | char-unique {S B : Ob} (m : Mono {\this} {S} {B}) (phi : Hom B omega)
                (phi-pull : Pullback true phi) : phi = char m

  | power \alias P (B : Ob) : Ob
  | belongs {B : Ob}  : Hom (Bprod B (P B)) omega
  | transpose {A B : Ob} (f : Hom (Bprod B A) omega) : Hom A (P B)
  | transpose-univ {A B : Ob} (f : Hom (Bprod B A) omega) : f = belongs ∘ (prodMap (id B) (transpose f))
  | transpose-unique {A B : Ob} (f : Hom (Bprod B A) omega) (g : Hom A (P B)) (comm : f = belongs ∘ prodMap (id B) g)
  : g = transpose f

  \where {
    \func internal-equality \alias eq {T : ElementaryTopos} (B : Ob {T}) : Hom (Bprod B B) omega =>
      char (diagonal.isSplitMono B)

    \func singleton {T : ElementaryTopos} (B : Ob {T}) : Hom B (P B) => transpose (eq B)

    -- pullback-lemma

    \func singleton-mono {T : ElementaryTopos} (B : Ob {T}) : Mono (singleton B)
    \cowith
      | isMono {X} {b} {b'} equal =>
        {?}
      \where {
        \func full-square {X : T} {b : Hom X B} : Pullback {T} {| apex => X | z => omega | x => Bprod B X | y => terminal | pbProj1 => pair b (id X)}
          => pullback-lemma right-square left-square

        \func right-square : Pullback {T} {Bprod B B} {terminal} {omega} (eq B) true B (diagonal B) terminalMap
          => char-pullback (diagonal.isSplitMono B)

        \func left-square{X : T} {b : Hom X B} : Pullback (prodMap (id B) b) (diagonal B) X (pair b (id X)) b
        \cowith
          | pbCoh => pair-unique
              (run {
                rewriteI o-assoc,
                rewrite (beta1 _ _, id-left),
                rewriteI o-assoc,
                rewrite (beta1 _ _, beta1 _ _) equation
              })
              (run {
                rewriteI o-assoc,
                rewrite (beta2 _ _),
                rewriteI o-assoc, rewrite (beta2 _ _, o-assoc, beta2 _ _) equation
              })
          | pbMap p1 _ _ => proj2 ∘ p1
          | pbBeta1 {w} {p1} {p2} {c} =>
                      \let
                        left : proj1 ∘ (diagonal B ∘ p2) = p2
                        => rewriteI o-assoc $ rewrite (beta1 _ _) equation
                        | right : proj1 ∘ (prodMap (id B) b ∘ p1) = proj1 ∘ p1 => rewriteI o-assoc $ rewrite (beta1 _ _) equation  \in
                        pair-unique
                            (run {
                              rewriteI o-assoc,
                              rewrite (beta1 _ _ ),
                              pbBeta2' w p1 p2 c *> inv left *> pmap (proj1 ∘ __ ) (inv c) *> right
                            })
                            (rewriteI o-assoc $ rewrite (beta2 _ _) equation)
          | pbBeta2 {w} {p1} {p2} {c} => pbBeta2' w p1 p2 c
          | pbEta {_} {h1} {h2} c _ =>
            \let p2 : h1 = proj2 ∘ (pair b (id X) ∘ h1) => rewriteI o-assoc $ rewrite (beta2 _ _) equation
                 | p1 : proj2 ∘ (pair b (id X) ∘ h2) = h2  => rewriteI o-assoc $ rewrite (beta2 _ _) equation
            \in p2 *> pmap (proj2 ∘ __) c *> p1
      }

    \func pbBeta2' {T : ElementaryTopos} {B X : T} {b : Hom X B} (w : T) (p1 : Hom w (Bprod B X))
                   (p2 : Hom w B) (c : prodMap (id B) b ∘ p1 = diagonal B ∘ p2) :  b ∘ (proj2 ∘ p1) = p2 =>
      \let left : proj2 ∘ (diagonal B ∘ p2) = p2 => rewriteI o-assoc $ rewrite (beta2 _ _) equation
           | right : proj2 ∘ (prodMap (id B) b ∘ p1) = b ∘ (proj2 ∘ p1)  =>
             rewriteI o-assoc $ rewrite (beta2 _ _) o-assoc
      \in
        inv right *> pmap (proj2 ∘ __) c *> left
  }