\import Algebra.Meta
\import Category
\import Category.CartesianClosed
\import Category.Limit
\import Equiv (QEquiv)
\import Function (isInj)
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set.Category
\open PrecatWithBprod

\class ToposPrecat \extends FinCompletePrecat, CartesianClosedPrecat {
  -- subobject classifier map

  | subobj-classifier \alias omega : Ob
  | true : Hom terminal omega
  -- characteristic maps

  | char {S B : Ob} (m : Mono {\this} {S} {B}) : Hom B omega
  | char-pullback {S B : Ob} (m : Mono {\this} {S} {B}) : Pullback {\this} (char m) true S m terminalMap
  | char-unique {S B : Ob} {m : Mono {\this} {S} {B}} {phi : Hom B omega}
                (phi-pull : Pullback phi true S m terminalMap) : phi = char m
  -- omega is exponentiable

  | power \alias P (B : Ob) : Ob
  | belongs {B : Ob} : Hom (Bprod B (P B)) omega
  | p-transpose {A B : Ob} (f : Hom (Bprod B A) omega) : Hom A (P B)
  | p-transpose-univ {A B : Ob} (f : Hom (Bprod B A) omega) : f = belongs ∘ (prodMap (id B) (p-transpose f))
  | p-transpose-unique {A B : Ob} {f : Hom (Bprod B A) omega} {g : Hom A (P B)} (comm : f = belongs ∘ prodMap (id B) g)
  : g = p-transpose f

  \func sub-from-char {B : Ob} (ch : Hom B omega) : Pullback {\this} ch true => pullback ch true

  \func anti-transpose  {A B : Ob} (g : Hom A (P B)) : Hom (Bprod B A) omega =>
    belongs ∘ (prodMap (id B) g)

  \func antitranspose-eq {A B : Ob} (f : Hom (Bprod B A) omega) : f = anti-transpose (p-transpose f) =>
    p-transpose-univ f

  \func transpose-inj {A B : Ob} {f g : Hom (Bprod B A) omega} (e : p-transpose f = p-transpose g)
    : f = g => p-transpose-univ f *> pmap (belongs ∘ prodMap (id B) __) e *> (inv $ p-transpose-univ g)

  \func internal-equality \alias eq (B : Ob) : Hom (Bprod B B) omega =>
    char (diagonal.isSplitMono B)

  \func singleton  (B : Ob) : Hom B (P B) => p-transpose (eq B)

  \func singleton-mono (B : Ob) : Mono (singleton B)
  \cowith
    | isMono {X} {b} {b'} sb=sb' =>
      \let
        c : eq B ∘ prodMap (id B) b = eq B ∘ prodMap (id B) b' => transpose-inj ((inv $ s-eq b) *> sb=sb' *> s-eq b')
        | b-square => full-square b
        | b'-square : Pullback {\this} (eq B ∘ prodMap (id B) b) true X (pair b' (id X)) =>
          transport (Pullback {\this} __ true X (pair b' (id X))) (inv c) (full-square b')
        | h-iso : Iso {\this} {X} {X} => Pullback.unique (eq B ∘ prodMap (id B) b) true b-square b'-square
        | pb~pb*h : pair b (id X) = pair b' (id X) ∘ h-iso => inv (Pullback.unique.p-beta1 b'-square b-square)
        | c' : proj2 ∘ (pair b' (id X) ∘ h-iso.f) = h-iso => rewriteI o-assoc $ rewrite (beta2 _ _) id-left
        | h~1 : id X = h-iso.f => inv (beta2 _ _) *> pmap (proj2 ∘ __) pb~pb*h *> c'
        | b~b'h : b = b' ∘ h-iso.f => inv (beta1 _ _) *> pmap (proj1 ∘ __) pb~pb*h *> (rewriteI o-assoc $ rewrite (beta1 _ _) idp)
      \in
        b~b'h *> rewriteI h~1 id-right
    \where {
      \func s-eq {X : Ob} (b : Hom X B) : singleton B ∘ b = p-transpose (eq B ∘ (prodMap (id B) b)) =>
        p-transpose-unique $ rewrite (prod-id-left _ _) $ rewriteI o-assoc $ rewriteI p-transpose-univ idp

      \func full-square {X : Ob} (b : Hom X B)
        : Pullback {\this} (eq B ∘ prodMap (id B) b) true X (pair b (id X)) => pullback-lemma right-square left-square

      \func right-square
        : Pullback {\this} {Bprod B B} {terminal} {omega} (eq B) true B (diagonal B) terminalMap =>
        char-pullback (diagonal.isSplitMono B)

      \func left-square{X : Ob} {b : Hom X B}
        : Pullback (prodMap (id B) b) (diagonal B) X (pair b (id X)) b
      \cowith
        | pbCoh => pair-unique
            (run {
              rewriteI o-assoc,
              rewrite (beta1 _ _, id-left),
              rewriteI o-assoc,
              rewrite (beta1 _ _, beta1 _ _) equation
            })
            (run {
              rewriteI o-assoc,
              rewrite (beta2 _ _),
              rewriteI o-assoc, rewrite (beta2 _ _, o-assoc, beta2 _ _) equation
            })
        | pbMap p1 _ _ => proj2 ∘ p1
        | pbBeta1 {w} {p1} {p2} {c} =>
          \let
            left : proj1 ∘ (diagonal B ∘ p2) = p2
            => rewriteI o-assoc $ rewrite (beta1 _ _) equation
            | right : proj1 ∘ (prodMap (id B) b ∘ p1) = proj1 ∘ p1 => rewriteI o-assoc $ rewrite (beta1 _ _) equation  \in
            pair-unique
                (run {
                  rewriteI o-assoc,
                  rewrite (beta1 _ _ ),
                  pbBeta2' w p1 p2 c *> inv left *> pmap (proj1 ∘ __ ) (inv c) *> right
                })
                (rewriteI o-assoc $ rewrite (beta2 _ _) equation)
        | pbBeta2 {w} {p1} {p2} {c} => pbBeta2' w p1 p2 c
        | pbEta {_} {h1} {h2} c _ =>
          \let p2 : h1 = proj2 ∘ (pair b (id X) ∘ h1) => rewriteI o-assoc $ rewrite (beta2 _ _) equation
               | p1 : proj2 ∘ (pair b (id X) ∘ h2) = h2  => rewriteI o-assoc $ rewrite (beta2 _ _) equation
          \in p2 *> pmap (proj2 ∘ __) c *> p1

      \func pbBeta2' {B X : Ob} {b : Hom X B} (w : Ob) (p1 : Hom w (Bprod B X))
                     (p2 : Hom w B) (c : prodMap (id B) b ∘ p1 = diagonal B ∘ p2) :  b ∘ (proj2 ∘ p1) = p2 =>
        \let left : proj2 ∘ (diagonal B ∘ p2) = p2 => rewriteI o-assoc $ rewrite (beta2 _ _) equation
             | right : proj2 ∘ (prodMap (id B) b ∘ p1) = b ∘ (proj2 ∘ p1)  =>
               rewriteI o-assoc $ rewrite (beta2 _ _) o-assoc
        \in
          inv right *> pmap (proj2 ∘ __) c *> left
    }

  \func is-singleton {B : Ob} : Hom (P B) omega => char (singleton-mono B)

  \func true-over-obj {B : Ob} : Hom B omega => true ∘ terminalMap

  \func true-over-obj-is-char {B : Ob} : true-over-obj = char (idIso {\this} {B}) =>
    char-unique (\new Pullback {
      | pbCoh => rewrite id-right idp
      | pbMap p1 _ _ => p1
      | pbBeta1 => rewrite id-left idp
      | pbBeta2 => terminal-unique
      | pbEta c _ => rewriteF (id-left, id-left) c
    })

  \func monic+epi=iso{X Y : Ob} (m : Mono {\this} {X} {Y}) (m-is-epi : isEpi {\this} {X} {Y} m)
    : Iso {\this} {X} {Y} m =>
    \let equalizer => monic-is-regular m
         | true=char-m : true-over-obj = char m => m-is-epi (Equalizer.equal {equalizer} : true-over-obj ∘ m.f = char m ∘ m)
         | equalizer-f : Equalizer (char m) (char m) => transport (Equalizer __ (char m) X m) true=char-m equalizer
    \in
      Equalizer.equalizer-iso equalizer-f

  \func monic-is-regular  {X Y : Ob} (m : Mono {\this} {X} {Y}) : Equalizer true-over-obj (char m) X m =>
    \new Equalizer {
      | equal =>
        rewrite (pbCoh {char-pullback m}, o-assoc) $
        rewrite terminal-unique idp
      | isEqualizer _ => \new QEquiv {
        | ret (h, com) => pbMap {char-pullback m} h terminalMap
            (rewriteI com $ rewrite o-assoc $ rewrite terminal-unique idp)
        | ret_f _ => pbEta {char-pullback m} (rewrite (pbBeta1 {char-pullback m}) $ idp)
            (rewrite (pbBeta2 {char-pullback m}) terminal-unique)
        | f_sec (h, com) => exts $ rewrite (pbBeta1 {char-pullback m}) idp
      }
    }

  \func global (X : Ob) => Hom terminal X

  \func name {A : Ob} (phi : Hom A omega) : global (P A) => p-transpose (phi ∘ terminal-prod-left.hinv)

  -- Topos is cartesian closed

  \func v {B C : Ob} : Hom (Bprod B (P $ Bprod C B)) (P C) =>
    p-transpose $ belongs ∘ associator-iso.hinv

  \func u' {B C : Ob} : Hom (Bprod B (P $ Bprod C B)) omega => is-singleton ∘ v

  \func u {B C : Ob} : Hom (P $ Bprod C B) (P B) => p-transpose u'

  \func graphs {B C : Ob} : Pullback (name (true-over-obj {\this} {B})) (u {\this} {B} {C}) =>
    pullback (name (true-over-obj {\this} {B})) (u {\this} {B} {C})
    \where {
      \func apex (B C : Ob) : Ob => Pullback.apex {graphs {_} {B} {C} }

      \func m {B C : Ob} : Hom (graphs.apex B C) (P $ Bprod C B) => Pullback.pbProj2 {graphs {_} {B} {C}}
    }

  \lemma terminate {B C : Ob} {f : Hom B C} : terminalMap ∘ f = terminalMap => terminal-unique

  \func eval {B C : Ob} : Hom (Bprod (graphs.apex B C) B) C =>
    pbMap {char-pullback $ singleton-mono C} (v ∘ prodMap (id B) graphs.m ∘ change) terminalMap comm
    \where {
      \func comm  : char (singleton-mono C) ∘ (v ∘ prodMap (id B) graphs.m ∘ change) = true ∘ terminalMap =>
        run {
          rewriteI (o-assoc, o-assoc),
          rewrite (antitranspose-eq _ : char (singleton-mono C) ∘ v = belongs ∘ prodMap (id B) u),
          rewrite {2} o-assoc,
          rewriteI (prod-id-left, pbCoh {graphs}),
          rewrite prod-id-left,
          rewriteI (o-assoc, antitranspose-eq _),
          rewrite (o-assoc, o-assoc, o-assoc, terminate) idp
        }
    }

  \func s0 {A B C : Ob} (f : Hom (Bprod B A) C) : Hom (Bprod C (Bprod B A)) omega => eq C ∘ prodMap (id C) f

  \func p-s0-is-v {A B C : Ob} (f : Hom (Bprod B A) C) : p-transpose (s0 f) = v ∘ prodMap (id B) (p-transpose (s0 f ∘ associator)) =>
    run {
      unfold s0,
      inv,
      p-transpose-unique,
      rewrite {2} prod-id-left,
      rewriteI (o-assoc, antitranspose-eq _),
      rewrite (o-assoc, associtor-prod _ _ _, inv o-assoc, prod-id, inv $ antitranspose-eq _),
      Iso.adjoint' idp
    }

  \func p-s0-is-singleton {A B C : Ob} (f : Hom (Bprod B A) C) : p-transpose (s0 f) = singleton C ∘ f =>
    unfold s0 $ inv (p-transpose-unique (rewrite (prod-id-left _ _) $ rewrite (p-transpose-univ (eq C)) o-assoc))

  \func h {A B C : Ob} (f : Hom (Bprod B A) C) : Hom A (P $ Bprod C B) =>
    p-transpose (eq C ∘ prodMap (id C) f ∘ associator)

  \func transpose' {A B C : Ob} (f : Hom (Bprod A B) C) : Hom A (graphs {\this} {B} {C}) =>
    pbMap terminalMap (h f')
        (unfold (Pullback.f, Pullback.g) (rewriteI (step5, step3, step4, step1, step2, p-s0-is-singleton _, p-s0-is-v f') idp))
    \where {
      \func f' : Hom (Bprod B A) C => f ∘ change

      \func step1 : is-singleton ∘ (singleton C ∘ f') = true-over-obj ∘ f' =>
        rewriteI o-assoc $ rewrite (pbCoh {char-pullback (singleton-mono C)}) idp

      \func step2 : is-singleton {_} {C} ∘ (v ∘ prodMap (id B) (h f')) = u' ∘ prodMap (id B) (h f') =>
        rewriteI o-assoc $ rewrite (idp : is-singleton {_} {C} ∘ v = u') idp

      \func step3 : p-transpose (u' ∘ prodMap (id B) (h f')) = u ∘ (h f') =>
        inv (p-transpose-unique $ unfold $ rewrite prod-id-left $ rewriteI (o-assoc, antitranspose-eq _) idp)

      \func step4 : true-over-obj ∘ f' = true-over-obj {_} {B} ∘ proj1 {_} {B} {A} =>
        unfold true-over-obj $ rewrite (o-assoc, terminate, o-assoc, terminate) idp

      \func step5 : p-transpose (true-over-obj {_} {B} ∘ proj1 {_} {B} {A}) = name (true-over-obj {_} {B}) ∘ terminalMap =>
        run {
          inv,
          p-transpose-unique,
          rewrite (prod-id-left, inv o-assoc, inv $ antitranspose-eq _),
          unfold true-over-obj,
          rewrite (o-assoc, terminate, o-assoc, o-assoc, terminate) idp
        }
    }

  \func last {A B C : Ob} (f : Hom (Bprod A B) C) : singleton C ∘ (f ∘ change) = v ∘ prodMap (id B) (graphs.m {_} {B} {C} ∘ transpose' f) =>
    rewrite (pbBeta2 {graphs {_} {B} {C}}, inv (p-s0-is-singleton _)) (p-s0-is-v _)

  \func transpose-univ' {A B C : Ob} (f : Hom (Bprod A B) C) : f = eval {\this} {B} {C} ∘ prodMap (transpose' f) (id B) =>
    unfold $ pbEta {char-pullback (singleton-mono C)} (rewrite (inv o-assoc, pbBeta1 {char-pullback (singleton-mono C)}, o-assoc, change-prod, inv o-assoc) $ change-iso.adjoint' (rewrite {2} o-assoc $ rewriteI (prod-id-left _ _) $ rewrite o-assoc (last _)))
                 (unfold Pullback.pbProj2 $ terminal-unique)

  \func transpose-unique' {A B C : Ob} {f : Hom (Bprod A B) C} {g : Hom A (graphs.apex B C)}
                          (eq : f = eval ∘ prodMap g (id B)) : transpose' f = g =>
    pbEta {graphs {_} {B} {C}} terminal-unique (run {
      unfold,
      rewrite (pbBeta2 {graphs {_} {B} {C}}),
      unfold h ,
      inv, p-transpose-unique,
      rewrite step2 ,
      rewrite (o-assoc, associator-iso.hinv_f, id-right),
      idp
    })
    \where {
      -- reverse version of the equation "last"

      \func step1 : singleton C ∘ transpose'.f' = v ∘ (prodMap (id B) (graphs.m {_} {B} {C} ∘ g)) => run {
        rewrite (eq, inv o-assoc, inv o-assoc, pbBeta1 {char-pullback (singleton-mono C)}),
        rewrite {2} o-assoc ,
        rewrite (change-prod, o-assoc),
        rewrite {2} o-assoc,
        rewrite (change-inv, id-right, o-assoc, prod-id-left) idp
      }

      \func step2 : s0 (f ∘ change) = belongs {_} {Bprod C B} ∘ prodMap (id (Bprod C B)) (graphs.m ∘ g) ∘ associator-iso.hinv =>
        run {
          transpose-inj,
          rewrite (p-s0-is-singleton _, step1),
          p-transpose-unique,
          rewrite {2} (prod-id-left _ _),
          rewriteI o-assoc,
          rewrite (inv $ antitranspose-eq _ : belongs ∘ prodMap (id C) v = belongs ∘ associator-iso.hinv),
          rewrite {2} o-assoc ,
          rewrite (associtor-prod _ _ _, prod-id),
          equation
        }
    }

  \default exp (B : Ob) : hasExponential {\this} B => RightAdjoint-Univ.toAdjoint (\new RightAdjoint-Univ {
    | L => bprodFunctor B
    | R Y => graphs.apex B Y
    | eval => eval
    | transpose => transpose'
    | transpose-univ => transpose-univ'
    | transpose-unique => transpose-unique'
  } )
}

\open PrecatWithTerminal

\instance SetTopos : ToposPrecat SetBicat
  | FinCompletePrecat => SetBicat
  | subobj-classifier => \Prop
  | true => \lam _ => \Sigma
  | char => IsElement
  | char-pullback m => \new Pullback {
    | pbCoh => exts (\lam a => propExt (\lam _ => ()) (\lam _ => isContained _ idp))
    | pbMap {w} p1 _ eq =>
      \let s (x : w) : IsElement m (p1 x) = (\Sigma)
      => path (\lam i => (eq @ i) x)
      | pre (x : w) : IsElement m (p1 x) => propExt.conv (s x) ()
      \in
      \lam w1 => cases (pre w1) \with {
        | SetTopos.isContained a p => a
      }
    | pbBeta1 => {?}
    | pbBeta2 => {?}
    | pbEta => {?}
  }
  | char-unique => {?}
  | power A => A -> \Prop
  | belongs => {?}
  | p-transpose => {?}
  | p-transpose-univ => {?}
  | p-transpose-unique => {?}
  \where {
    \func name {A : SetBicat} (a : A) : Hom terminal.apex A => \lam _ => a

    \func fin1-is-terminal : Product {Empty} {SetBicat} (absurd {\Set})
    \cowith
      | apex => \Sigma
      | proj => \lam x => absurd x
      | tupleMap => \lam _ _  => ()
      | tupleBeta {_} {_} {j} => absurd j
      | tupleEq _ => exts (\lam _ => exts)

    \func fin1-terminal-iso : Iso {SetBicat} {\Sigma} {terminal.apex} => terminal-obj-unique fin1-is-terminal

    \func name-f {A B : SetBicat} {a : A} (f : A -> B) : name (f a) = f ∘ {SetBicat} name a => idp

    \func unname {A : SetBicat} (f : Hom {SetBicat} terminal.apex A) : A => (f ∘ {SetBicat} fin1-terminal-iso.f) ()

    \func name-inj {A : SetBicat} {a b : A} (p : name a = name b) : a = b => pmap unname p

    \func mono-is-inj {A B : SetBicat} (m : Mono {SetBicat} {A} {B}) : isInj m.f => \lam {_} {_} p =>
        name-inj $ m.isMono $ rewriteI (name-f m.f) $ rewriteI {2} (name-f m.f) $ rewrite p idp

    \data IsElement {A B : SetBicat} (m : Mono {SetBicat} {A} {B}) (b : B)
      | isContained (a : A) (m.f a = b)
      \where {
        \use \level isProp {A B : SetBicat} (m : Mono {SetBicat} {A} {B}) (b : B) (x y : IsElement m b) : x = y
        \elim x, y
          | isContained a p, isContained c p1 =>
            \let a=c : a = c => mono-is-inj m (p *> inv p1)
                 | p=p1 : transport {A} (\lam (x : A) => m.f x = b) a=c p = p1 => prop-isProp _ _
            \in \case\elim a,\elim c,\elim p, \elim p1, \elim a=c, \elim p=p1 \with {
              | a, c, _, _, idp, idp => idp
            }
      }
  }