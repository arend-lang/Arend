\import Algebra.Meta
\import Category
\import Category.CartesianClosed
\import Category.Coreflection
\import Category.Limit
\import Equiv
\import Function (isInj)
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set.Category
\open PrecatWithBprod

\class ToposPrecat \extends FinCompletePrecat, CartesianClosedPrecat {
  -- subobject classifier map

  | subobj-classifier \alias omega : Ob
  | true : Hom terminal omega

  -- characteristic maps

  | char {S B : Ob} (m : Mono {\this} {S} {B}) : Hom B omega
  | char-pullback {S B : Ob} (m : Mono {\this} {S} {B}) : Pullback {\this} (char m) true S m terminalMap
  | char-unique {S B : Ob} {m : Mono {\this} {S} {B}} {phi : Hom B omega}
                (phi-pull : Pullback phi true S m terminalMap) : phi = char m

  -- omega is exponentiable

  | p-exponential : isExponentiable omega

  \default p-exponential => CartesianClosedPrecat.is-exponentiable omega

  \func power \alias P (B : Ob) : Ob => p-exponential B

  \func belongs {B : Ob} : Hom (Bprod (P B) B) omega => eps {p-exponential B}

  \func p-transpose {A B : Ob} (f : Hom (Bprod A B) omega) : Hom A (P B) => ret {isCoreflection {p-exponential B}} f

  \func p-transpose-univ {A B : Ob} (f : Hom (Bprod A B) omega) : f = belongs ∘ (prodMap (p-transpose f) (id B)) =>
    inv $ Equiv.f_ret {isCoreflection {p-exponential B}} f

  \func p-transpose-unique {A B : Ob} {f : Hom (Bprod A B) omega} {g : Hom A (P B)} (comm : f = belongs ∘ prodMap g (id B))
    : g = p-transpose f => Equiv.adjoint {isCoreflection {p-exponential B}} (inv comm)

  \func sub-from-char {B : Ob} (ch : Hom B omega) : Pullback {\this} ch true => pullback ch true

  \func anti-transpose  {A B : Ob} (g : Hom A (P B)) : Hom (Bprod A B) omega =>
    belongs ∘ (prodMap g (id B))

  \func antitranspose-eq {A B : Ob} (f : Hom (Bprod B A) omega) : f = anti-transpose (p-transpose f) =>
    p-transpose-univ f

  \func transpose-inj {A B : Ob} {f g : Hom (Bprod A B) omega} (e : p-transpose f = p-transpose g)
    : f = g => p-transpose-univ f *> pmap (belongs ∘ prodMap __ (id B)) e *> (inv $ p-transpose-univ g)

  \func internal-equality \alias eq (B : Ob) : Hom (Bprod B B) omega =>
    char (diagonal.isSplitMono B)

  \func singleton  (B : Ob) : Hom B (P B) => p-transpose (eq B)

  \func singleton-mono (B : Ob) : Mono (singleton B)
  \cowith
    | isMono {X} {b} {b'} sb=sb' =>
      \let
        c : eq B ∘ prodMap b (id B) = eq B ∘ prodMap  b' (id B) => transpose-inj ((inv $ s-eq b) *> sb=sb' *> s-eq b')
        | b-square => full-square b
        | b'-square : Pullback {\this} (eq B ∘ prodMap b (id B)) true X (pair (id X) b') =>
          transport (Pullback {\this} __ true X (pair (id X) b')) (inv c) (full-square b')
        | h-iso : Iso {\this} {X} {X} => Pullback.unique (eq B ∘ prodMap b (id B)) true b-square b'-square
        | pb~pb*h : pair (id X) b = pair (id X) b' ∘ h-iso => inv (Pullback.unique.p-beta1 b'-square b-square)
        | c' : proj1 ∘ (pair (id X) b' ∘ h-iso.f) = h-iso.f => rewriteI o-assoc $ rewrite (beta1 _ _) id-left
        | h~1 : id X = h-iso.f => inv (beta1 _ _) *> pmap (proj1 ∘ __) pb~pb*h *> c'
        | b~b'h : b = b' ∘ h-iso.f => inv (beta2 _ _) *> pmap (proj2 ∘ __) pb~pb*h *> (rewriteI o-assoc $ rewrite (beta2 _ _) idp)
      \in
        b~b'h *> rewriteI h~1 id-right
    \where {
      \func s-eq {X : Ob} (b : Hom X B) : singleton B ∘ b = p-transpose (eq B ∘ (prodMap b (id B))) =>
        run {
          p-transpose-unique {\this} {_} {_} {eq B ∘ (prodMap b (id B))} {singleton B ∘ b},
          rewrite (prod-id-right _ _, inv o-assoc, inv $ p-transpose-univ _) idp
        }

      \func full-square {X : Ob} (b : Hom X B)
        : Pullback {\this} (eq B ∘ prodMap b (id B)) true X (pair (id X) b) => pullback-lemma right-square left-square

      \func right-square
        : Pullback {\this} {Bprod B B} {terminal} {omega} (eq B) true B (diagonal B) terminalMap =>
        char-pullback (diagonal.isSplitMono B)

      \func left-square{X : Ob} {b : Hom X B}
        : Pullback (prodMap b (id B)) (diagonal B) X (pair (id X) b) b
      \cowith
        | pbCoh => pair-unique
            (run {
              rewriteI o-assoc,
              rewrite (beta1 _ _, o-assoc, beta1 _ _, id-right),
              rewriteI o-assoc,
              rewrite (beta1 _ _, id-left),
              idp
            })
            (run {
              rewriteI o-assoc,
              rewrite (beta2 _ _),
              rewriteI o-assoc, rewrite (beta2 _ _, o-assoc, beta2 _ _) equation
            })
        | pbMap p1 _ _ => proj1 ∘ p1
        | pbBeta1 {w} {p1} {p2} {c} =>
          \let
            left : proj2 ∘ (diagonal B ∘ p2) = p2 => rewriteI o-assoc $ rewrite (beta2 _ _) equation
            | right : proj2 ∘ (prodMap b (id B) ∘ p1) = proj2 ∘ p1 => rewriteI o-assoc $ rewrite (beta2 _ _) equation \in
            pair-unique
                (run {
                  rewriteI o-assoc,
                  rewrite (beta1 _ _ ),
                  equation
                })
                (run {rewriteI o-assoc,
                      rewrite (beta2 _ _),
                      pbBeta2' w p1 p2 c *> inv left *> pmap (proj2 ∘ __) (inv c) *> right
                })
        | pbBeta2 {w} {p1} {p2} {c} => pbBeta2' w p1 p2 c
        | pbEta {_} {h1} {h2} c _ =>
          \let p2 : h1 = proj1 ∘ (pair (id X) b ∘ h1) => rewriteI o-assoc $ rewrite (beta1 _ _) equation
               | p1 : proj1 ∘ (pair (id X) b ∘ h2) = h2  => rewriteI o-assoc $ rewrite (beta1 _ _) equation
          \in p2 *> pmap (proj1 ∘ __) c *> p1

      \func pbBeta2' {B X : Ob} {b : Hom X B} (w : Ob) (p1 : Hom w (Bprod X B))
                     (p2 : Hom w B) (c : prodMap b (id B) ∘ p1 = diagonal B ∘ p2) : b ∘ (proj1 ∘ p1) = p2 =>
        \let left : proj1 ∘ (diagonal B ∘ p2) = p2 => rewriteI o-assoc $ rewrite (beta1 _ _) equation
             | right : proj1 ∘ (prodMap b (id B) ∘ p1) = b ∘ (proj1 ∘ p1) =>
               rewriteI o-assoc $ rewrite (beta1 _ _) o-assoc
        \in
          inv right *> pmap (proj1 ∘ __) c *> left
    }

  \func is-singleton {B : Ob} : Hom (P B) omega => char (singleton-mono B)

  \func true-over-obj {B : Ob} : Hom B omega => true ∘ terminalMap

  \func true-over-obj-is-char {B : Ob} : true-over-obj = char (idIso {\this} {B}) =>
    char-unique (\new Pullback {
      | pbCoh => rewrite id-right idp
      | pbMap p1 _ _ => p1
      | pbBeta1 => rewrite id-left idp
      | pbBeta2 => terminal-unique
      | pbEta c _ => rewriteI id-left $ rewriteI {4} id-left c
    })

  \func monic+epi=iso{X Y : Ob} (m : Mono {\this} {X} {Y}) (m-is-epi : isEpi {\this} {X} {Y} m)
    : Iso {\this} {X} {Y} m =>
    \let equalizer => monic-is-regular m
         | true=char-m : true-over-obj = char m => m-is-epi (Equalizer.equal {equalizer} : true-over-obj ∘ m.f = char m ∘ m)
         | equalizer-f : Equalizer (char m) (char m) => transport (Equalizer __ (char m) X m) true=char-m equalizer
    \in
      Equalizer.equalizer-iso equalizer-f

  \func monic-is-regular  {X Y : Ob} (m : Mono {\this} {X} {Y}) : Equalizer true-over-obj (char m) X m =>
    \new Equalizer {
      | equal =>
        rewrite (pbCoh {char-pullback m}, o-assoc) $
        rewrite terminal-unique idp
      | isEqualizer _ => \new QEquiv {
        | ret (h, com) => pbMap {char-pullback m} h terminalMap
            (rewriteI com $ rewrite o-assoc $ rewrite terminal-unique idp)
        | ret_f _ => pbEta {char-pullback m} (rewrite (pbBeta1 {char-pullback m}) $ idp)
            (rewrite (pbBeta2 {char-pullback m}) terminal-unique)
        | f_sec (h, com) => exts $ rewrite (pbBeta1 {char-pullback m}) idp
      }
    }

  \func global (X : Ob) => Hom terminal X

  \func name {A : Ob} (phi : Hom A omega) : global (P A) => p-transpose (phi ∘ terminal-prod-left.hinv)

  -- Topos is cartesian closed

  \func v {B C : Ob} : Hom (Bprod (P $ Bprod B C) B) (P C) =>
    p-transpose $ belongs {_} {Bprod B C} ∘ associator-iso.f

  \func u' {B C : Ob} : Hom (Bprod (P $ Bprod B C) B) omega => is-singleton ∘ v

  \func u {B C : Ob} : Hom (P $ Bprod B C) (P B) => p-transpose u'

  \func graphs {B C : Ob} : Pullback (name (true-over-obj {\this} {B})) (u {\this} {B} {C}) =>
    pullback (name (true-over-obj {\this} {B})) (u {\this} {B} {C})
    \where {
      \func apex (B C : Ob) : Ob => Pullback.apex {graphs {_} {B} {C} }

      \func m {B C : Ob} : Hom (graphs.apex B C) (P $ Bprod B C) => Pullback.pbProj2 {graphs {_} {B} {C}}
    }

  \lemma terminate {B C : Ob} {f : Hom B C} : terminalMap ∘ f = terminalMap => terminal-unique

  \func eval {B C : Ob} : Hom (Bprod (graphs.apex B C) B) C =>
    pbMap {char-pullback $ singleton-mono C} (v ∘ prodMap graphs.m (id B)) terminalMap comm
    \where {
      \func comm  : char (singleton-mono C) ∘ (v ∘ prodMap graphs.m (id B)) = true ∘ terminalMap =>
        run {
          rewriteI o-assoc ,
          rewrite (antitranspose-eq _ : char (singleton-mono C) ∘ v = belongs ∘ prodMap u (id B)),
          rewrite o-assoc,
          rewriteI (prod-id-right, pbCoh {graphs}),
          rewrite prod-id-right,
          rewriteI (o-assoc, antitranspose-eq _),
          rewrite (o-assoc, o-assoc, terminate) idp
        }
    }

  \func s0 {A B C : Ob} (f : Hom (Bprod A B) C) : Hom (Bprod (Bprod A B) C) omega => eq C ∘ prodMap f (id C)

  \func p-s0-is-v {A B C : Ob} (f : Hom (Bprod A B) C) : p-transpose (s0 f) = v ∘ prodMap (p-transpose (s0 f ∘ associator-iso.hinv)) (id B) =>
    run {
      unfold s0,
      inv,
      p-transpose-unique {\this} {_} {_} {s0 f} {_},
      rewrite prod-id-right,
      rewriteI (o-assoc, antitranspose-eq {\this} _),
      rewrite o-assoc,
      rewrite (inv $ associtor-prod _ _ _,  inv o-assoc, prod-id, inv $ antitranspose-eq _),
      rewrite (o-assoc, Iso.hinv_f {associator-iso}, id-right) idp
    }

  \func p-s0-is-singleton {A B C : Ob} (f : Hom (Bprod B A) C) : p-transpose (s0 f) = singleton C ∘ f =>
    run {
      unfold s0,
      inv,
      p-transpose-unique {\this} {_} {_} {eq C ∘ prodMap f (id C)} {_},
      rewrite (prod-id-right _ _),
      rewrite (p-transpose-univ (eq C)),
      o-assoc
    }

  \func h {A B C : Ob} (f : Hom (Bprod A B) C) : Hom A (P $ Bprod B C) =>
    p-transpose (eq C ∘ prodMap f (id C) ∘ associator-iso.hinv)

  \func transpose' {A B C : Ob} (f : Hom (Bprod A B) C) : Hom A (graphs {\this} {B} {C}) =>
    pbMap terminalMap (h f)
        (unfold (Pullback.f, Pullback.g) (rewriteI (step5, step3, step4, step1, step2, p-s0-is-singleton _, p-s0-is-v f) idp))
    \where {
      \func step1 : is-singleton ∘ (singleton C ∘ f) = true-over-obj ∘ f =>
        rewriteI o-assoc $ rewrite (pbCoh {char-pullback (singleton-mono C)}) idp

      \func step2 : is-singleton {_} {C} ∘ (v ∘ prodMap (h f) (id B) ) = u' ∘ prodMap (h f) (id B) =>
        rewriteI o-assoc $ rewrite (idp : is-singleton {_} {C} ∘ v = u') idp

      \func step3 : p-transpose (u' ∘ prodMap (h f) (id B)) = u ∘ (h f) =>
        inv (p-transpose-unique $ unfold $ rewrite prod-id-right $ rewriteI (o-assoc, antitranspose-eq _) idp)

      \func step4 : true-over-obj ∘ f = true-over-obj {_} {B} ∘ proj2 {_} {A} {B} =>
        unfold true-over-obj $ rewrite (o-assoc, terminate, o-assoc, terminate) idp

      \func step5 : p-transpose (true-over-obj {_} {B} ∘ proj2 {_} {A} {B}) = name (true-over-obj {_} {B}) ∘ terminalMap =>
        run {
          inv,
          p-transpose-unique {\this} {_} {_} {true-over-obj {_} {B} ∘ proj2 {_} {A} {B}} {name (true-over-obj {_} {B}) ∘ terminalMap},
          rewrite (prod-id-right, inv o-assoc, inv $ antitranspose-eq _),
          rewrite (o-assoc, terminate, o-assoc, o-assoc, terminate),
          idp
        }
    }

  \func last {A B C : Ob} (f : Hom (Bprod A B) C) : singleton C ∘ f = v ∘ prodMap (graphs.m {_} {B} {C} ∘ transpose' f) (id B) =>
    rewrite (pbBeta2 {graphs {_} {B} {C}}, inv (p-s0-is-singleton _)) (p-s0-is-v _)

  \func transpose-univ' {A B C : Ob} (f : Hom (Bprod A B) C) : f = eval {\this} {B} {C} ∘ prodMap (transpose' f) (id B) =>
    unfold $ pbEta {char-pullback (singleton-mono C)} (rewrite (inv o-assoc, pbBeta1 {char-pullback (singleton-mono C)}) $ unfold $ rewrite (o-assoc, inv $ prod-id-right _ _) (last _))
                 (unfold Pullback.pbProj2 $ terminal-unique)

  \func transpose-unique' {A B C : Ob} {f : Hom (Bprod A B) C} {g : Hom A (graphs.apex B C)}
                          (s : f = eval ∘ prodMap g (id B)) : transpose' f = g =>
    pbEta {graphs {_} {B} {C}} terminal-unique (run {
      unfold,
      rewrite (pbBeta2 {graphs {_} {B} {C}}),
      unfold h ,
      inv,
      p-transpose-unique {\this} {_} {_} {eq C ∘ prodMap f (id C) ∘ hinv {associator-iso}} {pbProj2 ∘ g},
      rewrite step2 ,
      rewrite (o-assoc, associator-iso.f_hinv, id-right),
      idp
    })
    \where {
      \func step1 : singleton C ∘ f = v ∘ (prodMap (graphs.m {_} {B} {C} ∘ g) (id B)) =>
        rewrite (s, inv o-assoc, pbBeta1 {char-pullback (singleton-mono C)}, o-assoc, inv $ prod-id-right _ _) idp

      \func step2 : s0 f = belongs {_} {Bprod B C} ∘ prodMap (graphs.m ∘ g) (id (Bprod B C)) ∘ associator =>
        run {
          transpose-inj,
          rewrite (p-s0-is-singleton _, step1),
          p-transpose-unique {\this} {_} {_} {belongs ∘ prodMap (graphs.m ∘ g) (id (Bprod B C)) ∘ associator} {v ∘ prodMap (graphs.m ∘ g) (id B)},
          rewrite {2} (prod-id-right _ _),
          rewriteI o-assoc,
          rewrite (inv $ antitranspose-eq _ : belongs ∘ prodMap v (id C) = belongs ∘ associator-iso.f),
          rewrite {2} o-assoc ,
          rewrite (inv $ associtor-prod _ _ _, prod-id),
          o-assoc
        }
    }

  \func exp-adjoint (B : Ob) : RightAdjointCoreflection \this \this (bprodFunctorRight B)
    \cowith
      | coreflection => exp B
    \where {
      \func exp (B : Ob) (C : Ob) : Coreflection (bprodFunctorRight B) C \cowith
        | R => graphs.apex B C
        | eps => eval
        | isCoreflection => \new QEquiv {
          | ret => transpose'
          | ret_f _ => transpose-unique' idp
          | f_sec g => inv $ transpose-univ' g
        }
    }

  \default exp (B : Ob) : isExponential {\this} B => RightAdjointCoreflection.toAdjointCounit (exp-adjoint B)
}

\lemma sigma-prop-ext {A : \Prop} (a : A) : A = (\Sigma ) => exts (\lam _ => (), \lam _ => a)

\lemma sigma-prop-ext-inv {A : \Prop} (eq : A = (\Sigma)) : A => propExt.conv eq ()

\open PrecatWithTerminal
\open SetCartesianClosed

\instance SetTopos : ToposPrecat SetBicat
  | FinCompletePrecat => SetBicat
  | CartesianClosedPrecat => SetCartesianClosed
  | subobj-classifier => \Prop
  | true => \lam _ => \Sigma
  | char => IsElement
  | char-pullback m => \new Pullback {
    | pbCoh => exts (\lam _ => sigma-prop-ext (SetTopos.isContained _ idp))
    | pbMap {_} p1 _ eq =>
      \lam w1 => cases (isElement-char {_} {_} {_} {_} {p1} {eq} w1) \with {
        | SetTopos.isContained a p => a
      }
    | pbBeta1 {_} {p1} {_} {eq} => ext (\lam w1 => cases (isElement-char {_} {_} {_} {_} {p1} {eq} w1) \with {
      | SetTopos.isContained a p => p
    })
    | pbBeta2 => terminal-unique {SetBicat}
    | pbEta {_} {h1} {h2} eq _ => ext (\lam x => \let s : Mono.f {m} (h1 x) = Mono.f {m} (h2 x) => path (\lam i => (eq @ i) x) \in mono-is-inj m s)
  }
  | char-unique {S} {_} {m} {phi} pullback =>
    ext (\lam b =>
        ext (\lam p =>
                 \let preimage : terminal.apex -> S => pbMap {pullback} (name' b) (terminalMap {SetBicat}) (unfold (unfold name' $ exts (\lam _ => sigma-prop-ext p))) \in
                   SetTopos.isContained (unname' preimage)
                       (\let b-image : Mono.f {m} ∘ {SetBicat} preimage = name' b => pbBeta1 {pullback} \in name-inj
                           (rewriteI (name-f (Mono.f {m})) $ rewrite (global-elements-iso.f_ret preimage) b-image)),
             \let ss : phi ∘ {SetBicat} (Mono.f {m}) = terminalMap ∘ {SetBicat} true => pbCoh {pullback}
                  | ss-impl (x : S) : phi (Mono.f {m} x) = (\Sigma) => path (\lam i => (ss @ i) x) \in
               \lam c => cases c \with {
                 | SetTopos.isContained a p => rewriteI p $ sigma-prop-ext-inv (ss-impl a)
               }
        ))
  \where {
    \func mono-is-inj {A B : SetBicat} (m : Mono {SetBicat} {A} {B}) : isInj m.f => \lam {a} {b} p =>
        run {
          name-inj,
          m.isMono,
          rewrite (name-f m.f a, name-f m.f b),
          pmap name' p
        }

    \data IsElement {A B : SetBicat} (m : Mono {SetBicat} {A} {B}) (b : B)
      | isContained (a : A) (m.f a = b)
      \where {
        \use \level isProp {A B : SetBicat} (m : Mono {SetBicat} {A} {B}) (b : B) (x y : IsElement m b) : x = y
        \elim x, y
          | isContained a p, isContained c p1 =>
            \let a=c : a = c => mono-is-inj m (p *> inv p1)
                 | p=p1 : transport {A} (\lam (x : A) => m.f x = b) a=c p = p1 => prop-isProp _ _
            \in \case\elim a, \elim c, \elim p, \elim p1, \elim a=c, \elim p=p1 \with {
              | a, c, _, _, idp, idp => idp
            }
      }

    \func isElement-char {S B : SetBicat} {m : Mono {SetBicat} {S} {B}} {w : SetBicat} {p1 : w -> B}
                         {eq : (\lam x => IsElement m (p1 x)) = (\lam _ => \Sigma)} (x : w) : IsElement m (p1 x) =>
      \let s : IsElement m (p1 x) = (\Sigma) => path (\lam i => (eq @ i) x) \in
        sigma-prop-ext-inv s
  }