\import Category
\import Category.Adjoint
\import Category.Functor
\import Category.Limit
\import Equiv
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta

\class RightAdjointCounit \extends Functor {
  | LAdj : Functor D C
  | epsilon : NatTrans (Comp LAdj \this) Id
  \field isAdjoint-inv {X : D} {Y : C} : Equiv {Hom X (F Y)} {Hom (LAdj X) Y} (epsilon Y ∘ LAdj.Func __)

  \func eta : NatTrans Id (Comp \this LAdj) \cowith
    | trans X => isAdjoint-inv.ret (id (LAdj X))
    | natural {_} {_} _ => isAdjoint-inv.isInj $ unfold $ rewrite (Func-o {LAdj}, Func-o {LAdj}) $
                                                          rewriteI (o-assoc, o-assoc) $
                                                          rewrite (isAdjoint-inv.f_ret, id-left, epsilon.natural) $
                                                          rewrite (o-assoc, isAdjoint-inv.f_ret, id-right) idp

  \func adjoint-eta  {X : D} {Y : C} (g : Hom (LAdj X) Y) : isAdjoint-inv.ret g = Func g ∘ eta X =>
    isAdjoint-inv.isInj $ unfold $ rewrite (isAdjoint-inv.f_ret _, Func-o {LAdj}) $
                                   rewriteI o-assoc $ rewrite (epsilon.natural, o-assoc, isAdjoint-inv.f_ret _, id-right) idp
} \where {
  \use \coerce fromAdjoint (F : RightAdjoint) : RightAdjointCounit \cowith
    | Functor => F
    | LAdj => F.LAdj
    | epsilon => F.epsilon
    | isAdjoint-inv => \new Equiv {
      | ret => F.isAdjoint
      | ret_f => F.eta_eps_equiv.f_sec
      | sec => F.isAdjoint
      | f_sec => F.eta_eps_equiv.ret_f
    }

  \use \coerce toAdjoint (F : RightAdjointCounit) : RightAdjoint => \new RightAdjoint {
    | Functor => F
    | LAdj => LAdj
    | eta => eta
    | isAdjoint => \new QEquiv {
      | ret => isAdjoint-inv
      | ret_f _ => unfold $ rewriteI (adjoint-eta _ ) $ isAdjoint-inv.f_ret _
      | f_sec _ => isAdjoint-inv.isInj $ unfold $ run {
        rewrite (Func-o {LAdj}),
        rewriteI o-assoc,
        rewrite (epsilon.natural, o-assoc, isAdjoint-inv.f_ret _, id-right) idp
      }
    }
  }
}

\class Coreflection {C D : Precat} (L : Functor D C) (B : C) {
  | \classifying R : D
  | eps : Hom (L R) B
  \field isCoreflection {Z : D} : Equiv {Hom Z R} {Hom (L Z) B} (\lam x => eps ∘ (L.Func x))
}
  \where {
    -- todo : prove uniqueness and implement \use\level for categories
  }

\class RightAdjointCoreflection  \extends Functor {
  | L : Functor D C
  \field coreflection (Z : C) : Coreflection {C} {D} L Z
  | F X => coreflection X
  | Func {X} {_} f => Equiv.ret {isCoreflection} (f ∘ eps {coreflection X})
  | Func-id {_} => unfold $ rewrite id-left $ inv $ Equiv.adjoint $ unfold $ rewrite (Func-id {L}, id-right) idp
  | Func-o {_} {Y} {Z} {_} {_} => run {
    unfold,
    inv,
    Equiv.adjoint,
    unfold,
    rewrite (Func-o {L}),
    rewriteI o-assoc ,
    rewrite (Equiv.f_ret {isCoreflection {coreflection Z}}),
    rewrite o-assoc ,
    rewrite (Equiv.f_ret {isCoreflection {coreflection Y}}),
    inv o-assoc
  }

  \func eval-trans : NatTrans (Comp L \this) Id \cowith {
    | trans c => eps {coreflection c}
    | natural _ => unfold $ Equiv.f_ret {isCoreflection} _
  }

  \func is-adjoint-counit {X : D} {Y : C} : Equiv {Hom X (F Y)} {Hom (L X) Y} (eval-trans Y ∘ L.Func __) =>
    isCoreflection
}
  \where {
    \use \coerce toAdjoint(F : RightAdjointCoreflection) : RightAdjointCounit
    \cowith {
      | Functor => F
      | LAdj => F.L
      | epsilon => eval-trans
      | isAdjoint-inv => is-adjoint-counit
    }

    \use \coerce fromAdjoint (F : RightAdjointCounit) : RightAdjointCoreflection \cowith {
      | C => F.C
      | D => F.D
      | L => F.LAdj
      | coreflection => \lam Z => \new Coreflection {
        | R => F Z
        | eps => F.epsilon Z
        | isCoreflection => F.isAdjoint-inv
      }}
  }


\func isExponential {C : CartesianPrecat} (X : C) => RightAdjoint C C { | LAdj => C.bprodFunctor X }

\func isExponentiable {C : CartesianPrecat} (Y : C) => \Pi (X : C) -> Coreflection (C.bprodFunctor X) Y

\class CartesianClosedPrecat \extends CartesianPrecat {
  | exp (X : Ob) : isExponential X

  \func eval {X Y : Ob} : Hom (Bprod (exp X Y) X) Y =>
    epsilon {exp X} Y

  \func transpose {X Y Z : Ob} (f : Hom (Bprod Y X) Z) : Hom Y (exp X Z) => isAdjoint f

  \func antitranspose {X Y Z : Ob} (g : Hom Y (exp X Z)) : Hom (Bprod Y X) Z => isAdjoint.ret g

  \lemma adjoint-epsilon {X Y Z : Ob} (g : Hom Y (exp X Z))
      : antitranspose g = eval ∘ prodMap g (id X) => RightAdjoint.adjoint_epsilon {exp X} g

  \func antitranspose-unique {X Y Z : Ob} {g : Hom Y (exp X Z)} {f : Hom (Bprod Y X) Z}
                               (comm : f = eval ∘ prodMap g (id X)) : antitranspose g = f => adjoint-epsilon g *> inv comm

  \func antitranspose-inj {X Y Z : Ob} {g g' : Hom Y (exp X Z)} (p : antitranspose g = antitranspose g')
      : g = g' =>
      Equiv.isInj {RightAdjointCounit.isAdjoint-inv {exp X}} $ unfold $ rewriteI (adjoint-epsilon _, adjoint-epsilon _) p
}



