\import Category
\import Category.Adjoint
\import Category.Functor
\import Category.Limit
\import Equiv
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta

\class RightAdjoint-Counit \extends Functor {
  | LAdj : Functor D C
  | epsilon : NatTrans (Comp LAdj \this) Id
  \field isAdjoint-inv {X : D} {Y : C} : Equiv {Hom X (F Y)} {Hom (LAdj X) Y} (epsilon Y ∘ LAdj.Func __)

  \func eta : NatTrans Id (Comp \this LAdj) \cowith
    | trans X => isAdjoint-inv.ret (id (LAdj X))
    | natural {_} {_} _ => isAdjoint-inv.isInj $ unfold $ rewrite (Func-o {LAdj}, Func-o {LAdj}) $
                                                          rewriteI (o-assoc, o-assoc) $
                                                          rewrite (isAdjoint-inv.f_ret, id-left, epsilon.natural) $
                                                          rewrite (o-assoc, isAdjoint-inv.f_ret, id-right) idp

  \func adjoint-eta  {X : D} {Y : C} (g : Hom (LAdj X) Y) : isAdjoint-inv.ret g = Func g ∘ eta X =>
    isAdjoint-inv.isInj $ unfold $ rewrite (isAdjoint-inv.f_ret _, Func-o {LAdj}) $
                                   rewriteI o-assoc $ rewrite (epsilon.natural, o-assoc, isAdjoint-inv.f_ret _, id-right) idp
} \where {
  \use \coerce fromAdjoint (F : RightAdjoint) : RightAdjoint-Counit \cowith
    | Functor => F
    | LAdj => F.LAdj
    | epsilon => F.epsilon
    | isAdjoint-inv => \new Equiv {
      | ret => F.isAdjoint
      | ret_f => F.eta_eps_equiv.f_sec
      | sec => F.isAdjoint
      | f_sec => F.eta_eps_equiv.ret_f
    }

  \use \coerce toAdjoint (F : RightAdjoint-Counit) : RightAdjoint => \new RightAdjoint {
    | Functor => F
    | LAdj => LAdj
    | eta => eta
    | isAdjoint => \new QEquiv {
      | ret => isAdjoint-inv
      | ret_f _ => unfold $ rewriteI (adjoint-eta _ ) $ isAdjoint-inv.f_ret _
      | f_sec _ => isAdjoint-inv.isInj $ unfold $ run {
        rewrite (Func-o {LAdj}),
        rewriteI o-assoc,
        rewrite (epsilon.natural, o-assoc, isAdjoint-inv.f_ret _, id-right) idp
      }
    }
  }
}

{-
  Definition of an adjoint functor with the universal properties of the counit with the coreflection.
  This should be used primarily for ease of definition and not a replacement for the base class
-}

\class RightAdjoint-Univ  {C D : Precat} (L : Functor D C) {
  | R (Y : C) : D
  | eval {Y : C} : Hom (L (R Y)) Y
  | transpose {Y : D} {Z : C} (f : Hom (L Y) Z) : Hom Y (R Z)
  | transpose-univ {Y : D} {Z : C} (f : Hom (L Y) Z) : f = eval ∘ (L.Func (transpose f))
  | transpose-unique {Y : D} {Z : C} {f : Hom (L Y) Z} {g : Hom Y (R Z)} (comm : f = eval ∘ (L.Func g))
  : transpose f = g

  \func functor-R : Functor C D {
    | F => R
  } \cowith
    | Func {_} {_} f => transpose (f ∘ eval)
    | Func-id => transpose-unique $ rewrite id-left $ rewrite (Func-id {L}, id-right) idp
    | Func-o => transpose-unique $ rewrite (Func-o {L}, inv o-assoc, inv $ transpose-univ _)
                                     $ rewrite {2} o-assoc $ rewriteI (transpose-univ _) o-assoc

  \func eval-trans : NatTrans (Comp L functor-R) Id \cowith {
    | trans _ => eval
    | natural _ => unfold $ unfold $ rewriteI transpose-univ idp
  }

  \func is-adjoint-counit {X : D} {Y : C} : Equiv {Hom X (R Y)} {Hom (L X) Y} (eval-trans Y ∘ L.Func __) =>
    \new QEquiv {
      | ret => transpose
      | ret_f _ => transpose-unique $ idp
      | f_sec _ => inv $ transpose-univ _
    }
} \where {
  \use \coerce toAdjoint{C D : Precat} (F : RightAdjoint-Univ {C} {D}) : RightAdjoint-Counit
  \cowith {
    | Functor => functor-R
    | LAdj => F.L
    | epsilon => eval-trans
    | isAdjoint-inv => is-adjoint-counit
  }

  \use \coerce fromAdjoint (F : RightAdjoint-Counit) : RightAdjoint-Univ {F.C} {F.D} {
    | L => F.LAdj
  } \cowith {
    | R => F
    | eval {X} => F.epsilon X
    | transpose f => F.isAdjoint-inv.ret f
    | transpose-univ f => inv $ F.isAdjoint-inv.f_ret f
    | transpose-unique eq => rewrite eq $ F.isAdjoint-inv.ret_f _
  }
}

\func hasExponential {C : CartesianPrecat} (X : C)  => RightAdjoint C C { | LAdj => C.bprod-functor X}

\class CartesianClosedPrecat \extends CartesianPrecat {
  | exp (X : Ob) : hasExponential X

  \func eval {X Y : Ob} : Hom (Bprod (exp X Y) X) Y =>
    epsilon {exp X} Y

  \func transpose {X Y Z : Ob} (f : Hom (Bprod Y X) Z) : Hom Y (exp X Z)
    => isAdjoint f

  \func antitranspose {X Y Z : Ob} (g : Hom Y (exp X Z)) : Hom (Bprod Y X) Z
    => isAdjoint.ret g

  \func transpose-univ {X Y Z : Ob} (f : Hom (Bprod Y X) Z)
    : f = eval ∘ (prodMap (transpose f) (id X))
    => RightAdjoint-Univ.transpose-univ {exp X} f

  \func transpose-unique{X Y Z : Ob} {f : Hom (Bprod Y X) Z} {g : Hom Y (exp X Z)}
                        (comm : f = eval ∘ (prodMap g (id X))) : transpose f = g
    => RightAdjoint-Univ.transpose-unique {exp X} comm

  \lemma adjoint-epsilon {X Y Z : Ob} (g : Hom Y (exp X Z))
    : antitranspose g = eval ∘ prodMap g (id X)
    => RightAdjoint.adjoint_epsilon {exp X} g

  \func antitranspose-unique {X Y Z : Ob} {g : Hom Y (exp X Z)} {f : Hom (Bprod Y X) Z}
                             (comm : f = eval ∘ prodMap g (id X)) : antitranspose g = f
    => adjoint-epsilon g *> inv comm

  \func antitranspose-inj {X Y Z : Ob} {g g' : Hom Y (exp X Z)} (p : antitranspose g = antitranspose g')
    : g = g'
    => Equiv.isInj {RightAdjoint-Counit.isAdjoint-inv {exp X}} $ unfold $ rewriteI (adjoint-epsilon _, adjoint-epsilon _) p

--  \func one-power {X : Ob} : Iso {\this} {exp terminal X} {X} \cowith
--    | f => eval ∘ terminal-prod-left.f
--    | hinv => transpose proj1
--    | hinv_f => {?}
--    | f_hinv => {?}
}

