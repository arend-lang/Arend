\import Category
\import Category.Adjoint
\import Category.Functor
\import Category.Limit
\import Equiv
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\open CartesianPrecat

{-
Definition of a adjoint pair of functors with the counit of the adjunction.
This should be refactored in the future
 -}

\class RightAdjoint' \extends Functor {
  | LAdj : Functor D C
  | epsilon : NatTrans (Comp LAdj \this) Id
  \field isAdjoint {X : D} {Y : C} : Equiv {Hom X (F Y)} {Hom (LAdj X) Y} (epsilon Y ∘ LAdj.Func __)

  \func eta : NatTrans Id (Comp \this LAdj) \cowith
    | trans X => isAdjoint.ret (id (LAdj X))
    | natural {X} {Y} f => isAdjoint.isInj $ unfold $ rewrite (Func-o {LAdj}, Func-o {LAdj}) $
                                                      rewriteI (o-assoc, o-assoc) $
                                                      rewrite (isAdjoint.f_ret, id-left, epsilon.natural) $
                                                      rewrite (o-assoc, isAdjoint.f_ret, id-right) idp

  \func adjoint-eta {X : D} {Y : C} (g : Hom (LAdj X) Y) : isAdjoint.ret g = Func g ∘ eta X =>
    isAdjoint.isInj $ unfold $ rewrite (isAdjoint.f_ret _, Func-o {LAdj}) $
                               rewriteI o-assoc $ rewrite (epsilon.natural, o-assoc, isAdjoint.f_ret _, id-right) idp

  \func right-adjoint : RightAdjoint C D {
    | LAdj => LAdj
  } \cowith
    | Functor => \this
    | eta => eta
    | isAdjoint => \new Equiv {
      | ret => isAdjoint
      | ret_f g => unfold $ rewriteI (adjoint-eta _) (isAdjoint.f_ret g)
      | sec => isAdjoint
      | f_sec g => isAdjoint.isInj $ unfold $ rewrite (Func-o {LAdj}) $ rewriteI o-assoc $ rewrite (epsilon.natural, o-assoc, isAdjoint.f_ret _, id-right) idp
    }
}

\class Exponent {C : CartesianPrecat} (X : C) (\coerce exponent : Functor C C)
{
  | exponent-adj : RightAdjoint C C { | LAdj => bprod-functor X }
  -- counit

  | eval (Z : C) : Hom (Bprod (exponent Z) X) Z
  -- isAdj

  | transpose {Y Z : C} (f : Hom (Bprod Y X) Z) : Hom Y (exponent Z)
  -- f = antitranspose (transpose f)

  | transpose-univ {Y Z : C} (f : Hom (Bprod Y X) Z) : f = eval Z ∘ prodMap (transpose f) (id X)
  -- f = antitranspose (g) => g = transpose f

  | transpose-unique {Y Z : C} {f : Hom (Bprod Y X) Z} (g : Hom Y (exponent Z)) (eq : f = eval Z ∘ prodMap g (id X))
  : g = transpose f

  | antitranspose {Y Z : C} (g : Hom Y (exponent Z)) : Hom (Bprod Y X) Z
  \default antitranspose {Y Z : C} => eval Z ∘ prodMap __ (id X)

  \default exponent-adj => \new RightAdjoint {
    | Functor => exponent
    | eta => \new NatTrans {
      | trans X => {?}
      | natural => {?}
    }
    | isAdjoint => {?}
  }

  --  \default transpose => isAdjoint
  --  \func antitranspose {Y Z : C} (g : Hom Y (exponent Z)) : Hom (Bprod Y X) Z
  --    => exponent.isAdjoint.ret g
  --  \default eval (Z : C) => RightAdjoint.epsilon {exponent} Z

  \default transpose-univ {Y Z : C} (f : Hom (Bprod Y X) Z) => inv $ {?}
}

\class CartesianClosedPrecat \extends CartesianPrecat {
  | power (Y : Ob) : RightAdjoint \this \this { | LAdj => bprod-functor Y }
}