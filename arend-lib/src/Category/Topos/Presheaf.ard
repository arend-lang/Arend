\import Category
\import Category.Functor
\import Category.Limit
\import Category.Subcat
\import Category.Subobj
\import Category.Topos.Sheaf
\import Equiv (Embedding, Retraction)
\import Function.Meta
\import Meta
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set.Category
\import Topology.Locale

\instance FunctorPrecat {C : SmallPrecat} {D : Precat} : Precat (Functor C D)
  | Hom => NatTrans
  | id F => \new NatTrans {
    | trans X => id (F X)
    | natural f => id-left *> inv id-right
  }
  | o b a => \new NatTrans {
    | trans X => b X ∘ a X
    | natural f => run {
      rewrite (o-assoc, natural {a} f),
      rewriteI o-assoc,
      rewrite (natural {b} f),
      o-assoc
    }
  }
  | id-left => exts (\lam X => id-left)
  | id-right => exts (\lam X => id-right)
  | o-assoc => exts (\lam X => o-assoc)

\instance FunctorPrecat' {C : SmallPrecat} {D : Precat} : Precat \levels (obj,hom) _ (Functor C D)
  | Hom => NatTrans -- \levels (hom,hom,hom,obj) _
  | id F => \new NatTrans {
    | trans X => id (F X)
    | natural f => id-left *> inv id-right
  }
  | o b a => \new NatTrans {
    | trans X => b X ∘ a X
    | natural f => run {
      rewrite (o-assoc, natural {a} f),
      rewriteI o-assoc,
      rewrite (natural {b} f),
      o-assoc
    }
  }
  | id-left => exts (\lam X => id-left)
  | id-right => exts (\lam X => id-right)
  | o-assoc => exts (\lam X => o-assoc)

\instance FunctorCat {C : Precat} {D : Cat} : Cat (Functor C D)
  | Precat => FunctorPrecat
  | univalence => Cat.makeUnivalence $ later $ \lam e =>
                                                   (exts (\lam X => D.isotoid (mapIso e X), \lam {X} {Y} h => Cat.transport_Hom_iso (mapIso e X) (mapIso e Y) (natural h)),
                                                    simp_coe $ simp_coe $ \lam X => Cat.transport_iso (mapIso e X))
  \where {
    \func mapIso {C D : SmallPrecat} (e : Iso {FunctorPrecat {C} {D}}) (X : C) : Iso {D} \cowith
      | dom => e.dom X
      | cod => e.cod X
      | f => e.f X
      | hinv => e.hinv X
      | hinv_f => path (\lam i => trans {e.hinv_f @ i} X)
      | f_hinv => path (\lam i => trans {e.f_hinv @ i} X)
  }

\instance VPresheafCat (D : Cat) (C : SmallPrecat) : Cat
=> subCat {FunctorCat {C.op} {D}} {VPresheaf D C} (\new Embedding {
  | f P => P
  | isEmb _ _ => \new Retraction {
    | sec p => ext p
    | f_sec => idpe
  }
})

\instance PresheafCat (C : SmallPrecat) : Cat
=> VPresheafCat SetCat C

\func functor-curry {C : SmallPrecat} {D : Cat (\suc \lp)} (J : SmallPrecat)
                    (G : Functor J (FunctorCat {C} {D})) (c : C) : Functor J D => \new Functor {
  | F j => (G j) c
  | Func f => (G.Func f) c
  | Func-id {X} => rewrite (G.Func-id {X}) idp
  | Func-o => rewrite G.Func-o idp
}

\func has-limits  {J : SmallPrecat} (C : Cat (\suc \lp)) => \Pi (G : Functor J C) -> Limit G

\func limit {C : SmallPrecat} {D : Cat (\suc \lp)} (J : SmallPrecat) (j-limit-in-D : has-limits {J} D)
            (A : Functor J (FunctorCat {C} {D})) : Functor C D =>
  \let L (c : C) => j-limit-in-D (functor-curry J A c)
       | cone {X Y : C} (f : Hom X Y) : Cone (functor-curry J A Y)  => \new Cone {
         | apex => Cone.apex {L X}
         | coneMap j => Func f ∘ coneMap {L X} j
         | coneCoh {i} {j} h => rewriteI (coneCoh {L X} h, o-assoc, o-assoc)
             (pmap (__ ∘ coneMap i) (natural f))
       } \in
    \new Functor {
      | F c => L c
      | Func {X} {Y} f => limMap (cone f)
      | Func-id {X} => limUnique (\lam j =>
          rewrite id-right (limBeta {L X} {Cone.apex {L X}} (cone (id X)) j) *>
          rewrite (id-right, id-right) (unfold (rewrite (Func-id {A j}, id-left) idp))
      )
      | Func-o {X} {Y} {Z} {f} {g} =>
        limUnique (\lam j => rewrite (limBeta {L Z} (cone (f ∘ g)) j, inv o-assoc,
                                      limBeta {L Z} (cone f) j) (unfold coneMap
            (rewrite (Func-o {A j}, o-assoc, o-assoc) (rewrite (limBeta {L Y} (cone g) j) (unfold coneMap idp)))))
    }

\func alias' {C : SmallPrecat} (F : PresheafCat C) : FunctorCat {C.op} {SetCat}
  => \new Functor {
    | F X => F X
    | Func f => Func {F} f
    | Func-id => Func-id
    | Func-o => Func-o
  }

\func alias {C : SmallPrecat} {J : SmallPrecat} (G : Functor J (PresheafCat C)) : Functor J (FunctorCat {Precat.op {C}} {SetCat}) \cowith
  | F j => alias' (G j)
  | Func {X} {Y} f => Func {G} f
  | Func-id => Func-id
  | Func-o => Func-o

\instance PresheafComplete (C : SmallPrecat) : CompleteCat
  | Cat => PresheafCat C
  | limit {J} G => \new Limit {
    | apex => \new VPresheaf {
      | F => limit J SetBicat.limit (alias G)
    }
    | coneMap => {?}
    | coneCoh => {?}
    | isLimit => {?}
    | limMap => {?}
    | limBeta => {?}
    | limUnique => {?}
  }

\func SubPresheave (C : SmallPrecat) (P : PresheafCat C) => Preorder.PosetC {SubobjPreorder {PresheafCat C} P}

\instance PresheaveLocale (C : SmallPrecat) (obj : PresheafCat C)
: Locale (SubPresheave C obj)
  | Poset => SubPresheave C obj
  | meet => {?}
  | meet-left => {?}
  | meet-right => {?}
  | meet-univ => {?}
  | top => {?}
  | top-univ => {?}
  | Join => {?}
  | Join-cond => {?}
  | Join-univ => {?}
  | Join-ldistr>= => {?}
