\import Category
\import Category.Functor
\import Equiv \hiding (Map)
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\open Precat

\class Cone {J : Precat} (G : Functor J) (apex : G.D)
  | coneMap (j : J) : Hom apex (G j)
  | coneCoh {j j' : J} (h : Hom j j') : coneMap j >> G.Func h = coneMap j'
  \where {
    \func map {C D : Precat} (F : Functor C D) {J : Precat} {G : Functor J C} (c : Cone G) : Cone (Comp F G) \cowith
      | apex => F c.apex
      | coneMap j => Func (c.coneMap j)
      | coneCoh h => inv (Func-o _ _) *> pmap Func (c.coneCoh h)

    \func mapEquiv {C D : Precat} (F : FullyFaithfulFunctor C D) {J : Precat} {G : Functor J C} (X : C) : QEquiv {Cone G X} {Cone (Comp F G) (F X)} (\lam c => map F c) \cowith
      | ret (c : Cone) => \new Cone {
        | coneMap j => F.inverse (c.coneMap j)
        | coneCoh h => F.isFaithful $ run {
          rewrite F.Func-o,
          repeat {2} (rewrite F.inverse-right),
          c.coneCoh h
        }
      }
      | ret_f c => exts (\lam j => F.inverse-left _)
      | f_sec c => exts (\lam j => F.inverse-right _)
  }

\func conePullback {J : Precat} {F : Functor J} (C : Cone F) (z : F.D) (f : Hom z C.apex) : Cone F z \cowith
  | coneMap j => f >> coneMap j
  | coneCoh h => inv (o-assoc _ _ _) *> pmap (f >>) (coneCoh h)

\record Limit \extends Cone
  | isLimit (z : G.D) : Equiv (conePullback \this z)

\record SmallCone \extends Cone {
  \override J : SmallPrecat
}

\class CompletePrecat \extends Precat
  | limit {J : SmallPrecat} (F : Functor J \this) : Limit F

\class CompleteCat \extends CompletePrecat, Cat

\class CocompletePrecat \extends Precat
  | colimit {J : SmallPrecat} (F : Functor J (opP \this)) : Limit F

\class CocompleteCat \extends CocompletePrecat, Cat

