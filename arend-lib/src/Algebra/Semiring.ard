\import Algebra.Meta
\import Algebra.Monoid
\import Data.Array
\import Function.Meta
\import Logic
\import Paths
\import Paths.Meta
\import Set.Fin

\class Semiring \extends AbMonoid, Monoid {
  | ldistr {x y z : E} : x * (y + z) = x * y + x * z
  | rdistr {x y z : E} : (x + y) * z = x * z + y * z
  | zro_*-left {x : E} : zro * x = zro
  | zro_*-right {x : E} : x * zro = zro

  | natCoef : Nat -> E
  \default natCoef \as natCoefImpl n \with {
    | 0 => zro
    | suc n => natCoefImpl n + ide
  }
  | natCoefZero : natCoef 0 = zro
  \default natCoefZero \as natCoefZeroImpl : natCoefImpl 0 = zro => idp
  | natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide
  \default natCoefSuc \as natCoefSucImpl n : natCoefImpl (suc n) = natCoefImpl n + ide => idp

  \lemma zero-div {x : E} : Monoid.LDiv x 0 0 \cowith
    | inv-right => zro_*-right

  \lemma ldiv=0 {x y : E} (l : Monoid.LDiv x y) (p : x = 0) : y = 0
    => Paths.inv l.inv-right *> pmap (`* _) p *> zro_*-left

  \lemma ldiv/=0 {x y : E} (y/=0 : y /= 0) (x|y : Monoid.LDiv x y) : x /= 0
    => \lam x=0 => y/=0 (ldiv=0 x|y x=0)

  \lemma natCoef_+ (n m : Nat) : natCoef (n Nat.+ m) = natCoef n + natCoef m \elim m
    | 0 => inv (pmap (_ +) natCoefZero *> zro-right)
    | suc m => natCoefSuc _ *> pmap (`+ 1) (natCoef_+ n m) *> +-assoc *> inv (pmap (_ +) (natCoefSuc m))

  \lemma BigSum-ldistr {x : E} {l : Array E} : x * BigSum l = BigSum (map (x *) l) \elim l
    | nil => zro_*-right
    | :: a l => ldistr *> pmap (x * a +) BigSum-ldistr

  \lemma FinSum-ldistr {A : FinSet} {x : E} {y : A -> E} : x * FinSum y = FinSum (x * y __)
    => \case AbMonoid.FinSum.char y \with {
      | inP p => pmap (x *) p.2 *> BigSum-ldistr *> inv (AbMonoid.FinSum.char2 _ p.1)
    }

  \lemma BigSum-rdistr {l : Array E} {z : E} : BigSum l * z = BigSum (\lam i => l i * z) \elim l
    | nil => zro_*-left
    | :: a arr => rdistr *> pmap (_ +) BigSum-rdistr

  \lemma FinSum-rdistr {A : FinSet} {x : E} {y : A -> E} : FinSum y * x = FinSum (y __ * x)
    => \case AbMonoid.FinSum.char y \with {
      | inP p => pmap (`* x) p.2 *> BigSum-rdistr *> inv (AbMonoid.FinSum.char2 _ p.1)
    }

  \lemma BigSum_replicate {x : E} {n : Nat} : BigSum (replicate n x) = natCoef n * x \elim n
    | 0 => rewrite natCoefZero (inv zro_*-left)
    | suc n => rewrite natCoefSuc $ pmap (x +) BigSum_replicate *> equation

  \lemma FinSum_replicate {A : FinSet} {x : E} : FinSum {_} {A} (\lam _ => x) = natCoef A.finCard * x
    => FinSum-const *> BigSum_replicate

  \lemma BigSum_replicate0 {n : Nat} : BigSum (replicate n zro) = 0
    => BigSum_replicate *> zro_*-right

  \lemma BigProd_zro {l : Array E} (j : Fin l.len) (p : l j = 0) : BigProd l = 0 \elim l, j
    | a :: l, 0 => pmap (`* _) p *> zro_*-left
    | a :: l, suc j => pmap (_ *) (BigProd_zro j p) *> zro_*-right
} \where {
    \func op (R : Semiring) : Semiring \cowith
      | AbMonoid => R
      | Monoid => Monoid.op R
      | ldistr => R.rdistr
      | rdistr => R.ldistr
      | zro_*-left => zro_*-right
      | zro_*-right => zro_*-left
  }

\class NonZeroSemiring \extends Semiring {
  | zro/=ide : zro /= ide

  \lemma inv-nonZero {a : E} (i : Monoid.Inv a) : a /= zro
    => \lam a=0 => zro/=ide (inv zro_*-right *> pmap (_ *) (inv a=0) *> i.inv-left)
}

\class CSemiring \extends Semiring, CMonoid {
  \default ldistr => *-comm *> rdistr *> pmap2 (+) *-comm *-comm
  \default rdistr => *-comm *> ldistr *> pmap2 (+) *-comm *-comm
  \default zro_*-left => *-comm *> zro_*-right
  \default zro_*-right => *-comm *> zro_*-left
}
