\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Ring
\import Category
\import Category.Functor
\import Meta
\import Paths.Meta
\import Set.Category

\instance PowerLModule {R : Ring} (J : \Set) (M : LModule R) : LModule R (J -> M)
  | zro _ => 0
  | + f g j => f j M.+ g j
  | zro-left => ext (\lam j => M.zro-left)
  | zro-right => ext (\lam j => M.zro-right)
  | +-assoc => ext (\lam j => M.+-assoc)
  | negative f j => M.negative (f j)
  | negative-left => ext (\lam j => M.negative-left)
  | +-comm => ext (\lam j => M.+-comm)
  | *c r f j => r *c f j
  | *c-assoc => ext (\lam j => *c-assoc)
  | *c-ldistr => ext (\lam j => *c-ldistr)
  | *c-rdistr => ext (\lam j => *c-rdistr)
  | ide_*c => ext (\lam j => ide_*c)

\func FunctorPowerLMod{R : Ring} : Functor SetCat.op (LModuleCat R) \cowith
  | F I => PowerLModule I R_m
  | Func {I} {J} (f : Hom {SetCat.op} I J) => \new LinearMap {
    | func r => \lam (j : J) => r (f j)
    | func-+ {_} {_} => ext (\lam _ => idp)
    | func-*c => ext (\lam _ => idp)
  }
  | Func-id {_} => ext (ext (\lam _ _ => unfold idp))
  | Func-o => ext (ext (\lam _ _ => unfold idp))
  \where \func R_m : LModule R => RingLModule R
