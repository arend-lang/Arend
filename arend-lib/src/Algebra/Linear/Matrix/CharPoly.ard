\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.Symmetric
\import Algebra.Linear.Matrix
\import Algebra.Module
\import Algebra.Monoid
\import Algebra.Ring
\import Algebra.Ring.Poly
\import Algebra.Semiring
\import Arith.Fin
\import Data.Array
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin
\open FinLinearOrder

\func charPoly {R : CRing} {n : Nat} (M : Matrix R n n) : Poly R
  => determinant $ padd 1 0 *c matrix-map (padd 0) 1 - matrix-map (padd 0) M

\lemma charPoly-degree {R : CRing} {n : Nat} {M : Matrix R n n} : degree<= (charPoly M) n
  => degree<=_FinSum $ \lam j => degree<=_* (transport (degree<= __ 0) (sign.sign_hom polyEmbHom) idp) $
      transport (degree<= _) Semiring.BigSum_replicate $ degree<=_BigProd (replicate n 1) (\lam _ => idp)

\lemma charPoly-monic {R : CRing} {n : Nat} {M : Matrix R n n} : polyCoef (charPoly M) n = 1
  => AddMonoidHom.func-FinSum polyCoefHom *> AbMonoid.FinSum-unique 1 (\lam (e : Sym n) e/=id =>
        leadCoef-product (transport (degree<= __ 0) (sign.sign_hom polyEmbHom) idp) (transport (degree<= _) Semiring.BigSum_replicate $ degree<=_BigProd (replicate n 1) (\lam _ => idp)) *>
        pmap (_ *) (pmap (polyCoef _) (inv Semiring.BigSum_replicate) *> leadCoef_BigProd (replicate n 1) (\lam _ => idp) *>
                   later (\case FinSet.search (\lam j => e j /= j) (\lam j => decide) \with {
                     | yes (inP (j,ej/=j)) => R.BigProd_zro j $ later $ rewrite (decideEq/=_reduce ej/=j) (zro-left *> ide-left)
                     | no q => absurd $ e/=id $ Sym.equals $ \lam j => tightness $ \lam p => q (inP (j,p))
                   })) *> R.zro_*-right) *>
     pmap (\lam x => polyCoef (x * _) n) sign_ide *> pmap (polyCoef __ n) ide-left *> pmap (polyCoef _) (inv Semiring.BigSum_replicate) *>
     leadCoef_BigProd (replicate n 1) (\lam _ => idp) *> Monoid.BigProd_ide (\lam j => zro-left *> ide-left *> later (rewrite (decideEq=_reduce idp) idp))
