{- | The proofs are based on the following papers:
 -   Irving Kaplansky, Elementary divisors and modules, 1949
 -   Guillaume Cano, Cyril Cohen, Maxime Dénès, Anders Mörtberg, Vincent Siles, Formalized linear algebra over Elementary Divisor Rings in Coq, 2016, https://arxiv.org/abs/1601.07472
 -}

\import Algebra.Domain.Bezout
\import Algebra.Linear.Matrix
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Nat
\import Data.Array
\import Data.Fin (fsuc, fsuc/=)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Classical
\import Logic.Meta
\import Meta
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Set.Fin
\open Monoid \hiding (equals)

\type \infix 4 M~ {R : Ring} {n m : Nat} (A B : Matrix R n m) : \Prop
  => ∃ (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val MatrixRing.product A MatrixRing.product D.val)
  \where
    \lemma transposed {R : CRing} {n m : Nat} {A B : Matrix R n m} (p : A M~ B) : transpose A M~ transpose B \elim p
      | inP (C : Inv, D : Inv, p) => inP (transpose.isInv D, transpose.isInv C, pmap transpose p *> transpose_*.product {_} {_} {_} {_} {C.val MatrixRing.product A} *> pmap (transpose D.val MatrixRing.product) transpose_*.product *> inv (MatrixRing.product-assoc (transpose D.val) (transpose A) (transpose C.val)))

\lemma *c_M~ {R : CRing} {n m : Nat} {a : R} {A B : Matrix R n m} (A~B : A M~ B) : a *c A M~ a *c B \elim A~B
  | inP (C : Inv, D, p) => inP (C, D, pmap (a *c) p *> MatrixAlgebra.product_*c-comm-left (C.val MatrixRing.product A) *> cong MatrixAlgebra.product_*c-comm-right)

\lemma blockMatrix_M~ {R : CRing} {n m n' m' : Nat} {A B : Matrix R n m} {C D : Matrix R n' m'} (A~B : A M~ B) (C~D : C M~ D)
  : blockMatrix A C M~ blockMatrix B D \elim A~B, C~D
  | inP (P1 : Inv, Q1 : Inv, A~B), inP (P2 : Inv, Q2 : Inv, C~D) => inP (blockMatrix_Inv.2 (P1,P2), blockMatrix_Inv.2 (Q1,Q2), pmap2 blockMatrix A~B C~D *> inv (pmap (MatrixRing.`product blockMatrix Q1.val Q2.val) (blockMatrix_* _ _ _ _) *> blockMatrix_* (P1.val MatrixRing.product A) (P2.val MatrixRing.product C) _ _))

\instance M~-equiv {R : Ring} {n m : Nat} : Equivalence (Matrix R n m) (M~) \cowith
  | ~-reflexive {A} => inP (Inv.ide-isInv, Inv.ide-isInv, inv $ product_ide-right *> product_ide-left)
  | ~-symmetric {A} {B} => TruncP.map __ $ later \lam s => (Inv.op {s.1}, Inv.op {s.2}, inv $ pmap (\lam z => Inv.inv {s.1} product z product Inv.inv {s.2}) (s.3 *> product-assoc _ _ _) *>
                              \let A' => A product Inv.val {s.2}
                              \in pmap (`product _) (inv (product-assoc _ _ A') *> pmap (`product A') (Inv.inv-left {s.1}) *> product_ide-left {_} {_} {_} {A'}) *> product-assoc _ _ _ *> pmap (A product) (Inv.inv-right {s.2}) *> product_ide-right)
  | ~-transitive {P} {Q} {S} (inP s) (inP t) => inP (Inv.product t.1 s.1, Inv.product s.2 t.2, t.3 *> pmap (_ product __ product _) s.3 *> pmap (`product _) {_ product (_ product P product _)} {_ * _ product P product _} (pmap (_ product) (product-assoc _ _ _) *> inv (product-assoc _ _ (P product _)) *> inv (product-assoc (_ * _) _ _)) *> product-assoc (_ * _ product P) _ _)
  \where \open MatrixRing

\type IsSmith {R : Semiring} {n m : Nat} (A : Matrix R n m) : \Prop
  => \Sigma (IsDiagonal A) (\Pi (i : Nat) (p : suc i < n) (q : suc i < m) -> TruncP (LDiv (A ((\lam {k} => toFin k) $ <-transitive id<suc p) ((\lam {k} => toFin k) $ <-transitive id<suc q)) (A (toFin _ p) (toFin _ q))))
  \where {
    \lemma transposed {R : Semiring} {n m : Nat} {A : Matrix R n m} (s : IsSmith A) : IsSmith (transpose A)
      => (IsDiagonal.transposed s.1, \lam i p q => s.2 i q p)

    \lemma div00 {R : Semiring} {n m : Nat} {A : Matrix R (suc n) (suc m)} (As : IsSmith A) (i : Fin (suc n)) (j : Fin (suc m)) : TruncP (LDiv (A 0 0) (A i j))
      => \case decideEq (i : Nat) j \with {
        | yes i=j => transport2 (\lam x y => TruncP (LDiv (A 0 0) (A x y))) toFin=fin (fin_nat-inj $ toFin=id {i} {suc m} {rewrite i=j (fin_< j)} *> i=j) $ aux (fin_< i) $ rewrite i=j (fin_< j)
        | no i/=j => inP \new LDiv {
          | inv => 0
          | inv-right => zro_*-right *> inv (As.1 i j i/=j)
        }
      }
      \where \private \lemma aux {i : Nat} (p : i < suc n) (q : i < suc m) : TruncP (LDiv (A 0 0) (A (toFin i p) (toFin i q))) \elim i
        | 0 => inP LDiv.id-div
        | suc i => \case aux (<-transitive id<suc p) (<-transitive id<suc q), As.2 i p q \with {
          | inP d1, inP d2 => inP (LDiv.trans d1 d2)
        }
  }

\class SmithRing \extends StrictBezoutRing {
  | isKaplansky : IsKaplansky \this

  \lemma toSmith {n m : Nat} (A : Matrix E n m) : ∃ (B : Matrix E n m) (IsSmith B) (A M~ B)
    => Smith-char 0 3 (isStrictBezout,isKaplansky) A
} \where {
  \type IsKaplansky (R : CRing) => \Pi (a b c : R) -> IsCoprimeArray (a,b,c) -> ∃ (t s : R) (IsCoprime (t * a) (t * b + s * c))

  \lemma Smith-char {R : CRing} : TFAE (
    \Sigma R.IsStrictBezout (IsKaplansky R),
    \Sigma R.IsStrictBezout (\Pi (A : Matrix R 2 2) -> A 1 0 = 0 -> IsCoprimeArray (A 0 0, A 0 1, A 1 1) -> ∃ (B : Matrix R 2 2) (IsDiagonal B) (A M~ B)),
    \Pi {n m : Nat} -> n <= m -> m <= 2 -> \Pi (A : Matrix R n m) -> ∃ (B : Matrix R n m) (IsDiagonal B) (A M~ B),
    \Pi {n m : Nat} (A : Matrix R n m) -> ∃ (B : Matrix R n m) (IsSmith B) (A M~ B)
  ) => TFAE.cycle $ later (\lam (bez,kap) => (bez, \lam A A10=0 Ac =>
      \let | (inP (t,s,kc)) => kap (A 0 0) (A 0 1) (A 1 1) Ac
           | (inP (x1,y1,kd)) => gcd_bezout {\new StrictBezoutRing { | CRing => R | isStrictBezout => bez }} (IsCoprime.=>gcd kc)
           | C => makeMatrix ((t, s), (negative (A 1 1 * y1), A 0 0 * x1 + A 0 1 * y1))
           | D => makeMatrix ((x1, negative (t * A 0 1 + s * A 1 1)), (y1, t * A 0 0))
      \in inP (makeMatrix {E} ((1, 0), (0, A 0 0 * A 1 1)), \case \elim __, \elim __ \with {
        | 0, 0 => \lam p => absurd (p idp)
        | 0, 1 => \lam _ => idp
        | 1, 0 => \lam _ => idp
        | 1, 1 => \lam p => absurd (p idp)
      }, inP (determinant1_Inv C (determinant22 {_} {C} *> equation), determinant1_Inv D (determinant22 {_} {D} *> equation), matrixExt \case \elim __, \elim __ \with {
        | 0, 0 => equation
        | 0, 1 => equation
        | 1, 0 => equation
        | 1, 1 => equation
      }))
  ), \lam (bez,diag) {n} {m} => \case \elim n, \elim m \with {
    | 0, m => \lam _ _ A => inP (A, \case __ \with {}, ~-reflexive)
    | n, 0 => \lam _ _ A => inP (A, \lam _ => \case __ \with {}, ~-reflexive)
    | 1, 1 => \lam _ _ A => inP (A, \lam (0) (0) p => absurd (p idp), ~-reflexive)
    | 1, 2 => \lam _ _ A => TruncP.map (bez (A 0 0) (A 0 1)) \lam (s,t,u,v,au=bv,su+tv=1) =>
        (makeMatrix ((s * A 0 1 + t * A 0 0, zro) :: nil), \case \elim __, \elim __ \with {
          | 0, 0 => \lam p => absurd (p idp)
          | 0, 1 => \lam _ => idp
        }, inP (determinant1_Inv MatrixRing.ide (determinant11 MatrixRing.ide),
                \let C => makeMatrix ((t, negative u), (s, v))
                \in determinant1_Inv C (determinant22 {_} {C} *> equation),
                matrixExt \case \elim __, \elim __ \with {
                  | 0, 0 => equation
                  | 0, 1 => equation
                }))
    | 2, 2 => \lam _ _ A =>
        \let | (inP (s,t,u,v,p,q)) => bez (A 0 0) (A 1 0)
             | F => makeMatrix ((t, s), (negative u, v))
             | (inP (B,Bd,A~B)) => diagonalize_normed bez diag (F MatrixRing.product A) equation
             | (inP (s',t',u',v',p',q')) => bez (B 0 0) (B 1 1)
             | C => makeMatrix ((t', s'), (negative u', v'))
             | D => makeMatrix ((ide, negative (s' * u')), (ide, t' * v'))
        \in inP (C MatrixRing.product B MatrixRing.product D, \lam i j => unfold BigSum \case \elim i, \elim j \with {
          | 0, 0 => \lam p => absurd (p idp)
          | 0, 1 => \lam _ => rewrite (Bd 0 1 (\case __), Bd 1 0 \case __) equation
          | 1, 0 => \lam _ => rewrite (Bd 0 1 (\case __), Bd 1 0 \case __) equation
          | 1, 1 => \lam p => absurd (p idp)
        }, inP (determinant1_Inv F (determinant22 {_} {F} *> equation), Inv.ide-isInv,
                inv MatrixRing.product_ide-right) `~-transitive` A~B `~-transitive`
                  inP (determinant1_Inv C (determinant22 {_} {C} *> equation),
                       determinant1_Inv D (determinant22 {_} {D} *> equation),
                       idp))
    | _, suc (suc (suc m)) => \lam _ p => absurd linarith
    | 2, 1 => \lam p => absurd linarith
    | suc (suc (suc n)), suc m => \lam p q => absurd linarith
  }, \lam S A => aux S id<suc A, \lam S => (smith-isBezout \lam A => TruncP.map (S A) \lam (B,Bs,A~B) => (B,Bs.1,A~B), \lam a b c abc =>
      \case S (makeMatrix ((a,b),(0,c))) \with {
        | inP (B, Bs, inP (C : Inv, D : Inv, p) \as e) =>
          \let f => M~_LDiv (~-symmetric e) (IsSmith.div00 Bs)
          \in \case f 0 0, f 0 1, f 1 1 \with {
            | inP fa, inP fb, inP fc => inP (C.val 0 0, C.val 0 1, BezoutRing.bezoutInv_coprime {_} {D.val 0 0} {D.val 1 0} $ transport Inv (equation {usingOnly (pmap (__ 0 0) p)}) $ abc (B 0 0) (fa,fb,fc))
          }
      }))
  \where \private {
    \lemma transposed {R : CRing} {n m : Nat} {A : Matrix R n m} (p : ∃ (B : Matrix R m n) (IsSmith B) (transpose A M~ B)) : ∃ (B : Matrix R n m) (IsSmith B) (A M~ B) \elim p
      | inP (B,s,e) => inP (transpose B, IsSmith.transposed s, M~.transposed {_} {_} {_} {transpose A} e)

    \lemma smith-isBezout {R : CRing} (S : \Pi (A : Matrix R 1 2) -> ∃ (B : Matrix R 1 2) (IsDiagonal B) (A M~ B)) : R.IsStrictBezout
      => \lam a b => \case S (makeMatrix ((a,b) :: nil)) \with {
        | inP (B, Bd, inP (C : Inv, D : Inv, e)) =>
          \have detD-inv : Inv => determinant-inv.1 D
          \in inP (detD-inv.inv * D.val 1 0, detD-inv.inv * D.val 0 0, negative (D.val 0 1), D.val 1 1,
                   equation {usingOnly (inv (Bd 0 1 \case __) *> pmap (__ 0 1) e, pmap (__ 0 0) C.inv-left)},
                   equation {usingOnly (rewriteF determinant22 detD-inv.inv-left)})
      }

    \lemma diagonalize_normed {R : CRing} (bez : R.IsStrictBezout) (diag : \Pi (A : Matrix R 2 2) -> A 1 0 = 0 -> IsCoprimeArray (A 0 0, A 0 1, A 1 1) -> ∃ (B : Matrix R 2 2) (IsDiagonal B) (A M~ B))
      (A : Matrix R 2 2) (A10=0 : A 1 0 = 0) : ∃ (B : Matrix R 2 2) (IsDiagonal B) (A M~ B)
      => \let | (inP (s,u,p,d,f)) => StrictBezoutRing.bezoutArray {\new StrictBezoutRing { | CRing => R | isStrictBezout => bez }} (A 0 0, A 0 1, A 1 1)
              | (inP (B,Bd,e)) => diag (makeMatrix ((u 0, u 1), (0, u 2))) idp (BezoutRing.bezoutArray_coprime s p)
         \in inP (d *c B, *c_IsDiagonal Bd, transport (`M~ _) (matrixExt \lam i j => *-comm *> inv (later \case \elim i, \elim j \with {
          | 0, 0 => f 0
          | 0, 1 => f 1
          | 1, 0 => A10=0 *> inv zro_*-left
          | 1, 1 => f 2
        })) (*c_M~ e))

    \lemma aux {R : CRing} {k m n : Nat} (S : \Pi {n m : Nat} -> n <= m -> m <= 2 -> \Pi (A : Matrix R n m) -> ∃ (B : Matrix R n m) (IsDiagonal B) (A M~ B))
               (p : 2 Nat.* n Nat.+ m < k) (A : Matrix R n m) : ∃ (B : Matrix R n m) (IsSmith B) (A M~ B) \elim k, m, n
      | _, 0, _ => inP (A, (\lam _ => \case __ \with {}, \lam _ _ => \case __), ~-reflexive)
      | _, _, 0 => inP (A, (\case __ \with {}, \lam _ => \case __), ~-reflexive)
      | _, 1, 1 => inP (A, (\lam (0) (0) p => absurd (p idp), \lam n q => absurd linarith), ~-reflexive)
      | suc k, 1, suc (suc n) => transposed $ aux {_} {k} S linarith (transpose A)
      | suc k, 2, suc (suc (suc n)) => transposed $ aux {_} {k} S linarith (transpose A)
      | _, 2, 1 => TruncP.map (S linarith <=-refl A) \lam (B,Bd,A~B) => (B, (Bd, \lam i (NatSemiring.suc<suc ())), A~B)
      | _, 2, 2 =>
          \let | (inP (B,Bd,A~B)) => S <=-refl <=-refl A
               | (inP (s,t,u,v,p,q)) => smith-isBezout (S linarith <=-refl) (B 0 0) (B 1 1)
               | C => makeMatrix ((t, s), (negative u, v))
               | D => makeMatrix ((ide, negative (s * u)), (ide, t * v))
          \in inP (C MatrixRing.product B MatrixRing.product D, (\case \elim __, \elim __ \with {
            | 0, 0 => \lam p => absurd (p idp)
            | 0, 1 => \lam _ => unfold BigSum $ rewrite (Bd 1 0 \case __ \with {}, Bd 0 1 \case __) equation
            | 1, 0 => \lam _ => unfold BigSum $ rewrite (Bd 1 0 \case __ \with {}, Bd 0 1 \case __) equation
            | 1, 1 => \lam p => absurd (p idp)
          }, \case \elim __, \elim __, \elim __ \with {
            | 0, p, q => inP \new LDiv {
              | inv => u * v
              | inv-right => unfold BigSum $ rewrite (Bd 1 0 \case __ \with {}, Bd 0 1 \case __) equation
            }
            | suc i, NatSemiring.suc<suc (NatSemiring.suc<suc ()), _
          }), ~-transitive A~B $ inP (determinant1_Inv C $ determinant22 {_} {C} *> equation, determinant1_Inv D $ determinant22 {_} {D} *> equation, idp))
      | suc k, suc (suc (suc m)), suc n =>
        \let | (inP (B, Bs, inP (P1 : Inv, Q1 : Inv, A2~B))) => aux {_} {k} S linarith (mkMatrix \lam i j => A i (suc j))
             | A1 => mkColumn \lam i => A i 0
             | P1A1 => P1.val MatrixRing.product A1
             | D => transpose $ makeMatrix (P1A1 __ 0, B 0 0 :: replicate n zro)
             | (inP (F, Fs, inP (P2 : Inv, Q2 : Inv, D~'F) \as D~F)) => aux {_} {k} S linarith D
             | C => block12Matrix P1A1 B
             | A~C : A M~ C => inP (P1, (blockMatrix_Inv {_} {_} {_} {MatrixRing.ide {_} {1}}).2 (Inv.ide-isInv, Q1),
                                    matrixExt \lam i => \case \elim __ \with {
                                      | 0 => inv $ BigSum-unique {_} {\lam j => BigSum (\lam k => P1.val i k * A k j) * addRow (ide :: replicate (m Nat.+ 2) zro) (addColumn (replicate (m Nat.+ 2) zro) Q1.val) j 0} 0 (\case \elim __ \with {
                                        | 0 => \lam p => absurd (p idp)
                                        | suc j => \lam _ => zro_*-right
                                      }) *> ide-right
                                      | suc j => pmap (__ i j) A2~B *> inv zro-left *> pmap (`+ _) (inv zro_*-right)
                                    })
             | E' => mkMatrix \lam i j => B i (suc j)
             | G => P2.val MatrixRing.product E'
             | H => block12Matrix F G
             | C~H : C M~ H => inP (P2, (blockMatrix_Inv {_} {2} {suc m}).2 (Q2, Inv.ide-isInv),
                                    matrixExt $ rewrite D~'F \lam i => \case \elim __ \with {
                                      | 0 => inv $ BigSum-split {_} {2} {suc m} {\lam j => BigSum (\lam k => P2.val i k * (::) (BigSum (\lam j => P1.val k j * A j 0)) (B k) j) * blockMatrix Q2.val (MatrixRing.ide {_} {suc m}) j 0}
                                                     *> pmap2 (+) (cong $ ext \lam i' => pmap2 (*) (cong $ ext \lam k => pmap (P2.val i k *) $ \case \elim i', \elim k \with {
                                        | 0, k => idp
                                        | 1, 0 => idp
                                        | 1, suc k => Bs.1 (suc k) 0 \case __
                                      }) (blockMatrix.elem00 {_} {2} {2} {suc m} {suc m} {Q2.val} {MatrixRing.ide} i' 0)) (BigSum_zro {_} {\new Array E (suc m) \lam j => BigSum (\lam k => P2.val i k * B k (suc j)) * zro} \lam j => zro_*-right) *> zro-right
                                      | 1 => inv $ BigSum-split {_} {2} {suc m} {\lam j => BigSum (\lam k => P2.val i k * (::) (BigSum (\lam j => P1.val k j * A j 0)) (B k) j) * blockMatrix Q2.val MatrixRing.ide j 1} *> pmap2 (+) (cong $ ext \lam j => pmap2 (*) (cong $ ext \lam k => pmap (_ *) \case \elim j, \elim k \with {
                                        | 0, k => idp
                                        | 1, 0 => idp
                                        | 1, suc k => Bs.1 (suc k) 0 \case __
                                      }) (blockMatrix.elem00 {_} {2} {2} {suc m} {suc m} {Q2.val} {MatrixRing.ide} j 1)) (BigSum_zro {_} {\new Array E (suc m) \lam j => BigSum (\lam k => P2.val i k * B k (suc j)) * zro} \lam j => zro_*-right) *> zro-right
                                      | suc (suc j) => inv ide-right *> pmap (_ *) (later $ rewrite (decideEq=_reduce idp) idp) *> inv (BigSum-unique {_} {\lam k => BigSum (\lam j => P2.val i j * (::) (BigSum (\lam k => P1.val j k * A k 0)) (B j) k) * blockMatrix Q2.val MatrixRing.ide k (suc (suc j))} (suc (suc j)) \lam k j+2/=k => pmap (_ *) (later \case ++'.split-index {2} k \with {
                                        | inl (k',p) => rewrite p $ blockMatrix.elem01 {_} {2} {2} {suc m} {suc m} {Q2.val} {MatrixRing.ide} k' j
                                        | inr (k',p) => rewrite p $ mcases \with {
                                          | yes q => absurd $ j+2/=k $ inv $ p *> cong q
                                          | no _ => idp
                                        }
                                      }) *> zro_*-right)
                                    }
             )
             | (inP (K,Ks,H~K)) => ind-step H (\lam B => aux {_} {k} S linarith B) \lam i => \case \elim __ \with {
               | 0 => IsSmith.div00 Fs i 0
               | 1 => IsSmith.div00 Fs i 1
               | suc (suc j) => \case M~_LDiv (~-symmetric D~F) (IsSmith.div00 Fs) (0 : Fin (suc n)) 1, FinSet.finiteAC (\lam k => IsSmith.div00 Bs k (suc j)) \with {
                 | inP d1, inP d2 => inP $ LDiv.trans d1 $ LDiv_BigSum {_} {_} {\lam k => P2.val i k * B k (suc j)} \lam k => LDiv.factor-right (d2 k)
               }
             }
        \in inP (K, Ks, A~C `~-transitive` C~H `~-transitive` H~K)
  }

  \sfunc elimRow {R : CRing} {n m : Nat} (A : Matrix R (suc n) (suc m)) (d : \Pi (i : Fin n) -> LDiv (A 0 0) (A (suc i) 0))
    : \Sigma (B : Matrix R (suc n) (suc m)) (A M~ B) (\Pi (i : Fin n) -> B (suc i) 0 = 0) (\Pi (j : Fin (suc m)) -> B 0 j = A 0 j)
    => \let C => addColumn (ide :: \lam i => negative (LDiv.inv {d i})) (addRow {R} (replicate n zro) ide)
       \in (C MatrixRing.product A, inP (determinant1_Inv C (determinant_IsLowerTriangular {_} {_} {C} (\case \elim __, \elim __, \elim __ \with {
              | 0, suc j, _ => idp
              | suc i, suc j, NatSemiring.suc<suc i<j => rewrite (decideEq/=_reduce \lam (p : i = j) => NatSemiring.<-irreflexive $ transportInv {Nat} (i <) p i<j) idp
            }) *> cong (exts \case \elim __ \with {
              | 0 => idp
              | suc j => rewrite (decideEq=_reduce idp) idp
            }) *> BigProd_ide {_} {replicate (suc n) ide} (\lam _ => idp)), Inv.ide-isInv, inv MatrixRing.product_ide-right),
            \lam i => BigSum-unique2 {_} {\lam j => (::) (negative (LDiv.inv {d i})) (MatrixRing.ide i) j * A j 0} {0} {suc i} NatSemiring.zero<suc (\case \elim __ \with {
              | 0 => \lam p => absurd (p idp)
              | suc k => \lam _ k/=i => rewrite (decideEq/=_reduce \lam p => k/=i (inv (pmap fsuc p))) zro_*-left
            }) *> rewrite (decideEq=_reduce idp) (pmap2 (+) (negative_*-left *> pmap negative (*-comm *> LDiv.inv-right {d i})) ide-left *> negative-left),
            \lam j => BigSum-unique {_} {\lam k => (::) ide (replicate n zro) k * A k j} 0 (\case \elim __ \with {
              | 0 => \lam p => absurd (p idp)
              | suc k => \lam _ => zro_*-left
            }) *> ide-left)

  \sfunc elimColumn {R : CRing} {n m : Nat} (A : Matrix R (suc n) (suc m)) (d : \Pi (j : Fin m) -> LDiv (A 0 0) (A 0 (suc j)))
    : \Sigma (B : Matrix R (suc n) (suc m)) (A M~ B) (\Pi (j : Fin m) -> B 0 (suc j) = 0) (\Pi (i : Fin (suc n)) -> B i 0 = A i 0)
    => \have (B,At~B,c,d) => elimRow (transpose A) d
       \in (transpose B, M~.transposed {_} {_} {_} {transpose A} At~B, c, d)

  \sfunc elimRowColumn {R : CRing} {n m : Nat} (A : Matrix R (suc n) (suc m))
                       (d1 : \Pi (i : Fin n) -> LDiv (A 0 0) (A (suc i) 0))
                       (d2 : \Pi (j : Fin m) -> LDiv (A 0 0) (A 0 (suc j)))
    : \Sigma (B : Matrix R (suc n) (suc m)) (A M~ B) (B 0 0 = A 0 0) (\Pi (i : Fin n) -> B (suc i) 0 = 0) (\Pi (j : Fin m) -> B 0 (suc j) = 0)
    => \have | (B,A~B,c,d) => elimRow A d1
             | (C,B~C,c',d') => elimColumn B \lam j => transport2 LDiv (inv (d 0)) (inv (d (suc j))) (d2 j)
       \in (C, ~-transitive A~B B~C, d' 0 *> d 0, \lam i => d' (suc i) *> c i, c')

  \lemma M~_LDiv {R : CRing} {a : R} {n m : Nat} {A B : Matrix R n m} (A~B : A M~ B)
                 (d : \Pi (i : Fin n) (j : Fin m) -> TruncP (LDiv a (A i j)))
                 (i : Fin n) (j : Fin m) : TruncP (LDiv a (B i j)) \elim A~B
    | inP (C : Inv, D : Inv, A~B) => rewrite A~B $ TruncP.map (choice {_} {\lam (s : \Sigma (Fin n) (Fin m)) => LDiv a (A s.1 s.2)} \lam s => d s.1 s.2)
                                         \lam f => LDiv_BigSum \lam k => LDiv.factor-left {_} {_} {BigSum \lam j => C.val i j * A j k} {D.val k j} $ LDiv_BigSum \lam j => later $ LDiv.factor-right $ f (j,k)

  \lemma ind-step {R : CRing} {n m : Nat} (A : Matrix R (suc n) (suc m))
                  (IH : \Pi (B : Matrix R n m) -> ∃ (C : Matrix E n m) (IsSmith C) (B M~ C))
                  (d00 : \Pi (i : Fin (suc n)) (j : Fin (suc m)) -> TruncP (LDiv (A 0 0) (A i j)))
    : ∃ (B : Matrix E (suc n) (suc m)) (IsSmith B) (A M~ B)
    => \let | (inP d1) => FinSet.finiteAC (\lam i => d00 i 0)
            | (inP d2) => FinSet.finiteAC (d00 0)
            | (B,A~B,B00=A00,c,d) => elimRowColumn A (\lam i => d1 (suc i)) (\lam j => d2 (suc j))
            | B' => mkMatrix \lam i j => B (suc i) (suc j)
            | M11 => mkMatrix {_} {1} {1} \lam _ _ => A 0 0
            | B=B' : B = {Matrix R (suc n) (suc m)} blockMatrix M11 B' => matrixExt \case \elim __, \elim __ \with {
              | 0, 0 => B00=A00
              | 0, suc j => d j
              | suc i, 0 => c i
              | suc i, suc j => idp
            }
            | (inP (C,Cs,B'~C)) => IH B'
            | A~C : A M~ blockMatrix M11 C => ~-transitive A~B $ transportInv (`~ _) B=B' $ blockMatrix_M~ {_} {_} {_} {_} {_} {M11} {M11} {B'} {C} ~-reflexive B'~C
       \in inP (blockMatrix M11 C, (\case \elim __, \elim __ \with {
         | 0, 0 => \lam p => absurd (p idp)
         | 0, suc j => \lam _ => idp
         | suc i, 0 => \lam _ => idp
         | suc i, suc j => \lam p => Cs.1 i j \lam i=j => p (pmap suc i=j)
       }, \case \elim __ \with {
         | 0 => \case \elim n, \elim m, \elim C, \elim A, \elim A~C, \elim d00 \with {
           | 0, m, _, _, _, _ => \lam p => absurd (<-irreflexive p)
           | n, 0, _, _, _, _ => \lam _ p => absurd (<-irreflexive p)
           | suc n, suc m, C, A, A~C, d00 => \lam _ _ => \have x => M~_LDiv A~C d00 (1 : Fin (n + 2)) (1 : Fin (m + 2)) \in x
         }
         | suc i => \lam (NatSemiring.suc<suc p) (NatSemiring.suc<suc q) => Cs.2 i p q
       }), A~C)
}

\func embed22 {R : Ring} (A : Matrix R 2 2) {n : Nat} (k : Fin (suc n)) : Matrix R (suc n) (suc n)
  => makeMatrix $ replace2 (MatrixRing.ide {R} {suc n}) 0 k
                            (replace2 (replicate (suc n) zro) 0 k (A 0 0) (A 1 0))
                            (replace2 (replicate (suc n) zro) 0 k (A 0 1) (A 1 1))
  \where {
    \func replace2 {A : \Type} (l : Array A) (i j : Fin l.len) (a b : A) : Array A l.len
      => replace (replace l i a) j b

    \func replace2-first {A : \Type} {l : Array A} {i j : Fin l.len} {a b : A} (i/=j : i /= {Nat} j) : replace2 l i j a b i = a
      => replace-notIndex {A} {replace l i a} (/=-sym i/=j) *> replace-index

    \func replace2-second {A : \Type} {l : Array A} {i j : Fin l.len} {a b : A} : replace2 l i j a b j = b
      => replace-index
  }

\lemma embed22_determinant {R : CRing} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)} (k/=0 : k /= {Nat} 0)
  : determinant (embed22 A k) = determinant A \elim k
  | 0 => absurd (k/=0 idp)
  | suc k => inv (determinantN.=determinant {R} {suc n} {0} {embed22 A (suc k)}) *> pmap2 (+)
      (pmap2 (*) (ide-right *> embed22_00 {R} {_} {n} {suc k} \case __) $ pmap determinant embed22_minor00 *> determinant_diagonal *>
        BigProd-unique k (\lam j k/=j => later $ replace-notIndex (fin_nat-ineq k/=j)) *> replace-index)
      (R.BigSum-unique k (\lam j k/=j => later (rewrite (replace-notIndex (fin_nat-ineq k/=j), zro_*-left) zro_*-left)) *>
        later (rewrite replace-index $ simplify $ pmap R.negative $ *-assoc *> pmap (_ *) (\case \elim n, \elim k, \elim k/=0 \with {
          | suc n, k, k/=0 => later $ inv (isAlternating.alternating_perm {R} determinant.alternating embed22_minor_k0_perm.1 *> pmap (pow -1 __ * _) embed22_minor_k0_perm.2) *> determinant_diagonal1
        }) *> *-comm)) *> inv determinant22
  \where {
    \open embed22
    \open determinant

    \lemma embed22_00 {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)} (k/=0 : k /= {Nat} 0) : embed22 A k 0 0 = A 0 0
      => pmap {Array R (suc n)} (__ 0) (replace2-first {Array R (suc n)} {MatrixRing.ide} {0} (/=-sym k/=0)) *> replace2-first {_} {replicate (suc n) zro} (/=-sym k/=0)

    \lemma embed22_minor00 {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin n}
      : minor (embed22 A (suc k)) 0 0 = diagonal1 k (A 1 1)
      => minor00 (embed22 A (suc k)) *> matrixExt \lam i j => \case decideEq i k \with {
        | yes i=k => rewrite (i=k,replace-index,replace-index) $ mcases \with {
          | yes k=j => rewrite k=j replace-index
          | no k/=j => replace-notIndex (fin_nat-ineq k/=j)
        }
        | no i/=k => rewrite (replace-notIndex $ fin_nat-ineq $ /=-sym i/=k) $ mcases {2} \with {
          | yes i=j => rewrite (decideEq=_reduce $ pmap fsuc i=j) $ inv $ replace-notIndex $ fin_nat-ineq (/=-sym i/=k)
          | no i/=j => rewrite (decideEq/=_reduce $ fsuc/= i/=j) idp
        }
      }

    \func diagonal1 {R : Ring} {n : Nat} (k : Fin n) (a : R) : Matrix R n n
      => diagonal (replace (replicate n ide) k a)

    \lemma determinant_diagonal1 {R : CRing} {n : Nat} {k : Fin n} {a : R} : determinant (diagonal1 k a) = a
      => determinant_diagonal *> BigProd-unique k (\lam j k/=j => replace-notIndex $ fin_nat-ineq $ later k/=j) *> replace-index

    \lemma embed22_minor_k0 {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)}
      : minor (embed22 A (suc k)) (suc k) 0 = diagonal1 k (A 1 0) k :: skip {Array R (suc n)} (diagonal1 k (A 1 0)) k
      => matrixExt \lam i j => \case \elim i \with {
        | 0 => mcases \with {
          | yes k=j => rewrite k=j $ replace-index *> inv replace-index
          | no k/=j => replace-notIndex $ fin_nat-ineq k/=j
        }
        | suc i => pmap {Array (Array R (suc (suc n))) n} (\lam x => x i (suc j)) skip_replace_= *>
            pmap {Array (Array R (suc n)) n} (__ i j) (skip_map {Array R (suc (suc n))} {Array R (suc n)} (\lam l j => l (fsuc j)) *>
            skipExt \lam i i/=k => exts \lam j => mcases {2} \with {
              | yes i=j => rewrite (decideEq=_reduce $ pmap fsuc i=j, replace-notIndex $ fin_nat-ineq $ /=-sym i/=k) idp
              | no i/=j => rewrite (decideEq/=_reduce $ fsuc/= i/=j) idp
            })
      }

    \sfunc embed22_minor_k0_perm {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)}
      : \Sigma (p : Perm (diagonal1 k (A 1 0)) (minor (embed22 A (suc k)) (suc k) 0)) (Perm.inversions p = k)
      => rewrite embed22_minor_k0 (determinantN.alternating.permutation1 k (diagonal1 k (A 1 0)), determinantN.alternating.permutation1_inversions)
  }

\class SmithDomain \extends BezoutDomain.Dec, SmithRing