\import Algebra.Domain.Bezout
\import Algebra.Linear.Matrix
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Nat
\import Data.Array
\import Data.Fin (fsuc, fsuc/=)
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Set.Fin
\open Monoid \hiding (equals)

\func \infix 4 M~ {R : Ring} {n m : Nat} (A B : Matrix R n m) : \Prop
  => ∃ (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val MatrixRing.product A MatrixRing.product D.val)

\instance M~-equiv {R : Ring} {n m : Nat} : Equivalence (Matrix R n m) (M~) \cowith
  | ~-reflexive {A} => inP (Inv.ide-isInv, Inv.ide-isInv, inv $ product_ide-right *> product_ide-left)
  | ~-symmetric {A} {B} => TruncP.map __ \lam s => (Inv.op {s.1}, Inv.op {s.2}, inv $ pmap (\lam z => Inv.inv {s.1} product z product Inv.inv {s.2}) (s.3 *> product-gen-assoc) *>
                                                                                      \let A' => A product Inv.val {s.2}
                                                                                      \in pmap (`product _) (inv (product-assoc _ _ A') *> pmap (`product A') (Inv.inv-left {s.1}) *> product_ide-left {_} {_} {_} {A'}) *> product-gen-assoc *> pmap (A product) (Inv.inv-right {s.2}) *> product_ide-right)
  | ~-transitive {P} {Q} {S} (inP s) (inP t) => inP (Inv.product t.1 s.1, Inv.product s.2 t.2, t.3 *> pmap (_ product __ product _) s.3 *> pmap (`product _) {_ product (_ product P product _)} {_ * _ product P product _} (pmap (_ product) product-gen-assoc *> inv (product-assoc _ _ (P product _)) *> inv (product-assoc (_ * _) _ _)) *> product-assoc (_ * _ product P) _ _)
  \where \open MatrixRing

\type IsSmith {R : Semiring} {n m : Nat} (A : Matrix R n m) : \Prop
  => \Sigma (IsDiagonal A) (\Pi (i : Nat) (p : suc i < n) (q : suc i < m) -> TruncP (LDiv (A (toFin $ <-transitive id<suc p) (toFin $ <-transitive id<suc q)) (A (toFin p) (toFin q))))

\lemma isSmith11 {R : Semiring} {n m : Nat} (p : n <= 1) (q : m <= 1) {A : Matrix R n m} : IsSmith A \elim n, m
  | 0, _ => ((\case __), \lam _ => \case __)
  | _, 0 => (\lam _ => \case __ \with {}, \lam _ _ => \case __)
  | 1, 1 => (\lam (0) (0) p => absurd (p idp), \lam _ _ _ => inP LDiv.id-div)
  | suc (suc n), _ => absurd linarith
  | _, suc (suc m) => absurd linarith

\class SmithRing \extends StrictBezoutRing {
  | isSmith (A : Matrix E 2 2) : A 1 0 = 0 -> ∃ (B : Matrix E 2 2) (IsDiagonal B) (A M~ B)

  \lemma toSmith {n m : Nat} (A : Matrix E n m) : ∃ (B : Matrix E n m) (IsSmith B) (A M~ B)
    => {?}
    \where {
      \private \lemma aux {n m k : Nat} (p : n <= m) (q : m <= k) (A : Matrix E n m) : ∃ (B : Matrix E n m) (IsSmith B) (A M~ B) \elim k
        | 0 => inP (A, (\lam i => \case transport Fin (<=_exists $ p <=∘ q) i \with {}, \lam i _ s => \case transport (_ <) (<=_exists q) s), M~-equiv.~-reflexive)
        | 1 => inP (A, isSmith11 (p <=∘ q) q, M~-equiv.~-reflexive)
        | 2 => \case \elim n, \elim m, \elim p, \elim q, \elim A \with {
                 | n, 0, p, q, A => inP (A, isSmith11 linarith linarith, M~-equiv.~-reflexive)
                 | n, 1, p, q, A => inP (A, isSmith11 p <=-refl, M~-equiv.~-reflexive)
                 | 0, 2, p, q, A => inP (A, ((\case __), \lam _ => \case __), M~-equiv.~-reflexive)
                 | 1, 2, p, q, A => TruncP.map (isStrictBezout (A 0 0) (A 0 1)) \lam (s,t,u,v,au=bv,su+tv=1) =>
                     (makeMatrix ((s * A 0 1 + t * A 0 0, zro) :: nil), (\case \elim __, \elim __ \with {
                       | 0, 0 => \lam p => absurd (p idp)
                       | 0, 1 => \lam _ => idp
                     }, \case \elim __, \elim __ \with {
                       | i, NatSemiring.suc<suc ()
                     }), inP ((determinant-inv {_} {1} {MatrixRing.ide}).2 $ transportInv Inv (determinant11 MatrixRing.ide) Inv.ide-isInv,
                              \let C => makeMatrix ((t, negative u), (s, v))
                              \in (determinant-inv {_} {2} {C}).2 $ transportInv Inv (determinant22 {_} {C} *> equation) Inv.ide-isInv,
                              matrixExt \case \elim __, \elim __ \with {
                                | 0, 0 => equation
                                | 0, 1 => equation
                              }))
                 | 2, 2, _, _, A =>
                   \let | (inP (s,t,u,v,p,q)) => isStrictBezout (A 0 0) (A 1 0)
                        | F => makeMatrix ((t, s), (negative u, v))
                        | (inP (B,Bd,A~B)) => isSmith (F MatrixRing.product A) equation
                        | (inP (s',t',u',v',p',q')) => isStrictBezout (B 0 0) (B 1 1)
                        | C => makeMatrix ((t', s'), (negative u', v'))
                        | D => makeMatrix ((ide, negative (s' * u')), (ide, t' * v'))
                   \in inP (C MatrixRing.product B MatrixRing.product D, (\lam i j => unfold BigSum \case \elim i, \elim j \with {
                     | 0, 0 => \lam p => absurd (p idp)
                     | 0, 1 => \lam _ => rewrite (Bd 0 1 (\case __), Bd 1 0 \case __) equation
                     | 1, 0 => \lam _ => rewrite (Bd 0 1 (\case __), Bd 1 0 \case __) equation
                     | 1, 1 => \lam p => absurd (p idp)
                   }, \case \elim __, \elim __ \with {
                     | 0, _ => \lam _ => inP $ unfold BigSum $ rewrite (Bd 0 1 (\case __), Bd 1 0 \case __) $ simplify $
                                LDiv_+ (LDiv.factor-left $ LDiv.factor-right \new LDiv { | inv => v' | inv-right => equation })
                                       (LDiv.factor-left $ LDiv.factor-right \new LDiv { | inv => u' | inv-right => equation })
                     | suc n, NatSemiring.suc<suc (NatSemiring.suc<suc ())
                   }), (inP ((determinant-inv {_} {_} {F}).2 $ transportInv Inv (determinant22 {_} {F} *> equation) Inv.ide-isInv,
                             Inv.ide-isInv,
                             inv MatrixRing.product_ide-right) M~-equiv.`~-transitive` {_} {F MatrixRing.product A}
                       A~B) M~-equiv.`~-transitive`
                       inP ((determinant-inv {_} {_} {C}).2 $ transportInv Inv (determinant22 {_} {C} *> equation) Inv.ide-isInv,
                            (determinant-inv {_} {_} {D}).2 $ transportInv Inv (determinant22 {_} {D} *> equation) Inv.ide-isInv,
                            idp))
                 | (suc (suc (suc n))), 2, p, q, A => absurd linarith
                 | n, suc (suc (suc m)), p, q, A => absurd linarith
               }
        | suc (suc (suc k)) => {?}
    }
}

\func embed22 {R : Ring} (A : Matrix R 2 2) {n : Nat} (k : Fin (suc n)) : Matrix R (suc n) (suc n)
  => makeMatrix $ replace2 (MatrixRing.ide {R} {suc n}) 0 k
                            (replace2 (replicate (suc n) zro) 0 k (A 0 0) (A 1 0))
                            (replace2 (replicate (suc n) zro) 0 k (A 0 1) (A 1 1))
  \where {
    \func replace2 {A : \Type} (l : Array A) (i j : Fin l.len) (a b : A) : Array A l.len
      => replace (replace l i a) j b

    \func replace2-first {A : \Type} {l : Array A} {i j : Fin l.len} {a b : A} (i/=j : i /= {Nat} j) : replace2 l i j a b i = a
      => replace-notIndex {A} {replace l i a} (/=-sym i/=j) *> replace-index

    \func replace2-second {A : \Type} {l : Array A} {i j : Fin l.len} {a b : A} : replace2 l i j a b j = b
      => replace-index
  }

\lemma embed22_determinant {R : CRing} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)} (k/=0 : k /= {Nat} 0)
  : determinant (embed22 A k) = determinant A \elim k
  | 0 => absurd (k/=0 idp)
  | suc k => inv (determinantN.=determinant {R} {suc n} {0} {embed22 A (suc k)}) *> pmap2 (+)
      (pmap2 (*) (ide-right *> embed22_00 {R} {_} {n} {suc k} \case __) $ pmap determinant embed22_minor00 *> determinant_diagonal *>
        BigProd-unique k (\lam j k/=j => later $ replace-notIndex (fin_nat-ineq k/=j)) *> replace-index)
      (R.BigSum-unique k (\lam j k/=j => later (rewrite (replace-notIndex (fin_nat-ineq k/=j), zro_*-left) zro_*-left)) *>
        later (rewrite replace-index $ simplify $ pmap R.negative $ *-assoc *> pmap (_ *) (\case \elim n, \elim k, \elim k/=0 \with {
          | suc n, k, k/=0 => later $ inv (isAlternating.alternating_perm {R} determinant.alternating embed22_minor_k0_perm.1 *> pmap (pow -1 __ * _) embed22_minor_k0_perm.2) *> determinant_diagonal1
        }) *> *-comm)) *> inv determinant22
  \where {
    \open embed22
    \open determinant

    \lemma embed22_00 {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)} (k/=0 : k /= {Nat} 0) : embed22 A k 0 0 = A 0 0
      => pmap {Array R (suc n)} (__ 0) (replace2-first {Array R (suc n)} {MatrixRing.ide} {0} (/=-sym k/=0)) *> replace2-first {_} {replicate (suc n) zro} (/=-sym k/=0)

    \lemma embed22_minor00 {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin n}
      : minor (embed22 A (suc k)) 0 0 = diagonal1 k (A 1 1)
      => minor00 (embed22 A (suc k)) *> matrixExt \lam i j => \case decideEq i k \with {
        | yes i=k => rewrite (i=k,replace-index,replace-index) $ mcases \with {
          | yes k=j => rewrite k=j replace-index
          | no k/=j => replace-notIndex (fin_nat-ineq k/=j)
        }
        | no i/=k => rewrite (replace-notIndex $ fin_nat-ineq $ /=-sym i/=k) $ mcases {2} \with {
          | yes i=j => rewrite (decideEq=_reduce $ pmap fsuc i=j) $ inv $ replace-notIndex $ fin_nat-ineq (/=-sym i/=k)
          | no i/=j => rewrite (decideEq/=_reduce $ fsuc/= i/=j) idp
        }
      }

    \func diagonal1 {R : Ring} {n : Nat} (k : Fin n) (a : R) : Matrix R n n
      => diagonal (replace (replicate n ide) k a)

    \lemma determinant_diagonal1 {R : CRing} {n : Nat} {k : Fin n} {a : R} : determinant (diagonal1 k a) = a
      => determinant_diagonal *> BigProd-unique k (\lam j k/=j => replace-notIndex $ fin_nat-ineq $ later k/=j) *> replace-index

    \lemma embed22_minor_k0 {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)}
      : minor (embed22 A (suc k)) (suc k) 0 = diagonal1 k (A 1 0) k :: skip {Array R (suc n)} (diagonal1 k (A 1 0)) k
      => matrixExt \lam i j => \case \elim i \with {
        | 0 => mcases \with {
          | yes k=j => rewrite k=j $ replace-index *> inv replace-index
          | no k/=j => replace-notIndex $ fin_nat-ineq k/=j
        }
        | suc i => pmap {Array (Array R (suc (suc n))) n} (\lam x => x i (suc j)) skip_replace_= *>
            pmap {Array (Array R (suc n)) n} (__ i j) (skip_map {Array R (suc (suc n))} {Array R (suc n)} (\lam l j => l (fsuc j)) *>
            skipExt \lam i i/=k => exts \lam j => mcases {2} \with {
              | yes i=j => rewrite (decideEq=_reduce $ pmap fsuc i=j, replace-notIndex $ fin_nat-ineq $ /=-sym i/=k) idp
              | no i/=j => rewrite (decideEq/=_reduce $ fsuc/= i/=j) idp
            })
      }

    \sfunc embed22_minor_k0_perm {R : Ring} {A : Matrix R 2 2} {n : Nat} {k : Fin (suc n)}
      : \Sigma (p : Perm (diagonal1 k (A 1 0)) (minor (embed22 A (suc k)) (suc k) 0)) (Perm.inversions p = k)
      => rewrite embed22_minor_k0 (determinantN.alternating.permutation1 k (diagonal1 k (A 1 0)), determinantN.alternating.permutation1_inversions)
  }