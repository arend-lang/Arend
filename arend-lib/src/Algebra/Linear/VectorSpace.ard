\import Algebra.Field
\import Algebra.Linear.Matrix
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Pointed
\import Arith.Nat
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Set

\class VectorSpace \extends LModule {
  \override R : DiscreteField
}

\class FinVectorSpace \extends VectorSpace
  | isFreeVectorSpace : ∃ (l : Array E) (IsBasis l)

\meta VectorSpace' K => VectorSpace { | R => K }

\meta FinVectorSpace' K => FinVectorSpace { | R => K }

\lemma vectorSpace-bases {K : DiscreteField} {U V : VectorSpace' K} (f : LinearMap' U V) (lU' : Array U) (bU : U.IsBasis lU') (lV' : Array V) (bV : V.IsBasis lV')
  : ∃ (lU : Array U lU'.len) (U.IsBasis lU) (lV : Array V lV'.len) (V.IsBasis lV) (k : Nat) (k <= lU'.len) (k<=V : k <= lV'.len)
      (\Pi (i : Fin lU'.len) (i<k : i < k) -> f (lU i) = lV (toFin i $ <-transitive-left i<k k<=V))
      (\Pi (i : Fin lU'.len) -> k <= i -> f (lU i) = 0)
  => {?}

\lemma vectorSpace-bases' {K : DiscreteField} {n m : Nat} (A : Matrix K n m)
  : ∃ (B : Matrix K n n) (determinant B /= 0) (C : Matrix K m m) (determinant C /= 0) (k : Nat) (B MatrixRing.product A MatrixRing.product C = partialId k)
  => {?}
  \where {
    \func partialId {K : DiscreteField} {n m : Nat} (k : Nat) : Matrix K n m
      => mkMatrix \lam i j => \case decideEq (i : Nat) j, LinearOrder.dec<_<= (i : Nat) k \with {
        | yes _, inl _ => ide
        | _, _ => zro
      }
  }