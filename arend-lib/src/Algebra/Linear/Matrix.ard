\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.Symmetric
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Fin
\import Arith.Int
\import Arith.Nat
\import Data.Array
\import Data.Fin (fsuc, fsuc/=)
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin
\open FinLinearOrder

\type Matrix (R : \Type) (n m : Nat) => Array (Array R m) n

\func mkMatrix {R : \Type} {n m : Nat} (f : Fin n -> Fin m -> R) : Matrix R n m
  => \new Array (Array R m) n $ \lam i => \new Array R m (f i)

\func matrixFromArrays {R : \Type} {n m : Nat} (M : Array (Array R m) n) : Matrix R n m => M

\func matrixExt {R : \Type} {n m : Nat} {M N : Matrix R n m} (p : \Pi (i : Fin n) (j : Fin m) -> M i j = N i j) : M = N
  => path (\lam i => mkMatrix (\lam j k => p j k i))

\instance MatrixModule (R : Ring) (n m : Nat) : LModule' R \cowith
  | E => Matrix R n m
  | zro => mkMatrix $ \lam _ _ => zro
  | + => MatrixRing.add
  | zro-left => matrixExt $ \lam i j => zro-left
  | +-assoc => matrixExt $ \lam i j => +-assoc
  | +-comm => matrixExt $ \lam i j => +-comm
  | negative M => mkMatrix $ \lam i j => negative (M i j)
  | negative-left => matrixExt $ \lam i j => negative-left
  | *c a M => mkMatrix $ \lam i j => a * M i j
  | *c-assoc => matrixExt $ \lam i j => *-assoc
  | *c-ldistr => matrixExt $ \lam i j => ldistr
  | *c-rdistr => matrixExt $ \lam i j => rdistr
  | ide_*c => matrixExt $ \lam i j => ide-left

\instance MatrixRing (R : Ring) (n : Nat) : Ring (Matrix R n n)
  | AbGroup => MatrixModule R n n
  | ide : Matrix R n n => mkMatrix $ \lam i j => \case decideEq i j \with {
    | yes _ => R.ide
    | no _ => zro
  }
  | * => product
  | ide-left => product_ide-left
  | ide-right => product_ide-right
  | *-assoc => product-assoc
  | ldistr => matrix_ldistr
  | rdistr => matrix_rdistr
  \where {
    \open AddMonoid

    \func add {R : AddMonoid} {n m : Nat} (M N : Matrix R n m) : Matrix R n m
      => mkMatrix $ \lam i j => M i j + N i j

    \func product {R : Ring} {n m k : Nat} (M : Matrix R n m) (N : Matrix R m k) : Matrix R n k
      => mkMatrix $ \lam i k => BigSum $ \new Array R m $ \lam j => M i j * N j k

    \lemma product_ide-left {R : Ring} {n m : Nat} {M : Matrix R n m} : product ide M = M
      => matrixExt $ \lam i j => BigSum-unique i (\lam k i/=k => later $ rewrite (decideEq/=_reduce i/=k) R.zro_*-left) *> rewrite (decideEq=_reduce idp) ide-left

    \lemma product_ide-right {R : Ring} {n m : Nat} {M : Matrix R n m} : product M ide = M
      => matrixExt $ \lam i j => BigSum-unique j (\lam k j/=k => later $ rewrite (decideEq/=_reduce (\lam t => j/=k (inv t))) R.zro_*-right) *> rewrite (decideEq=_reduce idp) ide-right

    \lemma product-assoc {R : Ring} {n m k l : Nat} {M : Matrix R n m} {N : Matrix R m k} {L : Matrix R k l} : product (product M N) L = product M (product N L)
      => matrixExt $ \lam j1 j2 => path (\lam i => BigSum (\new Array R k (\lam j3 => R.BigSum-rdistr {\new Array R m (\lam j4 => M j1 j4 * N j4 j3)} {L j3 j2} i))) *>
            R.BigSum-transpose _ *> pmap BigSum (arrayExt $ \lam j3 => pmap BigSum $ arrayExt $ \lam j4 => *-assoc) *>
            inv (path (\lam i => BigSum (\new Array R m (\lam j3 => R.BigSum-ldistr {M j1 j3} {\new Array R k (\lam j4 => N j3 j4 * L j4 j2)} i))))

    \lemma matrix_ldistr {R : Ring} {n m k : Nat} {L : Matrix R n m} {M N : Matrix R m k} : product L (add M N) = add (product L M) (product L N)
      => matrixExt $ \lam i j => pmap BigSum (arrayExt $ \lam k => ldistr) *> R.BigSum_+

    \lemma matrix_rdistr {R : Ring} {n m k : Nat} {M N : Matrix R n m} {L : Matrix R m k} : product (add M N) L = add (product M L) (product N L)
      => matrixExt $ \lam i j => pmap BigSum (arrayExt $ \lam k => rdistr) *> R.BigSum_+

    \lemma ide_generates {R : Ring} {n : Nat} : LModule.isGenerated {ArrayLModule n (RingLModule R)} ide
      => \lam l => inP (l, arrayExt $ \lam j => inv $ ArrayLModule.BigSum-index *> R.BigSum-unique j (\lam i j/=i => later $ rewrite (decideEq/=_reduce $ \lam p => j/=i (inv p)) zro_*-right) *> rewrite (decideEq=_reduce idp) ide-right)

    -- | A recursive definition of the identity matrix is sometimes more convenient.
    \func ide' {R : Ring} {n : Nat} : Array (Array R n) n \elim n
      | 0 => nil
      | suc n => (1 :: replicate n zro) :: map (\lam l => R.zro :: l) ide'

    \lemma ide=ide' {R : Ring} {n : Nat} : ide {R} {n} = ide' \elim n
      | 0 => idp
      | suc n => matrixExt $ \case \elim __, \elim __ \with {
        | 0, 0 => idp
        | 0, suc j => idp
        | suc i, 0 => idp
        | suc i, suc j => (later $ cases (decideEq i j) \with {
          | yes e => rewrite (decideEq=_reduce $ pmap fsuc e) idp
          | no q => rewrite (decideEq/=_reduce $ fsuc/= q) idp
        }) *> pmap (__ i j) ide=ide'
      }
  }

\func determinant {R : CRing} {n : Nat} (M : Matrix R n n)
  => R.FinSum $ \lam (e : Sym n) => sign e * R.BigProd (\lam j => M (e j) j)
  \where {
    \func minor {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m
      => map (skip __ j0) (skip M i0)

    \func minor' {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m
      => skip (map (skip __ j0) M) i0

    \func minor=minor' {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : minor M i0 j0 = minor' M i0 j0
      => matrixExt (aux M i0 j0)
      \where {
        \func aux {R : \Type} {n m : Nat} (M : Array (Array R (suc m)) (suc n)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) (i : Fin n) (j : Fin m)
          : skip (skip M i0 i) j0 j = skip {Array R m} (map (skip __ j0) M) i0 i j \elim n, M, i0, i
          | suc n, l :: M, 0, i => idp
          | suc n, l :: M, suc i0, 0 => idp
          | suc n, l :: M, suc i0, suc i => aux M i0 j0 i j
      }

    \lemma multilinear {R : CRing} {n : Nat} : isMultiLinear {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinant M) \elim n
      | 0 => ()
      | suc n => transportInv (\lam d => isMultiLinear {R} (\lam M => d M)) (path $ \lam i M => determinantN.determinant=determinant0 {R} {n} {M} i) (determinantN.multilinear {R} {suc n} 0)

    \lemma alternating {R : CRing} {n : Nat} : isAlternating {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinant M) \elim n
      | 0 => ((), \lam _ (t,_,_,_) => \case t)
      | suc n => transportInv (\lam d => isAlternating {R} (\lam M => d M)) (path $ \lam i M => determinantN.determinant=determinant0 {R} {n} {M} i) (determinantN.alternating {R} {suc n} 0)
  }

\func determinantN {R : CRing} {n : Nat} (k : Fin n) (M : Matrix R n n) : R \elim n
  | 0 => 1
  | suc n => R.BigSum $ \lam i => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)
  \where {
    \open determinant
    \open skip
    \open ArrayLModule

    \lemma minor_insert {R : CRing} {n m : Nat} {i : Fin (suc n)} {x : Array R (suc m)} {l : Array (Array R (suc m)) n} {j : Fin (suc m)}
      : minor (insert x l i) i j = \new Array (Array R m) n (\lam i => skip (l i) j)
      => path (\lam i' => map (skip __ j) (skip_insert_= i'))

    \lemma aux/= {R : CRing} {n m : Nat} {j i : Fin (suc n)} (p : j /= i) {k : Fin (suc m)} {x : Array R (suc m)} {M : Array (Array R (suc m)) n}
      : insert {Array R (suc m)} x M j i k = M (newIndex (\lam q => p (inv q))) k \elim n, j, i, M
      | _, 0, 0, _ => absurd (p idp)
      | suc n, 0, suc i, y :: M => idp
      | suc n, suc j, 0, y :: M => idp
      | suc n, suc j, suc i, y :: M => aux/= (\lam q => p (pmap fsuc q))

    \func minor_replace {R : CRing} {n : Nat} {i k : Fin (suc n)} {M : Array (Array R (suc n)) (suc n)} {j : Fin (suc n)} {x : Array R (suc n)} (p : j /= i)
      : minor (replace M j x) i k = replace (minor M i k) (newIndex p) (skip x k)
      => path (\lam i => map (skip __ k) (skip_replace_/= p i)) *> pmap matrixFromArrays (map_replace (skip __ k))

    \lemma multilinear {R : CRing} {n : Nat} (k : Fin n) : isMultiLinear {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinantN k M) \elim n
      | 0 => ()
      | suc n => isMultilinear_BigSum {R} {suc n} {ArrayLModule (suc n) (RingLModule R)} (\lam i M => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)) $ \lam i M j => \case decideEq j i \with {
        | yes e => \new LinearMap {
          | func-+ {a} {b} => rewrite e $ *-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)}) *> rdistr *> pmap2 (+)
                                (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
                                (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
        | func-*c {r} {a} => rewrite e $ *-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)}) *> *-assoc *> pmap (r *) (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
        }
        | no q => \new LinearMap {
          | func-+ => rewrite (aux/= q, aux/= q, aux/= q) $ pmap (_ *) (inv (path (\lam i' => determinant (minor (replace_insert {_} {M} {j} {replicate (suc n) R.zro} i') i k))) *> pmap determinant (minor_replace q) *> later (rewrite skip_+ $ func-+ {isMultiLinear.toReplace {R} {_} {_} {n} determinant.multilinear _ _} *> pmap2 (determinant __ + determinant __) (inv (minor_replace q) *> path (\lam i' => minor (replace_insert i') i k)) (inv (minor_replace q) *> path (\lam i' => minor (replace_insert i') i k)))) *> ldistr
          | func-*c {r} {x} => rewrite (aux/= q, aux/= q) $ pmap (_ * _ * __) (inv (path (\lam i' => determinant (minor (replace_insert {_} {M} {j} {replicate (suc n) R.zro} i') i k))) *> pmap determinant (minor_replace q) *> later (rewrite skip_*c $ func-*c {isMultiLinear.toReplace {R} {_} {_} {n} determinant.multilinear _ _} *> pmap (r * determinant __) (inv (minor_replace q))) *> path (\lam i' => r * determinant (minor (replace_insert i') i k)) *> *-comm) *> inv *-assoc *> *-comm
        }
      }

    \lemma alternating {R : CRing} {n : Nat} (k : Fin n) : isAlternating {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinantN k M) \elim n
      | 0 => ((), \lam _ => \case __.1)
      | suc n => (multilinear k, aux k)
      \where {
        \open NatSemiring(<,suc<suc)

        \func permutation1 {R : \Type} {n : Nat} (j : Fin (suc n)) (l : Array R (suc n)) : Perm l (l j :: skip l j) \elim n, j, l
          | 0, 0, l => Perm.perm-refl
          | suc n, 0, l => Perm.perm-refl
          | suc n, suc j, a :: l => perm-trans (perm-:: idp (permutation1 j l)) (perm-swap idp idp idp)

        \func permutation {R : \Type} {n : Nat} {i j : Fin (suc n)} (p : i < j) (l : Array R (suc n)) (q : l i = l j) : Perm (skip l i) (skip l j) \elim n, i, j, p, l, q
          | 0, 0, 0, (), _, _
          | suc n, 0, suc j, _, a :: l, idp => permutation1 j l
          | suc n, suc i, suc j, suc<suc p, a :: l, q => perm-:: idp (permutation p l q)

        \lemma permutation1_inversions {R : \Type} {n : Nat} {j : Fin (suc n)} {l : Array R (suc n)} : Perm.inversions (permutation1 j l) = j \elim n, j, l
          | 0, 0, l => idp
          | suc n, 0, a :: l => Perm.inversions_perm-:: *> Perm.inversions_perm-refl
          | suc n, suc j, a :: l => pmap suc permutation1_inversions

        \lemma permutation_inversions {R : \Type} {n : Nat} {i j : Fin (suc n)} {p : i < j} {l : Array R (suc n)} {q : l i = l j} : Perm.inversions (permutation p l q) = j -' suc i \elim n, i, j, p, l, q
          | 0, 0, 0, (), _, _
          | suc n, 0, suc j, _, a :: l, idp => permutation1_inversions *> inv -'0
          | suc n, suc i, suc j, suc<suc p, a :: l, q => Perm.inversions_perm-:: *> permutation_inversions

        \lemma aux {R : CRing} {n : Nat} (k : Fin n) (M : Array (Array R n) n) (t : \Sigma (i j : Fin n) (i < j) (M i = M j)) : determinantN k M = 0 \elim n
          | 0 => \case t.1
          | suc n => R.BigSum-unique2 {\lam i => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)} t.3 (\lam i i/=t1 i/=t2 => pmap (_ *) (determinant.alternating.2 (minor M i k) (newIndex $ \lam p => i/=t1 (inv p), newIndex $ \lam p => i/=t2 (inv p), newIndex_< t.3, pmap (skip __ k) $ skip-index *> t.4 *> inv skip-index)) *> zro_*-right) *>
                      rewrite (pmap {Array R _} (__ k) t.4) (pmap2 (+) *-assoc *-assoc *> inv ldistr *> pmap (_ *) (later $ rewrite (minor=minor', minor=minor', isAlternating.alternating_perm {R} determinant.alternating $ permutation t.3 (map (skip __ k) M) $ pmap (skip __ k) t.4) $ rewriteI *-assoc $ inv rdistr *> pmap (`* _) (unfold Perm.sign $ rewrite (permutation_inversions, inv R.pow_+, inv R.pow_-1_+2) $
                        \have s : t.1 Nat.+ k Nat.+ (t.2 -' suc t.1) Nat.+ 2 = suc (t.2 Nat.+ k) => pmap suc $ unpos $ pmap (pos (suc (t.1 Nat.+ k)) +) (-'=- $ suc_<_<= t.3) *> linarith
                        \in pmap (R.pow -1 __ + _) s *> pmap (`+ _) R.negative_ide-right *> negative-left) *> zro_*-left) *> zro_*-right)
      }

    \lemma determinantN_ide {R : CRing} {n : Nat} (k : Fin n) : determinantN k (MatrixRing.ide {R} {n}) = 1 \elim n
      | 0 => idp
      | suc n => R.BigSum-unique {\lam i => MatrixRing.ide i k * R.pow -1 (i Nat.+ k) * determinant (minor MatrixRing.ide i k)} k (\lam j k/=j => rewrite (decideEq/=_reduce $ \lam p => k/=j $ inv p) simplify) *>
                  rewrite (decideEq=_reduce idp, ide-left) (pmap2 (*) R.pow_-1_even (pmap determinant (pmap (minor __ k k) MatrixRing.ide=ide' *> ide'_minor k *> inv MatrixRing.ide=ide') *> determinant_ide {R} {n}) *> ide-left)
      \where {
        \func double-skip {R : \Set} {n m : Nat} {M : Array (Array R n) (suc m)} {k : Fin (suc m)} {i : Fin m} {j : Fin n}
          : skip {Array R _} M k i j = skip (map {Array R n} (__ j) M) k i \elim m, M, k, i
          | suc m, l :: M, 0, i => idp
          | suc m, l :: M, suc k, 0 => idp
          | suc m, l :: M, suc k, suc i => double-skip

        \lemma ide'_minor {R : Ring} {n : Nat} (k : Fin (suc n)) : determinant.minor (MatrixRing.ide' {R}) k k = MatrixRing.ide' \elim n, k
          | 0, k => idp
          | suc n, 0 => idp
          | suc n, suc k => pmap matrixFromArrays $ pmap2 (::) (pmap (\lam l => R.ide :: l) (skip_replicate R.zro)) $ arrayExt $ \lam i => pmap2 (::) (double-skip *> pmap {Array R _} (__ i) (skip_replicate R.zro {k})) $ cong (arrayExt $ \lam j => double-skip *> inv double-skip) *> pmap {Matrix R n n} (__ i) (ide'_minor k)
      }

    \lemma =determinant {R : CRing} {n : Nat} {k : Fin n} {M : Matrix R n n} : determinantN k M = determinant M
      => alternating-unique {R} (alternating k) determinant.alternating MatrixRing.ide_generates (determinantN_ide k *> inv determinant_ide) M

    \open AbMonoid
    \open Monoid

    \lemma determinant=determinant0 {R : CRing} {n : Nat} {M : Matrix R (suc n) (suc n)} : determinant M = determinantN {R} {suc n} 0 M
      => \have t (e : Sym (suc n)) : BigProd (\lam j => minor M (e 0) 0 (Sym.reduce e j) j) = BigProd (\lam j => M (e (fsuc j)) (fsuc j)) => cong (ext $ \lam j => minor_Sym)
         \in FinSum (\lam (e : Sym (suc n)) => sign e * BigProd (\lam j => M (e j) j)) ==< pmap FinSum (ext $ \lam e => rewrite (t,R.pow_+) equation) *> inv (FinSum_Equiv symmetric-rec) >==
             FinSum (\lam (p : \Sigma (Fin (suc n)) (Sym n)) => M p.1 0 * pow -1 p.1 * (sign p.2 * BigProd (\lam j => minor M p.1 0 (p.2 j) j))) ==< inv FinSum-double >==
             FinSum (\lam i => FinSum (\lam (e : Sym n) => M i 0 * pow -1 i * (sign e * BigProd (\lam j => minor M i 0 (e j) j)))) ==< cong (ext $ \lam i => inv R.FinSum-ldistr) >==
             FinSum (\lam i => M i 0 * pow -1 i * determinant (minor M i 0)) ==< FinSum=BigSum >==
             R.BigSum (\lam i => M i 0 * pow -1 i * determinant (minor M i 0)) `qed
      \where {
        \func skip_skip {A : \Type} {n : Nat} {l : Array A (suc n)} {k j : Fin (suc n)} {d : k /= j} : skip l k (FinSet.skip k j d) = l j \elim n, l, k, j
          | n, l, 0, 0 => absurd (d idp)
          | suc n, a :: l, 0, suc j => idp
          | suc n, a :: l, suc k, 0 => idp
          | suc n, a :: l, suc k, suc j => skip_skip

        \func minor_Sym {A : \Type} {n : Nat} {M : Matrix A (suc n) (suc n)} {e : Sym (suc n)} {j : Fin n} : minor M (e 0) 0 (Sym.reduce e j) j = M (e (suc j)) (suc j)
          => skip_0 *> pmap {Array A (suc n)} (__ (suc j)) (skip_skip {Array A (suc n)})
      }
  }

\lemma determinant_ide {R : CRing} {n : Nat} : determinant (MatrixRing.ide {R} {n}) = 1 \elim n
  | 0 => \case AbMonoid.FinSum.char _ \with {
    | inP p => p.2 *> zro-right *> ide-right
  }
  | suc n => rewrite determinantN.determinant=determinant0 (determinantN.determinantN_ide {R} {suc n} 0)
  \where {
    \lemma ide_minor {R : Ring} {n : Nat} : determinant.minor (MatrixRing.ide {R} {suc n}) 0 0 = 1 \elim n
      | 0 => idp
      | suc n => matrixExt $ \lam i j => mcases {2} \with {
        | yes p => rewrite (decideEq=_reduce $ pmap fsuc p) idp
        | no q => rewrite (decideEq/=_reduce $ fsuc/= q) idp
      }
  }

\lemma determinant_* {R : CRing} {n : Nat} (M N : Matrix R n n) : determinant (M * N) = determinant M * determinant N
  => alternating-unique {R}
      (isAlternating_linear-left {R} (\new LinearMap {
        | func (l : Array R n) => mkArray $ \lam k => R.BigSum $ \lam j => l j * N j k
        | func-+ => arrayExt $ \lam k => pmap R.BigSum (arrayExt $ \lam j => rdistr) *> R.BigSum_+
        | func-*c => arrayExt $ \lam k => pmap R.BigSum (arrayExt $ \lam j => *-assoc) *> inv R.BigSum-ldistr
      }) determinant.alternating)
      (isAlternating_linear-right {R} determinant.alternating RingLModule.*_hom-right)
      MatrixRing.ide_generates
      (pmap determinant ide-left *> inv (pmap (`* _) determinant_ide *> ide-left))
      M

\func transpose {R : \Type} {n m : Nat} (M : Matrix R n m) : Matrix R m n
  => mkMatrix (\lam i j => M j i)

\lemma determinant_transpose {R : CRing} {n : Nat} {M : Matrix R n n} : determinant (transpose M) = determinant M
  => R.FinSum_Equiv SymmetricGroup.inv-isEquiv *> pmap R.FinSum (ext $ \lam (e : Sym n) => pmap2 (*) sign_inverse $ CMonoid.BigProd_Perm $ transport (Perm _) (arrayExt $ \lam j => later $ pmap (M (e j)) (e.ret_f j)) (Perm.equiv_perm e))

\func adjugate {R : CRing} {n : Nat} (M : Matrix R n n) : Matrix R n n \elim n
  | 0 => M
  | suc n => mkMatrix $ \lam i j => Monoid.pow -1 (j + i) * determinant (determinant.minor M j i)

\lemma determinant_adjugate_= {R : CRing} {n : Nat} {M : Matrix R (suc n) (suc n)} (k : Fin (suc n)) : determinant M = R.BigSum (\lam j => M j k * adjugate M k j)
  => inv ({?} *> determinantN.=determinant {R} {suc n} {k} {M})

\lemma adjugate-left {R : CRing} {n : Nat} {M : Matrix R n n} : adjugate M * M = determinant M *c ide
 => matrixExt $ \lam i k => mcases \with {
      | yes p => rewrite p {?} *> inv ide-right
      | no q => {?} *> inv zro_*-right
    }