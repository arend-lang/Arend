\import Algebra.Monoid
\import Paths

\class Group \extends Monoid {
  | inverse : E -> E
  | inverse-left (x : E) : inverse x * x = id
  | inverse-right (x : E) : x * inverse x = id

  \func cancelLeft (x y z : E) (p : x * y = x * z) : y = z =>
    y                   ==< inv (id-left y) >==
    id * y              ==< pmap (\lam t => t * y) (inv (inverse-left x)) >==
    (inverse x * x) * y ==< *-assoc (inverse x) x y >==
    inverse x * (x * y) ==< pmap (\lam t => inverse x * t) p >==
    inverse x * (x * z) ==< inv (*-assoc (inverse x) x z) >==
    (inverse x * x) * z ==< pmap (\lam t => t * z) (inverse-left x) >==
    id * z              ==< id-left z >==
    z                   `qed
}

\class AddGroup \extends AddMonoid
  | addInverse : E -> E
  | addInverse-left (x : E) : addInverse x + x = addId
  | addInverse-right (x : E) : x + addInverse x = addId
  \where {
    \use \coerce fromGroup (G : Group) => \new AddGroup G.E G.id (G.*) G.id-left G.id-right G.*-assoc G.inverse G.inverse-left G.inverse-right
    \use \coerce toGroup (G : AddGroup) => \new Group G.E G.addId (G.+) G.addId-left G.addId-right G.+-assoc G.addInverse G.addInverse-left G.addInverse-right
  }

\class CGroup \extends Group, CMonoid
  | inverse-right x => *-comm x (inverse x) *> inverse-left x

\class AbGroup \extends AddGroup, AbMonoid
  | addInverse-right x => +-comm x (addInverse x) *> addInverse-left x
  \where {
    \use \coerce fromCGroup (G : CGroup) => \new AbGroup G.E G.id (G.*) G.id-left G.*-assoc G.inverse G.inverse-left G.*-comm
    \use \coerce toCGroup (G : AbGroup) => \new CGroup G.E G.addId (G.+) G.addId-left G.+-assoc G.addInverse G.addInverse-left G.+-comm
  }
