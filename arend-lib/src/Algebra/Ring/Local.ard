\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ring
\import Logic
\import Paths
\open Monoid(Inv,LInv)

\class LocalRing \extends Ring {
  | zro/=ide : Not (zro = ide)
  | locality (x y : E) : x + y = ide -> Inv x || Inv y

  \lemma sumInv=>eitherInv (x y : E) (q : Inv (x + y)) : Inv x || Inv y =>
    \case locality (q.inv * x) (q.inv * y) (inv (ldistr q.inv x y) *> q.inv-left) \with {
      | byLeft s => byLeft (Inv.factor-right q.inv x (\new LInv q.inv (x + y) q.inv-right) s)
      | byRight s => byRight (Inv.factor-right q.inv y (\new LInv q.inv (x + y) q.inv-right) s)
    }
} \where {
  \open Ring
  \open AddGroup(negative-isInvolution)

  \class Impl \extends LocalRing, AddGroup.With#
    | #0 x => Inv x
    | #0-+ => sumInv=>eitherInv
    | #0-zro (j : Inv zro) => zro/=ide (inv (zro_*-right j.inv) *> j.inv-left)
    | #0-negative x (j : Inv x) => \new Inv {
      | inv => negative j.inv
      | inv-left => negative_*-left j.inv (negative x) *> pmap negative (negative_*-right j.inv x) *> negative-isInvolution (j.inv * x) *> j.inv-left
      | inv-right => negative_*-left x (negative j.inv) *> pmap negative (negative_*-right x j.inv) *> negative-isInvolution (x * j.inv) *> j.inv-right
    }
}

\class LocalCRing \extends LocalRing, CRing
  \where {
    \class Impl \extends LocalCRing, LocalRing.Impl, CRing.With#
      | #0-*-left => Inv.cfactor-left
  }
