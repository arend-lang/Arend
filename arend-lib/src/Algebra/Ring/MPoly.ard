\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Ring.Poly
\import Arith.Nat
\import Equiv
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.StrictOrder
\import Set.Fin.KFin

-- \data MPoly (R : AddPointed) => mPoly (f : Nat -> R) (TruncP (KFinSet (\Sigma (n : Nat) (f n /= 0))))

\lemma polyExt {R : AddPointed} (p q : Poly R) (c : \Pi (n : Nat) -> polyCoef p n = polyCoef q n) : p = q \elim p, q
  | pzero, pzero => idp
  | pzero, padd q e => {?}
  | padd p e, pzero => {?}
  | padd p e, padd q e' => {?}

\func Cond (R : AddPointed) (f : Nat -> R) => ∃ (p : Poly R) (polyCoef p = f)

\func Cond' (R : AddPointed) (f : Nat -> R) => ∃ (n : Nat) (\Pi (k : Nat) -> n < k -> f k = 0)

\func Cond=>Cond' {R : AddPointed} {f : Nat -> R} (c : Cond R f) : Cond' R f \elim c
  | inP c => \case degree-exists c.1 \with {
    | inP d => inP (d.1, {?})
  }

\func Cond'=>Cond {R : AddPointed} {f : Nat -> R} (c : Cond' R f) : Cond R f \elim c
  | inP c => inP {?}

{-
\Sigma (n : Nat) (Quotient (Array J n) Perm)
\Sigma (f : J -> Nat)
 -}

\record MPoly (R : AddPointed)
  | mCoef : Nat -> R
  | mPolyFin : TruncP (KFinSet (\Sigma (n : Nat) (mCoef n /= 0)))
  \where {
    \func madd {R : AddPointed} (p : MPoly R) (a : R) : MPoly R \cowith
      | mCoef => \case \elim __ \with {
        | 0 => a
        | suc n => p.mCoef n
      }
      | mPolyFin => \case p.mPolyFin \with {
        | inP (c : KFinSet) => inP $ \new KFinSet {
          | finCard => suc c.finCard
          | finSurj => TruncP.map c.finSurj $ \lam d => (\case \elim __ \with {
            | 0 => {?}
            | suc j => {?}
          }, {?})
        }
      }

    \func fromPoly {R : AddPointed} (p : Poly R) : MPoly R \elim p
      | pzero => \new MPoly R (\lam _ => 0) $ inP $ \new KFinSet {
        | finCard => 0
        | finSurj => inP ((\case __), \lam y => absurd $ y.2 idp)
      }
      | padd p e => {?}
      | peq => {?}

    -- \func equiv {R : AddPointed} : Equiv {Poly R} {MPoly R}
  }