\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Pointed.PointedHom
\import Algebra.Ring
\import Algebra.Ring.RingHom
\import Algebra.Ring.QPoly
\import Arith.Nat
\import Data.Array
\import Equiv
\import Equiv.Fiber
\import Equiv.Univalence
\import Function
\import Function.Meta
\import Logic.Unique
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set.Countable
\open Monoid

\data Poly (R : AddPointed)
  | pzero
  | padd (Poly R) R
  | peq : padd pzero 0 = pzero
  \where {
    \open QPoly

    \use \func toQPoly {R : AddPointed} (p : Poly R) : QPoly R \elim p
      | pzero => in~ nil
      | padd p e => qadd (toQPoly p) e
      | peq => path (~-equiv _ _ idp)

    \use \func fromArray {R : AddPointed} (l : Array R) : Poly R \elim l
      | nil => pzero
      | :: a l => padd (fromArray l) a

    \use \func cfunc {R : AddPointed} (l : Array R) : toQPoly (fromArray l) = in~ l \elim l
      | nil => idp
      | :: a l => pmap (qadd __ a) (cfunc l)

    \use \func path-lem {R : AddPointed} {p : R.zro = R.zro} : inv (path peq) *> pmap2 padd idp p *> path peq = idp
      => pmap (inv (path peq) *> pmap2 padd idp __ *> path peq) (prop-isProp _ idp) *> pmap (_ *>) (idp_*> _) *> inv_*> _

    \use \func toQPoly-nil {R : AddPointed} {p : Poly R} : toQPoly p = in~ nil -> p = pzero \elim p
      | pzero => \lam _ => idp
      | padd p e => \lam s => \have t => qadd_nil s \in pmap2 padd (toQPoly-nil t.1) t.2 *> path peq
      | peq => pathOver $ coe_pi *> ext (\lam s => coe_path (path peq) _ idp *> path-lem)

    \use \func gfunc {R : AddPointed} (l : Array R) (p : Poly R) : toQPoly p = in~ l -> p = fromArray l \elim l, p
      | nil, pzero => \lam _ => idp
      | nil, padd p e => \lam s => pmap2 padd (toQPoly-nil (qadd_nil s).1) (qadd_nil s).2 *> path peq
      | nil, peq => pathOver $ coe_pi *> ext (\lam _ => coe_path (path peq) _ idp *> path-lem)
      | :: a l, pzero => \lam s => inv (path peq) *> pmap2 padd (gfunc l pzero (nil_cons s).2) (nil_cons s).1
      | :: a l, padd p e => \lam s => pmap2 padd (gfunc l p (qadd_cons s).2) (qadd_cons {_} {e} {a} {toQPoly p} {l} s).1
      | :: a l, peq => pathOver $ coe_pi *> ext (\lam s => coe_path (path peq) _ idp *> pmap (inv (path peq) *>) (pmap2 (\lam x => pmap2 padd (gfunc l pzero x)) prop-pi set-pi))

    \use \lemma toQPoly-equiv {R : AddPointed} : Equiv (toQPoly {R})
      => contrFibers=>Equiv \case \elim __ \with {
        | in~ l => \new Contr {
          | center => (fromArray l, cfunc l)
          | contraction t => ext (inv (gfunc l t.1 t.2))
        }
      }

    \use \level levelSet {R : AddPointed} : isSet (Poly R)
      => transportInv isSet (Equiv-to-= toQPoly-equiv) (\lam _ _ _ _ => set-pi)

    \func poly-countable {R : AddPointed} (c : Countable R) : Countable (Poly R)
      => surj-countable (quotient-countable (array-countable c)) (Equiv.isSurj {symQEquiv toQPoly-equiv})

    \lemma poly-trivial {R : AddPointed} (p : \Pi (x : R) -> x = zro) (p : Poly R) : p = pzero \elim p
      | pzero => idp
      | padd q e => pmap2 padd (poly-trivial p q) (p e) *> peq
  }

\func polyMap (f : AddPointedHom) (p : Poly f.Dom) : Poly f.Cod \elim p
  | pzero => pzero
  | padd p e => padd (polyMap f p) (f e)
  | peq => rewrite f.func-zro peq

\lemma polyMap-comp {A B C : AddPointed} (f : AddPointedHom A B) (g : AddPointedHom B C) {p : Poly A} : polyMap g (polyMap f p) = polyMap (g AddPointedHom.∘ f) p \elim p
  | pzero => idp
  | padd p e => pmap (padd __ _) (polyMap-comp f g)

\lemma polyMap-inj {A B : AddPointed} {f : AddPointedHom A B} (inj : isInj f) {p q : Poly A} (s : polyMap f p = polyMap f q) : p = q \elim p, q
  | pzero, pzero => idp
  | pzero, padd q b => inv peq *> pmap2 padd (polyMap-inj {_} {_} {f} inj $ pmap polyShift s) (inj $ func-zro *> pmap (polyCoef __ 0) s)
  | padd p a, pzero => pmap2 padd (polyMap-inj {_} {_} {f} inj $ pmap polyShift s) (inj $ pmap (polyCoef __ 0) s *> inv func-zro) *> peq
  | padd p a, padd q b => pmap2 padd (later $ polyMap-inj {_} {_} {f} inj $ pmap polyShift s) (inj $ pmap (polyCoef __ 0) s)

\lemma polyMap_fromArray {f : AddPointedHom} {l : Array f.Dom} : polyMap f (Poly.fromArray l) = Poly.fromArray (map f l) \elim l
  | nil => idp
  | a :: l => pmap (padd __ _) polyMap_fromArray

\func polyEval {R : Ring} (p : Poly R) (a : R) : R \elim p
  | pzero => 0
  | padd p e => polyEval p a * a + e
  | peq => zro-right *> R.zro_*-left

\func polyMapEval {A : AddPointed} {R : Ring} (f : AddPointedHom A R) (p : Poly A) (a : R) : R
  => polyEval (polyMap f p) a

\lemma polyEval_polyMap {f : RingHom} {p : Poly f.Dom} {a : f.Dom} : polyEval (polyMap f p) (f a) = f (polyEval p a) \elim p
  | pzero => inv func-zro
  | padd p e => inv $ f.func-+ *> pmap (`+ _) (f.func-* *> pmap (`* _) (inv polyEval_polyMap))

\func polyCoef {R : AddPointed} (p : Poly R) (n : Nat) : R \elim p, n
  | pzero, _ => 0
  | padd p e, 0 => e
  | padd p e, suc n => polyCoef p n
  | peq, 0 => idp
  | peq, suc n => idp

\lemma polyCoef=0 {R : AddPointed} {r : R} {n : Nat} (n>0 : 0 < n) : polyCoef (padd pzero r) n = 0 \elim n
  | suc n => idp

\lemma polyCoef_polyMap {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} : polyCoef (polyMap f p) n = f (polyCoef p n) \elim p, n
  | pzero, n => inv f.func-zro
  | padd p e, 0 => idp
  | padd p e, suc n => polyCoef_polyMap

\lemma polyEval_fromArray {R : Ring} {l : Array R} {a : R} : polyEval (Poly.fromArray l) a = R.BigSum (\lam j => l j * pow a j) \elim l
  | nil => idp
  | c :: l => +-comm *> pmap2 (+) (inv ide-right) (pmap (`* a) polyEval_fromArray *> R.BigSum-rdistr *> pmap R.BigSum (exts \lam j => *-assoc))

\lemma polyMapEval_fromArray {R : AddPointed} {E : Ring} {f : AddPointedHom R E} {l : Array f.Dom} {a : f.Cod}
  : polyMapEval f (Poly.fromArray l) a = AddMonoid.BigSum (\lam j => f (l j) * pow a j)
  => pmap (polyEval __ a) polyMap_fromArray *> polyEval_fromArray

\lemma polyCoef_fromArray {R : AddPointed} {l : Array R} {j : Fin l.len} : polyCoef (Poly.fromArray l) j = l j \elim l, j
  | a :: l, 0 => idp
  | a :: l, suc j => polyCoef_fromArray

\func lastCoef {R : AddPointed} (p : Poly R) => polyCoef p 0

\func polyShift {R : AddPointed} (p : Poly R) : Poly R \elim p
  | pzero => pzero
  | padd p e => p
  | peq => idp

\lemma poly-root-div {R : CRing} {p : Poly R} {a : R} (q : polyEval p a = 0)
  : LDiv a (polyCoef p 0) (R.negative (polyEval (polyShift p) a)) \elim p
  | pzero => \new LDiv {
    | inv-right => simplify
  }
  | padd p e => \new LDiv {
    | inv-right => R.negative_*-right *> inv (R.fromZero $ +-comm *> pmap (`+ e) (R.negative-isInv *> *-comm) *> q)
  }

\lemma padd=pzero {R : AddPointed} {p : Poly R} {a : R} (q : padd p a = pzero) : \Sigma (p = pzero) (a = 0)
  => \have t => q *> inv peq
     \in (pmap polyShift t, pmap (polyCoef __ 0) t)

\func monomial {R : AddPointed} (c : R) (n : Nat) : Poly R \elim n
  | 0 => padd pzero c
  | suc n => padd (monomial c n) 0

\lemma polyCoef_monomial {R : AddPointed} {c : R} {n : Nat} : polyCoef (monomial c n) n = c \elim n
  | 0 => idp
  | suc n => polyCoef_monomial

\lemma polyMap_monomial {f : AddPointedHom} {c : f.Dom} {n : Nat} : polyMap f (monomial c n) = monomial (f c) n \elim n
  | 0 => idp
  | suc n => pmap2 padd polyMap_monomial func-zro

\lemma polyEval_monomial {R : Ring} {c a : R} {n : Nat} : polyEval (monomial c n) a = c * pow a n \elim n
  | 0 => simplify
  | suc n => rewrite polyEval_monomial equation.semiring

\lemma polyMapEval_monomial {f : RingHom} {a : f.Cod} {n : Nat} : polyMapEval f (monomial 1 n) a = pow a n
  => pmap (polyEval __ a) polyMap_monomial *> polyEval_monomial *> pmap (`* _) func-ide *> ide-left

\lemma monomial_zro {R : AddPointed} {n : Nat} : monomial R.zro n = pzero \elim n
  | 0 => peq
  | suc n => rewrite monomial_zro peq

\func degree< {R : AddPointed} (p : Poly R) (n : Nat)
  => \Pi {k : Nat} -> n <= k -> polyCoef p k = 0

\lemma degree<0 {R : AddPointed} {p : Poly R} (d : degree< p 0) : p = pzero
  => degree<=.trivialPoly (\lam k _ => d zero<=_)

\lemma degree<_padd {R : AddPointed} {p : Poly R} {e : R} {n : Nat} (d : degree< p n) : degree< (padd p e) (suc n)
  => \lam {k} => \case \elim k \with {
    | 0 => \lam s => absurd (s NatOrder.zero<suc)
    | suc k => \lam s => d (suc<=suc.conv s)
  }
  \where
    \lemma conv {R : AddPointed} {p : Poly R} {e : R} {n : Nat} (d : degree< (padd p e) (suc n)) : degree< p n
      => \lam s => d (suc<=suc s)

\lemma degree<_polyMap {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} (d : degree< p n) : degree< (polyMap f p) n \elim p, n
  | pzero, n => \lam _ => idp
  | padd p e, 0 =>
    \have t => padd=pzero (degree<0 d)
    \in rewrite (t.1, t.2, f.func-zro) $ transportInv (degree< __ 0) peq \lam _ => idp
  | padd p e, suc n => degree<_padd $ degree<_polyMap (degree<_padd.conv d)

\lemma polyEval_polyCoef {R : Ring} {p : Poly R} {a : R} {n : Nat} (d : degree< p n) : polyEval p a = R.BigSum (\new Array R n (\lam i => polyCoef p i * R.pow a i)) \elim p, n
  | pzero, n => inv $ R.BigSum_zro \lam j => R.zro_*-left
  | p, 0 => rewrite (degree<0 d) idp
  | padd p e, suc n => rewrite (polyEval_polyCoef (degree<_padd.conv d)) $ pmap2 (+) (R.BigSum-rdistr *> pmap (\lam x => R.BigSum (\new Array R n x)) (ext \lam j => *-assoc)) (inv ide-right) *> +-comm

\lemma polyMapEval_polyCoef {f : RingHom} {p : Poly f.Dom} {a : f.Cod} {n : Nat} (d : degree< p n)
  : polyMapEval f p a = AddMonoid.BigSum (\lam (i : Fin n) => f (polyCoef p i) * pow a i)
  => polyEval_polyCoef (degree<_polyMap d) *> pmap AddMonoid.BigSum (exts \lam j => pmap (`* _) polyCoef_polyMap)

\func degree<= {R : AddPointed} (p : Poly R) (n : Nat) : \Prop
  | pzero, n => \Sigma
  | padd p a, 0 => p = pzero
  | padd p a, suc n => degree<= p n
  | peq, 0 => ext (\lam _ => (), \lam _ => idp)
  | peq, suc n => idp
  \where {

    \lemma toCoefs {R : AddPointed} (p : Poly R) (n : Nat) (d : degree<= p n) {k : Nat} (n<k : n < k) : polyCoef p k = 0 \elim p, n, k, n<k
      | pzero, n, k, _ => idp
      | padd p e, 0, suc k, _ => rewrite d idp
      | padd p e, suc n, suc k, NatOrder.suc<suc n<k => toCoefs p n d n<k

    \lemma trivialPoly {R : AddPointed} {p : Poly R} (d : \Pi (k : Nat) -> degree<= p k -> polyCoef p k = 0) : p = pzero
      => \case degree-exists p \with {
           | inP (n,dp) => aux d n dp
         }
      \where
        \lemma aux {R : AddPointed} {p : Poly R} (d : \Pi (k : Nat) -> degree<= p k -> polyCoef p k = 0) (n : Nat) (dp : degree<= p n) : p = pzero \elim n
          | 0 => degree<=0 p dp *> pmap (padd pzero) (d 0 dp) *> peq
          | suc n => aux d n $ degree-reduce p n dp (d (suc n) dp)

    \lemma fromCoefs {R : AddPointed} (p : Poly R) (n : Nat) (d : \Pi {k : Nat} -> n < k -> polyCoef p k = 0) : degree<= p n \elim p, n
      | pzero, n => ()
      | padd p e, 0 => trivialPoly (\lam k _ => d NatOrder.zero<suc)
      | padd p e, suc n => fromCoefs p n (\lam n<k => d (NatOrder.suc<suc n<k))
  }

\lemma degree<=_degree< {R : AddPointed} {p : Poly R} {n : Nat} (d : degree<= p n) : degree< p (suc n)
  => \lam s => degree<=.toCoefs p n d (id<suc <∘l s)

\lemma degree<_degree<= {R : AddPointed} {p : Poly R} {n : Nat} (d : degree< p (suc n)) : degree<= p n
  => degree<=.fromCoefs p n \lam q => d (suc_<_<= q)

\lemma degree<=_polyMap {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} (d : degree<= p n) : degree<= (polyMap f p) n
  => degree<_degree<= $ degree<_polyMap (degree<=_degree< d)

\lemma degree-exists {R : AddPointed} (p : Poly R) : ∃ (n : Nat) (degree<= p n) \elim p
  | pzero => inP (0, ())
  | padd p e => TruncP.map (degree-exists p) \lam s => (suc s.1, s.2)

\lemma degree<-exists {R : AddPointed} (p : Poly R) : ∃ (n : Nat) (degree< p n)
  => TruncP.map (degree-exists p) \lam s => (suc s.1, degree<=_degree< s.2)

\lemma degree<=-trans {R : AddPointed} {p : Poly R} {n m : Nat} (d : degree<= p n) (n<=m : n <= m) : degree<= p m \elim p, n, m
  | pzero, n, m => ()
  | padd p x, 0, 0 => d
  | padd p x, suc n, 0 => absurd (n<=m NatOrder.zero<suc)
  | padd p x, 0, suc m => rewrite d ()
  | padd p x, suc n, suc m => degree<=-trans d (suc<=suc.conv n<=m)

\lemma degree-reduce {R : AddPointed} (p : Poly R) (n : Nat) (d : degree<= p (suc n)) (c : polyCoef p (suc n) = 0) : degree<= p n \elim p, n
  | pzero, n => ()
  | padd pzero e, 0 => idp
  | padd (padd p x) y, 0 => pmap2 padd d c *> peq
  | padd p e, suc n => degree-reduce p n d c

\lemma degree<=0 {R : AddPointed} (p : Poly R) (d : degree<= p 0) : p = padd pzero (polyCoef p 0) \elim p
  | pzero => inv peq
  | padd p e => pmap (padd __ e) d

\lemma degree<=_monomial {R : AddPointed} {c : R} {n : Nat} : degree<= (monomial c n) n \elim n
  | 0 => idp
  | suc n => degree<=_monomial

\lemma fromArray_polyCoef {R : AddPointed} {n : Nat} {p : Poly R} (d : degree< p n) : p = Poly.fromArray (\new Array R n (\lam j => polyCoef p j)) \elim n, p
  | 0, p => degree<=.trivialPoly (\lam k _ => d zero<=_)
  | n, pzero => inv fromArray0
  | suc n, padd p e => pmap (padd __ e) $ fromArray_polyCoef \lam q => d (suc<=suc q)
  \where
    \lemma fromArray0 {n : Nat} : Poly.fromArray (replicate n R.zro) = pzero \elim n
      | 0 => idp
      | suc n => pmap (padd __ zro) fromArray0 *> peq

\lemma fromArray_degree< {R : AddPointed} {l : Array R} : degree< (Poly.fromArray l) l.len \elim l
  | nil => \lam _ => idp
  | a :: l => \lam {k} => \case \elim k \with {
    | 0 => \lam d => \case suc_<=_< d
    | suc k => \lam d => fromArray_degree< (suc<=suc.conv d)
  }

\func isMonic {R : Ring} (p : Poly R) : \Prop
  => ∃ (n : Nat) (degree<= p n) (polyCoef p n = 1)

\lemma polyMap_isMonic {f : RingHom} {p : Poly f.Dom} (m : isMonic p) : isMonic (polyMap f p) \elim m
  | inP t => inP (t.1, degree<=_polyMap t.2, polyCoef_polyMap *> pmap f t.3 *> func-ide)

\lemma monomial-isMonic {R : Ring} (n : Nat) : isMonic (monomial R.ide n)
  => inP (n, degree<=_monomial, polyCoef_monomial)

\lemma monic/=0 {R : Ring} {p : Poly R} (pm : isMonic p) (p=0 : p = pzero) : 0 = {R} 1 \elim pm
  | inP (n,d,q) => rewrite p=0 in q

\lemma monic-unique {R : Ring} {p : Poly R} {n m : Nat} (n/=m : n /= m) (d1 : degree<= p n) (c1 : polyCoef p n = 1) (d2 : degree<= p m) (c2 : polyCoef p m = 1) : 0 = {R} 1
  => \case LinearOrder.trichotomy n m \with {
    | less n<m => inv (degree<=.toCoefs p n d1 n<m) *> c2
    | equals n=m => absurd (n/=m n=m)
    | greater m<n => inv (degree<=.toCoefs p m d2 m<n) *> c1
  }