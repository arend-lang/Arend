\import Algebra.Algebra
\import Algebra.Domain
\import Algebra.Domain.Euclidean
\import Algebra.Field
\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Algebra.Pointed.Category
\import Algebra.Ring
\import Algebra.Ring.Category
\import Algebra.Ring.QPoly
\import Algebra.Semiring
\import Arith.Nat
\import Data.Or
\import Equiv
\import Equiv.Fiber
\import Equiv.Univalence
\import Function
\import Function.Meta \hiding (#)
\import HLevel
\import Logic
\import Logic.Meta
\import Meta
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Set.Fin

\data Poly (R : AddPointed)
  | pzero
  | padd (Poly R) R
  | peq : padd pzero 0 = pzero
  \where {
    \open QPoly

    \func toQPoly {R : AddPointed} (p : Poly R) : QPoly R \elim p
      | pzero => in~ nil
      | padd p e => qadd (toQPoly p) e
      | peq => path (~-equiv _ _ idp)

    \func fromArray {R : AddPointed} (l : Array R) : Poly R \elim l
      | nil => pzero
      | :: a l => padd (fromArray l) a

    \func cfunc {R : AddPointed} (l : Array R) : toQPoly (fromArray l) = in~ l \elim l
      | nil => idp
      | :: a l => pmap (qadd __ a) (cfunc l)

    \func path-lem {R : AddPointed} {p : R.zro = R.zro} : inv (path peq) *> pmap2 padd idp p *> path peq = idp
      => pmap (inv (path peq) *> pmap2 padd idp __ *> path peq) (Path.inProp _ idp) *> pmap (_ *>) (idp_*> _) *> inv_*> _

    \func toQPoly-nil {R : AddPointed} {p : Poly R} : toQPoly p = in~ nil -> p = pzero \elim p
      | pzero => \lam _ => idp
      | padd p e => \lam s => \have t => qadd_nil s \in pmap2 padd (toQPoly-nil t.1) t.2 *> path peq
      | peq => pathOver $ coe_pi *> ext (\lam s => coe_path (path peq) _ idp *> path-lem)

    \func gfunc {R : AddPointed} (l : Array R) (p : Poly R) : toQPoly p = in~ l -> p = fromArray l \elim l, p
      | nil, pzero => \lam _ => idp
      | nil, padd p e => \lam s => pmap2 padd (toQPoly-nil (qadd_nil s).1) (qadd_nil s).2 *> path peq
      | nil, peq => pathOver $ coe_pi *> ext (\lam _ => coe_path (path peq) _ idp *> path-lem)
      | :: a l, pzero => \lam s => inv (path peq) *> pmap2 padd (gfunc l pzero (nil_cons s).2) (nil_cons s).1
      | :: a l, padd p e => \lam s => pmap2 padd (gfunc l p (qadd_cons s).2) (qadd_cons {_} {e} {a} {toQPoly p} {l} s).1
      | :: a l, peq => pathOver $ coe_pi *> ext (\lam s => coe_path (path peq) _ idp *> pmap (inv (path peq) *>) (pmap2 (\lam x => pmap2 padd (gfunc l pzero x)) propPath setPath))

    \func toQPoly-equiv {R : AddPointed} : Equiv (toQPoly {R})
      => contrFibers=>Equiv $ \case \elim __ \with {
        | in~ l => \new Contr {
          | center => (fromArray l, cfunc l)
          | contraction t => ext (inv (gfunc l t.1 t.2))
        }
      }

    \use \level levelSet {R : AddPointed} : isSet (Poly R)
      => transportInv isSet (Equiv-to-= toQPoly-equiv) (\lam _ _ _ _ => setPath)
  }

\func polyMap (f : AddPointedHom) (p : Poly f.Dom) : Poly f.Cod \elim p
  | pzero => pzero
  | padd p e => padd (polyMap f p) (f e)
  | peq => rewrite f.func-zro peq

\func polyEval {R : Ring} (p : Poly R) (a : R) : R \elim p
  | pzero => 0
  | padd p e => polyEval p a * a + e
  | peq => zro-right *> zro_*-left

\func polyCoef {R : AddPointed} (p : Poly R) (n : Nat) : R \elim p, n
  | pzero, _ => 0
  | padd p e, 0 => e
  | padd p e, suc n => polyCoef p n
  | peq, 0 => idp
  | peq, suc n => idp

\lemma polyCoef_polyMap {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} : polyCoef (polyMap f p) n = f (polyCoef p n) \elim p, n
  | pzero, n => inv f.func-zro
  | padd p e, 0 => idp
  | padd p e, suc n => polyCoef_polyMap

\func lastCoef {R : AddPointed} (p : Poly R) => polyCoef p 0

\func polyShift {R : AddPointed} (p : Poly R) : Poly R \elim p
  | pzero => pzero
  | padd p e => p
  | peq => idp

\lemma padd=pzero {R : AddPointed} {p : Poly R} {a : R} (q : padd p a = pzero) : \Sigma (p = pzero) (a = 0)
  => \have t => q *> inv peq
     \in (pmap polyShift t, pmap (polyCoef __ 0) t)

\func monomial {R : AddPointed} (c : R) (n : Nat) : Poly R \elim n
  | 0 => padd pzero c
  | suc n => padd (monomial c n) 0

\lemma polyCoef_monomial {R : AddPointed} {c : R} {n : Nat} : polyCoef (monomial c n) n = c \elim n
  | 0 => idp
  | suc n => polyCoef_monomial

\lemma monomial_zro {R : AddPointed} {n : Nat} : monomial R.zro n = pzero \elim n
  | 0 => peq
  | suc n => rewrite monomial_zro peq

\instance PolyRing (R : Ring) : Ring (Poly R)
  | zro => pzero
  | + (p q : Poly R) : Poly R \with {
    | pzero, q => q
    | padd p e, pzero => padd p e
    | padd p e, padd q e' => padd (p + q) (e R.+ e')
    | padd p e, peq => pmap2 padd zro-right R.zro-right
    | peq, pzero => path peq
    | peq, padd q e => pmap (padd q) R.zro-left
  }
  | zro-left => idp
  | zro-right {p : Poly R} : p + pzero = p \elim p {
    | pzero => idp
    | padd p e => idp
  }
  | +-assoc {p q s : Poly R} : (p + q) + s = p + (q + s) \elim p, q, s {
    | pzero, q, s => idp
    | padd p e, pzero, s => idp
    | padd p e, padd q e1, pzero => idp
    | padd p e, padd q e1, padd s e2 => pmap2 padd +-assoc R.+-assoc
  }
  | +-comm {p q : Poly R} : p + q = q + p \elim p, q {
    | pzero, pzero => idp
    | pzero, padd q e => idp
    | padd p e, pzero => idp
    | padd p e, padd q e' => pmap2 padd +-comm R.+-comm
  }
  | ide => padd pzero 1
  | * (p q : Poly R) : Poly R \elim p {
    | pzero => pzero
    | padd p e => padd (p * q) 0 + e *c q
    | peq => pmap (_ +) zro_*c *> path peq
  }
  | ide-left => pmap2 (+) (path peq) ide_*c
  | ide-right {p : Poly R} : p * padd pzero 1 = p \elim p {
    | pzero => idp
    | padd p e => pmap2 padd (zro-right *> ide-right) equation
  }
  | *-assoc {p q s : Poly R} : (p * q) * s = p * (q * s) \elim p {
    | pzero => idp
    | padd p e => rdistr *> +-assoc *> pmap2 (padd __ 0 +) *-assoc (pmap2 (+) zro_*c (inv *c-comm-left))
  }
  | ldistr {p q s : Poly R} : p * (q + s) = p * q + p * s \elim p {
    | pzero => idp
    | padd p e => pmap2 (+) (pmap2 padd ldistr (inv R.zro-left)) *c-ldistr
        *> +-assoc *> pmap (_ +) (inv +-assoc *> pmap (`+ _) +-comm *> +-assoc) *> inv +-assoc
  }
  | rdistr {p q s : Poly R} : (p + q) * s = p * s + q * s \elim p, q, s {
    | pzero, q, s => idp
    | padd p e, pzero, s => inv zro-right
    | padd p e, padd q e', s => pmap2 (+) (pmap2 padd rdistr (inv R.zro-left)) *c-rdistr
        *> +-assoc *> pmap (_ +) (inv +-assoc *> pmap (`+ _) +-comm *> +-assoc) *> inv +-assoc
  }
  | negative (p : Poly R) : Poly R \with {
    | pzero => pzero
    | padd p e => padd (negative p) (R.negative e)
    | peq => pmap (padd pzero) R.negative_zro *> path peq
  }
  | negative-left {p : Poly R} : negative p + p = pzero \elim p {
    | pzero => idp
    | padd p e => pmap2 padd negative-left R.negative-left *> path peq
  }
  | natCoef n => padd pzero (R.natCoef n)
  | natCoefZero => pmap (padd pzero) R.natCoefZero *> peq
  | natCoefSuc n => pmap (padd pzero) (R.natCoefSuc n)
  \where {
    \func \infixl 7 *c {R : Ring} (r : R) (p : Poly R) : Poly R \elim p
      | pzero => pzero
      | padd p e => padd (r *c p) (r R.* e)
      | peq => pmap (padd pzero) R.zro_*-right *> path peq

    \lemma zro_*c {R : Ring} {p : Poly R} : 0 *c p = pzero \elim p
      | pzero => idp
      | padd p e => pmap2 padd zro_*c R.zro_*-left *> path peq

    \lemma ide_*c {R : Ring} {p : Poly R} : 1 *c p = p \elim p
      | pzero => idp
      | padd p e => pmap2 padd ide_*c R.ide-left

    \lemma *c-rdistr {R : Ring} {e r : R} {p : Poly R} : (e R.+ r) *c p = e *c p + r *c p \elim p
      | pzero => idp
      | padd p e1 => pmap2 padd *c-rdistr R.rdistr

    \lemma *c-ldistr {R : Ring} {c : R} {p q : Poly R} : c *c (p + q) = c *c p + c *c q \elim p, q
      | pzero, q => idp
      | padd p e, pzero => idp
      | padd p e, padd q e' => pmap2 padd *c-ldistr R.ldistr

    \lemma *c-assoc {R : Ring} {c e : R} {p : Poly R} : c R.* e *c p = c *c (e *c p) \elim p
      | pzero => idp
      | padd p e' => pmap2 padd *c-assoc R.*-assoc

    \lemma *c-comm-left {R : Ring} {r : R} {p q : Poly R} : r *c (p * q) = (r *c p) * q \elim p
      | pzero => idp
      | padd p e => *c-ldistr *> pmap2 (+) (pmap2 padd *c-comm-left R.zro_*-right) (inv *c-assoc)

    \lemma padd0_*-comm {R : Ring} {p q : Poly R} : p * padd q 0 = padd (p * q) 0 \elim p
      | pzero => inv (path peq)
      | padd p e => pmap2 (\lam x => padd (x + _)) padd0_*-comm equation

    \lemma *c_* {R : Ring} {c : R} {p : Poly R} : c *c p = padd pzero c * p
      => inv $ pmap (`+ _) peq

    \lemma *c_negative {R : Ring} {c : R} {p : Poly R} : c *c negative p = negative (c *c p) \elim p
      | pzero => idp
      | padd p e => pmap2 padd *c_negative R.negative_*-right
  }

\instance PolyAlgebra (R : CRing) : CAlgebra { | R => R }
  | Ring => PolyRing R
  | *c => *c
  | *c-assoc => *c-assoc
  | *c-ldistr => *c-ldistr
  | *c-rdistr => *c-rdistr
  | ide_*c => ide_*c
  | *c-comm-left => *c-comm-left
  | *c-comm-right {r : R} {p q : Poly R} : r *c (p * q) = p * (r *c q) \elim p {
    | pzero => idp
    | padd p e => *c-ldistr *> pmap2 (+) (pmap2 padd *c-comm-right R.zro_*-right) (inv *c-assoc *> pmap (`*c q) R.*-comm *> *c-assoc)
  }
  | *-comm {p q : Poly R} : p * q = q * p \elim p, q {
    | pzero, pzero => idp
    | pzero, padd q e => inv (path peq) *> pmap (padd __ 0) *-comm
    | padd p e, pzero => pmap (padd __ 0) *-comm *> path peq
    | padd p e, padd q e' => pmap2 (\lam x y => padd x (0 R.+ y)) (pmap (`+ _) *-comm *> +-assoc *> pmap2 (padd __ 0 +) (inv *-comm) +-comm *> inv +-assoc *> pmap (`+ _) *-comm) R.*-comm
  }
  \where \open PolyRing

\instance PolyRingWith# (R : Ring.With#) : Ring.With#
  | Ring => PolyRing R
  | #0 (p : Poly R) : \Prop \with {
    | pzero => Empty
    | padd p e => #0 p || R.#0 e
    | peq => ext (||.rec' absurd R.#0-zro, absurd)
  }
  | #0-zro => absurd
  | #0-+ {p q : Poly R} (h : #0 (p + q)) : #0 p || #0 q \elim p, q, h {
    | pzero, q, h => byRight h
    | padd p e, pzero, h => byLeft h
    | padd p e, padd q e', byLeft h => ||.map byLeft byLeft (#0-+ h)
    | padd p e, padd q e', byRight h => ||.map byRight byRight (R.#0-+ h)
  }
  | #0-tight {p : Poly R} (h : Not (#0 p)) : p = pzero \elim p {
    | pzero => idp
    | padd p e => pmap2 padd (#0-tight (\lam x => h (byLeft x))) (R.#0-tight (\lam x => h (byRight x))) *> path peq
  }
  | #0-*-left {p q : Poly R} (h : #0 (p * q)) : #0 p \elim p {
    | pzero => h
    | padd p e => ||.rec' (||.map #0-*-left (\lam x => absurd (R.#0-zro x))) (\lam x => byRight (#0_*c-left x)) (#0-+ h)
  }
  | #0-*-right {p q : Poly R} (h : #0 (p * q)) : #0 q \elim p {
    | pzero => absurd h
    | padd p e => ||.rec' (||.rec' #0-*-right (\lam x => absurd (R.#0-zro x))) #0_*c-right (#0-+ h)
  }
  \where {
    \open PolyRing

    \lemma #0_*c-left {R : Ring.With#} {e : R} {p : Poly R} (h : #0 (e *c p)) : R.#0 e \elim p, h
      | padd p e', byLeft h => #0_*c-left h
      | padd p e', byRight h => R.#0-*-left h

    \lemma #0_*c-right {R : Ring.With#} {e : R} {p : Poly R} (h : #0 (e *c p)) : #0 p \elim p, h
      | padd p e', byLeft h => byLeft (#0_*c-right h)
      | padd p e', byRight h => byRight (R.#0-*-right h)
  }

\instance PolyCRingWith# (R : CRing.With#) : CRing.With#
  | Ring.With# => PolyRingWith# R
  | *-comm => PolyAlgebra.*-comm

\instance PolyDomain (R : Domain) : Domain
  | Ring.With# => PolyRingWith# R
  | zro#ide => byRight R.zro#ide
  | apartZeroProduct {p q : Poly R} (p#0 : #0 p) (q#0 : #0 q) : #0 (p * q) \elim p, q {
    | pzero, _ => absurd p#0
    | _, pzero => absurd q#0
    | padd p e, padd q e' => rewrite R.zro-left $ assuming
        (\lam h => ||.rec' (\lam q#0' => \case AddGroup.With#.#0-+-left {PolyRingWith# R} (apartZeroProduct {R} {padd p e} p#0 q#0') \with {
          | byLeft x => \have t : padd (p * q) 0 + p * padd pzero e' = p * padd q e' => pmap (`+ _) (inv padd0_*-comm) *> inv ldistr *> pmap2 (p * padd __ __) zro-right R.zro-left
                        \in byLeft $ transport #0 (+-assoc *> pmap (_ +) +-comm *> inv +-assoc *> pmap (`+ _) t) x
          | byRight x => h $ ||.rec' absurd (\lam x => x) (#0-*-right x)
        }) h q#0) $
        \lam e'#0 => assuming (\lam h => ||.rec' (\lam p#0' => \case AddGroup.With#.#0-+-left {PolyRingWith# R} (apartZeroProduct p#0' q#0) \with {
          | byLeft x => byLeft x
          | byRight x => h (#0_*c-left x)
        }) h p#0) $ \lam e#0 => byRight (R.apartZeroProduct e#0 e'#0)
  }
  \where {
    \open PolyRing
    \open PolyRingWith#
  }

\instance PolyIntegralDomain (R : IntegralDomain) : IntegralDomain
  | Domain => PolyDomain R
  | *-comm => PolyAlgebra.*-comm

\instance PolyStrictDomain (R : StrictDomain) : StrictDomain
  | Ring => PolyRing R
  | zro/=ide x => R.zro/=ide (pmap lastCoef x)
  | zeroProduct {p q : Poly R} (pq=0 : p * q = pzero) : (p = pzero) || (q = pzero) \elim p, q {
    | pzero, _ => byLeft idp
    | _, pzero => byRight idp
    | padd p e, padd q e' => \case R.zeroProduct $ inv R.zro-left *> pmap lastCoef pq=0 \with {
      | byLeft e=0 => \case zeroProduct $ inv (pmap (_ +) zro_*c *> zro-right) *> rewriteF e=0 (pmap polyShift pq=0) \with {
        | byLeft p=0 => byLeft (pmap2 padd p=0 e=0 *> path peq)
        | byRight x => byRight x
      }
      | byRight e'=0 => \case zeroProduct {R} {padd p e} $ rewriteF (e'=0, padd0_*-comm) $ pmap polyShift pq=0 \with {
        | byLeft x => byLeft x
        | byRight q=0 => byRight (pmap2 padd q=0 e'=0 *> path peq)
      }
    }
  }
  \where \open PolyRing

\instance PolyStrictIntegralDomain (R : StrictIntegralDomain) : StrictIntegralDomain
  | StrictDomain => PolyStrictDomain R
  | *-comm => PolyAlgebra.*-comm

\instance PolyDecRing (R : Ring.Dec) : Ring.Dec
  | Ring => PolyRing R
  | decideEq (p q : Poly R) : Dec (p = q) \with {
    | pzero, pzero => yes idp
    | pzero, padd q a => \case decideEq pzero q, R.decideEq 0 a \with {
      | yes e1, yes e2 => yes (inv peq *> pmap2 padd e1 e2)
      | _, no n => no (\lam e => n (pmap lastCoef e))
      | no n, _ => no (\lam e => n (pmap polyShift e))
    }
    | padd p a, pzero => \case decideEq p pzero, R.decideEq a 0 \with {
      | yes e1, yes e2 => yes (pmap2 padd e1 e2 *> path peq)
      | _, no n => no (\lam e => n (pmap lastCoef e))
      | no n, _ => no (\lam e => n (pmap polyShift e))
    }
    | padd p a, padd q a' => \case decideEq p q, R.decideEq a a' \with {
      | yes e1, yes e2 => yes (pmap2 padd e1 e2)
      | _, no n => no (\lam e => n (pmap lastCoef e))
      | no n, _ => no (\lam e => n (pmap polyShift e))
    }
  }

\open PolyRing(*c)

\lemma polyCoef_+ {R : Ring} {p q : Poly R} {n : Nat} : polyCoef (p + q) n = polyCoef p n + polyCoef q n \elim p, q, n
  | pzero, q, n => rewrite zro-left (inv zro-left)
  | padd p x, padd q y, 0 => idp
  | padd p x, pzero, n => inv zro-right
  | padd p x, padd q y, suc n => polyCoef_+

\func polyCoefHom {R : Ring} {n : Nat} : AddGroupHom (PolyRing R) R \cowith
  | func => polyCoef __ n
  | func-zro => idp
  | func-+ => polyCoef_+

\lemma polyCoef_negative {R : Ring} {p : Poly R} {n : Nat} : polyCoef (negative p) n = negative (polyCoef p n)
  => polyCoefHom.func-negative

\lemma polyCoef_*c {R : Ring} {a : R} {p : Poly R} {n : Nat} : polyCoef (a *c p) n = a * polyCoef p n \elim p, n
  | pzero, n => inv zro_*-right
  | padd p e, 0 => idp
  | padd p e, suc n => polyCoef_*c

\lemma polyCoef_* {R : Ring} {a : R} {p : Poly R} {k n : Nat} : polyCoef (monomial a k * p) (k + n) = a * polyCoef p n \elim k
  | 0 => pmap (\lam s => polyCoef (s + _) n) peq *> rewrite zro-left polyCoef_*c
  | suc k => unfold $ rewrite PolyRing.zro_*c polyCoef_*

\func polyMapRingHom (f : RingHom) : RingHom (PolyRing f.Dom) (PolyRing f.Cod) \cowith
  | func => polyMap f
  | func-+ {p q : Poly f.Dom} : polyMap f (p + q) = polyMap f p + polyMap f q \elim p, q {
    | pzero, q => idp
    | padd p a, pzero => idp
    | padd p a, padd q b => rewrite (func-+,f.func-+) idp
  }
  | func-ide => rewrite func-ide idp
  | func-* {p q : Poly f.Dom} : polyMap f (p * q) = polyMap f p * polyMap f q \elim p {
    | pzero => idp
    | padd p e => func-+ *> pmap2 (+) (pmap2 padd func-* func-zro) polyMap_*c
  }
  \where
    \func polyMap_*c {f : RingHom} {a : f.Dom} {q : Poly f.Dom} : polyMap f (a *c q) = f a *c polyMap f q \elim q
      | pzero => idp
      | padd q b => pmap2 padd polyMap_*c f.func-*

\func polyEmbHom {R : Ring} : RingHom R (PolyRing R) \cowith
  | func => padd 0
  | func-+ => idp
  | func-ide => idp
  | func-* => pmap (padd 0) (inv zro-left)

\func polyEvalRingHom {R : CRing} (a : R) : RingHom (PolyRing R) R \cowith
  | func => polyEval __ a
  | func-+ {p q : Poly R} : polyEval (p + q) a = polyEval p a + polyEval q a \elim p, q {
    | pzero, q => inv zro-left
    | padd p x, pzero => inv zro-right
    | padd p x, padd q y => rewrite func-+ equation
  }
  | func-ide => equation
  | func-* {p q : Poly R} : polyEval (p * q) a = polyEval p a * polyEval q a \elim p {
    | pzero => inv zro_*-left
    | padd p x => func-+ *> rewrite (func-*,polyEval_*c) equation
  }
  \where
    \lemma polyEval_*c {R : Ring} {x a : R} {p : Poly R} : polyEval (x *c p) a = x * polyEval p a \elim p
      | pzero => inv zro_*-right
      | padd p y => rewrite polyEval_*c equation

\func degree {R : Ring.Dec} (p : Poly R) : Nat \elim p
  | pzero => 0
  | padd p _ => \case decideEq p 0 \with {
    | yes _ => 0
    | no _ => suc (degree p)
  }
  | peq => idp

\func degree< {R : AddPointed} (p : Poly R) (n : Nat)
  => \Pi {k : Nat} -> n <= k -> polyCoef p k = 0

\lemma degree<_+ {R : Ring} {p q : Poly R} {n : Nat} (dp : degree< p n) (dq : degree< q n) : degree< (p + q) n
  => \lam s => polyCoef_+ *> pmap2 (+) (dp s) (dq s) *> zro-left

\lemma degree<_negative {R : Ring} {p : Poly R} {n : Nat} (dp : degree< p n) : degree< (negative p) n
  => \lam s => polyCoef_negative *> pmap negative (dp s) *> R.negative_zro

\lemma degree<0 {R : AddPointed} {p : Poly R} (d : degree< p 0) : p = pzero
  => degree<=.trivialPoly (\lam k _ => d zero<=_)

\lemma degree<_padd {R : AddPointed} {p : Poly R} {e : R} {n : Nat} (d : degree< p n) : degree< (padd p e) (suc n)
  => \lam {k} => \case \elim k \with {
    | 0 => \lam s => absurd (s NatSemiring.zero<suc)
    | suc k => \lam s => d (suc<=suc.conv s)
  }
  \where
    \lemma conv {R : AddPointed} {p : Poly R} {e : R} {n : Nat} (d : degree< (padd p e) (suc n)) : degree< p n
      => \lam s => d (suc<=suc s)

\lemma degree<_polyMap {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} (d : degree< p n) : degree< (polyMap f p) n \elim p, n
  | pzero, n => \lam _ => idp
  | padd p e, 0 =>
    \have t => padd=pzero (degree<0 d)
    \in rewrite (t.1, t.2, f.func-zro) $ transportInv (degree< __ 0) peq $ \lam _ => idp
  | padd p e, suc n => degree<_padd $ degree<_polyMap (degree<_padd.conv d)

\lemma polyEval_polyCoef {R : Ring} {p : Poly R} {a : R} {n : Nat} (d : degree< p n) : polyEval p a = R.BigSum (\new Array R n (\lam i => polyCoef p i * R.pow a i)) \elim p, n
  | pzero, n => inv $ R.BigSum_zro $ \lam j => R.zro_*-left
  | p, 0 => rewrite (degree<0 d) idp
  | padd p e, suc n => rewrite (polyEval_polyCoef (degree<_padd.conv d)) $ pmap2 (+) (R.BigSum-rdistr *> pmap (\lam x => R.BigSum (\new Array R n x)) (ext $ \lam j => *-assoc)) (inv ide-right) *> +-comm

\func degree<= {R : AddPointed} (p : Poly R) (n : Nat) : \Prop
  | pzero, n => \Sigma
  | padd p a, 0 => p = pzero
  | padd p a, suc n => degree<= p n
  | peq, 0 => ext (\lam _ => (), \lam _ => idp)
  | peq, suc n => idp
  \where {
    \lemma toDegree {R : Ring.Dec} {p : Poly R} {n : Nat} (d : degree<= p n) : degree p <= n \elim p, n
      | pzero, n => zero<=_
      | padd p e, 0 => rewrite (decideEq=_reduce d) zero<=_
      | padd p e, suc n => mcases \with {
        | yes _ => zero<=_
        | no _ => suc<=suc (toDegree d)
      }

    \lemma fromDegree {R : Ring.Dec} {p : Poly R} {n : Nat} (q : degree p <= n) : degree<= p n \elim p, n
      | pzero, n => ()
      | padd p e, 0 => cases (decideEq p 0, q) \with {
        | yes r, q => r
        | no _, q => absurd (q NatSemiring.zero<suc)
      }
      | padd p e, suc n => fromDegree $ cases (decideEq p 0, q) \with {
        | yes r, q => rewrite r zero<=_
        | no n1, q => suc<=suc.conv q
      }

    \lemma toCoefs {R : AddPointed} (p : Poly R) (n : Nat) (d : degree<= p n) {k : Nat} (n<k : n < k) : polyCoef p k = 0 \elim p, n, k, n<k
      | pzero, n, k, _ => idp
      | padd p e, 0, suc k, _ => rewrite d idp
      | padd p e, suc n, suc k, NatSemiring.suc<suc n<k => toCoefs p n d n<k

    \lemma trivialPoly {R : AddPointed} {p : Poly R} (d : \Pi (k : Nat) -> degree<= p k -> polyCoef p k = 0) : p = pzero
      => \case degree-exists p \with {
           | inP (n,dp) => aux d n dp
         }
      \where
        \lemma aux {R : AddPointed} {p : Poly R} (d : \Pi (k : Nat) -> degree<= p k -> polyCoef p k = 0) (n : Nat) (dp : degree<= p n) : p = pzero \elim n
          | 0 => degree<=0 p dp *> pmap (padd pzero) (d 0 dp) *> peq
          | suc n => aux d n $ degree-reduce p n dp (d (suc n) dp)

    \lemma fromCoefs {R : AddPointed} (p : Poly R) (n : Nat) (d : \Pi {k : Nat} -> n < k -> polyCoef p k = 0) : degree<= p n \elim p, n
      | pzero, n => ()
      | padd p e, 0 => trivialPoly (\lam k _ => d NatSemiring.zero<suc)
      | padd p e, suc n => fromCoefs p n (\lam n<k => d (NatSemiring.suc<suc n<k))
  }

\lemma degree<=_degree< {R : AddPointed} {p : Poly R} {n : Nat} (d : degree<= p n) : degree< p (suc n)
  => \lam s => degree<=.toCoefs p n d (<-transitive-left id<suc s)

\lemma degree-exists {R : AddPointed} (p : Poly R) : ∃ (n : Nat) (degree<= p n) \elim p
  | pzero => inP (0, ())
  | padd p e => TruncP.map (degree-exists p) $ \lam s => (suc s.1, s.2)

\lemma degree<=-trans {R : AddPointed} {p : Poly R} {n m : Nat} (d : degree<= p n) (n<=m : n <= m) : degree<= p m \elim p, n, m
  | pzero, n, m => ()
  | padd p x, 0, 0 => d
  | padd p x, suc n, 0 => absurd (n<=m NatSemiring.zero<suc)
  | padd p x, 0, suc m => rewrite d ()
  | padd p x, suc n, suc m => degree<=-trans d (suc<=suc.conv n<=m)

\lemma degree-reduce {R : AddPointed} (p : Poly R) (n : Nat) (d : degree<= p (suc n)) (c : polyCoef p (suc n) = 0) : degree<= p n \elim p, n
  | pzero, n => ()
  | padd pzero e, 0 => idp
  | padd (padd p x) y, 0 => pmap2 padd d c *> peq
  | padd p e, suc n => degree-reduce p n d c

\lemma degree<=0 {R : AddPointed} (p : Poly R) (d : degree<= p 0) : p = padd pzero (polyCoef p 0) \elim p
  | pzero => inv peq
  | padd p e => pmap (padd __ e) d

\lemma degree<=_+ {R : Ring} {p q : Poly R} {n : Nat} (dp : degree<= p n) (dq : degree<= q n) : degree<= (p + q) n \elim p, q, n
  | pzero, q, n => dq
  | padd p x, pzero, n => dp
  | padd p x, padd q y, 0 => pmap2 (+) dp dq
  | padd p x, padd q y, suc n => degree<=_+ dp dq

\lemma degree<=_BigSum {R : Ring} {l : Array (Poly R)} {n : Nat} (d : \Pi (j : Fin l.len) -> degree<= (l j) n) : degree<= (AddMonoid.BigSum l) n
  => AddMonoid.BigSum-pred {_} {degree<= __ n} () (\lam {p} {q} => degree<=_+) d

\lemma degree<=_FinSum {R : Ring} {J : FinSet} {a : J -> Poly R} {n : Nat} (d : \Pi (j : J) -> degree<= (a j) n) : degree<= (AbMonoid.FinSum a) n
  => AbMonoid.FinSum-pred {_} {degree<= __ n} () (\lam {p} {q} => degree<=_+) d

\lemma degree<=_*c {R : Ring} {a : R} {p : Poly R} {n : Nat} (d : degree<= p n) : degree<= (a *c p) n \elim p, n
  | pzero, n => ()
  | padd p e, 0 => pmap (a *c) d
  | padd p e, suc n => degree<=_*c d

\lemma degree<=_negative {R : Ring} {p : Poly R} {n : Nat} (d : degree<= p n) : degree<= (negative p) n \elim p, n
  | pzero, n => ()
  | padd p e, 0 => pmap negative d
  | padd p e, suc n => degree<=_negative d

\lemma degree<=_* {R : Ring} {p q : Poly R} {n m : Nat} (dp : degree<= p n) (dq : degree<= q m) : degree<= (p * q) (n + m) \elim p, n
  | pzero, n => ()
  | padd p e, 0 => rewrite dp $ transportInv (\lam x => degree<= (x + _) m) peq $ degree<=_*c dq
  | padd p e, suc n => degree<=_+ (later $ degree<=_* dp dq) (degree<=_*c $ degree<=-trans dq $ NatSemiring.<=_+ {0} {suc n} zero<=_ <=-refl)

\lemma degree<=_BigProd {R : Ring} {l : Array (Poly R)} (d : Array Nat l.len) (p : \Pi (j : Fin l.len) -> degree<= (l j) (d j))
  : degree<= (Monoid.BigProd l) (AddMonoid.BigSum d) \elim l, d
  | nil, d => idp
  | a :: l, n :: d => degree<=_* (p 0) $ degree<=_BigProd d $ \lam j => p (suc j)

\lemma degree<=_monomial {R : AddPointed} {c : R} {n : Nat} : degree<= (monomial c n) n \elim n
  | 0 => idp
  | suc n => degree<=_monomial

\lemma *c_monomial {R : Ring} {a c : R} {n : Nat} : a *c monomial c n = monomial (a * c) n \elim n
  | 0 => idp
  | suc n => pmap2 padd *c_monomial zro_*-right

\lemma leadCoef-product {R : Ring} {p q : Poly R} {n m : Nat} (dp : degree<= p n) (dq : degree<= q m) : polyCoef (p * q) (n + m) = polyCoef p n * polyCoef q m \elim p, n
  | pzero, n => inv zro_*-left
  | padd p x, 0 => polyCoef_+ *> pmap2 (+) (\case \elim m \with {
    | 0 => idp
    | suc m => later (rewrite dp idp)
  }) polyCoef_*c *> zro-left
  | padd p x, suc n => polyCoef_+ *> pmap2 (+) (leadCoef-product dp dq) (polyCoef_*c *> pmap (x *) (degree<=.toCoefs q m dq $ <_+-left m NatSemiring.zero<suc) *> zro_*-right) *> zro-right

\lemma leadCoef_BigProd {R : Ring} {l : Array (Poly R)} (d : Array Nat l.len) (ld : \Pi (j : Fin l.len) -> degree<= (l j) (d j))
  : polyCoef (Monoid.BigProd l) (AddMonoid.BigSum d) = R.BigProd (\lam j => polyCoef (l j) (d j)) \elim l, d
  | nil, d => idp
  | p :: l, n :: d => leadCoef-product (ld 0) (degree<=_BigProd d (\lam j => ld (suc j))) *> pmap (_ *) (leadCoef_BigProd d (\lam j => ld (suc j)))

\func isMonic {R : Ring} (p : Poly R) : \Prop
  => ∃ (n : Nat) (degree<= p n) (polyCoef p n = 1)

\lemma monomial-isMonic {R : Ring} (n : Nat) : isMonic (monomial R.ide n)
  => inP (n, degree<=_monomial, polyCoef_monomial)

\func polyDivision {R : CRing} (f g : Poly R) (k m n : Nat) (p : suc m = k + n) (df : degree<= f m) (dg : degree<= g n)
  : \Sigma (q r : Poly R) (Monoid.pow (polyCoef g n) k *c f = q * g + r) (degree< r n) \elim k, m, n
  | 0, m, n => (pzero, f, PolyRing.ide_*c *> equation, rewriteI p $ degree<=_degree< df)
  | 1, 0, 0 => (f, pzero, rewrite (degree<=0 g dg, ide-left, zro-right) $ PolyRing.*c_* *> *-comm, \lam _ => idp)
  | 1, 0, suc n => \case p
  | suc (suc k), 0, n => \case p
  | suc k, suc m, n => \let f1 => polyCoef g n *c f - monomial (polyCoef f (suc m)) k * g \in
                       \have rec => polyDivision f1 g k m n (pmap pred p) (degree-reduce f1 m
                                (degree<=_+ (degree<=_*c df) (degree<=_negative $ rewrite (pmap pred p) $ degree<=_* degree<=_monomial dg))
                                (polyCoef_+ *> pmap (_ +) polyCoef_negative *> rewrite polyCoef_*c (rewrite {3} (pmap pred p) $ rewrite (polyCoef_*,*-comm) negative-right))) dg
                       \in (rec.1 + monomial (Monoid.pow (polyCoef g n) k * polyCoef f (suc m)) k, rec.2, rewrite (PolyRing.*c-assoc, rdistr) $ unfold f1 (rewrite (PolyRing.*c-ldistr, PolyRing.*c_negative, PolyRing.*c-comm-left, *c_monomial) equation) *> pmap (_ +) rec.3 *> inv +-assoc *> pmap (`+ _) +-comm, rec.4)

\lemma monicPolyDivision {R : CRing} (f g : Poly R) (n : Nat) (dg : degree<= g n) (dm : polyCoef g n = 1) : Contr (\Sigma (q r : Poly R) (f = q * g + r) (degree< r n))
  => \case degree-exists f \with {
       | inP (l,df) => isProp=>isContr (\lam s1 s2 =>
           \have | s : (s1.1 - s2.1) * g = s2.2 - s1.2 => equation {CRing} {usingOnly {s1.3, s2.3}}
                 | t => aux (s1.1 - s2.1) g n dg dm $ rewrite s $ degree<_+ s2.4 $ degree<_negative s1.4
           \in ext (AddGroup.fromZero t, inv $ AddGroup.fromZero $ inv s *> pmap (`* g) t)) $
           \have s => polyDivision f g (suc l) (l + n) n idp (degree<=-trans df $ NatSemiring.<=_+ <=-refl zero<=_) dg
           \in (s.1, s.2, later (rewrite dm $ inv $ pmap (`*c f) (R.pow_ide {suc l}) *> PolyRing.ide_*c) *> s.3, s.4)
     }
  \where {
    \lemma aux {R : Ring} (q g : Poly R) (n : Nat) (dg : degree<= g n) (dm : polyCoef g n = 1) (dqg : degree< (q * g) n) : q = 0
      => degree<=.trivialPoly $ \lam k dq => inv (leadCoef-product dq dg *> pmap (_ *) dm *> ide-right) *> dqg (LinearlyOrderedSemiring.<=_+ zero<=_ <=-refl)
  }

\func leadCoef {R : Ring.Dec} (p : Poly R) : R \elim p
  | pzero => 0
  | padd p e => \case decideEq p 0 \with {
    | yes _ => e
    | no _ => leadCoef p
  }
  | peq => idp

\lemma leadCoef=0-lem {R : Ring.Dec} {p : Poly R} (s : leadCoef p = 0) : p = 0 \elim p
  | pzero => idp
  | padd p a => cases (decideEq p 0, s) \with {
    | yes p=0, a=0 => pmap2 padd p=0 a=0 *> path peq
    | no p/=0, s => absurd $ p/=0 (leadCoef=0-lem s)
  }

\lemma leadCoef_monomial {R : Ring.Dec} {a : R} {n : Nat} : leadCoef (monomial a n) = a \elim n
  | 0 => idp
  | suc n => mcases \with {
    | yes e => inv (pmap leadCoef e) *> leadCoef_monomial
    | no _ => leadCoef_monomial
  }

\lemma degree_monomial {R : Ring.Dec} {a : R} {n : Nat} (a/=0 : a /= 0) : degree (monomial a n) = n \elim n
  | 0 => idp
  | suc n => mcases \with {
    | yes e => absurd $ a/=0 $ inv leadCoef_monomial *> pmap leadCoef e
    | no _ => pmap suc (degree_monomial a/=0)
  }

\lemma degree=0-lem {R : Ring.Dec} {p : Poly R} (dp=0 : degree p = 0) : p = padd pzero (leadCoef p) \elim p
  | pzero => inv peq
  | padd p a => mcases \with {
    | yes p=0 => pmap (padd __ a) p=0
    | no p/=0 => \case rewriteF (decideEq/=_reduce p/=0) dp=0
  }

\instance PolyDecCRing (R : CRing.Dec) : CRing.Dec
  | Ring.Dec => PolyDecRing R
  | *-comm => PolyAlgebra.*-comm

\instance PolyDecDomain (R : Domain.Dec) : Domain.Dec
  | Domain => PolyDomain R
  | decideEq => PolyDecRing.decideEq
  | nonZeroApart {p : Poly R} (p/=0 : p /= 0) : #0 p \elim p {
    | pzero => p/=0 idp
    | padd p a => \case R.decideEq a 0 \with {
      | yes a=0 => byLeft $ nonZeroApart $ \lam p=0 => p/=0 $ pmap2 padd p=0 a=0 *> path peq
      | no n => byRight (R.nonZeroApart n)
    }
  }
  \where \open PolyRingWith#

\instance PolyDecIntegralDomain (R : IntegralDomain.Dec) : IntegralDomain.Dec
  | Domain.Dec => PolyDecDomain R
  | *-comm => PolyAlgebra.*-comm

\lemma degree_padd {R : Ring.Dec} {p : Poly R} (a : R) (p/=0 : p /= 0) : degree (padd p a) = suc (degree p)
  => rewrite (decideEq/=_reduce p/=0) idp

\lemma degree_+ {R : Ring.Dec} {p q : Poly R} (q<p : degree q < degree p) : degree (p + q) = degree p \elim p, q
  | pzero, pzero => idp
  | pzero, padd q a => \case q<p
  | padd p a, pzero => idp
  | padd p a, padd q a' => cases (decideEq p 0, decideEq q 0, q<p) \with {
    | no p/=0, yes q=0, NatSemiring.zero<suc => rewrite (q=0, PolyRing.zro-right, decideEq/=_reduce p/=0) idp
    | no p/=0, no q/=0, NatSemiring.suc<suc q<p => mcases \with {
      | yes p+q=0 => \case rewriteF (inv $ rewriteF p+q=0 (degree_+ q<p)) q<p
      | no _ => pmap suc (degree_+ q<p)
    }
  }

\lemma leadCoef_+ {R : Ring.Dec} {p q : Poly R} (q<p : degree q < degree p) : leadCoef (p + q) = leadCoef p \elim p, q
  | pzero, pzero => idp
  | pzero, padd q a => \case q<p
  | padd p a, pzero => idp
  | padd p a, padd q a' => cases (decideEq p 0, decideEq q 0, q<p) \with {
    | no p/=0, yes q=0, NatSemiring.zero<suc => rewrite (q=0, PolyRing.zro-right, decideEq/=_reduce p/=0) idp
    | no p/=0, no q/=0, NatSemiring.suc<suc q<p => mcases \with {
      | yes p+q=0 => \case rewriteF (inv $ rewriteF p+q=0 (degree_+ q<p)) q<p
      | no _ => leadCoef_+ q<p
    }
  }

\lemma degree_*c {R : Domain.Dec} {c : R} {p : Poly R} (c/=0 : c /= 0) : degree (c PolyRing.*c p) = degree p \elim p
  | pzero => idp
  | padd p a => mcases {2} \with {
    | yes p=0 => rewrite p=0 idp
    | no p/=0 => rewrite (decideEq/=_reduce $ *c-nonZero p/=0) $ pmap suc (degree_*c c/=0)
  }
  \where {
    \lemma *c-nonZero {p : Poly R} (p/=0 : p /= 0) : c PolyRing.*c p /= 0
      => transportInv (`/= 0) PolyRing.*c_* $ Domain.nonZeroProduct {_} {padd pzero c} (\lam e => c/=0 $ pmap lastCoef e) p/=0
  }

\lemma degree_* {R : Domain.Dec} {p q : Poly R} (p/=0 : p /= 0) (q/=0 : q /= 0) : degree (p * q) = degree p + degree q \elim p
  | pzero => absurd (p/=0 idp)
  | padd p e => mcases \with {
    | yes p=0 => rewrite p=0 $ pmap (\lam x => degree (x + _)) peq *> degree_*c (\lam e=0 => p/=0 $ pmap2 padd p=0 e=0 *> path peq)
    | no p/=0' => degree_+ (later $ rewrite (decideEq/=_reduce $ Domain.nonZeroProduct p/=0' q/=0) (degree_< p/=0')) *>
        rewrite (decideEq/=_reduce $ Domain.nonZeroProduct p/=0' q/=0) (pmap suc (degree_* p/=0' q/=0))
  }
  \where
    \lemma degree_< {a : R} {p : Poly R} (p/=0 : p /= 0) : degree (a PolyRing.*c q) < suc (degree (p * q))
      => \case decideEq a 0 \with {
        | yes a=0 => rewrite (a=0,PolyRing.zro_*c) NatSemiring.zero<suc
        | no a/=0 => rewrite (degree_*c a/=0, degree_* p/=0 q/=0) $ <-transitive-right (LinearlyOrderedSemiring.<=_+ zero<=_ <=-refl) id<suc
      }

\lemma leadCoef_*c {R : Domain.Dec} {a : R} {p : Poly R} : leadCoef (a PolyRing.*c p) = a * leadCoef p \elim p
  | pzero => inv R.zro_*-right
  | padd p e => mcases {2} \with {
    | yes p=0 => rewrite p=0 idp
    | no p/=0 => \case decideEq a 0 \with {
      | yes a=0 => rewrite (a=0,PolyRing.zro_*c) simplify
      | no a/=0 => rewrite (decideEq/=_reduce $ degree_*c.*c-nonZero a/=0 p/=0) leadCoef_*c
    }
  }

\lemma leadCoef_* {R : Domain.Dec} {p q : Poly R} : leadCoef (p * q) = leadCoef p * leadCoef q \elim p
  | pzero => inv R.zro_*-left
  | padd p e => mcases \with {
    | yes p=0 => rewrite p=0 $ pmap (leadCoef $ __ + _) peq *> leadCoef_*c
    | no p/=0 => \case decideEq q 0 \with {
      | yes q=0 => rewrite (q=0, Ring.zro_*-right {PolyRing R}) (inv R.zro_*-right)
      | no q/=0 => leadCoef_+ (later $ rewrite (decideEq/=_reduce $ Domain.nonZeroProduct p/=0 q/=0) (degree_*.degree_< q/=0 p/=0)) *> rewrite (decideEq/=_reduce $ Domain.nonZeroProduct p/=0 q/=0) leadCoef_*
    }
  }

\instance PolyEuclideanRingData (R : DiscreteField) : EuclideanRingData (Poly R)
  | CRing => PolyAlgebra R
  | decideEq => PolyDecRing.decideEq
  | euclideanMap => degree
  | divMod p q => \case decideEq (degree q) 0 \with {
    | yes _ => \case decideEq q 0 \with {
      | yes _ => (0,p)
      | no _ => (finv (leadCoef q) PolyRing.*c p, 0)
    }
    | no _ => divMod_fuel p q (EuclideanSemiringData.suc' (degree p))
  }
  | isDivMod p q => cases (decideEq (degree q) 0) \with {
    | yes dq=0 => mcases \with {
      | yes _ => pmap (`+ p) Ring.zro_*-right
      | no q/=0 => zro-right *> pmap (`* _) (degree=0-lem dq=0) *> pmap (`+ _) peq *> inv PolyRing.*c-assoc *> pmap (PolyRing.`*c p) (R.finv-right (q/=0 $ leadCoef=0-lem __)) *> PolyRing.ide_*c
    }
    | no dq/=0 => divMod_fuel-correct p q dq/=0 $ rewrite EuclideanSemiringData.suc'=suc id<suc
  }
  | isEuclideanMap p q q/=0 => cases (decideEq (degree q) 0) \with {
    | yes dq=0 => rewrite (decideEq/=_reduce q/=0) $ \lam r/=0 => absurd (r/=0 idp)
    | no dq/=0 => \lam _ => divMod_fuel-rem-lem p q dq/=0
  }
  \where {
    \func divMod_fuel {R : DiscreteField} (p q : Poly R) (n : Nat) : \Sigma (Poly R) (Poly R) \elim n
      | 0 => (0,0)
      | suc n => \case LinearOrder.dec<_<= (degree p) (degree q) \with {
        | inl _ => (0,p)
        | inr _ =>
          \let | m => monomial (leadCoef p * finv (leadCoef q)) (degree p -' degree q)
               | (d,r) => divMod_fuel (p - m * q) q n
          \in (d + m, r)
      }

    \lemma divMod_fuel-correct {R : DiscreteField} (p q : Poly R) (dq/=0 : degree q /= 0) {n : Nat} (s : degree p < n) : q * (divMod_fuel p q n).1 + (divMod_fuel p q n).2 = p \elim n
      | 0 => \case s
      | suc n => mcases \with {
        | inl p<q => pmap (`+ p) Ring.zro_*-right
        | inr q<=p =>
          \let | p/=0 : p /= 0 => dq/=0 $ <=_exists $ rewriteF __ q<=p
               | q/=0 => dq/=0 $ pmap degree __
               | lq/=0 => q/=0 $ leadCoef=0-lem __
               | m => monomial (leadCoef p * finv (leadCoef q)) (degree p -' degree q)
               | lm/=0 : leadCoef p * finv (leadCoef q) /= 0 => Domain.nonZeroProduct (p/=0 $ leadCoef=0-lem __) (R.inv-nonZero $ R.finv-Inv lq/=0)
               | dp=dmq : degree p = degree (m * q) => inv $ degree_* (transportInv (`/= 0) (leadCoef_monomial {R}) lm/=0 $ pmap leadCoef __) q/=0 *> rewrite (degree_monomial lm/=0) (+-comm *> <=_exists q<=p)
          \in equation {CRing} {usingOnly (divMod_fuel-correct (p - m * q) q dq/=0 $ <-transitive-left (diff-lem dp=dmq (inv $ leadCoef_* *> pmap (`* _) leadCoef_monomial *> *-assoc *> pmap (_ *) (R.finv-left lq/=0) *> ide-right) $ \lam dmq=0 => dq/=0 $ <=_exists $ transport (_ <=) (dp=dmq *> dmq=0) q<=p) (<_suc_<= s))}
      }

    \lemma divMod_fuel-rem-lem {R : DiscreteField} (p q : Poly R) (dq/=0 : degree q /= 0) {n : Nat} : degree (divMod_fuel p q n).2 < degree q \elim n
      | 0 => nonZero>0 dq/=0
      | suc n => mcases \with {
        | inl p<q => p<q
        | inr q<=p => divMod_fuel-rem-lem _ q dq/=0
      }

    \lemma diff-lem {R : Ring.Dec} {p q : Poly R} (s : degree p = degree q) (t : leadCoef p = leadCoef q) (dq/=0 : degree q /= 0) : degree (p - q) < degree p \elim p, q
      | _, pzero => absurd (dq/=0 idp)
      | pzero, padd q a => absurd (cases (decideEq q 0, s, t) \with {
        | yes q=0, _, a=0 => dq/=0 $ rewrite (decideEq=_reduce q=0) idp
      })
      | padd p a, padd q a' => cases (decideEq p 0, decideEq q 0, s, t) \with {
        | yes p=0, yes q=0, _, a=a' => absurd $ rewriteF (decideEq=_reduce q=0) dq/=0 idp
        | no p/=0, no q/=0, s, t => mcases \with {
          | yes _ => NatSemiring.zero<suc
          | no p-q/=0 => NatSemiring.suc<suc $ diff-lem (pmap pred s) t $
              \lam dq=0 => p-q/=0 $ AddGroup.toZero $ degree=0-lem (pmap pred s *> dq=0) *> pmap (padd pzero) t *> inv (degree=0-lem dq=0)
        }
      }
  }

\instance PolyEuclideanDomain (R : DiscreteField) : EuclideanDomain (Poly R)
  | IntegralDomain.Dec => PolyDecIntegralDomain R
  | isEuclidean => inP (PolyEuclideanRingData R)