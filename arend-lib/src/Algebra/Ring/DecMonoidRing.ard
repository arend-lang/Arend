\import Algebra.FinSuppFunc
\import Algebra.Monoid
\import Algebra.Ring
\import Algebra.Semiring
\import Data.Array
\import Function.Meta ($)
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin

\instance DecMonoidSemiring (M : AddMonoid) {D : DecSet M} (R : Semiring) : Semiring (FinSuppFunc M R)
  | AbMonoid => FinSuppFuncAbMonoid
  | ide => \new FinSuppFunc {
    | func i => \case decideEq i 0 \with {
      | yes _ => 1
      | no _ => 0
    }
    | fSupp => inP (0 :: nil, \lam i d => rewrite (decideEq/=_reduce $ /=-sym $ d 0) idp)
  }
  | * f g => (TruncP.rec2-set (fSupp {f}) (fSupp {g}) (\lam (s1 : Array M, _) (s2 : Array M, _) => \new FinSuppFunc M R {
    | func i => R.FinSum {SigmaFin (ProdFin (FinFin s1.len) (FinFin s2.len)) (\lam t => DecFin {s1 t.1 + s2 t.2 = i} decide)} $ \lam t => f (s1 t.1.1) * g (s2 t.1.2)
    | fSupp => inP (pairs (+) s1 s2, \lam i d => R.FinSum_zro $ \lam t => later $ absurd $ d _ $ (pairs.pairs-index t.1.1 t.1.2).2 *> t.2)
  }) $ \lam s1 s1' s2 s2' => exts $ \lam i => unfold_let {?}).1
  | ide-left => {?}
  | ide-right => {?}
  | *-assoc => {?}
  | ldistr => {?}
  | rdistr => {?}
  | zro_*-left => {?}
  | zro_*-right => {?}