\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Category (Cat, Iso)
\import Category.Sub
\import Equiv
\import Paths
\import Paths.Meta
\import Set.Category

\record SemiringHom \extends AddMonoidHom, MonoidHom {
  \override Dom : Semiring
  \override Cod : Semiring
}

\record RingHom \extends SemiringHom, AddGroupHom {
  \override Dom : Ring
  \override Cod : Ring
} \where {
    \func equals {R S : Ring} {f g : RingHom R S} (p : \Pi (x : R) -> f x = g x) : f = g
      => ext p
}

\instance RingCategory : Cat Ring
  | Hom M N => RingHom M N
  | id => id
  | o {x y z : Ring} (g : RingHom y z) (f : RingHom x y) => \new RingHom {
    | func x => g (f x)
    | func-ide => pmap g f.func-ide *> g.func-ide
    | func-+ x y => pmap g (f.func-+ x y) *> g.func-+ (f x) (f y)
    | func-* x y => pmap g (f.func-* x y) *> g.func-* (f x) (f y)
  }
  | id-left _ => idp
  | id-right _ => idp
  | o-assoc _ _ _ => idp
  | univalence (e : Iso) =>
    \let R=S => Ring.equals (path (iso e.f e.inv (\lam x => path (\lam i => func {e.f_inv @ i} x)) (\lam y => path (\lam i => func {e.inv_f @ i} y)))) (func-+, func-*)
    \in (R=S, RingHom.equals (\lam x => Jl {Ring} (\lam T R=T => func {transport (RingHom e.dom __) R=T (id e.dom)} x = coe (R=T @ __) x right) idp R=S))
  \where
    \func id (M : Ring) : RingHom M M \cowith
      | func x => x
      | func-ide => idp
      | func-+ _ _ => idp
      | func-* _ _ => idp

\instance CRingCategory : Cat CRing
  => subCat (\new Embedding {CRing} {Ring} {
    | f R => R
    | isEmb (R S : CRing) => \new Retraction {
      | sec p => path (\lam i => \new CRing {
        | Ring => p @ i
        | *-comm => pathInProp (\Pi {x y : p @ __} -> x * y = y * x) R.*-comm S.*-comm @ i
      })
      | f_sec => idpe
    }
  })
