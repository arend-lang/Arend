\import Algebra.Linear.Matrix
\import Algebra.Linear.Matrix.CharPoly
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Pointed.Sub
\import Algebra.Ring
\import Algebra.Ring.Category
\import Algebra.Ring.Poly
\import Algebra.Ring.Sub
\import Category
\import Data.Array
\import Function.Meta
\import HLevel
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set.Fin

\func polyImage {R : Ring} {E : CRing} (f : RingHom R E) (a : E) : SubRing E
  => ringHomImage (polyEvalRingHom a ∘ polyMapRingHom f)

\lemma polyImage-closed {R : Ring} {E : CRing} (f : RingHom R E) (a : E) (x : SubRing.cStruct (polyImage f a)) : polyImage f a (a * x.1) \elim x
  | (x, inP (p,q)) => inP $ unfold (padd p 0, unfold $ rewrite (q,f.func-zro) (zro-right *> *-comm))

\lemma element-polyImage {R : Ring} {E : CRing} (f : RingHom R E) (a : E) : polyImage f a a
  => rewriteF ide-right $ polyImage-closed f a (ide {SubRing.cStruct (polyImage f a)})

\func polyImageHom {R : Ring} {E : CRing} (f : RingHom R E) (a : E) : RingHom R (SubRing.cStruct (polyImage f a)) \cowith
  | func x => (f x, inP (padd pzero x, pmap (`+ f x) Ring.zro_*-left *> zro-left))
  | func-+ => ext f.func-+
  | func-ide => ext f.func-ide
  | func-* => ext f.func-*

\lemma monic-generated {R E : CRing} (f : RingHom R E) (a : E) (p : Poly R) (n : Nat) (dp : degree<= p n) (dm : polyCoef p n = 1) (e : polyEval (polyMap f p) a = 0)
  : LModule.isGenerated {homLModule (polyImageHom f a)} (\new Array _ n (\lam i => Monoid.pow {SubRing.cStruct (polyImage f a)} (a, element-polyImage f a) i))
  => \lam (b, inP (g,ga)) =>
      \have (q,r,g=q*p+r,dr<n) => Contr.center {monicPolyDivision g p n dp dm}
      \in inP (mkArray $ \lam j => polyCoef r j, (unfold,unfold) at ga $ ext $ inv ga *> rewrite (g=q*p+r,polyMapRingHom.func-+,polyEvalRingHom.func-+,polyMapRingHom.func-*,polyEvalRingHom.func-*,e,E.zro_*-right)
            (zro-left *> polyEval_polyCoef (degree<_polyMap dr<n) *> pmap AddMonoid.BigSum (arrayExt $ \lam j => pmap2 (*) polyCoef_polyMap (inv SubMonoid.struct_pow)) *> inv SubAddMonoid.struct_BigSum))

\lemma module-monic {R E : CRing} (f : RingHom R E) (a : E) (S : SubRing E) (SR : \Pi (x : R) -> S (f x))
                    (l : Array S.struct) (Sg : LModule.isGenerated {homLModule (S.corestrict f SR)} l) (Sa : S a)
  : ∃ (p : Poly R) (degree<= p l.len) (polyCoef p l.len = 1) (polyEval (polyMap f p) a = 0)
  => \let | (inP Sg') => FinSet.finiteAC $ \lam j => Sg (a * (l j).1, contains_* Sa (l j).2)
          | (inP d) => Sg (1,contains_ide)
          | A => mkMatrix (\lam i => (Sg' i).1)
     \in inP (charPoly A, charPoly-degree A, charPoly-monic A, pmap (polyEval __ a) (charPoly_map f A) *> eigen-root (matrix-map f A) (
          inP (mkMatrix $ \lam i _ => (l i).1,
               \lam x p => inv ide-right *> pmap (x *) (pmap __.1 d.2 *> S.struct_BigSum) *> E.BigSum-ldistr *> E.BigSum_zro (\lam i => equation {usingOnly (pmap (__ i 0) p)}),
               matrixExt $ \lam i _ => pmap __.1 (Sg' i).2 *> S.struct_BigSum)))

\func isIntegral (f : RingHom) (x : f.Cod) : \Prop
  => ∃ (p : Poly f.Dom) (isMonic p) (polyEval (polyMap f p) x = 0)

\func isIntegralExt (f : RingHom) : \Prop
  => \Pi (x : f.Cod) -> isIntegral f x

\lemma integral-comp {R S T : CRing} (f : RingHom R S) (g : RingHom S T) (Ri : isIntegralExt f) {a : T} (ai : isIntegral g a) : isIntegral (g ∘ f) a \elim ai
  | inP (p, inP (d,dp,dc), pa=0) => \let S' => Big {S} {CRing} (\lam x a => SubRing.cStruct $ polyImage (polyEvalRingHom x) a) S nil \in {?}

-- TODO
\func integralClosure {R E : CRing} (f : RingHom R E) : SubRing E \cowith
  | contains => isIntegral f
  | contains_zro => inP (monomial 1 1, monomial-isMonic 1, rewrite f.func-zro $ zro-right *> E.zro_*-right)
  | contains_+ => {?}
  | contains_ide => inP (padd (padd pzero 1) -1, {?}, {?})
  | contains_* => {?}
  | contains_negative => {?}