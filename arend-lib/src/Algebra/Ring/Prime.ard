\import Algebra.Domain
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Data.Or
\import Logic
\import Paths
\import Relation.Apartness
\open CMonoid(Inv,Div)

\record Prime {R : CRing} (e : R) (notZero : Not (e = zro)) (notInv : Not (Inv e))
  | isPrime (x y : R) : Div e (x * y) -> Div e x || Div e y

\record Irr {R : CRing} (e : R) (notInv : Not (Inv e)) {
  | isIrr (x y : R) : e = x * y -> Inv x || Inv y

  \func decide (x y : R) (e=x*y : e = x * y) : Inv x `Or` Inv y =>
    ||.rec (Or.isProp (\lam (i : Inv x) (j : Inv y) => notInv (transport (\lam x => Inv x) (inv e=x*y) (Inv.product i j)))) inl inr (isIrr x y e=x*y)
}

\lemma Prime-isIrr {D : IntegralDomain} (p : Prime {D}) : Irr p.e p.notInv \cowith
  | isIrr x y p=x*y => \case p.isPrime x y (\new Div p.e (x * y) ide (ide-left p.e *> p=x*y)) \with {
    | byLeft p|x =>
      \let j => Div.inv {p|x}
      \in byRight (\new Inv y j (Domain.nonZero-cancel-right (j * y) ide x (\lam x=0 => p.notZero (p=x*y *> pmap (\lam t => t * y) x=0 *> zro_*-left y)) (
        (j * y) * x ==< *-assoc j y x >==
        j * (y * x) ==< pmap (j *) (*-comm y x) >==
        j * (x * y) ==< pmap (j *) (inv p=x*y) >==
        j * p.e     ==< Div.inv-left {p|x} >==
        x           ==< inv (ide-left x) >==
        ide * x     `qed
      )))
    | byRight p|y =>
      \let j => Div.inv {p|y}
      \in byLeft (\new Inv x j (Domain.nonZero-cancel-right (j * x) ide y (\lam y=0 => p.notZero (p=x*y *> pmap (x *) y=0 *> zro_*-right x)) (
        (j * x) * y ==< *-assoc j x y >==
        j * (x * y) ==< pmap (j *) (inv p=x*y) >==
        j * p.e     ==< Div.inv-left {p|y} >==
        y           ==< inv (ide-left y) >==
        ide * y     `qed
      )))
  }
