\import Algebra.Algebra
\import Algebra.Domain
\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Data.Or
\import Equiv
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Order.Biordered
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set.Fin
\open AddGroup

\type FSeries (R : \Set) => Nat -> R

\instance FSeriesRing (R : Ring) : Ring (FSeries R)
  | zro _ => 0
  | + f g n => f n + g n
  | zro-left => ext \lam n => zro-left
  | +-assoc => ext \lam n => +-assoc
  | +-comm => ext \lam n => +-comm
  | negative f n => negative (f n)
  | negative-left => ext \lam n => negative-left
  | ide => coef 1
  | * f g n => R.FinSum {PairsFinSet n} \lam s => f s.1 * g s.2
  | *-assoc {x} {y} {z} => ext \lam n => path (\lam i => R.FinSum (\lam (s : PairsFinSet n) => R.FinSum-rdistr {PairsFinSet s.1} {z s.2} {\lam t => x t.1 * y t.2} i)) *>
      R.FinSum-double-dep (\lam (s : PairsFinSet n) => PairsFinSet s.1) *> R.FinSum_Equiv2 (later \new QEquiv {
        | f ((i,j,i+j=n),(k,m,k+m=i)) => ((k, m + j, inv +-assoc *> pmap (`+ j) k+m=i *> i+j=n), (m, j, idp))
        | ret ((i,j,i+j=n),(k,m,k+m=j)) => ((i + k, m, +-assoc *> pmap (i +) k+m=j *> i+j=n), (i, k, idp))
        | ret_f s => PairsFinSet-ext1 s.2.3 idp idp idp
        | f_sec s => PairsFinSet-ext2 idp s.2.3 idp idp
      }) (\lam s => *-assoc) *> inv (path (\lam i => R.FinSum (\lam (s : PairsFinSet n) => R.FinSum-ldistr {PairsFinSet s.2} {x s.1} {\lam t => y t.1 * z t.2} i)) *> R.FinSum-double-dep (\lam (s : PairsFinSet n) => PairsFinSet s.2) {\lam s => x s.1.1 * (y s.2.1 * z s.2.2)})
  | ldistr => ext \lam n => pmap R.FinSum (ext \lam s => R.ldistr) *> R.FinSum_+
  | rdistr => ext \lam n => pmap R.FinSum (ext \lam s => R.rdistr) *> R.FinSum_+
  | ide-left {x} => ext \lam n => R.FinSum-unique (later (0, n, idp)) (\lam s s/=0 => pmap (`* _) (coef_/=0 \lam p => s/=0 $ ext (p, pmap (`+ _) (inv p) *> s.3)) *> R.zro_*-left) *> ide-left
  | ide-right {x} => ext \lam n => R.FinSum-unique (later (n, 0, idp)) (\lam s s/=0 => pmap (_ *) (coef_/=0 \lam p => s/=0 $ ext (pmap (_ +) (inv p) *> s.3, p)) *> R.zro_*-right) *> ide-right
  | natCoef n => coef (R.natCoef n)
  | natCoefZero => ext \case \elim __\with {
    | 0 => R.natCoefZero
    | suc j => idp
  }
  | natCoefSuc n => ext \case \elim __\with {
    | 0 => R.natCoefSuc n
    | suc j => inv zro-left
  }
  \where {
    \func coef (a : R) (n : Nat) : R \elim n
      | 0 => a
      | suc _ => 0

    \lemma coef_/=0 {a : R} {n : Nat} (n/=0 : n /= 0) : coef a n = 0 \elim n
      | 0 => absurd (n/=0 idp)
      | suc n => idp

    \lemma PairsFinSet (n : Nat) : FinSet (\Sigma (i j : Nat) (\property i + j = n)) (suc n) \cowith
      | finEq => inP \new QEquiv {
        | f i => (i, n -' i, <=_exists $ <_suc_<= $ fin_< i)
        | ret s => toFin s.1 $ <=_<_suc $ NatSemiring.<=_+ <=-refl zero<=_ <=∘ =_<= s.3
        | ret_f i => fin_nat-inj toFin=id
        | f_sec s => ext (toFin=id, pmap2 (`-') (inv s.3 *> +-comm) toFin=id *> -'+)
      }

    \lemma PairsFinSet-ext1 {n : Nat} {x y : \Sigma (s : PairsFinSet n) (PairsFinSet s.1)} (p1 : x.1.1 = y.1.1) (p2 : x.1.2 = y.1.2) (p3 : x.2.1 = y.2.1) (p4 : x.2.2 = y.2.2) : x = y \elim x, y, p1, p2, p3, p4
      | ((i1,j1,p1),(k1,m1,q1)), ((i2,j2,p2),(k2,m2,q2)), idp, idp, idp, idp => idp

    \lemma PairsFinSet-ext2 {n : Nat} {x y : \Sigma (s : PairsFinSet n) (PairsFinSet s.2)} (p1 : x.1.1 = y.1.1) (p2 : x.1.2 = y.1.2) (p3 : x.2.1 = y.2.1) (p4 : x.2.2 = y.2.2) : x = y \elim x, y, p1, p2, p3, p4
      | ((i1,j1,p1),(k1,m1,q1)), ((i2,j2,p2),(k2,m2,q2)), idp, idp, idp, idp => idp
  }

\instance FSeriesAlgebra (R : CRing) : CAlgebra R
  | Ring => FSeriesRing R
  | *c c x n => c * x n
  | *c-assoc => ext \lam n => *-assoc
  | *c-ldistr => ext \lam n => R.ldistr
  | *c-rdistr => ext \lam n => R.rdistr
  | ide_*c => ext \lam n => ide-left
  | *c-comm-left => ext \lam n => R.FinSum-ldistr *> pmap R.FinSum (ext \lam s => inv *-assoc)
  | coefMap a => FSeriesRing.coef a
  | coefMap_*c => ext \case \elim __\with {
    | 0 => inv ide-right
    | suc j => inv R.zro_*-right
  }
  | *-comm => ext \lam n => R.FinSum_Equiv2 (later \new QEquiv {
    | f s => (s.2, s.1, +-comm *> s.3)
    | ret s => (s.2, s.1, +-comm *> s.3)
    | ret_f => idpe
    | f_sec => idpe
  }) \lam s => *-comm

\instance FSeriesRingWith# (R : Ring.With#) : Ring.With#
  | Ring => FSeriesRing R
  | #0 x => ∃ (n : Nat) (x n `#0)
  | #0-zro (inP (_,p)) => #0-zro p
  | #0-+ (inP (n,p)) => \case #0-+ p \with {
    | byLeft xn#0 => byLeft $ inP (n, xn#0)
    | byRight yn#0 => byRight $ inP (n, yn#0)
  }
  | #0-tight c => ext \lam n => #0-tight \lam xn#0 => c $ inP (n, xn#0)
  | #0-*-left (inP (n,p)) => \case R.#0-FinSum p \with {
    | inP (s,q) => inP (s.1, R.#0-*-left q)
  }
  | #0-*-right (inP (n,p)) => \case R.#0-FinSum p \with {
    | inP (s,q) => inP (s.2, R.#0-*-right q)
  }

\instance FSeriesCRingWith# (R : CRing.With#) : CRing.With#
  | Ring.With# => FSeriesRingWith# R
  | *-comm => (FSeriesAlgebra R).*-comm

\instance FSeriesDomain (R : Domain) : Domain
  | Ring.With# => FSeriesRingWith# R
  | zro#ide => inP (0, R.zro#ide)
  | #0-* (inP (n,xn#0)) (inP (m,ym#0)) => aux {R} {_} {n} {m} id<suc xn#0 ym#0
  \where {
    \protected \lemma aux {k n m : Nat} (n+m<k : n + m < k) {x y : FSeries R} (xn#0 : x n `#0) (ym#0 : y m `#0) : ∃ (k : Nat) ((x * y) k `#0) \elim k
      | suc k => \case R.#0-FinSum-conv {FSeriesRing.PairsFinSet (n + m)} {_} {n,m,idp} (R.#0-* xn#0 ym#0) \with {
        | byLeft r => inP (n + m, r)
        | byRight ((i,j,i+j=n+m),ij/=nm,p) => \case LinearOrder.dec<_<= i n \with {
          | inl i<n => aux (NatSemiring.<_+-left m i<n <∘l <_suc_<= n+m<k) (R.#0-*-left p) ym#0
          | inr n<=i => aux (NatSemiring.<_+-right n (\case LinearOrder.dec<_<= j m \with {
            | inl j<m => j<m
            | inr m<=j => absurd $ ij/=nm $ ext
              \have j=m => <=-antisymmetric (NatBSemilattice.<=_cancel-left i $ =_<= i+j=n+m <=∘ NatSemiring.<=_+ n<=i <=-refl) m<=j
              \in (NatSemiring.cancel-right j $ i+j=n+m *> pmap (n +) (inv j=m), j=m)
          }) <∘l <_suc_<= n+m<k) xn#0 (R.#0-*-right p)
        }
      }
  }

\instance FSeriesIntegralDomain (R : IntegralDomain) : IntegralDomain
  | Domain => FSeriesDomain R
  | *-comm => (FSeriesAlgebra R).*-comm
