\import Algebra.Domain
\import Algebra.Domain.Euclidean
\import Algebra.Field
\import Algebra.Group.Category
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Monoid.Prime
\import Algebra.Ordered
\import Algebra.Ring
\import Algebra.Ring.Category
\import Algebra.Ring.Ideal
\import Algebra.Ring.Integral
\import Algebra.Ring.Poly
\import Algebra.Ring.Reduced
\import Algebra.Semiring
\import Arith.Nat
\import Equiv
\import Function.Meta
\import Logic
\import Meta
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set

\func isMinPoly (f : RingHom) (a : f.Cod) (p : Poly f.Dom) : \Prop
  => \Sigma (polyEval (polyMap f p) a = 0) (\Pi {q : Poly f.Dom} -> polyEval (polyMap f q) a = 0 -> TruncP (Monoid.LDiv p q))

\lemma integral_factor-equiv {R E : CRing} (f : RingHom R E) (a : E) (p : Poly R) (pm : isMinPoly f a p) : Equiv (integral_factor f a p pm.1)
  => Equiv.fromInjSurj _ (AddGroupHom.injective $ unfold \lam {q} => \case \elim q \with {
    | in~ q => \lam u => FactorRing.fequiv $ Ideal.closure1_LDiv.2 $ simplify $ pm.2 (pmap __.1 u)
  }) \lam s => TruncP.map s.2 \lam t => (in~ t.1, ext t.2)

\func isMonicMinPoly (f : RingHom) (a : f.Cod) (p : Poly f.Dom) : \Prop
  => \Sigma (isMonic p) (isMinPoly f a p)
  \where {
    \lemma unique {R : StrictDomain} {f : RingHom R} {a : f.Cod} {p q : Poly R} (pm : isMonicMinPoly f a p) (qm : isMonicMinPoly f a q) : p = q
      => \case pm.2.2 qm.2.1, qm.2.2 pm.2.1 \with {
        | inP (p|q : Monoid.LDiv), inP (q|p : Monoid.LDiv) => \case polyDiv p|q q|p \with {
          | byLeft (p=0,_) => \case pm.1 \with {
            | inP (n,_,s) => absurd $ zro/=ide (rewriteF p=0 s)
          }
          | byRight (a,b,u,v,ab=1,ba=1) => \case pm.1, qm.1 \with {
            | inP (n,dp,cp), inP (m,dq,cq) => \case LinearOrder.trichotomy n m \with {
              | less n<m => absurd $ NonZeroSemiring.inv-nonZero (\new Monoid.Inv b a ab=1 ba=1) $ inv ide-left *> pmap (`* _) (inv cq) *> inv polyCoef_*-right *> rewriteF (inv q|p.inv-right, v) (degree<=.toCoefs p n dp n<m)
              | equals n=m => inv ide-right *> pmap (p *) (inv $ u *> pmap (padd pzero) (inv ide-left *> pmap (`* a) (inv cp *> pmap (polyCoef p) n=m) *> inv polyCoef_*-right *> rewriteF (inv p|q.inv-right, u) cq)) *> p|q.inv-right
              | greater m<n => absurd $ NonZeroSemiring.inv-nonZero (\new Monoid.Inv a b ba=1 ab=1) $ inv ide-left *> pmap (`* _) (inv cp) *> inv polyCoef_*-right *> rewriteF (inv p|q.inv-right, u) (degree<=.toCoefs q m dq m<n)
            }
          }
        }
      }
  }

\lemma irr_minPoly {K : DiscreteField} {E : NonZeroCRing} (f : RingHom K E) (a : E) (p : Irr {PolyAlgebra K}) (pe : polyEval (polyMap f p) a = 0) : isMinPoly f a p
  => \have p/=0 (p=0 : p.e = 0) => K.zro/=ide $ pmap lastCoef $ p.isCancelable-left {0} {1} $ rewrite p=0 idp
     \in (pe, minPoly-fromDeg f a p pe p/=0 \lam q/=0 qe => aux f a p pe p/=0 id<suc q/=0 qe)
  \where {
    \lemma aux {K : DiscreteField} {E : NonZeroCRing} (f : RingHom K E) (a : E) (p : Irr {PolyAlgebra K}) (pe : polyEval (polyMap f p) a = 0) (p/=0 : p.e /= 0) {n : Nat}
               {q : Poly K} (qd : degree q < n) (q/=0 : q /= 0) (qe : polyEval (polyMap f q) a = 0) : degree p <= degree q \elim n
      | suc n =>
        \have d : EuclideanRingData (Poly K) => PolyEuclideanRingData K
        \in \case decideEq (d.divMod p q).2 0 \with {
          | yes r=0 =>
            \have p=qd => rewriteF r=0 (inv (d.isDivMod p q)) *> zro-right
            \in \case p.isIrr p=qd \with {
              | byLeft (e : Monoid.Inv) => \case polyInv e \with {
                | inP s => absurd $ NonZeroSemiring.inv-nonZero (f.func-Inv s.3) $ inv zro-left *> rewriteF (s.2,zro_*-left) qe
              }
              | byRight (e : Monoid.Inv) => rewrite (inv $ pmap (`* e.inv) p=qd *> *-assoc *> pmap (q *) e.inv-right *> ide-right, degree_* p/=0 \lam e1=0 => zro/=ide {PolyDomain K} $ inv zro_*-right *> pmap (e *) (inv e1=0) *> e.inv-right) (LinearlyOrderedSemiring.<=_+ <=-refl zero<=_)
            }
          | no r/=0 => \have | dr<dq => d.isEuclideanMap p q q/=0 r/=0
                             | dp<=dr => aux f a p pe p/=0 (<-transitive-left dr<dq $ suc<=suc.conv $ suc_<_<= qd) r/=0 $
                                 inv (func-+ {polyMapEvalRingHom f a} *> pmap (`+ _) (func-* {polyMapEvalRingHom f a} *> pmap (`* _) qe *> zro_*-left) *> zro-left) *>
                                 pmap (\lam x => polyEval (polyMap f x) a) (d.isDivMod p q) *> pe
                       \in LinearOrder.<_<= (<-transitive-right dp<=dr dr<dq)
        }

    \lemma minPoly-fromDeg {K : DiscreteField} {E : CRing} (f : RingHom K E) (a : E) (p : Poly K) (pe : polyEval (polyMap f p) a = 0) (p/=0 : p /= 0)
                           (c : \Pi {q : Poly K} -> q /= 0 -> polyEval (polyMap f q) a = 0 -> degree p <= degree q)
                           {q : Poly K} (qe : polyEval (polyMap f q) a = 0) : TruncP (Monoid.LDiv p q)
      => \let d : EuclideanRingData (Poly K) => PolyEuclideanRingData K
         \in \case decideEq (d.divMod q p).2 0 \with {
          | yes r=0 => inP \new Monoid.LDiv {
            | inv => (d.divMod q p).1
            | inv-right => inv zro-right *> pmap (_ +) (inv r=0) *> d.isDivMod q p
          }
          | no r/=0 => absurd $ <-irreflexive $ <-transitive-left (d.isEuclideanMap q p p/=0 r/=0) $ c r/=0 $
              inv (func-+ {polyMapEvalRingHom f a} *> pmap (`+ _) (func-* {polyMapEvalRingHom f a} *> equation) *> zro-left) *> pmap (\lam u => polyEval (polyMap f u) a) (d.isDivMod q p) *> qe
        }
  }

\lemma monicMinPoly_irr {K : DiscreteField} {E : ImpotentCRing} (f : RingHom K E) (a : E) (p : Poly K) (pm : isMonicMinPoly f a p) : Prime p
  => minPoly_irr f a (inP (p, pm.1, pm.2.1)) p pm.2
  \where
    \lemma minPoly_irr {K : DiscreteField} {E : ImpotentCRing} (f : RingHom K E) (a : E) (ai : isIntegral f a) (p : Poly K) (pm : isMinPoly f a p) : Prime p
      => FactorIrrField.conv (\lam q => Domain.nonZero-cancel-left (\lam p=0 => \case \elim ai \with {
        | inP (q,qm,qe) => K.zro/=ide $ monic/=0 qm $ \case pm.2 qe \with {
          | inP (_,s) => inv s *> pmap (`* _) p=0
        }
      }) q) $ DiscreteField.backwards (integral_factor f a p pm.1) (integral_factor-equiv f a p pm) (polyImage_field f a ai)
