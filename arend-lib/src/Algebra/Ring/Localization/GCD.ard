\import Algebra.Domain
\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Monoid.GCD
\import Algebra.Monoid.Prime
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Ring.Category \hiding (func, func-ide, func-*)
\import Algebra.Ring.Localization \using (localization \as rloc)
\import Algebra.Semiring
\import Category (isEpi)
\import HLevel
\import Logic
\import Paths
\open Monoid

\class RSubset
  | Nom : IntegralDomain
  | Denom : Monoid
  | map : MonoidHom Denom Nom
  \where
    \func toSubset {S : RSubset} : Subset Nom \cowith
      | contains x => TruncP (\Sigma (y : Denom) (map.func y = x))

\record LocSet {S : RSubset} (nom : Nom) (denom : Denom) (coprime : Coprime nom (map.func denom))
  \where
    \lemma equals {S : RSubset} {a b : LocSet} (p : a.nom = b.nom) (q : a.denom = b.denom) : a = b
      => path (\lam i => \new LocSet {
        | nom => p @ i
        | denom => q @ i
        | coprime => pathInProp (\lam j => Coprime (p @ j) (map.func (q @ j))) a.coprime b.coprime @ i
      })

\instance LocRing {S : GCDSubset} : IntegralDomain LocSet
  | zro => inc zro
  | + => ++
  | zro-left (a : LocSet) => ratio.pmap (
      zro * map.func a.denom + a.nom * map.func ide ==< pmap (\lam t => t + a.nom * map.func ide) (Semiring.zro_*-left _) >==
      zro + a.nom * map.func ide                    ==< zro-left _ >==
      a.nom * map.func ide                          ==< pmap (a.nom *) map.func-ide >==
      a.nom * ide                                   ==< ide-right a.nom >==
      a.nom                                         `qed
    ) (ide-left a.denom) *> ratio-lem a
  | +-assoc (a b c : LocSet) =>
      \let p =>
          (a.nom * map.func b.denom + b.nom * map.func a.denom) * map.func c.denom + c.nom * map.func (a.denom * b.denom)                                 ==< pmap2 (\lam t s => t + c.nom * s) (rdistr _ _ _) (map.func-* _ _) >==
          ((a.nom * map.func b.denom) * map.func c.denom + (b.nom * map.func a.denom) * map.func c.denom) + c.nom * (map.func a.denom * map.func b.denom) ==< +-assoc _ _ _ >==
          (a.nom * map.func b.denom) * map.func c.denom + ((b.nom * map.func a.denom) * map.func c.denom + c.nom * (map.func a.denom * map.func b.denom)) ==< path (\lam i => (*-assoc _ _ _ @ i) + (((*-assoc _ _ _ *> pmap (b.nom *) (*-comm _ _) *> inv (*-assoc _ _ _)) @ i) + ((pmap (c.nom *) (*-comm _ _) *> inv (*-assoc _ _ _)) @ i))) >==
          a.nom * (map.func b.denom * map.func c.denom) + ((b.nom * map.func c.denom) * map.func a.denom + (c.nom * map.func b.denom) * map.func a.denom) ==< inv (pmap2 (\lam t s => a.nom * t + s) (map.func-* _ _) (rdistr _ _ _)) >==
          a.nom * map.func (b.denom * c.denom) + (b.nom * map.func c.denom + c.nom * map.func b.denom) * map.func a.denom                                 `qed
      \in (a ++ b) ++ c                                                                                                                                           ==< inv (path (\lam i => ((ratio-lem a @ i) ++ (ratio-lem b @ i)) ++ (ratio-lem c @ i))) >==
          (ratio a.nom a.denom ++ ratio b.nom b.denom) ++ ratio c.nom c.denom                                                                                     ==< path (\lam i => (ratio-+ a.nom b.nom a.denom b.denom @ i) ++ ratio c.nom c.denom) >==
          ratio (a.nom * map.func b.denom + b.nom * map.func a.denom) (a.denom * b.denom) ++ ratio c.nom c.denom                                                  ==< ratio-+ _ _ _ _ >==
          ratio ((a.nom * map.func b.denom + b.nom * map.func a.denom) * map.func c.denom + c.nom * map.func (a.denom * b.denom)) ((a.denom * b.denom) * c.denom) ==< ratio.pmap p (*-assoc _ _ _) >==
          ratio (a.nom * map.func (b.denom * c.denom) + (b.nom * map.func c.denom + c.nom * map.func b.denom) * map.func a.denom) (a.denom * (b.denom * c.denom)) ==< inv (ratio-+ _ _ _ _) >==
          ratio a.nom a.denom ++ ratio (b.nom * map.func c.denom + c.nom * map.func b.denom) (b.denom * c.denom)                                                  ==< inv (path (\lam i => ratio a.nom a.denom ++ (ratio-+ b.nom c.nom b.denom c.denom @ i))) >==
          ratio a.nom a.denom ++ (ratio b.nom b.denom ++ ratio c.nom c.denom)                                                                                     ==< path (\lam i => (ratio-lem a @ i) ++ ((ratio-lem b @ i) ++ (ratio-lem c @ i))) >==
          a ++ (b ++ c)                                                                                                                                           `qed
  | +-comm (a b : LocSet) => ratio.pmap (+-comm _ _) (denom_comm a.denom b.denom)
  | ide => \new LocSet ide ide (\lam z z|1 _ => Inv.ldiv z|1)
  | * => **
  | ide-left a => ratio.pmap (ide-left _) (ide-left _) *> ratio-lem a
  | *-assoc (a b c : LocSet) =>
      (a ** b) ** c                                                       ==< inv (path (\lam i => ((ratio-lem a @ i) ** (ratio-lem b @ i)) ** (ratio-lem c @ i))) >==
      (ratio a.nom a.denom ** ratio b.nom b.denom) ** ratio c.nom c.denom ==< path (\lam i => (ratio-* a.nom b.nom a.denom b.denom @ i) ** ratio c.nom c.denom) >==
      ratio (a.nom * b.nom) (a.denom * b.denom) ** ratio c.nom c.denom    ==< ratio-* (a.nom * b.nom) c.nom (a.denom * b.denom) c.denom >==
      ratio ((a.nom * b.nom) * c.nom) ((a.denom * b.denom) * c.denom)     ==< ratio.pmap (*-assoc a.nom b.nom c.nom) (*-assoc a.denom b.denom c.denom) >==
      ratio (a.nom * (b.nom * c.nom)) (a.denom * (b.denom * c.denom))     ==< inv (ratio-* a.nom (b.nom * c.nom) a.denom (b.denom * c.denom)) >==
      ratio a.nom a.denom ** (ratio (b.nom * c.nom) (b.denom * c.denom))  ==< inv (path (\lam i => ratio a.nom a.denom ** (ratio-* b.nom c.nom b.denom c.denom @ i))) >==
      ratio a.nom a.denom ** (ratio b.nom b.denom ** ratio c.nom c.denom) ==< path (\lam i => (ratio-lem a @ i) ** ((ratio-lem b @ i) ** (ratio-lem c @ i))) >==
      a ** (b ** c)                                                       `qed
  | ldistr (a b c : LocSet) =>
      \let p =>
          map.func a.denom * ((a.nom * b.nom) * map.func c.denom + (a.nom * c.nom) * map.func b.denom)                      ==< pmap (map.func a.denom *) (pmap2 (+) (*-comm _ _) (*-comm _ _)) >==
          map.func a.denom * (map.func c.denom * (a.nom * b.nom) + map.func b.denom * (a.nom * c.nom))                      ==< ldistr _ _ _ >==
          map.func a.denom * (map.func c.denom * (a.nom * b.nom)) + map.func a.denom * (map.func b.denom * (a.nom * c.nom)) ==< inv (pmap2 (+) (*-assoc _ _ _) (*-assoc _ _ _)) >==
          (map.func a.denom * map.func c.denom) * (a.nom * b.nom) + (map.func a.denom * map.func b.denom) * (a.nom * c.nom) ==< pmap2 (+) (*-comm _ _) (*-comm _ _) >==
          (a.nom * b.nom) * (map.func a.denom * map.func c.denom) + (a.nom * c.nom) * (map.func a.denom * map.func b.denom) ==< inv (pmap2 (\lam t s => (a.nom * b.nom) * t + (a.nom * c.nom) * s) (map.func-* _ _) (map.func-* _ _)) >==
          (a.nom * b.nom) * map.func (a.denom * c.denom) + (a.nom * c.nom) * map.func (a.denom * b.denom)                   `qed
      \in a ** (b ++ c)                                                                                                                                       ==< inv (path (\lam i => (ratio-lem a @ i) ** ((ratio-lem b @ i) ++ (ratio-lem c @ i)))) >==
          ratio a.nom a.denom ** (ratio b.nom b.denom ++ ratio c.nom c.denom)                                                                                 ==< path (\lam i => ratio a.nom a.denom ** (ratio-+ b.nom c.nom b.denom c.denom @ i)) >==
          ratio a.nom a.denom ** ratio (b.nom * map.func c.denom + c.nom * map.func b.denom) (b.denom * c.denom)                                              ==< ratio-* _ _ _ _ >==
          ratio (a.nom * (b.nom * map.func c.denom + c.nom * map.func b.denom)) (a.denom * (b.denom * c.denom))                                               ==< ratio.pmap (ldistr a.nom _ _ *> inv (pmap2 (+) (*-assoc _ _ _) (*-assoc _ _ _))) (inv (*-assoc _ _ _) *> pmap (\lam t => t * c.denom) (denom_comm _ _) *> *-assoc _ _ _) >==
          ratio ((a.nom * b.nom) * map.func c.denom + (a.nom * c.nom) * map.func b.denom) (b.denom * (a.denom * c.denom))                                     ==< ratio-*-left _ _ _ >==
          ratio (map.func a.denom * ((a.nom * b.nom) * map.func c.denom + (a.nom * c.nom) * map.func b.denom)) (a.denom * (b.denom * (a.denom * c.denom)))    ==< ratio.pmap p (inv (*-assoc _ _ _)) >==
          ratio ((a.nom * b.nom) * map.func (a.denom * c.denom) + (a.nom * c.nom) * map.func (a.denom * b.denom)) ((a.denom * b.denom) * (a.denom * c.denom)) ==< inv (ratio-+ _ _ _ _) >==
          ratio (a.nom * b.nom) (a.denom * b.denom) ++ ratio (a.nom * c.nom) (a.denom * c.denom)                                                              ==< inv (path (\lam i => (ratio-* a.nom b.nom a.denom b.denom @ i) ++ (ratio-* a.nom c.nom a.denom c.denom @ i))) >==
          ratio a.nom a.denom ** ratio b.nom b.denom ++ ratio a.nom a.denom ** ratio c.nom c.denom                                                            ==< path (\lam i => (ratio-lem a @ i) ** (ratio-lem b @ i) ++ (ratio-lem a @ i) ** (ratio-lem c @ i)) >==
          a ** b ++ a ** c                                                                                                                                    `qed
  | negative (a : LocSet) => \new LocSet (negative a.nom) a.denom (\lam z (z|-an : LDiv z (negative a.nom)) => a.coprime z (\new LDiv {
      | inv => negative z|-an.inv
      | inv-right => Ring.negative_*-right z z|-an.inv *> pmap negative z|-an.inv-right *> negative-isInv a.nom
    }))
  | negative-left (a : LocSet) => nom_=0 (Domain.nonZero-cancel-right _ _ _ (denom_/=0 _)
      (gcd_nom _ _ *> pmap (\lam t => t + a.nom * map.func a.denom) (Ring.negative_*-left a.nom (map.func a.denom)) *> negative-left (a.nom * map.func a.denom) *> inv (zro_*-left _)))
  | *-comm (a b : LocSet) => ratio.pmap (*-comm a.nom b.nom) (denom_comm a.denom b.denom)
  | #0 (a : LocSet) => a.nom `#0
  | #0-zro => #0-zro
  | #0-+ (a b : LocSet) a+b#0 => \case #0-+ _ _ (transport #0 (gcd_nom _ _) (apartZeroProduct _ _ a+b#0 (denom_#0 _))) \with {
    | byLeft an*bd#0 => byLeft (Ring.#0-*-left _ _ an*bd#0)
    | byRight bn*ad#0 => byRight (Ring.#0-*-left _ _ bn*ad#0)
  }
  | #0-tight (a : LocSet) a/#0 => nom_=0 (#0-tight a.nom a/#0)
  | #0-*-left (a b : LocSet) a*b#0 =>
      Ring.#0-*-left a.nom b.nom (transport #0 (gcd_nom (a.nom * b.nom) (a.denom * b.denom)) (apartZeroProduct _ _ a*b#0 (denom_#0 _)))
  | zro#ide => zro#ide
  | apartZeroProduct (a b : LocSet) a#0 b#0 =>
      Ring.#0-*-left _ _ (transport #0 (inv (gcd_nom (a.nom * b.nom) (a.denom * b.denom))) (apartZeroProduct a.nom b.nom a#0 b#0))
  \where {
    \open AddGroup

    \func inc {S : GCDSubset} (x : Nom) => \new LocSet x ide (\lam z _ z|1 => Inv.ldiv (transport (\lam x => LDiv z x) map.func-ide z|1))

    \class GCDSubset \extends RSubset
      | rat : Nom -> Denom -> \Sigma Nom Denom
      | gcd_val : Nom -> Denom -> Denom
      | gcd_nom (a : Nom) (b : Denom) : (rat a b).1 * map.func (gcd_val a b) = a
      | gcd_denom (a : Nom) (b : Denom) : (rat a b).2 * gcd_val a b = b
      | gcd_val_univ (a : Nom) (b : Denom) (z : Nom) : LDiv z a -> LDiv z (map.func b) -> LDiv z (map.func (gcd_val a b))
      | denom_#0 (a : Denom) : map.func a `#0
      | denom_ide (x : Nom) (a b : Denom) : map.func a * x = map.func b -> Inv x -> x = ide
      | map-inj (a b : Denom) : map.func a = map.func b -> a = b

    \lemma denom_/=0 {S : GCDSubset} (a : Denom) : Not (map.func a = zro)
      => \lam p => #0-zro (transport #0 p (denom_#0 a))

    \lemma denom_comm {S : GCDSubset} (a b : Denom) : a * b = b * a
      => map-inj (a * b) (b * a) (map.func-* a b *> *-comm (map.func a) (map.func b) *> inv (map.func-* b a))

    \lemma denom_inv_ide {S : GCDSubset} (x : Denom) : Inv (map.func x) -> x = ide
      => \lam p => map-inj x ide (denom_ide (map.func x) ide x (inv (map.func-* ide x) *> pmap map.func (ide-left x)) p *> inv map.func-ide)

    \lemma nom_=0 {S : GCDSubset} {a : LocSet} (p : a.nom = zro) : a = inc zro
      => LocSet.equals p (denom_inv_ide a.denom (a.coprime (map.func a.denom)
            (\new LDiv { | inv => zro | inv-right => zro_*-right _ *> inv p })
            (\new LDiv { | inv => ide | inv-right => ide-right _ })))

    \func ratio {S : GCDSubset} (nom : Nom) (denom : Denom) : LocSet
      => \let! (x,y) => rat nom denom
         \in \new LocSet x y (coprime nom denom)
      \where {
        \lemma coprime {S : GCDSubset} (a : Nom) (b : Denom) : Coprime (rat a b).1 (map.func (rat a b).2)
          => \lam z z|x z|y =>
            \let | u => map.func (gcd_val a b)
                 | zu|a => transport (\lam t => LDiv (z * u) t) (gcd_nom a b) (LDiv.product-right z (rat a b).1 u z|x)
                 | zu|b => transport (\lam t => LDiv (z * u) t) (inv (map.func-* _ _) *> Paths.pmap map.func (gcd_denom a b)) (LDiv.product-right z (map.func (rat a b).2) u z|y)
                 | zu|u : LDiv (z * u) u => gcd_val_univ a b (z * u) zu|a zu|b
            \in Inv.lmake zu|u.inv (Domain.nonZero-cancel-right (zu|u.inv * z) ide u (denom_/=0 (gcd_val a b)) (
              (zu|u.inv * z) * u ==< *-assoc _ _ _ >==
              zu|u.inv * (z * u) ==< *-comm _ _ >==
              (z * u) * zu|u.inv ==< zu|u.inv-right >==
              u                  ==< inv (ide-left u) >==
              ide * u            `qed))

        \func pmap {S : GCDSubset} {a a' : Nom} (p : a = a') {b b' : Denom} (q : b = b') : ratio a b = ratio a' b'
          => path (\lam i => ratio (p @ i) (q @ i))
      }

    \lemma denom_div {S : GCDSubset} {a b : Denom} (a|b : LDiv (map.func a) (map.func b)) (b|a : LDiv (map.func b) (map.func a)) : a = b
      => map-inj a b (inv (pmap (map.func a *) (inv_ide a|b b|a) *> ide-right (map.func a)) *> a|b.inv-right)
      \where
        \lemma inv_ide {S : GCDSubset} {a b : Denom} (a|b : LDiv (map.func a) (map.func b)) (b|a : LDiv (map.func b) (map.func a)) : a|b.inv = ide
          => denom_ide a|b.inv a b a|b.inv-right (Inv.lmake b|a.inv (Domain.nonZero-cancel-left _ _ _(denom_/=0 b) (
                map.func b * (b|a.inv * a|b.inv) ==< inv (*-assoc _ _ _) >==
                (map.func b * b|a.inv) * a|b.inv ==< pmap (\lam t => t * a|b.inv) b|a.inv-right >==
                map.func a * a|b.inv             ==< a|b.inv-right >==
                map.func b                       ==< inv (ide-right _) >==
                map.func b * ide                 `qed)))

    \lemma ratio-*-right {S : GCDSubset} (x : Nom) (y z : Denom) : ratio x y = ratio (x * map.func z) (y * z)
      => \let | (x',y') => rat x y
              | u => gcd_val x y
              | (xz',yz') => rat (x * map.func z) (y * z)
              | xz'*v=x*z => gcd_nom (x * map.func z) (y * z)
              | yz'*v=y*z => inv (map.func-* yz' (gcd_val (x * map.func z) (y * z))) *> pmap map.func (gcd_denom (x * map.func z) (y * z)) *> map.func-* y z
              | u*z=v => inv (pmap map.func (gcd-*-right x y z) *> map.func-* u z)
         \in LocSet.equals (Domain.nonZero-cancel-right x' xz' _ (denom_/=0 u) (gcd_nom x y *> inv (Domain.nonZero-cancel-right (xz' * map.func u) x _ (denom_/=0 z) (*-assoc _ _ _ *> pmap (xz' *) u*z=v *> xz'*v=x*z))))
                           (map-inj y' yz' (Domain.nonZero-cancel-right (map.func y') (map.func yz') _ (denom_/=0 u) (inv (map.func-* y' u) *> pmap map.func (gcd_denom x y) *> inv (Domain.nonZero-cancel-right (map.func yz' * map.func u) (map.func y) _ (denom_/=0 z) (*-assoc _ _ _ *> pmap (map.func yz' *) u*z=v *> yz'*v=y*z)))))
      \where
        \lemma gcd-*-right {S : GCDSubset} (a : Nom) (b c : Denom) : gcd_val (a * map.func c) (b * c) = gcd_val a b * c
          => \let | (a',b') => rat a b
                  | (ac',bc') => rat (a * map.func c) (b * c)
                  | d => gcd_val a b
                  | e => gcd_val (a * map.func c) (b * c)
                  | d*c|e : LDiv => gcd_val_univ (a * map.func c) (b * c) (map.func d * map.func c)
                        (\new LDiv {
                          | inv => a'
                          | inv-right => *-comm _ _ *> inv (*-assoc _ _ _) *> pmap (\lam t => t * map.func c) (gcd_nom a b)
                        })
                        (\new LDiv {
                          | inv => map.func b'
                          | inv-right => *-comm _ _ *> inv (*-assoc _ _ _) *> pmap (\lam t => t * map.func c) (inv (map.func-* _ _) *> pmap map.func (gcd_denom a b)) *> inv (map.func-* b c)
                        })
                  | u => d*c|e.inv
                  | e=[u*d]*c => inv (*-assoc _ _ _ *> *-comm _ _ *> d*c|e.inv-right)
                  | [u*d]*c|a*c : LDiv => transport (\lam t => LDiv t (a * map.func c)) e=[u*d]*c (\new LDiv { | inv => ac' | inv-right => *-comm _ _ *> gcd_nom (a * map.func c) (b * c) })
                  | [u*d]*c|b*c : LDiv => transport (\lam t => LDiv t (map.func b * map.func c)) e=[u*d]*c (\new LDiv { | inv => map.func bc' | inv-right => *-comm _ _ *> inv (map.func-* _ _) *> pmap map.func (gcd_denom (a * map.func c) (b * c)) *> map.func-* _ _ })
                  | u*d|d : LDiv => gcd_val_univ a b (u * map.func d)
                                          (\new LDiv {
                                            | inv => [u*d]*c|a*c.inv
                                            | inv-right => Domain.nonZero-cancel-right ((u * map.func d) * [u*d]*c|a*c.inv) a _ (denom_/=0 c) (*-assoc _ _ _ *> pmap ((u * map.func d) *) (*-comm _ _) *> inv (*-assoc _ _ _) *> [u*d]*c|a*c.inv-right)
                                          })
                                          (\new LDiv {
                                            | inv => [u*d]*c|b*c.inv
                                            | inv-right => Domain.nonZero-cancel-right ((u * map.func d) * [u*d]*c|b*c.inv) (map.func b) _ (denom_/=0 c) (*-assoc _ _ _ *> pmap ((u * map.func d) *) (*-comm _ _) *> inv (*-assoc _ _ _) *> [u*d]*c|b*c.inv-right)
                                          })
                  | u=1 => denom_ide u (d * c) e (pmap (\lam t => t * u) (map.func-* d c) *> d*c|e.inv-right) (Inv.lmake u*d|d.inv (Domain.nonZero-cancel-right (u*d|d.inv * u) ide _ (denom_/=0 d) (*-assoc _ _ _ *> *-comm _ _ *> u*d|d.inv-right *> inv (ide-left _))))
             \in map-inj e (d * c) (e=[u*d]*c *> pmap (\lam t => (t * map.func d) * map.func c) u=1 *> pmap (\lam t => t * map.func c) (ide-left (map.func d)) *> inv (map.func-* d c))

    \lemma ratio-*-left {S : GCDSubset} (x : Nom) (y z : Denom) : ratio x y = ratio (map.func z * x) (z * y)
      => ratio-*-right x y z *> ratio.pmap (*-comm x (map.func z)) (denom_comm y z)

    \lemma ratio-equiv {S : GCDSubset} (x r : Nom) (y s : Denom) (p : x * map.func s = r * map.func y) : ratio x y = ratio r s
      => ratio x y                      ==< ratio-*-right x y s >==
         ratio (x * map.func s) (y * s) ==< ratio.pmap (p *> *-comm _ _) idp >==
         ratio (map.func y * r) (y * s) ==< inv (ratio-*-left r s y) >==
         ratio r s                      `qed

    \lemma ratio-lem {S : GCDSubset} (a : LocSet) : ratio a.nom a.denom = a
      => \let | (x,y) => rat a.nom a.denom
              | u => gcd_val a.nom a.denom
              | x*u=an => gcd_nom a.nom a.denom
              | y*u=ad => gcd_denom a.nom a.denom
              | x*ad=an*y => Domain.nonZero-cancel-right _ _ _ (denom_/=0 u) (
                  (x * map.func a.denom) * map.func u ==< *-assoc _ _ _ >==
                  x * (map.func a.denom * map.func u) ==< pmap (x *) (*-comm _ _) >==
                  x * (map.func u * map.func a.denom) ==< inv (*-assoc _ _ _) >==
                  (x * map.func u) * map.func a.denom ==< pmap (\lam t => t * map.func a.denom) x*u=an >==
                  a.nom * map.func a.denom            ==< inv (pmap (\lam t => a.nom * map.func t) y*u=ad) >==
                  a.nom * map.func (y * u)            ==< pmap (a.nom *) (map.func-* y u) >==
                  a.nom * (map.func y * map.func u)   ==< inv (*-assoc _ _ _) >==
                  (a.nom * map.func y) * map.func u   `qed)
              | ad|y : LDiv (map.func a.denom) (map.func y) => div-lem a.denom y a.nom
                        (\lam z z|ad z|an => a.coprime z z|an z|ad)
                        (transport (\lam t => LDiv (map.func a.denom) t) x*ad=an*y (\new LDiv { | inv => x | inv-right => *-comm _ _ }))
              | y|ad : LDiv (map.func y) (map.func a.denom) => div-lem y a.denom x
                        (\lam z z|y z|x => ratio.coprime a.nom a.denom z z|x z|y)
                        (transport (\lam t => LDiv (map.func y) t) (inv x*ad=an*y) (\new LDiv { | inv => a.nom | inv-right => *-comm _ _ }))
              | u=1 => inv (Domain.nonZero-cancel-left _ _ _ (denom_/=0 y) (y|ad.inv-right *> inv (pmap map.func y*u=ad) *> map.func-* _ _)) *> denom_div.inv_ide y|ad ad|y
         \in LocSet.equals (inv (pmap (x *) u=1 *> ide-right x) *> x*u=an) (denom_div y|ad ad|y)
      \where {
        \lemma div-lem {S : GCDSubset} (a c : Denom) (b : Nom) (p : Coprime (map.func a) b) (a|bc : LDiv (map.func a) (b * map.func c))
          : \level (LDiv (map.func a) (map.func c))
                   (LDiv.cancelProp (map.func a) (\lam x y => Domain.nonZero-cancel-left (map.func a) x y (denom_/=0 a)) (map.func c))
          => \let | e => gcd_val (b * map.func c) (a * c)
                  | c|e : LDiv (map.func c) (map.func e) => gcd_val_univ (b * map.func c) (a * c) (map.func c)
                                                                         (\new LDiv { | inv => b | inv-right => *-comm _ _ })
                                                                         (\new LDiv { | inv => map.func a | inv-right => *-comm _ _ *> inv (map.func-* a c) })
                  | x => c|e.inv
                  | (x',y') => rat (b * map.func c) (a * c)
                  | x-inv : Inv x => p x (\new LDiv {
                      | inv => map.func y'
                      | inv-right => Domain.nonZero-cancel-left _ _ _ (denom_/=0 c) (
                          map.func c * (x * map.func y') ==< inv (*-assoc _ _ _) >==
                          (map.func c * x) * map.func y' ==< pmap (\lam t => t * map.func y') c|e.inv-right >==
                          map.func e * map.func y'       ==< *-comm _ _ >==
                          map.func y' * map.func e       ==< inv (map.func-* y' e) >==
                          map.func (y' * e)              ==< pmap map.func (gcd_denom (b * map.func c) (a * c)) >==
                          map.func (a * c)               ==< map.func-* a c >==
                          map.func a * map.func c        ==< *-comm _ _ >==
                          map.func c * map.func a        `qed)
                    }) (\new LDiv {
                      | inv => x'
                      | inv-right => Domain.nonZero-cancel-left _ _ _ (denom_/=0 c) (
                          map.func c * (x * x') ==< inv (*-assoc _ _ _) >==
                          (map.func c * x) * x' ==< pmap (\lam t => t * x') c|e.inv-right >==
                          map.func e * x'       ==< *-comm _ _ >==
                          x' * map.func e       ==< gcd_nom (b * map.func c) (a * c) >==
                          b * map.func c        ==< *-comm _ _ >==
                          map.func c * b        `qed)
                    })
             \in LDiv.trans (map.func a) (map.func e) (map.func c)
                            (gcd_val_univ (b * map.func c) (a * c) (map.func a) a|bc (\new LDiv { | inv => map.func c | inv-right => inv (map.func-* a c) }))
                            (\new LDiv {
                              | inv => x-inv.inv
                              | inv-right =>
                                  map.func e * x-inv.inv       ==< pmap (\lam t => t * x-inv.inv) (inv c|e.inv-right) >==
                                  (map.func c * x) * x-inv.inv ==< *-assoc (map.func c) x x-inv.inv >==
                                  map.func c * (x * x-inv.inv) ==< pmap (map.func c *) x-inv.inv-right >==
                                  map.func c * ide             ==< ide-right (map.func c) >==
                                  map.func c                   `qed
                            })
      }

    \func \infixl 6 ++ {S : GCDSubset} (a b : LocSet) => ratio (a.nom * map.func b.denom + b.nom * map.func a.denom) (a.denom * b.denom)

    \lemma ratio-+ {S : GCDSubset} (x y : Nom) (z w : Denom) : ratio x z ++ ratio y w = ratio (x * map.func w + y * map.func z) (z * w)
      => \let | (x',z') => rat x z
              | (y',w') => rat y w
              | u => gcd_val x z
              | v => gcd_val y w
              | p1 =>
                  (x' * map.func w') * (map.func z * map.func w)                 ==< inv (pmap (\lam t => (x' * map.func w') * (map.func t * map.func w)) (gcd_denom x z)) >==
                  (x' * map.func w') * (map.func (z' * u) * map.func w)          ==< pmap (\lam t => (x' * map.func w') * (t * map.func w)) (map.func-* z' u *> *-comm _ _) >==
                  (x' * map.func w') * ((map.func u * map.func z') * map.func w) ==< rloc.swap _ _ _ _ >==
                  (x' * (map.func u * map.func z')) * (map.func w' * map.func w) ==< pmap2 (*) (inv (*-assoc _ _ _)) (*-comm _ _) >==
                  ((x' * map.func u) * map.func z') * (map.func w * map.func w') ==< rloc.swap _ _ _ _ >==
                  ((x' * map.func u) * map.func w) * (map.func z' * map.func w') ==< pmap (\lam t => (t * map.func w) * (map.func z' * map.func w')) (gcd_nom x z) >==
                  (x * map.func w) * (map.func z' * map.func w')                 `qed
              | p2 =>
                  (y' * map.func z') * (map.func z * map.func w)                 ==< inv (pmap (\lam t => (y' * map.func z') * (map.func z * map.func t)) (gcd_denom y w)) >==
                  (y' * map.func z') * (map.func z * map.func (w' * v))          ==< pmap (\lam t => (y' * map.func z') * (map.func z * t)) (map.func-* w' v *> *-comm _ _) >==
                  (y' * map.func z') * (map.func z * (map.func v * map.func w')) ==< inv (pmap ((y' * map.func z') *) (*-assoc _ _ _)) >==
                  (y' * map.func z') * ((map.func z * map.func v) * map.func w') ==< rloc.swap _ _ _ _ >==
                  (y' * (map.func z * map.func v)) * (map.func z' * map.func w') ==< pmap (\lam t => t * (map.func z' * map.func w')) (pmap (y' *) (*-comm _ _) *> inv (*-assoc _ _ _)) >==
                  ((y' * map.func v) * map.func z) * (map.func z' * map.func w') ==< pmap (\lam t => (t * map.func z) * (map.func z' * map.func w')) (gcd_nom y w) >==
                  (y * map.func z) * (map.func z' * map.func w')                 `qed
         \in ratio-equiv _ _ _ _ (
                (x' * map.func w' + y' * map.func z') * map.func (z * w)                                        ==< pmap ((x' * map.func w' + y' * map.func z') *) (map.func-* z w) >==
                (x' * map.func w' + y' * map.func z') * (map.func z * map.func w)                               ==< rdistr _ _ _ >==
                (x' * map.func w') * (map.func z * map.func w) + (y' * map.func z') * (map.func z * map.func w) ==< pmap2 (+) p1 p2 >==
                (x * map.func w) * (map.func z' * map.func w') + (y * map.func z) * (map.func z' * map.func w') ==< inv (rdistr _ _ _) >==
                (x * map.func w + y * map.func z) * (map.func z' * map.func w')                                 ==< inv (pmap ((x * map.func w + y * map.func z) *) (map.func-* z' w')) >==
                (x * map.func w + y * map.func z) * map.func (z' * w')                                          `qed)

    \func \infixl 7 ** {S : GCDSubset} (a b : LocSet) => ratio (a.nom * b.nom) (a.denom * b.denom)

    \lemma ratio-* {S : GCDSubset} (x y : Nom) (z w : Denom) : ratio x z ** ratio y w = ratio (x * y) (z * w)
      => \let | (x',z') => rat x z
              | (y',w') => rat y w
              | u => gcd_val x z
              | v => gcd_val y w
         \in ratio-equiv (x' * y') (x * y) (z' * w') (z * w) (
                (x' * y') * map.func (z * w)                                          ==< pmap2 (\lam t s => (x' * y') * map.func (t * s)) (inv (gcd_denom x z)) (inv (gcd_denom y w)) >==
                (x' * y') * map.func ((z' * u) * (w' * v))                            ==< pmap ((x' * y') *) (map.func-* _ _) >==
                (x' * y') * (map.func (z' * u) * map.func (w' * v))                   ==< rloc.swap x' y' (map.func (z' * u)) (map.func (w' * v)) >==
                (x' * map.func (z' * u)) * (y' * map.func (w' * v))                   ==< pmap2 (\lam t s => (x' * t) * (y' * s)) (map.func-* z' u *> *-comm _ _) (map.func-* w' v *> *-comm _ _) >==
                (x' * (map.func u * map.func z')) * (y' * (map.func v * map.func w')) ==< inv (pmap2 (*) (*-assoc _ _ _) (*-assoc _ _ _)) >==
                ((x' * map.func u) * map.func z') * ((y' * map.func v) * map.func w') ==< rloc.swap _ _ _ _ >==
                ((x' * map.func u) * (y' * map.func v)) * (map.func z' * map.func w') ==< inv (pmap (((x' * map.func u) * (y' * map.func v)) *) (map.func-* z' w')) >==
                ((x' * map.func u) * (y' * map.func v)) * map.func (z' * w')          ==< pmap2 (\lam t s => (t * s) * map.func (z' * w')) (gcd_nom x z) (gcd_nom y w) >==
                (x * y) * map.func (z' * w')                                          `qed)
  }

\open LocRing

\func localization {S : GCDSubset} : Localization Nom {RSubset.toSubset} \cowith
  | R' => LocRing
  | inL => locMap
  | local x p => \case p \with {
    | inP (y,fy=x) =>
      \let j => \new LocSet ide y (\lam z z|1 _ => Inv.ldiv z|1)
      \in Inv.lmake j (
        j ** inc x                         ==< inv (path (\lam i => (ratio-lem j @ i) ** (ratio-lem (inc x) @ i))) >==
        ratio ide y ** ratio x ide         ==< ratio-* ide x y ide >==
        ratio (ide * x) (y * ide)          ==< path (\lam i => ratio ((pmap (ide *) (inv fy=x) *> *-comm _ _) @ i) (y * ide)) >==
        ratio (map.func y * ide) (y * ide) ==< inv (ratio-*-left _ _ _) >==
        ratio ide ide                      ==< ratio-lem ide >==
        (ide : LocSet)                     `qed)
  }
  | local-univ {R} (f : RingHom Nom R) l =>
    \let | B (g : RingHom LocRing R) => \Pi (x : Nom) -> g.func (inc x) = f.func x
         | f' : RingHom LocRing R =>
            \let j (x : Denom) : Inv (f.func (map.func x)) => l (map.func x) (inP (x, idp))
            \in \new RingHom {
              | func (a : LocSet) => f.func a.nom * Inv.inv {j a.denom}
              | func-ide => inv (pmap (\lam t => f.func t * Inv.inv {j ide}) map.func-ide) *> inv-right {j ide}
              | func-+ (a b : LocSet) => {?}
              | func-* (a b : LocSet) => {?}
            }
         | p : \Sigma (f' : RingHom LocRing R) (B f') => (f', {?})
    \in Contr.make p (\lam q => SigmaPropExt B p q {?})
  \where {
    \func locMap {S : GCDSubset} : RingHom Nom LocRing \cowith
      | func => inc
      | func-ide => idp
      | func-+ x y =>
        inc (x + y)                                             ==< inv (ratio-lem (inc (x + y))) >==
        ratio (x + y) ide                                       ==< inv (ratio.pmap (pmap2 (+) (pmap (x *) map.func-ide *> ide-right x) (pmap (y *) map.func-ide *> ide-right y)) (ide-left ide)) >==
        ratio (x * map.func ide + y * map.func ide) (ide * ide) ==< inv (ratio-+ _ _ _ _) >==
        ratio x ide ++ ratio y ide                              ==< path (\lam i => (ratio-lem (inc x) @ i) ++ (ratio-lem (inc y) @ i)) >==
        inc x ++ inc y                                          `qed
      | func-* x y =>
        inc (x * y)                ==< inv (ratio-lem (inc (x * y))) >==
        ratio (x * y) ide          ==< inv (path (\lam i => ratio (x * y) (ide-left ide @ i))) >==
        ratio (x * y) (ide * ide)  ==< inv (ratio-* _ _ _ _) >==
        ratio x ide ** ratio y ide ==< path (\lam i => (ratio-lem (inc x) @ i) ** (ratio-lem (inc y) @ i)) >==
        inc x ** inc y             `qed

    \lemma locMap-epi {S : GCDSubset} : isEpi {CRingCategory} locMap => \lam {Q} (g h : RingHom) q =>
        \let | q' x : g.func (inc x) = h.func (inc x) => path (\lam i => RingHom.func {q @ i} x)
             | p (f : RingHom LocRing Q) (a : LocSet) : f.func a * f.func (inc (map.func a.denom)) = f.func (inc a.nom) =>
               inv (f.func-* _ _) *> pmap f.func (
                 a ** inc (map.func a.denom)                         ==< inv (path (\lam i => (ratio-lem a @ i) ** (ratio-lem (inc (map.func a.denom)) @ i))) >==
                 ratio a.nom a.denom ** ratio (map.func a.denom) ide ==< ratio-* _ _ _ _ >==
                 ratio (a.nom * map.func a.denom) (a.denom * ide)    ==< path (\lam i => ratio (*-comm _ _ @ i) (a.denom * ide)) >==
                 ratio (map.func a.denom * a.nom) (a.denom * ide)    ==< inv (ratio-*-left a.nom ide a.denom) >==
                 ratio a.nom ide                                     ==< ratio-lem (inc a.nom) >==
                 qed {LocSet} (inc a.nom))
             | ide/ y => \new LocSet ide y (\lam z z|1 _ => Inv.ldiv z|1)
             | j y : Inv (g.func (inc (map.func y))) => Inv.lmake (g.func (ide/ y)) (p g (ide/ y) *> g.func-ide)
        \in RingHom.equals {LocRing} (\lam (a : LocSet) => RInv.cancel (j a.denom) (
          g.func a * g.func (inc (map.func a.denom)) ==< p g a >==
          g.func (inc a.nom)                         ==< q' a.nom >==
          h.func (inc a.nom)                         ==< inv (p h a) >==
          h.func a * h.func (inc (map.func a.denom)) ==< inv (pmap (h.func a *) (q' (map.func a.denom))) >==
          h.func a * g.func (inc (map.func a.denom)) `qed))
  }
