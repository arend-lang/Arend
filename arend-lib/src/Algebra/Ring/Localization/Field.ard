\import Algebra.Field
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Ring.Localization
\import Logic
\import Paths
\import Relation.Equivalence
\open Monoid
\open LocRing

{-
\func test {R : CRing} (S : MSubset R) (a : SType S) : ** S (in~ a) (in~ a) = in~ (a.1 * a.1, (a.2.1 * a.2.1, contains_* a.2.1 a.2.1 a.2.2 a.2.2)) => idp

\lemma localization-inv {R : CRing} (S : MSubset R) (a : SType S) (r : R) (p : contains (a.1 * r)) : Inv {LocRing S} (in~ (a.1, (a.2.1, a.2.2)))
  => Inv.lmake {LocRing S} (in~ (a.2.1 * r, (a.1 * r, p)))
               (path (~-equiv {SType S} _ _ (
                 ((a.2.1 * r) * a.1) * ide ==< ide-right _ >==
                 (a.2.1 * r) * a.1         ==< *-comm _ _ >==
                 a.1 * (a.2.1 * r)         ==< inv (*-assoc _ _ _) >==
                 (a.1 * a.2.1) * r         ==< pmap (\lam t => t * r) (*-comm _ _) >==
                 (a.2.1 * a.1) * r         ==< *-assoc _ _ _ >==
                 a.2.1 * (a.1 * r)         ==< *-comm _ _ >==
                 (a.1 * r) * a.2.1         ==< inv (ide-left _) >==
                 ide * ((a.1 * r) * a.2.1) `qed)))

\lemma localization-nonTrivial {R : CRing} (S : MSubset R) (p : Not (S.contains zro)) : Not (zro = {LocRing S} ide)
  => \lam zro=ide => {?}

\lemma localization-isDiscreteField {R : CRing} (S : MSubset R) (nt : Not (S.contains zro)) : DiscreteField { | CRing => LocRing S } \cowith
  | zro/=ide => localization-nonTrivial S nt
  | eitherZeroOrInv x~ => \case x~ \as x~ \return (x~ = in~ (zro, (ide, contains_ide))) || Inv x~ \with {
    | in~ x => {?}
  }
 -}