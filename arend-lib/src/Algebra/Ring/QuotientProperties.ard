\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Pointed.Category
\import Algebra.Ring
\import Algebra.Ring.Category
\import Algebra.Ring.Ideal
\import Algebra.Ring.RingHom
\import Algebra.Ring.Sub
\import Category
\import Function
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\func univ_img {R : Ring} {S : Ring} (f : RingHom R S) : RingHom (FactorRing f.Ker) (SubRing.struct {f.Im}) \cowith {
  | func => univ {R} {S} {f}
  | func-+ => univ_+ {R} {S} {f}
  | func-ide => ext (unfold (func-ide {f}))
  | func-* => univ_* {R} {S} {f}
} \where {
  \func univ {R : Ring} {S : Ring} {f : RingHom R S} (x : FactorRing f.Ker) : SubRing.struct {f.Im} \elim x
    | in~ a => (f a, inP (a, idp))
    | ~-equiv x1 y r => ext \let A0 => rewrite (zro-left, +-assoc, negative-left, zro-right) (pmap (\lam z => z S.+ f y) (rewrite r in AddGroupHom.func-minus {f} {x1} {y})) \in inv A0

  \func univ_+ {R : Ring} {S : Ring} {f : RingHom R S} {x y : FactorRing f.Ker} : univ {R} {S} {f} (x + y) = univ {R} {S} {f} x + {SubRing.struct {f.Im}} univ {R} {S} {f} y \elim x, y
    | in~ a, in~ a1 => ext (rewrite (func-+ {f}) idp)

  \func univ_* {R : Ring} {S : Ring} {f : RingHom R S} {x y : FactorRing f.Ker} : univ {R} {S} {f} (x * y) = univ {R} {S} {f} x * {SubRing.struct {f.Im}} univ {R} {S} {f} y \elim x, y
    | in~ a, in~ a1 => ext (rewrite (func-* {f}) idp)

  \func univ_surj {R : Ring} {S : Ring} {f : RingHom R S} : isSurj (univ {R} {S} {f}) => \lam (x, inP (r, A)) => inP (in~ r, ext A)

  \func univ_inj {R : Ring} {S : Ring} {f : RingHom R S} : isInj (univ {R} {S} {f}) => \lam {in~ a} {in~ a'} p => FactorRing.fequiv (unfold (rewrite (AddGroupHom.func-minus {f}) (AddGroup.toZero (pmap (\lam x => x.1) p))))
}

\func iso_cast {R S : CRing} {f : RingHom R S} (p : Iso {RingCat} {R} {S} f) : Iso {CRingCat} {R} {S} f \cowith
  | hinv => p.hinv
  | hinv_f => p.hinv_f
  | f_hinv => p.f_hinv

\func theoremA {R : Ring} {S : Ring} (f : RingHom R S) : Iso {RingCat} {FactorRing f.Ker} {SubRing.struct {RingHom.Im {f}}} (univ_img f)
  => RingHom.asIso {univ_img f} (univ_img.univ_inj, univ_img.univ_surj)

\func theoremA_C {R S : CRing} (f : RingHom R S) : Iso {CRingCat} {CFactorRing (RingHom.KerC f)} {CSubRing.struct {RingHom.ImC f}} (univ_img f)
  => iso_cast (theoremA f)