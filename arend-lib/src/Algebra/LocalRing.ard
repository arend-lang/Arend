\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ring
\import Logic
\import Paths
\import Relation.Apartness
\open CMonoid(Inv)

\class LocalCRing \extends CRing, Apartness {
  | nonTrivial : Not (addId = id)
  | clocality (x y : E) : x + y = id -> Inv x || Inv y

  | # x y => Inv (x - y)
  | #-irreflexive x (p : Inv (x - x)) => nonTrivial (
    addId           ==< inv (addId_*-right p.inv) >==
    p.inv * addId   ==< inv (pmap (\lam t => p.inv * t) (negative-right x)) >==
    p.inv * (x - x) ==< p.inv-left >==
    id              `qed)
  | #-symmetric x y (p : Inv (x - y)) => \new Inv (y - x) (negative p.inv) (
    negative p.inv * (y - x)                         ==< ldistr (negative p.inv) y (negative x) >==
    negative p.inv * y + negative p.inv * negative x ==< pmap (\lam t => negative p.inv * y + t) (Ring.negative_*-left p.inv (negative x)) >==
    negative p.inv * y - p.inv * negative x          ==< pmap (\lam t => negative p.inv * y - t) (Ring.negative_*-right p.inv x) >==
    negative p.inv * y - negative (p.inv * x)        ==< pmap (\lam t => negative p.inv * y + t) (Group.inverse-isInvolution {AbGroup.toCGroup (_ : AbGroup)} (p.inv * x)) >==
    negative p.inv * y + p.inv * x                   ==< +-comm (negative p.inv * y) (p.inv * x) >==
    p.inv * x + negative p.inv * y                   ==< pmap (\lam t => p.inv * x + t) (Ring.negative_*-left p.inv y) >==
    p.inv * x - p.inv * y                            ==< pmap (\lam t => p.inv * x + t) (inv (Ring.negative_*-right p.inv y)) >==
    p.inv * x + p.inv * negative y                   ==< inv (ldistr p.inv x (negative y)) >==
    p.inv * (x - y)                                  ==< p.inv-left >==
    id                                               `qed)
  | #-comparison x y z p => sumInv=>eitherInv' clocality (x - y) (y - z) (transport (\lam t => Inv t) (
    x - z                    ==< pmap (\lam t => t - z) (inv (addId-right x)) >==
    x + addId - z            ==< pmap (\lam t => x + t - z) (inv (negative-left y)) >==
    x + (negative y + y) - z ==< pmap (\lam t => t - z) (inv (+-assoc x (negative y) y)) >==
    (x - y) + y - z          ==< +-assoc (x - y) y (negative z) >==
    (x - y) + (y - z)        `qed) p)

  \lemma sumInv=>eitherInv (x y : E) (q : Inv (x + y)) : Inv x || Inv y => sumInv=>eitherInv' clocality x y q
} \where {
  \lemma sumInv=>eitherInv' {R : CRing} (p : \Pi (x y : R) -> x + y = id -> Inv x || Inv y) (x y : R) (q : Inv (x + y)) : Inv x || Inv y =>
    \case p (q.inv * x) (q.inv * y) (inv (ldistr q.inv x y) *> q.inv-left) \with {
      | byLeft s => byLeft (\new Inv x (Inv.inv {s} * q.inv) (*-assoc (Inv.inv {s}) q.inv x *> Inv.inv-left {s}))
      | byRight s => byRight (\new Inv y (Inv.inv {s} * q.inv) (*-assoc (Inv.inv {s}) q.inv y *> Inv.inv-left {s}))
    }
}