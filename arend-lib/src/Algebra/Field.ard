\import Algebra.Domain
\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ring.Local
\import Data.Or
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\open Monoid(Inv)

-- | A field is a commutative local ring such that non-invertible elements equal to {zro}.
\class Field \extends LocalCRing, IntegralDomain
  | #0 x => Inv x
  | #0-+ {x} {y} => LocalRing.sumInv=>eitherInv x y
  | #0-zro (j : Inv zro) => zro/=ide (inv zro_*-right *> j.inv-left)
  | #0-*-left {x} {y} => Inv.cfactor-left x y
  | zro#ide => Inv.lmake ide ide-left
  | apartZeroProduct xj yj => Inv.product xj yj

-- | A discrete field is a commutative ring such that every element is either {zro} or invertible.
\class DiscreteField \extends Field, IntegralDomain.Dec {
  | finv : E -> E
  | finv_zro : finv 0 = 0
  | id_finv {x : E} (x/=0 : x /= 0) : x * finv x = 1
  | eitherZeroOrInv (x : E) : (x = 0) `Or` Inv x
    \level Or.levelProp (\lam x=0 j => inv-nonZero j x=0)

  \default finv \as finvImpl x => \case eitherZeroOrInv x \with {
    | inl _ => 0
    | inr (j : Inv) => j.inv
  }
  \default finv_zro \as finv_zroImpl : finvImpl 0 = 0 => unfold finvImpl (mcases \with {
    | inl _ => idp
    | inr (j : Inv) => absurd (zro/=ide (inv zro_*-left *> j.inv-right))
  })
  \default id_finv \as id_finvImpl {x} x/=0 : x * finvImpl x = 1 => unfold finvImpl (mcases \with {
    | inl x=0 => absurd (x/=0 x=0)
    | inr (j : Inv) => j.inv-right
  })
  \default eitherZeroOrInv x => \case decideEq x 0 \with {
    | yes x=0 => inl x=0
    | no x/=0 => inr (Inv.rmake (finv x) (id_finv x/=0))
  }

  | locality x => \case eitherZeroOrInv x \with {
    | inl x=0 => byRight (Inv.lmake ide equation)
    | inr xInv => byLeft xInv
  }
  \default decideEq x y => \case eitherZeroOrInv (x - y) \with {
    | inl x-y=0 => yes (fromZero x-y=0)
    | inr x-y-isInv => no (\lam x=y => #-irreflexive (rewriteF x=y x-y-isInv))
  }
  | nonZeroApart {x} x/=0 => \case eitherZeroOrInv x \with {
    | inl x=0 => absurd (x/=0 x=0)
    | inr x#0 => x#0
  }

  \lemma finv_id {x : E} (x/=0 : x /= 0) : finv x * x = 1
    => *-comm *> id_finv x/=0

  \lemma finv-Inv {x : E} (x/=0 : x /= 0) : Inv (finv x)
    => Inv.lmake x (id_finv x/=0)

  \lemma nonZero-Inv {x : E} (x/=0 : x /= 0) : Inv x
    => Inv.rmake (finv x) (id_finv x/=0)
}