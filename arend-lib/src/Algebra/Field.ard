\import Algebra.Domain
\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ring.Local
\import Logic
\import Paths
\import Set
\open Monoid(Inv)

-- | A field is a local commutative local ring such that non-invertible elements equal to {zro}.
\class Field \extends LocalCRing.Impl, IntegralDomain
  | zro#ide => Inv.lmake ide (ide-left ide)
  | apartZeroProduct x y (xj : Inv x) (yj : Inv y) => Inv.lmake (yj.inv * xj.inv) (
      (yj.inv * xj.inv) * (x * y) ==< *-assoc yj.inv xj.inv (x * y) >==
      yj.inv * (xj.inv * (x * y)) ==< pmap (yj.inv *) (inv (*-assoc xj.inv x y)) >==
      yj.inv * ((xj.inv * x) * y) ==< pmap (\lam t => yj.inv * (t * y)) xj.inv-left >==
      yj.inv * (ide * y)          ==< pmap (yj.inv *) (ide-left y) >==
      yj.inv * y                  ==< yj.inv-left >==
      ide                         `qed)

-- | A discrete field is a commutative ring such that every element is either {zro} or invertible.
\class DiscreteField \extends Field, DecSet {
  | eitherZeroOrInv (x : E) : (x = zro) || (Inv x)

  | #0-tight x xNotInv => \case eitherZeroOrInv x \with {
    | byLeft x=0 => x=0
    | byRight xInv => absurd (xNotInv xInv)
  }
  | locality x y x+y=1 => \case eitherZeroOrInv x \with {
    | byLeft x=0 => byRight (Inv.lmake ide (
        ide * y ==< ide-left y >==
        y       ==< inv (zro-left y) >==
        zro + y ==< pmap (\lam t => t + y) (inv x=0) >==
        x + y   ==< x+y=1 >==
        ide     `qed))
    | byRight xInv => byLeft xInv
  }
  | decideEq x y => \case eitherZeroOrInv (x - y) \with {
    | byLeft x-y=0 => yes (AddGroup.fromZero x y x-y=0)
    | byRight x-y-isInv => no (\lam x=y => #-irreflexive y (transport (\lam t => Inv (t - y)) x=y x-y-isInv))
  }
}