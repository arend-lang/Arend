\import Algebra.Domain
\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ring
\import Algebra.Ring.Local
\import Logic
\import Paths
\import Set
\open Monoid(Inv)

-- | A field is a commutative local ring such that non-invertible elements equal to {zro}.
\class Field \extends LocalCRing, IntegralDomain
  | #0 x => Inv x
  | #0-+ => LocalRing.sumInv=>eitherInv
  | #0-zro (j : Inv zro) => zro/=ide (inv (zro_*-right j.inv) *> j.inv-left)
  | #0-negative x (j : Inv x) => \new Inv {
    | inv => negative j.inv
    | inv-left => negative_*-left j.inv (negative x) *> pmap negative (negative_*-right j.inv x) *> negative-isInvolution (j.inv * x) *> j.inv-left
    | inv-right => negative_*-left x (negative j.inv) *> pmap negative (negative_*-right x j.inv) *> negative-isInvolution (x * j.inv) *> j.inv-right
  }
  | #0-*-left => Inv.cfactor-left
  | zro#ide => Inv.lmake ide (ide-left ide)
  | apartZeroProduct x y (xj : Inv x) (yj : Inv y) => Inv.lmake (yj.inv * xj.inv) (
      (yj.inv * xj.inv) * (x * y) ==< *-assoc yj.inv xj.inv (x * y) >==
      yj.inv * (xj.inv * (x * y)) ==< pmap (yj.inv *) (inv (*-assoc xj.inv x y)) >==
      yj.inv * ((xj.inv * x) * y) ==< pmap (\lam t => yj.inv * (t * y)) xj.inv-left >==
      yj.inv * (ide * y)          ==< pmap (yj.inv *) (ide-left y) >==
      yj.inv * y                  ==< yj.inv-left >==
      ide                         `qed)
  \where {
    \open AddGroup(negative-isInvolution)
    \open Ring
  }

-- | A discrete field is a commutative ring such that every element is either {zro} or invertible.
\class DiscreteField \extends Field, DecSet {
  | eitherZeroOrInv (x : E) : (x = zro) || (Inv x)

  | #0-tight x xNotInv => \case eitherZeroOrInv x \with {
    | byLeft x=0 => x=0
    | byRight xInv => absurd (xNotInv xInv)
  }
  | locality x y x+y=1 => \case eitherZeroOrInv x \with {
    | byLeft x=0 => byRight (Inv.lmake ide (
        ide * y ==< ide-left y >==
        y       ==< inv (zro-left y) >==
        zro + y ==< pmap (\lam t => t + y) (inv x=0) >==
        x + y   ==< x+y=1 >==
        ide     `qed))
    | byRight xInv => byLeft xInv
  }
  | decideEq x y => \case eitherZeroOrInv (x - y) \with {
    | byLeft x-y=0 => yes (AddGroup.fromZero x y x-y=0)
    | byRight x-y-isInv => no (\lam x=y => #-irreflexive y (transport (\lam t => Inv (t - y)) x=y x-y-isInv))
  }
}