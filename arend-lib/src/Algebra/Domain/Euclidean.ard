\import Algebra.Domain
\import Algebra.Domain.Bezout
\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Int
\import Arith.Nat
\import Data.Or
\import Logic
\import Meta
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\open Monoid(LDiv)

\class EuclideanSemiringData \extends CSemiring, DecSet {
  | euclideanMap : E -> Nat
  | divMod : E -> E -> \Sigma E E
  | isDivMod (x y : E) : y * (divMod x y).1 + (divMod x y).2 = x
  | isEuclideanMap (x y : E) : Not (y = 0) -> Or ((divMod x y).2 = 0) (\Sigma (Not ((divMod x y).2 = 0)) (euclideanMap (divMod x y).2 < euclideanMap y))
  | summandDiv {x y z d : E} (d/=0 : Not (d = 0)) (p : d * x + y = d * z) : LDiv d y

  \func gcd (a b : E) => gcd-fueled (suc (euclideanMap b)) a b

  \func gcd-fueled (s : Nat) (a b : E) : E \elim s
    | 0 => a
    | suc s => \case decideEq b 0 \with {
      | yes _ => a
      | no _ => gcd-fueled s b (divMod a b).2
    }

  \lemma fueled_zro (s : Nat) (a : E) : gcd-fueled s a 0 = a \elim s
    | 0 => idp
    | suc s => mcases \with {
      | yes _ => idp
      | no p => absurd (p idp)
    }

  \func reduce-fueled (s : Nat) (a b : E) : \Sigma E E \elim s
    | 0 => (1,0)
    | suc s => \case decideEq b 0 \with {
      | yes _ => (1,0)
      | no _ => \let! | (d,m) => divMod a b
                      | (a',b') => reduce-fueled s b m
                \in (a' * d + b', a')
    }

  \func reduce (a b : E) => reduce-fueled (suc (euclideanMap b)) a b

  \lemma reduce_zro (s : Nat) (a : E) : reduce-fueled s a 0 = (1,0) \elim s
    | 0 => idp
    | suc s => mcases \with {
      | yes _ => idp
      | no p => absurd (p idp)
    }

  \lemma reduce*fueled-left (s : Nat) (a b : E) (b<=s : euclideanMap b < s) : (reduce-fueled s a b).1 * gcd-fueled s a b = a \elim s
    | 0 => ide-left
    | suc s => mcases \with {
      | yes _ => ide-left
      | no b/=0 => \case isEuclideanMap a b b/=0 \with {
        | inl mod=0 => run {
          unfold_let,
          rewrite mod=0,
          rewrite reduce_zro,
          rewrite fueled_zro,
          rewrite zro-right,
          rewrite ide-left,
          *-comm *> inv (pmap (_ +) mod=0 *> zro-right) *> isDivMod a b
        }
        | inr (_,q) => rdistr *> pmap2 (+)
            (pmap (`* _) *-comm *> *-assoc *> *-comm *> pmap (`* _) (reduce*fueled-left s b (divMod a b).2 (<=-transitive q (NatLE.unsuc b<=s))))
            (reduce*fueled-right s b (divMod a b).2 (<=-transitive q (NatLE.unsuc b<=s))) *> isDivMod a b
      }
    }

  \lemma reduce*fueled-right (s : Nat) (a b : E) (b<=s : euclideanMap b < s) : (reduce-fueled s a b).2 * gcd-fueled s a b = b \elim s
    | 0 => \case b<=s \with {}
    | suc s => mcases \with {
      | yes b=0 => zro_*-left *> inv b=0
      | no b/=0 => \case isEuclideanMap a b b/=0 \with {
        | inl mod=0 => pmap2 ((reduce-fueled s b __).1 * gcd-fueled s b __) mod=0 mod=0 *> pmap2 (__.1 * __) (reduce_zro s b) (fueled_zro s b) *> ide-left
        | inr (_,q) => reduce*fueled-left s b (divMod a b).2 (<=-transitive q (NatLE.unsuc b<=s))
      }
    }

  \lemma reduce*gcd-right (a b : E) : (reduce a b).2 * gcd a b = b
    => reduce*fueled-right (suc (euclideanMap b)) a b <=-reflexive

  \func gcd-isGCD-fueled (s : Nat) {a b g : E} (g|a : LDiv g a) (g|b : LDiv g b) : LDiv g (gcd-fueled s a b) \elim s
    | 0 => g|a
    | suc s => mcases \with {
      | yes _ => g|a
      | no b/=0 => gcd-isGCD-fueled s g|b (summandDiv (\lam g=0 => b/=0 (inv g|b.inv-right *> pmap (`* _) g=0 *> zro_*-left)) (pmap (`+ _) (inv *-assoc) *> pmap (__ * _ + _) g|b.inv-right *> isDivMod a b *> inv g|a.inv-right))
    }

  \func gcd-isGCD (a b : E) : GCD a b \cowith
    | gcd => gcd a b
    | gcd|val1 => \new LDiv {
      | inv => (reduce a b).1
      | inv-right => *-comm *> reduce*fueled-left (suc (euclideanMap b)) a b <=-reflexive
    }
    | gcd|val2 => \new LDiv {
      | inv => (reduce a b).2
      | inv-right => *-comm *> reduce*gcd-right a b
    }
    | gcd-univ g g|a g|b => gcd-isGCD-fueled (suc (euclideanMap b)) g|a g|b
}

\open EuclideanSemiringData

\class EuclideanRingData \extends EuclideanSemiringData, CRing {
  | summandDiv {x} {y} {z} {d} _ p => \new LDiv {
    | inv => z - x
    | inv-right => ldistr *> +-comm *> pmap (+ _) (inv p) *> inv +-assoc *> pmap (`+ y) (inv ldistr *> pmap (d *) (negative-left x) *> zro_*-right) *> zro-left
  }

  \func bezout-fueled (s : Nat) (a b : E) : \Sigma E E \elim s
    | 0 => (1,0)
    | suc s => \case decideEq b 0 \with {
      | yes _ => (1,0)
      | no _ => \let! | (d,m) => divMod a b
                      | (u,v) => bezout-fueled s b m
                \in (v, u - d * v)
    }

  \func bezout (a b : E) => bezout-fueled (suc (euclideanMap b)) a b

  \lemma ringLem {b1 b2 q r b : E} : b2 * (b * q + r) + (b1 - q * b2) * b = b1 * b + b2 * r
    => equation

  \lemma bezoutIdentity-fueled (s : Nat) (a b : E) : (bezout-fueled s a b).1 * a + (bezout-fueled s a b).2 * b = gcd-fueled s a b \elim s
    | 0 => pmap2 (+) ide-left zro_*-left *> zro-right
    | suc s => mcases \with {
      | yes _ => pmap2 (+) ide-left zro_*-left *> zro-right
      | no _ => unfold_let (pmap (_ * __ + _) (inv (isDivMod a b)) *> ringLem *> bezoutIdentity-fueled s b (divMod a b).2)
    }

  \lemma bezoutIdentity (a b : E) : (bezout a b).1 * a + (bezout a b).2 * b = gcd a b
    => bezoutIdentity-fueled (suc (euclideanMap b)) a b
}

\class EuclideanDomain \extends IntegralDomain.Dec, BezoutDomain
  | isEuclidean : TruncP (EuclideanRingData { | CRing => \this | decideEq => decideEq })
  | isBezout a b => TruncP.map isEuclidean (\lam (d : EuclideanRingData { | CRing => \this }) =>
      ((d.bezout a b).1, (d.bezout a b).2,
       rewrite d.bezoutIdentity (GCD.gcd|val1 {d.gcd-isGCD a b}),
       rewrite d.bezoutIdentity (GCD.gcd|val2 {d.gcd-isGCD a b})))

\instance NatEuclideanDomainData : EuclideanSemiringData
  | CSemiring => NatSemiring
  | euclideanMap n => n
  | divMod => divMod
  | isDivMod => divModProp
  | isEuclideanMap n m m/=0 => \case \elim m, m/=0 \with {
    | 0, c => absurd (c idp)
    | suc m, _ => \case NatSemiring.decideEq (mod n (suc m)) 0 \with {
      | yes mod=0 => inl mod=0
      | no mod/=0 => inr (mod/=0, fin_<= (mod n (suc m)))
    }
  }
  | decideEq => NatSemiring.decideEq
  | summandDiv {x y z d : Nat} (d/=0 : Not (d = 0)) (dx+y=dz : d * x + y = d * z) : Monoid.LDiv d y \elim d {
    | 0 => absurd (d/=0 idp)
    | suc _ \as d => \new Monoid.LDiv {
      | inv => div y d
      | inv-right => pmap (d * div y d +) (mod-unique {d} {z} {0} {x + div y d} {mod y d} (suc<=suc zero<=_) (fin_<= (mod y d)) (inv (pmap (`+ _) ldistr *> +-assoc *> pmap (_ +) (divModProp y d) *> dx+y=dz))) *> divModProp y d
    }
  }
  \where \open Nat

\instance EuclideanData : EuclideanRingData
  | CRing => IntRing
  | decideEq => IntRing.decideEq
  | euclideanMap => iabs
  | divMod x y =>
    \let! (d,m) => Nat.divMod (iabs x) (iabs y)
    \in (pos d * signum y * signum x, pos m * signum x)
  | isDivMod (x y : Int) : y * (pos (Nat.div (iabs x) (iabs y)) * signum y * signum x) + pos (Nat.mod (iabs x) (iabs y)) * signum x = x \with {
    | pos 0, y => pmap (y * __ + _) zro_*-right *> pmap (`+ 0) zro_*-right
    | pos (suc n), pos 0 => idp
    | neg (suc n), pos 0 => idp
    | pos (suc _ \as n), pos (suc _ \as m) => pmap pos (Nat.divModProp n m)
    | pos (suc _ \as n), neg (suc _ \as m) => pmap (_ * __ + _) ide-right *> pmap pos (Nat.divModProp n m)
    | neg (suc _ \as n), pos (suc _ \as m) => pmap neg (Nat.divModProp n m)
    | neg (suc _ \as n), neg (suc _ \as m) => pmap (_ * __ + _) (Ring.negative_*-left (pos (Nat.div n m)) -1) *> pmap neg (Nat.divModProp n m)
  }
  | isEuclideanMap x y y/=0 =>
    \have |y|/=0 : Not (iabs y = 0) => \case \elim y, y/=0 \with {
      | 0, c => \lam _ => c idp
      | pos (suc _), c => \lam y=0 => c (pmap pos y=0)
      | neg (suc _), c => \lam y=0 => c (pmap neg y=0)
    }
    \in unfold_let (\case isEuclideanMap (iabs x) (iabs y) |y|/=0, decideEq (signum x) 0 \with {
      | _, yes x=0 => inl (rewrite x=0 idp)
      | inl mod=0, no x/=0 => inl (pmap (pos __ * _) mod=0 *> zro_*-left)
      | inr (mod/=0, q), no x/=0 =>
        \have t : iabs (pos (Nat.mod (iabs x) (iabs y)) * signum x) = Nat.mod (iabs x) (iabs y) => iabs.*-comm *> pmap (_ *) (iabs.signum_/=0 x/=0)
        \in inr (IntDomain.apartZeroProduct (\lam imod=0 => mod/=0 (pmap iabs imod=0)) x/=0, transport (`< iabs y) (inv t) q)
    })

\instance IntDomain : EuclideanDomain
  | CRing => IntRing
  | zro#ide => \case __ \with {}
  | apartZeroProduct {x y : Int} (x/=0 : Not (x = 0)) (y/=0 : Not (y = 0)) : Not (x * y = 0) \elim x, y {
    | pos 0, _ => \lam _ => x/=0 idp
    | pos _, pos 0 => \lam _ => y/=0 idp
    | neg _, pos 0 => \lam _ => y/=0 idp
    | pos (suc n), pos (suc m) => \case __ \with {}
    | pos (suc n), neg (suc m) => \case __ \with {}
    | neg (suc n), pos (suc m) => \case __ \with {}
    | neg (suc n), neg (suc m) => \case __ \with {}
  }
  | decideEq => IntRing.decideEq
  | isEuclidean => inP EuclideanData
