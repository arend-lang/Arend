\import Algebra.Domain
\import Algebra.Monoid
\import Algebra.Monoid.Prime
\import Algebra.Pointed
\import Arith.Nat
\import Data.Or
\import Logic
\import Order.StrictOrder
\import Paths
\import Relation.Apartness
\open IntegralDomain(nonZeroMonoid)
\open Monoid(LDiv)

\func EuclideanMap (D : IntegralDomain) => \Sigma (f : nonZeroMonoid {D} -> Nat) (is f)
  \where
    \func is {D : IntegralDomain} (f : nonZeroMonoid {D} -> Nat) =>
      \Pi (a b : nonZeroMonoid) -> LDiv a.1 b.1 `Or` (\Sigma (q : D) (r : nonZeroMonoid) (b.1 = a.1 * q + r.1) (f r < f a))

\module Euclidean \where {
  \open NatLE
  \open Nat(<=)

  -- | Computes the GCD of two non-zero elements
  \func gcd {D : IntegralDomain} (f : EuclideanMap D) (a b : nonZeroMonoid {D}) => helper f a b (f.1 a) <=-reflexive
    \where
      \func helper {D : IntegralDomain} (f : EuclideanMap D) (a b : nonZeroMonoid {D}) (n : Nat) (p : f.1 a <= n) : D \elim n
        | 0 => \case f.2 a b \with {
          | inl a|b => a.1
          | inr c => \case <=-transitive c.4 p \with {}
        }
        | suc n => \case f.2 a b \with {
          | inl a|b => a.1
          | inr (_, r, _, fr<fa) => helper f r a n (unsuc (<=-transitive fr<fa p))
        }

  -- | Computes a pair (x,y) such that {gcd f a b * x = a} and {gcd f a b * y = b}
  \func reduce {D : IntegralDomain} (f : EuclideanMap D) (a b : nonZeroMonoid {D}) => helper f a b (f.1 a) <=-reflexive
    \where
      \func helper {D : IntegralDomain} (f : EuclideanMap D) (a b : nonZeroMonoid {D}) (n : Nat) (p : f.1 a <= n) : \Sigma D D \elim n
        | 0 => \case f.2 a b \with {
          | inl (a|b : LDiv a.1 b.1) => (ide, a|b.inv)
          | inr c => \case <=-transitive c.4 p \with {}
        }
        | suc n => \case f.2 a b \with {
          | inl (a|b : LDiv a.1 b.1) => (ide, a|b.inv)
          | inr (q, r, b=aq+r, fr<fa) =>
            \let s => helper f r a n (unsuc (<=-transitive fr<fa p))
            \in (s.2, s.2 * q + s.1)
        }

  \func Coprime' {M : CMonoid} (p : \Sigma M M) => Coprime p.1 p.2

  -- | If reduce f a b = (x,y), then x and y are coprime.
  \func reduced-coprime {D : IntegralDomain} (f : EuclideanMap D) (a b : nonZeroMonoid {D}) : Coprime' (reduce f a b) => helper f a b (f.1 a) <=-reflexive
    \where
      \func helper {D : IntegralDomain} (f : EuclideanMap D) (a b : nonZeroMonoid {D}) (n : Nat) (p : f.1 a <= n) : Coprime' (reduce.helper f a b n p) \elim n
        | 0 => \case f.2 a b \as t \return Coprime' (\case t \with { | inl (a|b : LDiv a.1 b.1) => (ide, a|b.inv) | inr c => \case <=-transitive c.4 p \with {} }) \with {
          | inl a|b => {?}
          | inr c => {?}
        }
        | suc n => {?}
}

{-
\func euclideanAlgorithm {D : IntegralDomain} (a b : nonZeroMonoid {D}) (f : EuclideanMap D) (n : Nat) (p : f.1 a <= n)
  : \Sigma (s t : D) (LDiv (s * a.1 + t * b.1) a.1) (LDiv (s * a.1 + t * b.1) b.1) \elim n
  | 0 => \case f.2 a b \with {
    | inl a|b => div a|b
    | inr c => \case <=-transitive c.4 p \with {}
  }
  | suc n => \case f.2 a b \with {
    | inl a|b => div a|b
    | inr (s, t, sa+tb#0, q) => \case <=-transitive q p \with {
      | suc<=suc f[sa+tb]<=n => \case euclideanAlgorithm (s * a.1 + t * b.1, sa+tb#0) b f n f[sa+tb]<=n \with {
        | (s', t', s'[sa+tb]+t'b|a, s'[sa+tb]+t'b|b) =>
          \let r : s' * (s * a.1 + t * b.1) + t' * b.1 = (s' * s) * a.1 + (s' * t + t') * b.1 => {?}
          \in (s' * s, s' * t + t', transport (\lam z => LDiv z a.1) r s'[sa+tb]+t'b|a, transport (\lam z => LDiv z b.1) r s'[sa+tb]+t'b|b)
      }
    }
  }
  \where {
    \open NatLE

    \func div {D : IntegralDomain} {a b : D} (a|b : LDiv a b) : \Sigma (s t : D) (LDiv (s * a + t * b) a) (LDiv (s * a + t * b) b) =>
      \let ide*a+zro*b=a => pmap2 (+) (ide-left a) (IntegralDomain.zro_*-left b) *> zro-right a
      \in (ide, zro, \new LDiv {
        | inv => ide
        | inv-right => ide-right _ *> ide*a+zro*b=a
      }, transport (\lam x => LDiv x b) (inv ide*a+zro*b=a) a|b)
  }
-}

\class EuclideanDomain \extends IntegralDomain
  | isEuclidean : TruncP (EuclideanMap \this)
