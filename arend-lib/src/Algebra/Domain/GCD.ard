\import Algebra.Domain
\import Algebra.Field
\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Logic
\import Paths
\open Monoid(LDiv,Inv)

\class GCDDomain \extends IntegralDomain {
  | isGCD (x y : E) : x # zro -> y # zro -> TruncP (GCD x y)

  \func nonZeroMonoid : GCDMonoid \cowith
    | CancelCMonoid => IntegralDomain.nonZeroMonoid
    | isGCD x y => \case isGCD x.1 y.1 x.2 y.2 \with {
      | inP gcd => {?}
    }
} \where {
  \func fromField (K : Field) : GCDDomain \cowith
    | IntegralDomain => IntegralDomain.fromField K
    | isGCD x y (x#0 : Inv (x - zro)) (y#0 : Inv (y - zro)) => inP (\new GCD {
      | gcd => ide
      | gcd|val1 => {?} -- \new LDiv { | inv => x | inv-right => K.ide-left x }
      | gcd|val2 => {?} -- \new LDiv { | inv => y | inv-right => K.ide-left y }
      | gcd-univ g g|x g|y => {?} {- g (g|x : LDiv g x) (g|y : LDiv g y) => \new LDiv {
        | inv => g|x.inv K.* x#0.inv
        | inv-right =>
          g K.* (g|x.inv K.* x#0.inv) ==< inv (K.*-assoc g g|x.inv x#0.inv) >==
          (g K.* g|x.inv) K.* x#0.inv ==< pmap (\lam t => t K.* x#0.inv) g|x.inv-right >==
          x K.* x#0.inv               ==< pmap (\lam t => t K.* x#0.inv) (inv (AddGroup.minus_zro {K} x)) >==
          (x - K.zro) K.* x#0.inv     ==< x#0.inv-right >==
          K.ide                       `qed
      } -}
    })
}
