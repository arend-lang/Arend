\import Algebra.Domain
\import Algebra.Field
\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Logic
\import Paths
\import Paths.Meta
\open Monoid(LDiv,Inv)

\class GCDDomain \extends IntegralDomain {
  | isGCD (x y : E) : x `#0 -> y `#0 -> TruncP (GCD x y)

  \func nonZeroMonoid : GCDMonoid \cowith
    | CancelCMonoid => IntegralDomain.nonZeroMonoid
    | isGCD x y => \case isGCD x.1 y.1 x.2 y.2 \with {
      | inP (g : GCD x.1 y.1) =>
        \have | g*x#0 => transport #0 (inv g.gcd|val1.inv-right) x.2
              | g#0 => #0-*-left g*x#0
        \in inP (\new GCD {
                   | gcd => (g.gcd, g#0)
                   | gcd|val1 => \new LDiv {
                     | inv => (g.gcd|val1.inv, #0-*-right g*x#0)
                     | inv-right => ext g.gcd|val1.inv-right
                   }
                   | gcd|val2 => \new LDiv {
                     | inv => (g.gcd|val2.inv, #0-*-right (transport #0 (inv g.gcd|val2.inv-right) y.2))
                     | inv-right => ext g.gcd|val2.inv-right
                   }
                   | gcd-univ h (h|x : LDiv h x) (h|y : LDiv h y) =>
                     \have h|g : LDiv h.1 g.gcd => g.gcd-univ h.1 (\new LDiv h.1 x.1 h|x.inv.1 (pmap __.1 h|x.inv-right))
                                                                  (\new LDiv h.1 y.1 h|y.inv.1 (pmap __.1 h|y.inv-right))
                     \in \new LDiv {
                       | inv => (h|g.inv, #0-*-right (transport #0 (inv h|g.inv-right) g#0))
                       | inv-right => ext h|g.inv-right
                     }
                 })
    }
} \where {
  \func fromField (K : Field) : GCDDomain \cowith
    | IntegralDomain => K
    | isGCD x y (x#0 : Inv x) _ => inP (\new GCD {
      | gcd => ide
      | gcd|val1 => \new LDiv { | inv => x | inv-right => ide-left }
      | gcd|val2 => \new LDiv { | inv => y | inv-right => ide-left }
      | gcd-univ g (g|x : LDiv g x) (g|y : LDiv g y) => \new LDiv {
        | inv => g|x.inv K.* x#0.inv
        | inv-right =>
            g * (g|x.inv * x#0.inv) ==< inv *-assoc >==
            (g * g|x.inv) * x#0.inv ==< pmap (`* x#0.inv) g|x.inv-right >==
            x * x#0.inv             ==< x#0.inv-right >==
            ide                     `qed
      }
    })
}
