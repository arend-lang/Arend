\import Algebra.Domain.GCD(GCDDomain)
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\open Monoid(LDiv)

\class BezoutDomain \extends GCDDomain {
  | isBezout : IsBezout
  | isGCDDomain x y _ _ => TruncP.map (isBezout x y) (\lam p => bezoutGCD p.3 p.4)
} \where {
  \class Dec \extends StrictBezoutDomain, GCDDomain.Dec {
    \default isStrictBezout a b => \case decideEq a 0 \with {
      | yes e => inP (1, 1, 1, 0, simplify e, simplify Monoid.Inv.ide-isInv)
      | no a/=0 => TruncP.map (isBezout a b) \lam (s, t, p : LDiv, q : LDiv) =>
        \have gcd/=0 : GCD.gcd {bezoutGCD p q} /= 0 => \lam gcd=0 => a/=0 $ inv p.inv-right *> equation
        \in (t, s, q.inv, p.inv, nonZero-cancel-right gcd/=0 $ equation {usingOnly (p.inv-right, q.inv-right)},
             transportInv Monoid.Inv (nonZero-cancel-right gcd/=0 $ equation {usingOnly (p.inv-right, q.inv-right)}) Monoid.Inv.ide-isInv)
    }
  }
}

\class StrictBezoutDomain \extends BezoutDomain {
  | isStrictBezout (a b : E) : âˆƒ (s t u v : E) (a * u = b * v) (Monoid.Inv (s * u + t * v))
  \default isBezout a b => TruncP.map (isStrictBezout a b) \lam (s,t,u,v,p,(x,xl,_)) => (t, s, \new LDiv {
    | inv => x * v
    | inv-right => equation
  }, \new LDiv {
    | inv => x * u
    | inv-right => equation
  })
}