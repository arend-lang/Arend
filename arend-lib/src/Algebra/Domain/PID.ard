{- | Adequate rings were defined in
 -   Olaf Helmer, The elementary divisor theorem for certain rings without chain condition, 1943
 -
 -   The proof that adequate rings satisfy the Kaplansky condition is taken from
 -   Irving Kaplansky, Elementary divisors and modules, 1949
-}

\import Algebra.Domain
\import Algebra.Domain.Bezout
\import Algebra.Domain.GCD
\import Algebra.Group
\import Algebra.Linear.Matrix.Smith
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Algebra.Ring.Ideal
\import Algebra.Ring.Noetherian
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\open DivQuotient \hiding (~)
\open Monoid

\class PID \extends SmithDomain, NoetherianCRing {
  | divChain : CMonoid.DivChain {DivQuotientMonoid nonZeroMonoid}
  | isNoetherian I Ifg => Ideal.fromMonoidChainCondition (IntegralDomain.Dec.fromNonZeroDivChain divChain) I \lam n => bezout_finitelyGenerated_principal.1 isBezout (Ifg n)
  | isKaplansky => adequate_kaplansky (domain_adequate divChain)
} \where {
  \type IsAdequate {M : CMonoid} (a : M) => \Pi (b : M) -> âˆƒ (c : E) (LDiv c a) (IsCoprime c b) (\Pi (d : E) -> LDiv d a -> IsCoprime d b -> TruncP (LDiv d c))

  \open UnitlessGCDMonoid

  \lemma unitless_adequate {M : UnitlessGCDMonoid} (dc : M.DivChain) (a : M) : IsAdequate a
    => \lam b =>
        \let | g x => GCD.gcd|val1 {gcdC x b}
             | f x => LDiv.inv {g x}
             | (inP (n, d : LDiv)) => dc (iterr f __ a) \lam i => inP $ LDiv.swap $ g (iterr f i a)
             | c => iterr f n a
        \in inP (c, iterr-ind {_} {LDiv __ a} LDiv.id-div (LDiv.trans (LDiv.swap (g _)) __) n,
                 IsCoprime.<=gcd $ transport (GCD c b) (uniqueUnit $ Inv.lmake d.inv $ cancel_*-left c $ inv *-assoc *> pmap (`* g c) d.inv-right *> *-comm *> LDiv.inv-right {g c} *> inv ide-right) (gcdC c b),
                 \lam d (d|a : LDiv d a) d_b => inP $ iterr-ind {_} {LDiv d} d|a (\lam {x} (d|x : LDiv d x) => \new LDiv {
                   | inv => f d|x.inv
                   | inv-right => cancel_*-left (gcdC d|x.inv b) $ *-comm *> *-assoc *> pmap (d *) (*-comm *> LDiv.inv-right {g d|x.inv}) *> d|x.inv-right *> inv (LDiv.inv-right {g x})
                 }) n)

  \lemma monoid_adequate {M : CancelGCDMonoid} (dc : DivChain {DivQuotientMonoid M}) (a : M) : IsAdequate a
    => \lam b => \case unitless_adequate dc (inD a) (inD b) \with {
      | inP (in~ c, c|a, c_b, f) => inP (c, div-from~ c|a, IsCoprime.<=gcd $ gcd-from~ (IsCoprime.=>gcd c_b), \lam d d|a d_b => TruncP.map (f (inD d) (div-to~ d|a) (IsCoprime.<=gcd $ gcd-to~ $ IsCoprime.=>gcd d_b)) div-from~)
    }

  \lemma domain_adequate {M : GCDDomain.Dec} (dc : DivChain {DivQuotientMonoid M.nonZeroMonoid}) {a : M} (a/=0 : a /= 0) : IsAdequate a
    => \lam b => \case decideEq b 0 \with {
      | yes b=0 => inP (1, LDiv.ide-div, IsCoprime.<=gcd $ div_gcd LDiv.ide-div, \lam d _ g =>
                        inP (GCD.gcd-univ {IsCoprime.=>gcd g} d LDiv.id-div $ \new LDiv { | inv => 0 | inv-right => zro_*-right *> inv b=0 }))
      | no b/=0 => TruncP.map (monoid_adequate dc (a, nonZeroApart a/=0) (b, nonZeroApart b/=0)) \lam (c,c|a,c_b,f) =>
          (c.1, nonZero_ldiv c|a, IsCoprime.<=gcd $ nonZero_gcd $ IsCoprime.=>gcd c_b, \lam d (d|a : LDiv d a) d_b =>
           TruncP.map (f (d, #0-*-left $ transportInv #0 d|a.inv-right $ nonZeroApart a/=0) (ldiv_nonZero d|a) (IsCoprime.<=gcd $ gcd_nonZero $ IsCoprime.=>gcd d_b)) nonZero_ldiv)
    }

  \lemma adequate_kaplansky {R : BezoutDomain.Dec} (adeq : \Pi {a : R} -> a /= 0 -> IsAdequate a) : SmithRing.IsKaplansky R
    => \lam a b c a_b_c => \case coprime_bezoutArray a_b_c, decideEq a 0 \with {
      | inP (s,p), yes a=0 => inP (s 1, s 2, BezoutRing.bezout_coprime {_} {0} {1} equation)
      | _, no a/=0 =>
        \have | (inP R) => adeq a/=0 c
              | (inP (c',c*,cp)) => gcd_bezout (IsCoprime.=>gcd R.3)
        \in inP (1, c* * (1 - b), simplify \lam d d1 (y,p) =>
            \have | d_c : IsCoprime d c => \lam z (x1,p1) (x2,p2) => a_b_c z
                            (LDiv.trans (LDiv.make x1 p1) d1, LDiv.make (x1 * y - x2 * c* * (1 - b)) equation, LDiv.make x2 p2)
                  | d_R : IsCoprime d R.1 => BezoutRing.bezout_coprime {_} {y} {(1 - b) * c'} equation
            \in d_R d LDiv.id-div $ LDiv_TruncP $ R.4 d d1 d_c)
    }
}
