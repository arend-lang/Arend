\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Solver
\import Algebra.Solver.Group
\import Algebra.Solver.Monoid
\import Arith.Int()
\import Data.Array
\import Data.Bool
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\open GroupSolverModel

\func CGroupSolverModel (G : CGroup) : SolverModel G \cowith
  | Term => Term
  | NF n => Array Int n
  | normalize => normalize
  | interpret => interpret
  | interpretNF => interpretNF
  | interpretNF-consistent => interpretNF-consistent _
  \where {
    \func toArray (cs : Array Int) (env : Array G cs.len) : Array G \elim cs, env
      | nil, nil => nil
      | 0 :: cs, _ :: env => toArray cs env
      | pos (suc n) :: cs, a :: env => a :: toArray (pos n :: cs) (a :: env)
      | neg (suc n) :: cs, a :: env => inverse a :: toArray (neg n :: cs) (a :: env)

    \func sBigProd (l : Array G) : G \elim l
      | nil => G.ide
      | a :: nil => a
      | a :: l => a * sBigProd l

    \lemma sBigProd_:: {a : G} {l : Array G} : sBigProd (a :: l) = a * sBigProd l \elim l
      | nil => inv ide-right
      | b :: l => idp

    \func interpretNF {n : Nat} (env : Fin n -> G) (l : Array Int n) : G
      => sBigProd (toArray l env)

    \lemma interpretNF-correct (cs : Array Int) {env : Array G cs.len} : sBigProd (toArray cs env) = G.BigProd \lam j => G.ipow (env j) (cs j) \elim cs, env
      | nil, nil => idp
      | 0 :: cs, _ :: env => interpretNF-correct cs *> inv ide-left
      | pos (suc m) :: cs, a :: env => equation.monoid {sBigProd_::, interpretNF-correct (_ :: cs), inv G.pow-left}
      | neg (suc m) :: cs, a :: env => equation.monoid {sBigProd_::, interpretNF-correct (_ :: cs), inv G.pow-left}

    \lemma interpretNF-consistent' {n : Nat} {env : Fin n -> G} {t : Term n} : G.BigProd (\lam j => G.ipow (env j) (normalize t j)) = interpret env t \elim t
      | var i => G.BigProd-unique i (\lam j p => later $ rewrite (decideEq/=_reduce p) idp) *> rewrite (decideEq=_reduce idp) ide-left
      | :ide => G.BigProd_replicate1
      | :inverse t => G.BigProd-ext (\lam i => G.ipow_negaitve) *> inv G.BigProd_inverse *> pmap inverse interpretNF-consistent'
      | t :* s => G.BigProd-ext (\lam i => G.ipow_+) *> G.BigProd_* *> pmap2 (*) interpretNF-consistent' interpretNF-consistent'

    \lemma interpretNF-consistent {n : Nat} {env : Fin n -> G} (t : Term n) : interpretNF env (normalize t) = interpret env t
      => interpretNF-correct _ *> interpretNF-consistent'

    \open Arith.Int.IntRing(negative,+)

    \func normalize {n : Nat} (t : Term n) : Array Int n \elim t
      | var v => single v (pos 1) 0
      | :ide => replicate n (pos 0)
      | :inverse t => map negative (normalize t)
      | t :* s => mkArray \lam j => normalize t j + normalize s j

    \lemma terms-equality (env : Array G) (t s : Term env.len) (p : interpretNF env (normalize (t :* :inverse s)) = G.ide) : interpret env t = interpret env s
      => inv (*-assoc *> pmap (_ *) inverse-left *> G.ide-right) *> pmap (`* _) (inv (interpretNF-consistent (t :* :inverse s)) *> p) *> G.ide-left

    \lemma terms-equality-conv (env : Array G) (t s : Term env.len) (p : interpret env t = interpret env s) : interpretNF env (normalize (t :* :inverse s)) = G.ide
      => interpretNF-consistent (t :* :inverse s) *> pmap (`* _) p *> inverse-right
  }

\func AbGroupSolverModel (A : AbGroup) : SolverModel A
  => CGroupSolverModel (AbGroup.toCGroup A)
  \where {
    \open CGroupSolverModel

    \lemma terms-equality (env : Array A) (t s : Term env.len) (p : interpretNF {AbGroup.toCGroup A} env (normalize (t :* :inverse s)) = A.zro)
      => CGroupSolverModel.terms-equality env t s p

    \lemma terms-equality-conv (env : Array A) (t s : Term env.len) (p : interpret {AbGroup.toCGroup A} env t = interpret {AbGroup.toCGroup A} env s)
      => CGroupSolverModel.terms-equality-conv env t s p
  }
