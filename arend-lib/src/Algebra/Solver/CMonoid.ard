\import Algebra.Monoid
\import Algebra.Solver \using (interpretNF)
\import Algebra.Solver.Monoid
\import Arith.Fin.Order
\import Data.List
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\open MonoidSolverModel
\open Sort

\func CMonoidSolverModel (M : CMonoid) : SubstSolverModel M \cowith
  | Term => Term
  | NF n => List (Fin n)
  | normalize => (MonoidSolverModel M).normalize
  | interpret => MonoidSolverModel.interpret
  | interpretNF env nf => MonoidSolverModel.interpretNF env (RedBlack.sort nf)
  | interpretNF-consistent => sort-consistent *> (MonoidSolverModel M).interpretNF-consistent
  | nfVar v => v :: nil
  | >>= => >>=
  | >>=-consistent => sort-consistent *> (MonoidSolverModel M).>>=-consistent *> pmap (interpretNF __ _) (ext \lam v => inv sort-consistent) *> inv sort-consistent
  \where {
    \lemma sort-consistent {n : Nat} {env : Fin n -> M} {l : List (Fin n)}
      : (MonoidSolverModel M).interpretNF env (RedBlack.sort l) = (MonoidSolverModel M).interpretNF env l
      => inv $ rewrite RedBlack.sort=insert (perm-consistent (Sort.Insertion.sort-perm l))

    \protected \lemma perm-consistent {n : Nat} {env : Fin n -> M} {l l' : List (Fin n)} (p : Sort.Perm l l') : MonoidSolverModel.interpretNF env l = MonoidSolverModel.interpretNF env l' \elim l, l', p
      | nil, nil, perm-nil => idp
      | :: a1 l1, :: a2 l2, perm-:: idp p => repeat {2} (rewrite MonoidSolverModel.interpretNF_::) $ pmap (env a1 *) (perm-consistent p)
      | :: a1 (:: a1' l1), :: a2 (:: a2' l2), perm-swap idp idp idp => repeat {2} (rewrite MonoidSolverModel.interpretNF_::) $ inv *-assoc *> pmap (`* _) *-comm *> *-assoc
      | l1, l2, perm-trans p1 p2 => perm-consistent p1 *> perm-consistent p2
  }

\func AbMonoidSolverModel (A : AbMonoid) : SubstSolverModel A
  => CMonoidSolverModel (AbMonoid.toCMonoid A)
