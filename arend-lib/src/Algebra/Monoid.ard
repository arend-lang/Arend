\import Algebra.Pointed
\import Paths

\class Monoid \extends Pointed {
  | \infixl 7 * : E -> E -> E
  | ide-left (x : E) : ide * x = x
  | ide-right (x : E) : x * ide = x
  | *-assoc (x y z : E) : (x * y) * z = x * (y * z)
} \where {
  \record Inv {M : Monoid} (val inv : M)
    | inv-left : inv * val = ide
    | inv-right : val * inv = ide
  \where {
    \use \level isProp {M : Monoid} {x : M} (j j' : Inv x) : j = j' =>
      \let q : j.inv = j'.inv =>
        j.inv                ==< Paths.inv (ide-left j.inv) >==
        ide * j.inv          ==< Paths.inv (pmap (\lam t => t * j.inv) j'.inv-left) >==
        (j'.inv * x) * j.inv ==< *-assoc j'.inv x j.inv >==
        j'.inv * (x * j.inv) ==< pmap (\lam t => j'.inv * t) j.inv-right >==
        j'.inv * ide         ==< ide-right j'.inv >==
        j'.inv               `qed
      \in path (\lam i => \new Inv x {
        | inv => q @ i
        | inv-left => pathOver (Path.inProp (coe (\lam i => (q @ i) * x = ide) j.inv-left right) j'.inv-left) @ i
        | inv-right => pathOver (Path.inProp (coe (\lam i => x * (q @ i) = ide) j.inv-right right) j'.inv-right) @ i
      })
  }

  \func op (M : Monoid) : Monoid \cowith
    | Pointed => M
    | * x y => M.* y x
    | ide-left => M.ide-right
    | ide-right => M.ide-left
    | *-assoc x y z => inv (M.*-assoc z y x)
}

\class AddMonoid \extends AddPointed
  | \infixl 6 + : E -> E -> E
  | zro-left (x : E) : zro + x = x
  | zro-right (x : E) : x + zro = x
  | +-assoc (x y z : E) : (x + y) + z = x + (y + z)
  \where {
    \use \coerce fromMonoid (M : Monoid) => \new AddMonoid M.E M.ide (M.*) M.ide-left M.ide-right M.*-assoc
    \use \coerce toMonoid (M : AddMonoid) => \new Monoid M.E M.zro (M.+) M.zro-left M.zro-right M.+-assoc
  }

\class CMonoid \extends Monoid {
  | *-comm (x y : E) : x * y = y * x
  | ide-right x => *-comm x ide *> ide-left x
} \where {
  \record Div {M : CMonoid} (val elem inv : M)
    | inv-left : inv * val = elem

  \record Inv \extends Div
    | elem => ide
  \where {
    \use \level isProp {M : CMonoid} {x : M} (j j' : Inv x) : j = j' =>
      \let q : j.inv = j'.inv =>
        j.inv                ==< Paths.inv (ide-left j.inv) >==
        ide * j.inv          ==< Paths.inv (pmap (\lam t => t * j.inv) j'.inv-left) >==
        (j'.inv * x) * j.inv ==< *-assoc j'.inv x j.inv >==
        j'.inv * (x * j.inv) ==< pmap (\lam t => j'.inv * t) (*-comm x j.inv) >==
        j'.inv * (j.inv * x) ==< pmap (\lam t => j'.inv * t) j.inv-left >==
        j'.inv * ide         ==< ide-right j'.inv >==
        j'.inv               `qed
      \in path (\lam i => \new Inv x { | inv => q @ i | inv-left => pathOver (Path.inProp (coe (\lam i => (q @ i) * x = ide) j.inv-left right) j'.inv-left) @ i })

    \lemma factor-right {M : CMonoid} (x y : M) (i : Inv (x * y)) : Inv y \cowith
      | inv => i.inv * x
      | inv-left => *-assoc i.inv x y *> i.inv-left

    \lemma factor-left {M : CMonoid} (x y : M) (i : Inv (x * y)) : Inv x => factor-right y x (transport (\lam t => Inv t) (*-comm x y) i)

    \lemma product {M : CMonoid} (i j : Inv {M}) : Inv (i.val * j.val) \cowith
      | inv => j.inv * i.inv
      | inv-left =>
        (j.inv * i.inv) * (i.val * j.val) ==< *-assoc j.inv i.inv (i.val * j.val) >==
        j.inv * (i.inv * (i.val * j.val)) ==< pmap (j.inv *) (Paths.inv (*-assoc i.inv i.val j.val)) >==
        j.inv * ((i.inv * i.val) * j.val) ==< pmap (\lam t => j.inv * (t * j.val)) i.inv-left >==
        j.inv * (ide * j.val)             ==< pmap (j.inv *) (ide-left j.val) >==
        j.inv * j.val                     ==< j.inv-left >==
        ide                               `qed
  }
}

\class AbMonoid \extends AddMonoid
  | +-comm (x y : E) : x + y = y + x
  | zro-right x => +-comm x zro *> zro-left x
  \where {
    \use \coerce fromCMonoid (M : CMonoid) => \new AbMonoid M.E M.ide (M.*) M.ide-left M.*-assoc M.*-comm
    \use \coerce toCMonoid (M : AbMonoid) => \new CMonoid M.E M.zro (M.+) M.zro-left M.+-assoc M.+-comm
  }
