\import Algebra.Group
\import Algebra.Group.Product
\import Algebra.Meta
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Ring
\import Algebra.Ring.Category
\import Algebra.Semiring
\import Data.Array
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta

\class LModule (R : Ring) \extends AbGroup {
  | \infixl 7 *c : R -> E -> E
  | *c-assoc {r r' : R} {a : E} : r * r' *c a = r *c (r' *c a)
  | *c-ldistr {r : R} {a b : E} : r *c (a + b) = r *c a + r *c b
  | *c-rdistr {r s : R} {a : E} : (r R.+ s) *c a = r *c a + s *c a
  | ide_*c {a : E} : 1 *c a = a

  \lemma cancel {r : R} {a b : E} (i : Monoid.Inv r) (s : r *c a = r *c b) : a = b
    => inv ide_*c *> inv (pmap (`*c a) i.inv-left) *> *c-assoc *> pmap (i.inv *c) s *> inv *c-assoc *> pmap (`*c b) i.inv-left *> ide_*c

  \lemma *c_zro-left {a : E} : 0 *c a = 0
    => cancel-left (0 *c a) $ inv *c-rdistr *> simplify

  \lemma *c_zro-right {r : R} : r *c 0 = 0
    => cancel-left (r *c 0) $ inv *c-ldistr *> simplify

  \lemma *c_negative-left {r : R} {a : E} : R.negative r *c a = negative (r *c a)
    => negative-unique (r *c a) (inv *c-rdistr *> pmap (`*c a) R.negative-left *> *c_zro-left) negative-right

  \lemma *c_negative-right {r : R} {a : E} : r *c negative a = negative (r *c a)
    => negative-unique (r *c a) (inv *c-ldistr *> pmap (r *c) negative-left *> *c_zro-right) negative-right

  \lemma neg_ide_*c {a : E} : -1 *c a = negative a
    => *c_negative-left *> pmap negative ide_*c

  \lemma *c_BigSum-left {l : Array R} {a : E} : R.BigSum l *c a = BigSum (\lam i => l i *c a) \elim l
    | nil => *c_zro-left
    | r :: l => *c-rdistr *> pmap (_ +) *c_BigSum-left

  \lemma *c_BigSum-right {r : R} {l : Array E} : r *c BigSum l = BigSum (\lam i => r *c l i) \elim l
    | nil => *c_zro-right
    | a :: l => *c-ldistr *> pmap (_ +) *c_BigSum-right

  \type isGenerated (l : Array E) : \Prop
    => \Pi (x : E) -> âˆƒ (c : Array R l.len) (x = BigSum (mkArray (\lam i => c i *c l i)))

  \func isFaithful : \Prop
    => \Pi (r : R) -> (\Pi (m : E) -> r *c m = 0) -> r = 0
}

\meta LModule' R => LModule { | R => R }

\instance ProductLModule (R : Ring) (A B : LModule' R) : LModule' R
  | AbGroup => ProductAbGroup A B
  | *c r p => (r *c p.1, r *c p.2)
  | *c-assoc => pmap2 (__,__) *c-assoc *c-assoc
  | *c-ldistr => pmap2 (__,__) *c-ldistr *c-ldistr
  | *c-rdistr => pmap2 (__,__) *c-rdistr *c-rdistr
  | ide_*c => pmap2 (__,__) ide_*c ide_*c

\func RingLModule (R : Ring) : LModule R { | R => R } \cowith
  | AbGroup => R
  | *c => *
  | *c-assoc => *-assoc
  | *c-ldistr => R.ldistr
  | *c-rdistr => R.rdistr
  | ide_*c => ide-left
  \where {
    \func *_hom-left {R : CRing} {x : R} : LinearMap' (RingLModule R) (RingLModule R) \cowith
      | func y => x * y
      | func-+ => ldistr
      | func-*c => equation

    \func *_hom-right {R : Ring} {x : R} : LinearMap' (RingLModule R) (RingLModule R) \cowith
      | func y => y * x
      | func-+ => rdistr
      | func-*c => *-assoc

    \lemma generated {R : Ring} : LModule.isGenerated {RingLModule R} (1 :: nil)
      => \lam x => inP (x :: nil, simplify)
  }

\instance PowerLModule {R : Ring} (J : \Set) (M : LModule' R) : LModule (J -> M) { | R => R }
  | zro _ => 0
  | + f g j => f j + g j
  | zro-left => ext (\lam j => zro-left)
  | zro-right => ext (\lam j => zro-right)
  | +-assoc => ext (\lam j => +-assoc)
  | negative f j => negative (f j)
  | negative-left => ext (\lam j => negative-left)
  | +-comm => ext (\lam j => +-comm)
  | *c r f j => r *c f j
  | *c-assoc => ext (\lam j => *c-assoc)
  | *c-ldistr => ext (\lam j => *c-ldistr)
  | *c-rdistr => ext (\lam j => *c-rdistr)
  | ide_*c => ext (\lam j => ide_*c)

\instance ArrayLModule {R : Ring} (n : Nat) (M : LModule' R) : LModule (Array M n) { | R => R }
  | zro _ => 0
  | + f g j => f j + g j
  | zro-left => arrayExt (\lam j => zro-left)
  | zro-right => arrayExt (\lam j => zro-right)
  | +-assoc => arrayExt (\lam j => +-assoc)
  | negative f j => negative (f j)
  | negative-left => arrayExt (\lam j => negative-left)
  | +-comm => arrayExt (\lam j => +-comm)
  | *c r f j => r *c f j
  | *c-assoc => arrayExt (\lam j => *c-assoc)
  | *c-ldistr => arrayExt (\lam j => *c-ldistr)
  | *c-rdistr => arrayExt (\lam j => *c-rdistr)
  | ide_*c => arrayExt (\lam j => ide_*c)
  \where {
    \lemma skip_*c {R : CRing} {n : Nat} {r : R} {l : Array R (suc n)} {k : Fin (suc n)}
      : skip (r *c {ArrayLModule _ (RingLModule R)} l) k = r *c {ArrayLModule _ (RingLModule R)} skip l k \elim n, l, k
      | 0, a :: nil, 0 => idp
      | suc n, a :: l, 0 => idp
      | suc n, a :: l, suc k => path (\lam i => r *c a :: skip_*c i)

    \lemma skip_+ {R : CRing} {n : Nat} {l l' : Array R (suc n)} {k : Fin (suc n)}
      : skip (l + {ArrayLModule _ (RingLModule R)} l') k = skip l k + {ArrayLModule _ (RingLModule R)} skip l' k \elim n, l, l', k
      | 0, a :: nil, a' :: nil, 0 => idp
      | suc n, a :: l, a' :: l', 0 => idp
      | suc n, a :: l, a' :: l', suc k => path (\lam i => a + a' :: skip_+ i)

    \func BigSum-index {R : Ring} {n : Nat} {M : LModule' R} {l : Array (Array M n)} {i : Fin n}
      : AddMonoid.BigSum {ArrayLModule n M} l i = M.BigSum (map {Array M n} (__ i) l) \elim l
      | nil => idp
      | a :: l => pmap (_ +) BigSum-index
  }

\func homLModule (f : RingHom) : LModule' f.Dom \cowith
  | AbGroup => f.Cod
  | *c x y => f x * y
  | *c-assoc => pmap (`* _) f.func-* *> *-assoc
  | *c-ldistr => ldistr
  | *c-rdistr => pmap (`* _) f.func-+ *> rdistr
  | ide_*c => pmap (`* _) f.func-ide *> ide-left