\import Algebra.Group
\import Algebra.Group.Product
\import Algebra.Linear.Matrix
\import Algebra.Meta
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Ring
\import Algebra.Ring.Category
\import Algebra.Semiring
\import Category
\import Data.Array
\import Data.Fin \hiding (Index)
\import Data.Or
\import Equiv \hiding (Map)
\import Function (isInj)
\import Function.Meta
\import HLevel
\import Logic
\import Logic.Classical
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin

\class LModule (R : Ring) \extends AbGroup {
  | \infixl 7 *c : R -> E -> E
  | *c-assoc {r r' : R} {a : E} : r * r' *c a = r *c (r' *c a)
  | *c-ldistr {r : R} {a b : E} : r *c (a + b) = r *c a + r *c b
  | *c-rdistr {r s : R} {a : E} : (r R.+ s) *c a = r *c a + s *c a
  | ide_*c {a : E} : 1 *c a = a

  \lemma cancel {r : R} {a b : E} (i : Monoid.Inv r) (s : r *c a = r *c b) : a = b
    => inv ide_*c *> inv (pmap (`*c a) i.inv-left) *> *c-assoc *> pmap (i.inv *c) s *> inv *c-assoc *> pmap (`*c b) i.inv-left *> ide_*c

  \lemma *c_zro-left {a : E} : 0 *c a = 0
    => cancel-left (0 *c a) $ inv *c-rdistr *> simplify

  \lemma *c_zro-right {r : R} : r *c 0 = 0
    => cancel-left (r *c 0) $ inv *c-ldistr *> simplify

  \lemma *c_negative-left {r : R} {a : E} : R.negative r *c a = negative (r *c a)
    => negative-unique (r *c a) (inv *c-rdistr *> pmap (`*c a) R.negative-left *> *c_zro-left) negative-right

  \lemma *c_negative-right {r : R} {a : E} : r *c negative a = negative (r *c a)
    => negative-unique (r *c a) (inv *c-ldistr *> pmap (r *c) negative-left *> *c_zro-right) negative-right

  \lemma neg_ide_*c {a : E} : -1 *c a = negative a
    => *c_negative-left *> pmap negative ide_*c

  \lemma *c_BigSum-rdistr {l : Array R} {a : E} : R.BigSum l *c a = BigSum (\lam i => l i *c a) \elim l
    | nil => *c_zro-left
    | r :: l => *c-rdistr *> pmap (_ +) *c_BigSum-rdistr

  \lemma *c_BigSum-ldistr {r : R} {l : Array E} : r *c BigSum l = BigSum (\lam i => r *c l i) \elim l
    | nil => *c_zro-right
    | a :: l => *c-ldistr *> pmap (_ +) *c_BigSum-ldistr

  \lemma *c_FinSum-rdistr {J : FinSet} {f : J -> R} {a : E} : R.FinSum f *c a = FinSum (\lam j => f j *c a)
    => \case R.FinSum_char f \with {
         | inP (e,p) => pmap (`*c a) p *> *c_BigSum-rdistr *> inv (FinSum_char2 _ e)
       }

  \lemma *c_FinSum-ldistr {r : R} {J : FinSet} {f : J -> E} : r *c FinSum f = FinSum (\lam j => r *c f j)
    => \case FinSum_char f \with {
         | inP (e,p) => pmap (r *c) p *> *c_BigSum-ldistr *> inv (FinSum_char2 _ e)
       }

  \func IsDependent (l : Array E) : \Prop
    => ∃ (c : Array R l.len) (BigSum (\lam j => c j *c l j) = 0) (j : Fin l.len) (c j /= 0)

  \func IsIndependent (l : Array E) : \Prop
    => \Pi (c : Array R l.len) -> BigSum (\lam j => c j *c l j) = 0 -> \Pi (j : Fin l.len) -> c j = 0

  \type IsGenerated (l : Array E) : \Prop
    => \Pi (x : E) -> ∃ (c : Array R l.len) (x = BigSum (\lam i => c i *c l i))

  \type IsBasis (l : Array E) : \Prop
    => \Sigma (IsIndependent l) (IsGenerated l)

  \type IsIndependentSet {J : \Set} (g : J -> E) : \Prop
    => \Pi (c : Array (\Sigma R J)) -> sum g c = 0 -> c ~ nil
    \where {
      \func sum {J : \Set} (g : J -> E) (c : Array (\Sigma R J)) => BigSum (\lam j => (c j).1 *c g (c j).2)

      \lemma sum-ldistr {J : \Set} (g : J -> E) {r : R} {c : Array (\Sigma R J)} : r *c sum g c = sum g (map (\lam s => (r * s.1, s.2)) c)
        => *c_BigSum-ldistr *> pmap BigSum (exts \lam j => inv *c-assoc)

      \lemma sum_++ {c d : Array (\Sigma R J)} : sum g (c ++ d) = sum g c + sum g d
        => pmap (sum g) ++_++' *> pmap BigSum (exts \case ++'.split-index __ \with {
          | inl (j,p) => rewrite (p, ++'.++'_index-left, ++'.++'_index-left {_} {_} {d.len}) idp
          | inr (j,p) => rewrite (p, ++'.++'_index-right, ++'.++'_index-right {_} {_} {d.len}) idp
        }) *> BigSum_++'

      \lemma sum_negative {c : Array (\Sigma R J)} : negative (sum g c) = sum g (map (\lam s => (R.negative s.1, s.2)) c)
        => BigSum_negative *> pmap BigSum (exts \lam j => inv *c_negative-left)

      \lemma sum_EPerm {J : \Set} (g : J -> E) {l l' : Array (\Sigma R J)} (p : EPerm l l') : sum g l = sum g l' \elim l, l', p
        | nil, nil, eperm-nil => idp
        | x :: l1, _ :: l2, eperm-:: idp q => pmap (_ +) (sum_EPerm g q)
        | x :: (x' :: l1), _ :: (_ :: _), eperm-swap idp idp idp => inv +-assoc *> pmap (`+ _) +-comm *> +-assoc
        | l, l', eperm-trans p1 p2 => sum_EPerm g p1 *> sum_EPerm g p2

      \lemma =_~ (gi : IsIndependentSet g) {c d : Array (\Sigma R J)} (p : sum g c = sum g d) : c ~ d
        => ~-trans (transport2 (~) ++_nil (inv ++-assoc) (~_++-right ~_negative)) $ ~_++-left $ gi (c ++ map (\lam s => (R.negative s.1, s.2)) d) $ (sum_++ *> pmap (_ +) (inv sum_negative)) *> toZero p

      \lemma ~_= {J : \Set} (g : J -> E) {c d : Array (\Sigma R J)} (p : c ~ d) : sum g c = sum g d \elim c, d, p
        | nil, nil, ~-nil => idp
        | x :: l1, y :: l2, ~-:: idp q => pmap (_ +) (~_= g q)
        | x :: (x' :: l), _ :: (_ :: _), ~-swap idp idp idp => inv +-assoc *> pmap (`+ _) +-comm *> +-assoc
        | x :: l, d, ~-0 p q => unfold sum $ unfold BigSum $ rewrite (p,*c_zro-left) $ zro-left *> pmap (sum g) q
        | x :: (y :: l1), z :: _, ~-+ p1 p2 p3 idp => inv +-assoc *> pmap (`+ _) (later $ rewrite (p2, p3, inv p1) $ inv *c-rdistr)
        | c, d, ~-sym p => inv (~_= g p)
        | c, d, ~-trans p1 p2 => ~_= g p1 *> ~_= g p2
    }

  \type IsIndependentDec {J : \Set} (g : J -> E) : \Prop
    => \Pi (l : Array J) (c : Array R l.len) -> isInj l -> BigSum (\lam j => c j *c g (l j)) = 0 -> \Pi (j : Fin c.len) -> c j = 0

  \lemma IsIndependentSet<->IsIndependentDec {J : DecSet} {g : J -> E} : IsIndependentSet g <-> IsIndependentDec g
    => (\lam li l c inj p j => inv (count-unique {_} {J} {_} {c} inj j) *> ~_count (li (\lam j => (c j, l j)) p) (l j),
        \lam li c p => \let | js => nub (map __.2 c)
                            | t => li js (map (count c) js) nub-isInj $ pmap BigSum (exts \lam j => rewrite count-char $ *c_BigSum-rdistr *> pmap BigSum (exts \lam k => pmap (_ *c g __) $ keep.element (\lam s => decideEq (nub (map (\lam p0 => p0.2) c) j) s.2) {c} {k})) *> inv (sum_Big++ g) *> inv (sum_EPerm g nub-split) *> p
                       \in ~-sym $ count_~ \lam j => inv (t j))

  \lemma IsIndependent<->IsIndependentSet {l : Array E} : IsIndependent l <-> IsIndependentSet l
    => <->trans (later (\lam li l' c l'inj p j =>
        \let | cl' => mkArray \lam j => (c j, l' j)
             | t => li (count cl') (inv FinSum=BigSum *> FinSum-inj l' l'inj (\lam b q => pmap (`*c _) (count_zro {R} {_} {l'} {c} b \lam k => /=-sym (q k)) *> *c_zro-left) *> pmap FinSum (ext \lam k => pmap (`*c _) $ count-unique {R} {_} {l'} l'inj k) *> FinSum=BigSum *> p)
        \in inv (count-unique {R} {_} {l'} l'inj j) *> t (l' j), \lam li c p j => li (mkArray \lam j => j) c (\lam q => q) p j)) (<->sym IsIndependentSet<->IsIndependentDec)

  \type IsGeneratingSet {J : \Set} (g : J -> E) : \Prop
    => \Pi (x : E) -> ∃ (c : Array (\Sigma R J)) (x = IsIndependentSet.sum g c)

  \type IsBasisSet {J : \Set} (g : J -> E) : \Prop
    => \Sigma (IsIndependentSet g) (IsGeneratingSet g)

  \lemma independent-split-unique {l : Array E} (li : IsIndependent l) {c d : Array R l.len} (p : BigSum (\lam j => c j *c l j) = BigSum (\lam j => d j *c l j)) (j : Fin l.len) : c j = d j
    => R.fromZero $ li (\lam i => c i - d i) (cancel-right _ $ inv (BigSum_+ {_} {_} {\lam j => (c j - d j) *c l j}) *> pmap BigSum (exts \lam j => pmap (`+ _) *c-rdistr *> +-assoc *> pmap (_ +) (pmap (`+ _) *c_negative-left *> negative-left) *> zro-right) *> p *> inv zro-left) j

  \lemma basis-split-pair {l : Array E} (lb : IsBasis l) (x : E) : \Sigma (c : Array R l.len) (x = BigSum (\lam j => c j *c l j))
    \level basis-split-unique lb.1 x
    => \case lb.2 x \with {
      | inP r => r
    }
    \where {
      \lemma basis-split-unique {l : Array E} (li : IsIndependent l) (x : E) : isProp (\Sigma (c : Array R l.len) (x = BigSum (\lam j => c j *c l j)))
        => \lam s t => ext $ exts $ independent-split-unique li (inv s.2 *> t.2)
    }

  \func basis-split {l : Array E} (lb : IsBasis l) (x : E) : Array R l.len
    => (basis-split-pair lb x).1

  \lemma basis-split-char {l : Array E} {lb : IsBasis l} {x : E} : x = BigSum (\lam j => basis-split lb x j *c l j)
    => (basis-split-pair lb x).2

  \lemma basis-split-unique {l : Array E} (lb : IsBasis l) {x : E} (d : Array R l.len) (p : x = BigSum (\lam j => d j *c l j)) (j : Fin l.len) : basis-split lb x j = d j
    => independent-split-unique lb.1 (inv basis-split-char *> p) j

  \lemma basis_split_basis {l : Array E} {lb : IsBasis l} {j k : Fin l.len} : basis-split lb (l j) k = (\case decideEq j k \with { | yes _ => 1 | no _ => 0 })
    => \let f : Array R l.len => \case decideEq j __ \with { | yes _ => 1 | no _ => 0 }
       \in independent-split-unique lb.1 {_} {f} (inv $ BigSum-unique {_} {\lam k => f k *c l k} j (\lam k j/=k => rewrite (decideEq/=_reduce j/=k) *c_zro-left) *> rewrite (decideEq=_reduce idp) ide_*c *> basis-split-char) k

  \lemma basis_split_= {l : Array E} {lb : IsBasis l} {j : Fin l.len} : basis-split lb (l j) j = 1
    => basis_split_basis *> rewrite (decideEq=_reduce idp) idp

  \lemma basis_split_/= {l : Array E} {lb : IsBasis l} {j k : Fin l.len} (j/=k : j /= k) : basis-split lb (l j) k = 0
    => basis_split_basis *> rewrite (decideEq/=_reduce j/=k) idp

  \type IsGeneratedFin {J : FinSet} (f : J -> E) : \Prop
    => \Pi (x : E) -> ∃ (c : J -> R) (x = FinSum (\lam j => c j *c f j))

  \func IsFinitelyGenerated : \Prop
    => ∃ (l : Array E) (IsGenerated l)

  \lemma generated-array-fin {l : Array E} (g : IsGenerated l) : IsGeneratedFin l
    => \lam x => TruncP.map (g x) $ \lam t => (t.1, t.2 *> inv FinSum=BigSum)

  \lemma generated-fin-array {J : FinSet} {f : J -> E} (g : IsGeneratedFin f) : IsFinitelyGenerated
    => TruncP.map J.finEq $ \lam (e : Equiv {Fin J.finCard} {J}) =>
        (\lam i => f (e i), \lam x => TruncP.map (g x) $ \lam t => (\lam i => t.1 (e i), t.2 *> FinSum_Equiv e *> FinSum=BigSum))

  \func IsFaithful : \Prop
    => \Pi (r : R) -> (\Pi (m : E) -> r *c m = 0) -> r = 0
} \where {
  \func count {R : Semiring} {J : DecSet} (l : Array (\Sigma R J)) (j : J) : R \elim l
    | nil => 0
    | s :: l => \case decideEq s.2 j \with {
      | yes _ => s.1 R.+ count l j
      | no _ => count l j
    }

  \lemma count-char {R : Semiring} {J : DecSet} {l : Array (\Sigma R J)} {j : J} : count l j = R.BigSum (map __.1 $ keep (\lam s => decideEq j s.2) l) \elim l
    | nil => idp
    | s :: l => mcases \with {
      | yes p, yes p1 => pmap (_ R.+) count-char
      | yes p, no n => \case n (inv p)
      | no n, yes p => \case n (inv p)
      | no n, no n1 => count-char
    }

  \lemma count_zro {R : Semiring} {J : DecSet} {l : Array J} {c : Array R l.len} (j : J) (p : \Pi (k : Fin c.len) -> j /= l k) : count {R} (\lam j => (c j, l j)) j = 0 \elim l, c
    | nil, nil => idp
    | a :: c, j' :: l => mcases \with {
      | yes q => absurd (p 0 (inv q))
      | no q => count_zro j \lam k => p (suc k)
    }

  \lemma count-unique {R : Semiring} {J : DecSet} {l : Array J} {c : Array R l.len} (inj : isInj l) (k : Fin l.len) : count (\lam j => (c j, l j)) (l k) = c k \elim l, c, k
    | j :: l, a :: c, 0 => rewrite (decideEq=_reduce idp) $ pmap (a R.+) (count_zro j \lam k j=lk => \case inj {0} {suc k} j=lk) *> R.zro-right
    | j :: l, a :: c, suc k => mcases \with {
      | yes p => \case inj {0} {suc k} p
      | no q => count-unique (\lam p => unfsuc (inj p)) k
    }

  \truncated \data \infix 4 ~ {R : Semiring} {J : \Set} (l1 l2 : Array (\Sigma R J)) : \Prop \elim l1, l2
    | nil, nil => ~-nil
    | x :: l1, y :: l2 => ~-:: (x = y) (l1 ~ l2)
    | x :: x' :: l1, y :: y' :: l2 => ~-swap (x = y') (x' = y) (l1 = l2)
    | x :: l1, l2 => ~-0 (x.1 = 0) (l1 = l2)
    | x :: y :: l1, z :: l2 => ~-+ (x.1 R.+ y.1 = z.1) (y.2 = z.2) (x.2 = z.2) (l1 = l2)
    | l1, l2 => ~-sym (l2 ~ l1)
    | l1, l2 => ~-trans {l : Array (\Sigma R J)} (l1 ~ l) (l ~ l2)

  \lemma EPerm_~ {R : Semiring} {J : \Set} {l l' : Array (\Sigma R J)} (p : EPerm l l') : l ~ l' \elim l, l', p
    | nil, nil, eperm-nil => ~-nil
    | x :: l1, y :: l2, eperm-:: p q => ~-:: p (EPerm_~ q)
    | x :: (x' :: l1), y :: (y' :: l2), eperm-swap p1 p2 q => ~-swap p1 p2 q
    | l, l', eperm-trans p1 p2 => ~-trans (EPerm_~ p1) (EPerm_~ p2)

  \lemma ~_++-left {R : Semiring} {J : \Set} {l1 l2 l : Array (\Sigma R J)} (p : l1 ~ l2) : l1 ++ l ~ l2 ++ l \elim l1, l2, p
    | nil, nil, ~-nil => EPerm_~ EPerm.eperm-refl
    | x :: l1, y :: l2, ~-:: p q => ~-:: p (~_++-left q)
    | x :: (x' :: l1), y :: (y' :: l2), ~-swap p1 p2 idp => ~-swap p1 p2 idp
    | x :: l1, l2, ~-0 p q => ~-0 p (pmap (`++ l) q)
    | x :: (y :: l1), z :: l2, ~-+ p1 p2 p3 idp => ~-+ p1 p2 p3 idp
    | l1, l2, ~-sym p => ~-sym (~_++-left p)
    | l1, l2, ~-trans p1 p2 => ~-trans (~_++-left p1) (~_++-left p2)

  \lemma ~_++-right {R : Semiring} {J : \Set} {l l1 l2 : Array (\Sigma R J)} (p : l1 ~ l2) : l ++ l1 ~ l ++ l2 \elim l
    | nil => p
    | a :: l => ~-:: idp (~_++-right p)

  \lemma ~-+' {R : Semiring} {J : \Set} {x y : R} {j : J} {l : Array (\Sigma R J)} : (x,j) :: (y,j) :: l ~ (x R.+ y, j) :: l
    => ~-+ idp idp idp idp

  \lemma ~-0' {R : Semiring} {J : \Set} {j : J} {l : Array (\Sigma R J)} : (0,j) :: l ~ l
    => ~-0 idp idp

  \lemma ~_negative {R : Ring} {J : \Set} {c : Array (\Sigma R J)} : nil ~ map (\lam s => (R.negative s.1, s.2)) c ++ c \elim c
    | nil => ~-nil
    | a :: c =>
      ~_negative {_} {_} {c} `~-trans`
      ~-sym (~-trans ~-+' $ later $ rewrite R.negative-left $ ~-trans ~-0' $ EPerm_~ EPerm.eperm-++-comm) `~-trans`
      EPerm_~ {_} {_} {_ :: a :: c ++ map (\lam s => (R.negative s.1, s.2)) c} (eperm-:: idp EPerm.eperm-++-comm)

  \lemma ~_Big++ {R : Semiring} {J : DecSet} {n : Nat} {cs ds : Array (Array (\Sigma R J)) n} (p : \Pi (j : Fin n) -> cs j ~ ds j) : Big (++) nil cs ~ Big (++) nil ds \elim n, cs, ds
    | 0, nil, nil => ~-nil
    | suc n, c :: cs, d :: ds => ~-trans (~_++-left (p 0)) (~_++-right (~_Big++ \lam j => p (suc j)))

  \lemma count_~ {R : Semiring} {J : DecSet} {l l' : Array (\Sigma R J)} (p : \Pi (j : Fin (DArray.len {nub $ map __.2 $ l ++ l'})) -> count l (nub (map __.2 $ l ++ l') j) = count l' (nub (map __.2 $ l ++ l') j)) : l ~ l'
    => \let ll' => map __.2 $ l ++ l'
       \in aux (nub-isInj {J} {ll'}) (\lam i => \let (k,p) => nub-isSurj ll' (++.index-left i) \in (k, p *> path \lam i' => (++.++_index-left i i').2)) `~-trans`
           EPerm_~ (EPerm.eperm-= $ path \lam i j => (p j i, nub ll' j)) `~-trans`
           ~-sym (aux (nub-isInj {J} {ll'}) \lam i => \let (k,p) => nub-isSurj ll' (++.index-right i) \in (k, p *> path \lam i' => (++.++_index-right {_} {_} {_} {i} i').2))
    \where {
      \private \lemma aux {R : Semiring} {J : DecSet} {l : Array (\Sigma R J)} {js : Array J} (inj : isInj js) (p : \Pi (i : Fin l.len) -> \Sigma (k : Fin js.len) (js k = (l i).2)) : l ~ map (\lam j => (count l j, j)) js
        => ~-trans (EPerm_~ $ nub-split.aux js inj p) $ transportInv (_ ~) Big_++-singleton $ later $ ~_Big++ {R} {J} {js.len} \lam i => aux2

      \private \lemma aux2 {R : Semiring} {J : DecSet} {l : Array (\Sigma R J)} {j : J} : keep (\lam s => decideEq j s.2) l ~ (count l j, j) :: nil \elim l
        | nil => ~-sym ~-0'
        | s :: l => mcases {1} \with {
          | yes q => rewrite (decideEq=_reduce $ inv q) $ mkcon ~-trans {s :: (count l j, j) :: nil} (~-:: idp aux2) $ later $ rewrite q $ ~-+ idp idp idp idp
          | no q => rewrite (decideEq/=_reduce $ /=-sym q) aux2
        }

      \func Big_++-singleton {A : \Type} {l : Array A} : l = Big (++) nil (map (\lam a => a :: nil) l) \elim l
        | nil => idp
        | a :: l => pmap (a ::) Big_++-singleton
    }

  \lemma ~_count {R : Semiring} {J : DecSet} {l l' : Array (\Sigma R J)} (p : l ~ l') (j : J) : count l j = count l' j \elim l, l', p
    | nil, nil, ~-nil => idp
    | x :: l1, _ :: l2, ~-:: idp q => mcases \with {
      | yes _ => pmap (x.1 R.+) (~_count q j)
      | no _ => ~_count q j
    }
    | x :: (x' :: l), _ :: (_ :: _), ~-swap idp idp idp => mcases \with {
      | yes r, yes r' => rewrite (decideEq=_reduce r, decideEq=_reduce r') equation
      | yes r, no r' => rewrite (decideEq=_reduce r, decideEq/=_reduce r') idp
      | no r, yes r' => rewrite (decideEq/=_reduce r, decideEq=_reduce r') idp
      | no r, no r' => rewrite (decideEq/=_reduce r, decideEq/=_reduce r') idp
    }
    | x :: l, l', ~-0 p q => mcases \with {
      | yes _ => pmap2 (\lam x y => x R.+ count y j) p q *> R.zro-left
      | no _ => pmap (count __ j) q
    }
    | (x1,x2) :: ((y1,_) :: l), (_,_) :: _, ~-+ idp idp idp idp => mcases \with {
      | yes p => rewrite (decideEq=_reduce p) (inv R.+-assoc)
      | no q => rewrite (decideEq/=_reduce q) idp
    }
    | l, l', ~-sym p => inv (~_count p j)
    | l, l', ~-trans p1 p2 => ~_count p1 j *> ~_count p2 j

  \open IsIndependentSet

  \sfunc basisSet-split {R : Ring} {U V : LModule' R} {J : \Set} {u : J -> U} (ub : IsBasisSet u) (v : J -> V) (x : U)
    : \Sigma (y : V) (∃ (c : Array (\Sigma R J)) (x = sum u c) (y = sum v c))
    => \case TruncP.rec-set (ub.2 x) (\lam s => sum v s.1) (\lam s s' => ~_= v $ =_~ u ub.1 $ inv s.2 *> s'.2) \with {
      | (y, t) => (y, TruncP.map t \lam s => (s.1.1, s.1.2, inv s.2))
    }

  \lemma sum_Big++ {R : Ring} {U : LModule' R} {J : \Set} (g : J -> U) {l : Array (Array (\Sigma R J))} : sum g (Big (++) nil l) = BigSum (map (sum g) l) \elim l
    | nil => idp
    | c :: l => sum_++ g *> pmap (_ +) (sum_Big++ g)

  \func pullback (f : RingHom) (M : LModule' f.Cod) : LModule' f.Dom \cowith
    | AbGroup => M
    | *c a x => f a *c x
    | *c-assoc => pmap (`*c _) f.func-* *> *c-assoc
    | *c-ldistr => *c-ldistr
    | *c-rdistr => pmap (`*c _) f.func-+ *> *c-rdistr
    | ide_*c => pmap (`*c _) f.func-ide *> ide_*c

  \lemma generated-fin-comp (f : RingHom) {M : LModule' f.Cod} {I J : FinSet} {a : I -> f.Cod} {b : J -> M} (Cg : IsGeneratedFin {homLModule f} a) (Mg : IsGeneratedFin b)
    : IsGeneratedFin {pullback f M} (\lam (p : \Sigma J I) => a p.2 *c b p.1)
    => \lam x => \have | (inP (d,p)) => Mg x
                       | (inP g) => choice (\lam j => Cg (d j))
                 \in inP (\lam s => (g s.1).1 s.2, p *> path (\lam i => FinSum (\lam j => (g j).2 i *c b j)) *>
                            path (\lam i' => FinSum (\lam j => M.*c_FinSum-rdistr {I} {\lam i => (g j).1 i *c a i} {b j} i')) *> FinSum-double *> pmap FinSum (ext $ \lam s => *c-assoc))

  \lemma generated-pullback (f : RingHom) {M : LModule' f.Cod} (Cg : IsFinitelyGenerated {homLModule f}) (Mg : M.IsFinitelyGenerated) : IsFinitelyGenerated {pullback f M} \elim Cg, Mg
    | inP (l,Cg), inP (l',Mg) => generated-fin-array {pullback f M} $ generated-fin-comp f (generated-array-fin Cg) (generated-array-fin Mg)

  \lemma generated-comp {R S T : Ring} (f : RingHom R S) (g : RingHom S T) (fg : IsFinitelyGenerated {homLModule f}) (gg : IsFinitelyGenerated {homLModule g}) : IsFinitelyGenerated {homLModule (g ∘ f)}
    => generated-pullback f fg gg
}

\meta LModule' R => LModule { | R => R }

\instance ProductLModule (R : Ring) (A B : LModule' R) : LModule' R
  | AbGroup => ProductAbGroup A B
  | *c r p => (r *c p.1, r *c p.2)
  | *c-assoc => pmap2 (__,__) *c-assoc *c-assoc
  | *c-ldistr => pmap2 (__,__) *c-ldistr *c-ldistr
  | *c-rdistr => pmap2 (__,__) *c-rdistr *c-rdistr
  | ide_*c => pmap2 (__,__) ide_*c ide_*c

\func RingLModule (R : Ring) : LModule R { | R => R } \cowith
  | AbGroup => R
  | *c => *
  | *c-assoc => *-assoc
  | *c-ldistr => R.ldistr
  | *c-rdistr => R.rdistr
  | ide_*c => ide-left
  \where {
    \func *_hom-left {R : CRing} {x : R} : LinearMap' (RingLModule R) (RingLModule R) \cowith
      | func y => x * y
      | func-+ => ldistr
      | func-*c => equation

    \func *_hom-right {R : Ring} {x : R} : LinearMap' (RingLModule R) (RingLModule R) \cowith
      | func y => y * x
      | func-+ => rdistr
      | func-*c => *-assoc

    \lemma basis {R : Ring} : LModule.IsBasis {RingLModule R} (1 :: nil)
      => (\lam c p (0) => inv ide-right *> inv zro-right *> p, \lam x => inP (x :: nil, simplify))
  }

\instance PowerLModule {R : Ring} (J : \Set) (M : LModule' R) : LModule (J -> M) { | R => R }
  | zro _ => 0
  | + f g j => f j + g j
  | zro-left => ext (\lam j => zro-left)
  | zro-right => ext (\lam j => zro-right)
  | +-assoc => ext (\lam j => +-assoc)
  | negative f j => negative (f j)
  | negative-left => ext (\lam j => negative-left)
  | +-comm => ext (\lam j => +-comm)
  | *c r f j => r *c f j
  | *c-assoc => ext (\lam j => *c-assoc)
  | *c-ldistr => ext (\lam j => *c-ldistr)
  | *c-rdistr => ext (\lam j => *c-rdistr)
  | ide_*c => ext (\lam j => ide_*c)

\instance ArrayLModule {R : Ring} (n : Nat) (M : LModule' R) : LModule (Array M n) { | R => R }
  | zro _ => 0
  | + f g j => f j + g j
  | zro-left => arrayExt (\lam j => zro-left)
  | zro-right => arrayExt (\lam j => zro-right)
  | +-assoc => arrayExt (\lam j => +-assoc)
  | negative f j => negative (f j)
  | negative-left => arrayExt (\lam j => negative-left)
  | +-comm => arrayExt (\lam j => +-comm)
  | *c r f j => r *c f j
  | *c-assoc => arrayExt (\lam j => *c-assoc)
  | *c-ldistr => arrayExt (\lam j => *c-ldistr)
  | *c-rdistr => arrayExt (\lam j => *c-rdistr)
  | ide_*c => arrayExt (\lam j => ide_*c)
  \where {
    \lemma skip_*c {R : CRing} {n : Nat} {r : R} {l : Array R (suc n)} {k : Fin (suc n)}
      : skip (r *c {ArrayLModule _ (RingLModule R)} l) k = r *c {ArrayLModule _ (RingLModule R)} skip l k \elim n, l, k
      | 0, a :: nil, 0 => idp
      | suc n, a :: l, 0 => idp
      | suc n, a :: l, suc k => path (\lam i => r *c a :: skip_*c i)

    \lemma skip_+ {R : CRing} {n : Nat} {l l' : Array R (suc n)} {k : Fin (suc n)}
      : skip (l + {ArrayLModule _ (RingLModule R)} l') k = skip l k + {ArrayLModule _ (RingLModule R)} skip l' k \elim n, l, l', k
      | 0, a :: nil, a' :: nil, 0 => idp
      | suc n, a :: l, a' :: l', 0 => idp
      | suc n, a :: l, a' :: l', suc k => path (\lam i => a + a' :: skip_+ i)

    \func BigSum-index {R : Ring} {n : Nat} {M : LModule' R} {l : Array (Array M n)} {i : Fin n}
      : AddMonoid.BigSum {ArrayLModule n M} l i = M.BigSum (map {Array M n} (__ i) l) \elim l
      | nil => idp
      | a :: l => pmap (_ +) BigSum-index

    \lemma basis {R : Ring} {n : Nat} : LModule.IsBasis {ArrayLModule n (RingLModule R)} MatrixRing.ide
      => (\lam c p j => inv ide-right *> rewriteF (decideEq=_reduce idp) (inv (R.BigSum-unique j \lam k j/=k => later $ rewrite (decideEq/=_reduce $ /=-sym j/=k) zro_*-right) *> inv BigSum-index *> path (\lam i => p i j)),
          \lam x => inP (x, exts \lam j => inv $ BigSum-index *> R.BigSum-unique j (\lam k j/=k => later $ rewrite (decideEq/=_reduce $ /=-sym j/=k) zro_*-right) *> rewrite (decideEq=_reduce idp) ide-right))
  }

\func homLModule (f : RingHom) : LModule' f.Dom \cowith
  | AbGroup => f.Cod
  | *c x y => f x * y
  | *c-assoc => pmap (`* _) f.func-* *> *-assoc
  | *c-ldistr => ldistr
  | *c-rdistr => pmap (`* _) f.func-+ *> rdistr
  | ide_*c => pmap (`* _) f.func-ide *> ide-left