\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Data.Bool
\import Equiv
\import Function.Meta
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Order.PartialOrder
\import Set.Category
\open Group


\class SubGroup \extends SubMonoid {
  \override S : Group
  | contains_inverse {x : S} : contains x -> contains (inverse x)

  \func struct : Group \cowith
    | Monoid => SubMonoid.struct
    | inverse x => (inverse x.1, contains_inverse x.2)
    | inverse-left => ext inverse-left
    | inverse-right => ext inverse-right

  \func equivalence : Equivalence S \cowith
    | ~ x y => contains (inverse x * y)
    | ~-reflexive => transportInv contains inverse-left contains_ide
    | ~-symmetric c => transport contains (inverse_* *> pmap (_ *) inverse-isInv) (contains_inverse c)
    | ~-transitive {x} {y} c1 c2 => rewriteEqF (inverse-right {S} {y}, ide-left) (contains_* c1 c2)

  \func Cosets => Quotient (equivalence.~)

  \lemma invariant-right-multiplication {x y : S} (p : 1 equivalence.~ y) : in~{S} {equivalence.~} x = in~ {S} {equivalence.~} (x * y) => {?}

  \lemma equivalence-to-1 {x y : S} (p : x equivalence.~ y) : 1 equivalence.~ inverse x * y => {?}

} \where {
  \func cStruct {G : CGroup} (S : SubGroup G) : CGroup \cowith
    | Group => S.struct
    | *-comm => ext *-comm
}

\class DecSubGroup \extends SubGroup, DecSubMonoid {
  \override S : Group
}

\instance SubGroupPreorder {G : Group} : Preorder (SubGroup G)
  | <= (H K : SubGroup G) => \Pi (g : G) -> H.contains g -> K.contains g
  | <=-refl {H : SubGroup G} => \lam (g : G) (p : H.contains g) => p
  | <=-transitive {H K N : SubGroup G}
                  (p : \Pi (g : G) -> H.contains g -> K.contains g)
                  (q : \Pi (g : G) -> K.contains g -> N.contains g)
  => \lam (g : G) (r : H.contains g) => q g (p g r)


\lemma pseudo-<=-antisymmetric {G : Group}{x y : SubGroup G} :
  (\Pi (g : G) -> x g -> y g) -> (\Pi (g : G) -> y g -> x g) -> x.contains = y.contains
  => \lam p q => funExt {G} (\lam z => \Prop) (equal-funcs p q)
  \where \lemma equal-funcs {x y : SubGroup G} (p : \Pi (g : G) -> x g -> y g)
                            (q : \Pi (g : G) -> y g -> x g) (g : G)  : x g = y g =>
      ext (p g, q g)

\instance SubGroupPoset {G : Group} : Poset (SubGroup G)
  | Preorder => SubGroupPreorder
  | <=-antisymmetric {x y : SubGroup G} : (\Pi (g : G) -> x g -> y g) -> (\Pi (g : G) -> y g -> x g) -> x = y
  => {?}


\func funExt {A : \Type} (B : A -> \Type) {f g : \Pi (a : A) -> B a}
             (p : \Pi (a : A) -> f a = g a) : f = g
  => path (\lam i => \lam a => p a @ i)


\func conjSubGrp {G : Group} (g : G) (H : SubGroup G) : SubGroup G \cowith
  | contains h => H.contains (conjugate (inverse g) h)
  | contains_ide => pmap (\lam (u : \Sigma()() -> H.contains_ide)) H.contains_ide (H.contains (conjugate (inverse g) G.ide) ==< pmap H.contains (conjugate-id (inverse g)) >==
    H.contains (G.ide) `qed)
  | contains_* => {?}
  | contains_inverse => {?}

\class NormalSubGroup \extends SubGroup {
  | isNormal (g : S) {h : S} : contains h -> contains (conjugate g h)

  \lemma isNormal' (g : S) {h : S} (c : contains h) : contains (g * h * inverse g)
    => simplifyF (isNormal (inverse g) c)

  \func quotient : Group Cosets \cowith
    | ide => in~ 1
    | * (x y : Cosets) : Cosets \with {
      | in~ g, in~ g' => in~ (g Group.* g')
      | in~ g, ~-equiv x y r => ~-pequiv $ rewriteEq (inverse_*, inverse-left {S} {g}, ide-left) r
      | ~-equiv x y r, in~ g => ~-pequiv $ rewriteEq inverse_* $ transport contains equation (isNormal g r)
    }
    | ide-left {x} => cases x \with {
      | in~ a => pmap in~ ide-left
    }
    | ide-right {x} => cases x \with {
      | in~ a => pmap in~ ide-right
    }
    | *-assoc {x} {y} {z} => cases (x,y,z) \with {
      | in~ x, in~ y, in~ z => pmap in~ *-assoc
    }
    | inverse (x : Cosets) : Cosets \with {
      | in~ g => in~ (Group.inverse g)
      | ~-equiv x y r => ~-pequiv $ rewrite inverse-isInv $ rewriteEqF (inverse_*, inverse-isInv) $ contains_inverse $ rewriteEqF (inverse-right {S} {x}, ide-left) (isNormal' x r)
    }
    | inverse-left {x} => cases x \with {
      | in~ a => pmap in~ inverse-left
    }
    | inverse-right {x} => cases x \with {
      | in~ a => pmap in~ inverse-right
    }

  \func quotient-proj-setwise : SetHom S quotient \cowith
    | func s => in~ s
}

\class SubAddGroup \extends SubAddMonoid {
  \override S : AddGroup
  | contains_negative {x : S} : contains x -> contains (negative x)

  \lemma contains_- {x y : S} : contains x -> contains y -> contains (x - y)
    => \lam cx cy => contains_+ cx (contains_negative cy)

  \func struct : AddGroup \cowith
    | AddMonoid => SubAddMonoid.struct
    | negative x => (negative x.1, contains_negative x.2)
    | negative-left => ext negative-left
    | negative-right => ext negative-right
} \where {
  \func abStruct {A : AbGroup} (S : SubAddGroup A) : AbGroup \cowith
    | AddGroup => S.struct
    | +-comm => ext +-comm

  \func max {A : AddGroup} : SubAddGroup \cowith
    | SubAddMonoid => SubAddMonoid.max {A}
    | contains_negative _ => ()
}

\class FinSubGroup \extends DecSubGroup {
  \override S : FinGroup

  \func struct : FinGroup \cowith
    | Group => SubGroup.struct
    | FinSet => DecSubSet.isFin S \this
}