\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Arith.Bool
\import Arith.Nat
\import Data.Bool
\import Data.List
\import Data.Or
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.Lexicographical
\import Order.LinearOrder
\import Order.PartialOrder \hiding (ProductPoset)
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\open Sort
\open OrderedAddMonoid
\open LinearlyOrderedSemiring

\data GroupTerm (V : \Type)
  | var V
  | :ide
  | :inv (GroupTerm V)
  | \infixl 6 :* (t s : GroupTerm V)

\class Data \noclassifying {G : Group} {V : \Set} (f : V -> G) {
  \func interpret (t : GroupTerm V) : G \elim t
    | var x => f x
    | :ide => ide
    | :inv t => inverse (interpret t)
    | :* t s => interpret t * interpret s
}

\class NatData \extends Data {
  | V => Nat

  \func rp-correctness-both-inside (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (p : interpret (get-leaf t fstLeafToRemoveInd) = inverse (interpret $ get-leaf t (suc fstLeafToRemoveInd)))
                                   (lb : 1 <= fstLeafToRemoveInd) (ub : fstLeafToRemoveInd < count-leaves t) : interpret (remove-pair t fstLeafToRemoveInd).1 = interpret t \elim t
    | l :* r => mcases {1} \with {
      | less q => mcases {1} \with {
        | true => {?}
        | false => {?}
      }
      | equals q => {?}
      | greater q => {?}
    }

  \data Leaf
    | var-leaf (v : V)
    | inv-var-leaf (v : V)
  \where {
    \func leaf-to-term (l : Leaf) : GroupTerm V \elim l
      | var-leaf v => var v
      | inv-var-leaf v => :inv (var v)
  }

  \func rp-returns-true-lemma''' (l r : GroupTerm V) (fstLeafToRemoveInd : Nat)
    : (remove-pair (l :* r) fstLeafToRemoveInd).2 = true ->
  \Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)
    => mcases {1} \with {
      | less _ => mcases {1} \with {
        | true => absurd `o` true/=false `o` inv
        | false => absurd `o` true/=false `o` inv
      }
      | equals p => mcases {1, 2} {arg addPath, arg addPath} \with {
        | false, _, false, _ => absurd `o` true/=false `o` inv
        | true, _, false, q =>  \lam p => absurd (true/=false (inv p *> q))
        | false, q, true, _ => \lam p => absurd (true/=false (inv p *> q))
        | true, _, true, q => \lam _ => (idp, idp, p) -- rewrite (p, -'id) q)
      }
      | greater _ => mcases {1} \with {
        | true => absurd `o` true/=false `o` inv
        | false => absurd `o` true/=false `o` inv
      }
    }

  \func rp-returns-true-lemma'' (t : GroupTerm V) (fstLeafToRemoveInd : Nat)
    : (remove-pair t fstLeafToRemoveInd).2 = true -> count-leaves t >= 1 \elim t
    | l :* r => \lam p => <=_+ (rp-returns-true-lemma'' l fstLeafToRemoveInd (rp-returns-true-lemma''' l r fstLeafToRemoveInd p).1) zero<=_
    | :inv a \as t' => cases a (absurd `o` true/=false `o` inv) \with {
      | var x => \lam _ => <=-refl
    }
    | var x \as t' => \lam _ => <=-refl
    | :ide => absurd `o` true/=false `o` inv

  \func rp-returns-true-lemma' (l r : GroupTerm V) (fstLeafToRemoveInd : Nat)
    (p : (remove-pair (l :* r) fstLeafToRemoveInd).2 = true) : \Sigma (l' r' : Leaf) (l = Leaf.leaf-to-term l') (r = Leaf.leaf-to-term r') \elim l, r
    -- in this case we have fstLeafToRemoveInd = count-leaves ll + count-leaves lr = count-leaves ll, which means count-leaves lr = 0, but count-leaves lr >= 1
    | ll :* lr \as l, r => \let | p_l => (rp-returns-true-lemma''' l r fstLeafToRemoveInd p).1
                                | p_lr => (rp-returns-true-lemma''' ll lr fstLeafToRemoveInd p_l).2
                                | rmInd-eq-ll+lr => (rp-returns-true-lemma''' l r fstLeafToRemoveInd p).3
                                | rmInd-eq-ll => (rp-returns-true-lemma''' ll lr fstLeafToRemoveInd p_l).3
                                | ll+lr-eq-ll => inv rmInd-eq-ll+lr *> rmInd-eq-ll
                                | abs : 0 >= 1 => rewriteF (NatSemiring.cancel-left (count-leaves ll) {count-leaves lr} {0} ll+lr-eq-ll) (rp-returns-true-lemma'' lr 0 p_lr)
                                | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                                \in contradiction
    | l, rl :* rr \as r => {?}
    {- cases lo (\let | p_l => (rp-returns-true-lemma''' l r fstLeafToRemoveInd p).1
                                                     | abs : 0 >= 1 => rp-returns-true-lemma'' l fstLeafToRemoveInd p_l
                                                     | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                                                \in contradiction) \with { -}
    | :inv lo \as l, :inv ro \as r => cases (lo, p) (\let | p_l => (rp-returns-true-lemma''' (:inv lo) r fstLeafToRemoveInd p).1
                                                          | abs : 0 >= {NatSemiring} 1 => rp-returns-true-lemma'' (:inv lo) fstLeafToRemoveInd p_l
                                                          | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                                                     \in contradiction) \with {
      | var x \as lo, p => cases ro (\let | p_l => (rp-returns-true-lemma''' (:inv lo) r fstLeafToRemoveInd p).1
                                | abs : 0 >= {NatSemiring} 1 => rp-returns-true-lemma'' l fstLeafToRemoveInd p_l
                                | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                           \in contradiction) \with {
        | var y => (inv-var-leaf x, inv-var-leaf y, idp, idp)
      }
      | l' :* r' \as lo, p => \let | p_l => (rp-returns-true-lemma''' l r fstLeafToRemoveInd p).1
                         | abs : 0 >= {NatSemiring} 1 => rp-returns-true-lemma'' (:inv lo) fstLeafToRemoveInd p_l
                         | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                    \in contradiction
      | :inv _ \as lo, p => \let | p_l => (rp-returns-true-lemma''' (:inv lo) r fstLeafToRemoveInd p).1
                          | abs : 0 >= {NatSemiring} 1 => rp-returns-true-lemma'' (:inv lo) fstLeafToRemoveInd p_l
                          | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                     \in contradiction
      | :ide \as lo, p => \let | p_l => (rp-returns-true-lemma''' (:inv :ide) r fstLeafToRemoveInd p).1
                        | abs : 0 >= {NatSemiring} 1 => rp-returns-true-lemma'' (:inv :ide) fstLeafToRemoveInd p_l
                        | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs
                   \in contradiction {- -}
    }
    | :inv lo \as l, var y \as r => {?}
    | var x \as l, :inv ro \as r => {?}
    | var x \as l, var y \as r => {?}
    | :ide, _ => {?}
    | _, :ide => {?}

  \where {
    \meta left-inv-contradiction l r ind p => \let | p_l => (rp-returns-true-lemma''' l r ind p).1
                                                   | abs : 0 >= 1 => rp-returns-true-lemma'' l ind p_l
                                                   | abs' : 0 = 1 => <=-antisymmetric zero<=_ abs \in contradiction
  }


  \func rp-returns-true-lemma (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (p : (remove-pair t fstLeafToRemoveInd).2 = true)
                              (lb : 1 <= fstLeafToRemoveInd) (ub : fstLeafToRemoveInd < count-leaves t)
    : interpret t = (interpret $ get-leaf t fstLeafToRemoveInd) * (interpret $ get-leaf t (suc fstLeafToRemoveInd)) \elim t
    | l :* r => mcases \with {
      | _, inl q => {?}
    }
  --(\Sigma (l : Leaf) (t = Leaf.leaf-to-term l)) `Or` (\Sigma (l r : Leaf) (t = Leaf.leaf-to-term l :* Leaf.leaf-to-term r)) \elim t


{-
      \case Algebra.Ordered.OrderedRing.Dec.trichotomy fstLeafToRemoveInd (count-leaves l) \with {
      | less q => mcases {1} \with {
        | inr w => contradiction
        | inl _ => mcases {1} \with {
          | true => rp-correctness-both-inside l fstLeafToRemoveInd (rewrite (q, <-transitive q id<suc) p) lb q
          | false => {?}
        }
      }
      | equals q => {?}
      | greater q => {?}
    }-}

  \func get-leaf-less-lemma (l r : GroupTerm V) (ind : Nat) (p : ind < suc (count-leaves l))
                            : get-leaf (l :* r) ind = get-leaf l ind
    => rewrite (LinearOrder.dec<_reduce p) idp

  {-
    \func get-leaf-less-lemma (l r : GroupTerm V) (ind : Nat) (p : interpret (get-leaf (l :* r) ind) = inverse (interpret $ get-leaf (l :* r) (suc ind)))
                              (q : ind < count-leaves l) : interpret (get-leaf l ind) = inverse (interpret $ get-leaf l (suc ind))
      => {?}
  -}
  {- \func remove-pair-correctness (t : GroupTerm V) (fstLeafToRemoveInd : Nat)
    (p : interpret (get-leaf t fstLeafToRemoveInd) = inverse (interpret $ get-leaf t fstLeafToRemoveInd))
    : \case decideEq fstLeafToRemoveInd (count-leaves t) \with {
    | yes _ => interpret (remove-pair t fstLeafToRemoveInd).1 * interpret (get-leaf t fstLeafToRemoveInd) = interpret t
    | no _ => interpret (remove-pair t fstLeafToRemoveInd).1 = interpret t
  } \elim t

    \where { -}

  -- \func rp-correctness

  {-
  \func rp-correctness-less (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat) (p : fstLeafToRemoveInd < suc lastVisitedLeafInd)
    : (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).1 = t \elim t
    | l :* r => mcases {1} {arg addPath} \with {
      | true, q => absurd $ true/=false (inv q *> never-remove-lemma l fstLeafToRemoveInd lastVisitedLeafInd p)
      | false, _ => \let | res-l => remove-pair l fstLeafToRemoveInd lastVisitedLeafInd
                         | p' : fstLeafToRemoveInd < suc res-l.2 =>
                           rewrite (rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd)
                               (<=_+-right {_} {fstLeafToRemoveInd} {0} {suc lastVisitedLeafInd} {count-leaves l} p zero<=_) \in
        mcases {1} {arg addPath} \with {
        | true, q => absurd $ true/=false (inv q *> never-remove-lemma r fstLeafToRemoveInd res-l.2 p')
        | false, _ => pmap2 (:*) (rp-correctness-less l fstLeafToRemoveInd lastVisitedLeafInd p) (rp-correctness-less r fstLeafToRemoveInd res-l.2 p')
      }
    }
    | :inv a \as t' => cases a idp \with {
      | var x => processLeaf-lemma t' fstLeafToRemoveInd lastVisitedLeafInd p
    }
    | var x \as t' => processLeaf-lemma t' fstLeafToRemoveInd lastVisitedLeafInd p
    | :ide => idp
  \where {
    \func never-remove-lemma (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat) (p : fstLeafToRemoveInd < suc lastVisitedLeafInd)
      : (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).3 = false \elim t
      | l :* r => mcases {1} {arg addPath} \with {
        | true, q => absurd (true/=false (inv q *> never-remove-lemma l fstLeafToRemoveInd lastVisitedLeafInd p))
        | false, q => mcases {_} {arg addPath} \with {
          | true, q =>\let | res-l => remove-pair l fstLeafToRemoveInd lastVisitedLeafInd
                            | p' : fstLeafToRemoveInd < suc res-l.2 =>
                               rewrite (rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd)
                                  (<=_+-right {_} {fstLeafToRemoveInd} {0} {suc lastVisitedLeafInd} {count-leaves l} p zero<=_) \in
            absurd (true/=false (inv q *> never-remove-lemma r fstLeafToRemoveInd res-l.2 p'))
          | false, q => idp
        }
      }
      | :inv a \as t' => cases a idp \with {
        | var x => processLeaf-lemma t' fstLeafToRemoveInd lastVisitedLeafInd p
      }
      | var x \as t' => processLeaf-lemma t' fstLeafToRemoveInd lastVisitedLeafInd p
      | :ide => idp

      \meta processLeaf-lemma t fstLeafToRemoveInd lastVisitedLeafInd p
        => mcases \with {
          | yes p', _ => absurd $ <-irreflexive $ transport (\lam x => x < suc lastVisitedLeafInd) p' p
        -- contradiction {usingOnly (p, p')}
          | no _, yes p' => absurd $ <-irreflexive $ transport (\lam x => x < suc (suc lastVisitedLeafInd)) p' (<_+ p (NatSemiring.zero<suc {0})) -- couldn't infer 0 in NatSemiring.zero<suc {0}!!
          | no _, no _ => idp
        }
  }


  \func rp-leaf-counter-lemma (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat)
    : (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).2 = lastVisitedLeafInd + count-leaves t
    \elim t
      -- Fix usages of duplicate code below!
      | l :* r => mcases {1} \with {
        | true =>
          \let leftProof => rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd
               | rightProof => rp-leaf-counter-lemma r fstLeafToRemoveInd (leftProof @ right) \in
            rewriteEq (idp {Nat}  {lastVisitedLeafInd + count-leaves l + count-leaves r}) (rewrite leftProof rightProof)
        | false => mcases {1}
            (
              \let | leftProof => rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd
                   | rightProof => rp-leaf-counter-lemma r fstLeafToRemoveInd (leftProof @ right) \in
                rewriteEq (idp {Nat} {lastVisitedLeafInd + count-leaves l + count-leaves r}) (rewrite leftProof rightProof)) \with {
        }
      }
      | :inv a \as t' => cases a idp \with { | var x => mcases idp \with {}}
      | var x \as t' => mcases idp \with {}
      | :ide => idp
  }
-}

  \func get-rightmost-leaf (t : GroupTerm V) : GroupTerm V \elim t
    | l :* r => get-rightmost-leaf r
    | :inv (var x) \as t' => t'
    | var x \as t' => t'
    | t' => t'

  \func get-leaf (t : GroupTerm V) (ind : Nat) : GroupTerm V \elim t
    | l :* r => \case LinearOrder.dec<_<= ind (suc $ count-leaves l) \with {
      | inl _ => get-leaf l ind
      | _ => get-leaf r (ind -' count-leaves l)
    }
    | :inv (var x) \as t' => \case ind \with {
      | 1 => t' | _ => :ide
    }
    | :inv _ => :ide
    | var x \as t' => \case ind \with {
      | 1 => t' | _ => :ide
    }
    | :ide => :ide

  \func count-leaves (t : GroupTerm V) : Nat \elim t
    | l :* r => count-leaves l + count-leaves r
    | :inv (var x) => 1
    | :inv _ => 0
    | var x \as t' => 1
    | _ => 0

  \func remove-pair (t : GroupTerm V) (fstLeafToRemoveInd : Nat)
    : \Sigma (GroupTerm V) Bool \elim t
    | l :* r => \case LinearOrder.trichotomy fstLeafToRemoveInd (count-leaves l) \with {
      | less _ => \let res-l => remove-pair l fstLeafToRemoveInd \in \case res-l.2 \with {
        | true => (r, false) | false => (res-l.1 :* r, false)
      }
      | equals _ => \let res-l => remove-pair l fstLeafToRemoveInd | res-r => remove-pair r 0 \in
        \case res-l.2, res-r.2 \with {
          | true, true => (:ide, true)
          | true, false => res-r
          | false, true => res-l
          | false, false => (res-l.1 :* res-r.1, false)
        }
      | greater _ => \let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l) \in \case res-r.2 \with {
        | true => (l, false) | false => (l :* res-r.1, false)
      }
    }
    {-
    \let res-l => remove-pair l fstLeafToRemoveInd \in
    \case LinearOrder.dec<_<= fstLeafToRemoveInd (suc $ count-leaves l) \with {
      | inl _ => \case res-l.2 \with {
        | true => (r, false) | false => (res-l.1 :* r, false)
      }
      | inr _ => \case res-l.2 \with {
        | true => remove-pair r $ fstLeafToRemoveInd -' count-leaves l
        -- Unfold res-r by hand because it does not unfold automatically when rewrite deals with it.
        -- res-r should be used again once this issue is fixed.
        | false => \let res-r => remove-pair r $ fstLeafToRemoveInd -' count-leaves l \in
          \case res-r.2 \with {
            | true => (res-l.1, false) | false => (res-l.1 :* res-r.1, false)
          }
      }
    }-}
    | :inv (var x) \as t' => (:ide, true) -- processLeaf t' fstLeafToRemoveInd
    | :inv _ \as t' => (t', false)
    | var x \as t' => (:ide, true) -- processLeaf t' fstLeafToRemoveInd
    | :ide => (:ide, false)
    \where {
      \func processLeaf (t : GroupTerm V) (fstLeafToRemoveInd : Nat) : \Sigma (GroupTerm V) Bool =>
        \case decideEq fstLeafToRemoveInd 1, decideEq fstLeafToRemoveInd 2 \with {
          | no _, no _ => (t, false)
          | _, _ => (:ide, true)
        }
    }

  \func find-pair-to-remove (t : GroupTerm V) (lastVisitedLeafInd : Nat) (lastVisitedLeaf : V) (withInv : Bool)
    : \Sigma Nat V Bool Bool \elim t
    | :inv (var x) => processLeaf x true lastVisitedLeafInd lastVisitedLeaf withInv
    | var x => processLeaf x false lastVisitedLeafInd lastVisitedLeaf withInv
    | l :* r => \let res => find-pair-to-remove l lastVisitedLeafInd lastVisitedLeaf withInv \in \case res.4 \with {
      | true => res
      | false => find-pair-to-remove r res.1 res.2 res.3
    }
    | _ => (lastVisitedLeafInd, lastVisitedLeaf, withInv, false)
    \where {
      \func processLeaf (x : V) (xWithInv : Bool) (lastVisitedLeafInd : Nat) (lastVisitedLeaf : V) (withInv : Bool)
        : \Sigma Nat V Bool Bool => \case lastVisitedLeafInd \with {
        | suc n => \case decideEq (x, xWithInv) (lastVisitedLeaf, not withInv) \with {
          | yes _ => (n, lastVisitedLeaf, withInv, true)
          | no _ => (suc n, x, xWithInv, false)
        }
        | 0 => (1, x, xWithInv, false)
      }
    }

  {-
  \func remove-leaves (t : GroupTerm V) (toRemove : List Nat) (leafInd : Nat) : \Sigma (GroupTerm V) Nat \elim t
    | :ide => (:ide, leafInd)
    | var x :* r => \case toRemove \with {
      | ind :: restToRemove => \case decideEq leafInd ind \with {
        | yes _ => remove-leaves r restToRemove (suc leafInd)
        | no _ => \let res => remove-leaves r toRemove (suc leafInd) \in (var x :* res.1, res.2)
      }
      | nil => (var x :* r, leafInd)
    }
    | l :* var x => {?}
  \where {
  --  \func processLeaf (x : V) (withInv : Bool)
  }

  \func leaves-to-remove (t : GroupTerm V) (notToRemove : List (\Sigma V Bool)) (toRemove : List Nat) (leafInd : Nat)
    : \Sigma (List (\Sigma V Bool)) (List Nat) Nat \elim t
    | :ide => (notToRemove, toRemove, leafInd)
    | l :* r => \let leftRes => leaves-to-remove l notToRemove toRemove leafInd \in leaves-to-remove r leftRes.1 leftRes.2 leftRes.3
    | :inv (var x) => processLeaf x true notToRemove toRemove leafInd
    | var x => processLeaf x false notToRemove toRemove leafInd
    | _ => (notToRemove, toRemove, leafInd)
    \where {
      \func processLeaf (x : V) (xWithInv : Bool) (notToRemove : List (\Sigma V Bool)) (toRemove : List Nat) (leafInd : Nat)
        : \Sigma (List (\Sigma V Bool)) (List Nat) Nat \elim notToRemove
        | (y, withInv) :: l \as notToRemove => \case decideEq (y, withInv) (x, not xWithInv) \with {
          | yes _ => (l, leafInd :: toRemove, suc leafInd)
          | no _ => ((x, xWithInv) :: notToRemove, toRemove, suc leafInd)
        }
        | _ => ((x, xWithInv) :: nil, nil, suc leafInd)
    }

 -}

  \func simplify (t : GroupTerm V) => {?}
}

\class CData \extends NatData {
  \override G : CGroup

  \lemma removeVar-lem (t : GroupTerm V) (v : V) (withInv : Bool) {n : Nat}
    : \Sigma (interpret (removeVar n t v withInv).1 * G.pow (if withInv (inverse (f v)) (f v)) (n ∧ countVar t v withInv) = interpret t)
             ((removeVar n t v withInv).2 = n -' countVar t v withInv) \elim t, n
    | t, 0 => (rewrite rdistr0 ide-right, idp)
    | var x, suc n => mcases \with {
      | yes e => (rewrite (NatSemiring.meet_+-left {1}, ldistr0) $ ide-left *> ide-left *> rewriteI (pmap __.2 e) (pmap (\lam s => f s.1) (inv e)), inv $ <=_exists zero<=_)
      | no q => (ide-right, idp)
    }
    | :ide, suc n => (ide-left, idp)
    | :inv t, suc n => (pmap (_ *) pow-lem *> *-comm *> inv G.inverse_* *> pmap inverse (removeVar-lem t v (not withInv)).1, (removeVar-lem t v (not withInv)).2)
    | :* t1 t2, suc n => (rewrite sum-lem $ pmap (_ *) G.pow_+ *> rewrite (removeVar-lem t1 v withInv).2 (equation *> pmap2 (*) (removeVar-lem t1 v withInv {suc n}).1 (removeVar-lem t2 v withInv {suc n -' countVar t1 v withInv}).1),
                          (removeVar-lem _ v withInv).2 *> rewrite (removeVar-lem t1 v withInv).2 -'-')
    \where {
      \open NatBSemilattice

      \lemma pow-lem {b : Bool} {n : Nat} {x : G} : G.pow (if b (inverse x) x) n = inverse (G.pow (if (not b) (inverse x) x) n) \elim b
        | false => inv $ G.inverse_pow *> pmap (G.pow __ n) (G.inverse-isInv x)
        | true => inv G.inverse_pow

      \lemma sum-lem {a b c : Nat} : a ∧ (b + c) = a ∧ b + (a -' b) ∧ c \elim a, b
        | 0, b => rdistr0 *> inv (pmap2 (+) rdistr0 rdistr0)
        | suc a, 0 => idp
        | suc a, suc b => NatSemiring.meet_+-left {1} *> pmap suc sum-lem *> inv (pmap (`+ _) (NatSemiring.meet_+-left {1}))
    }

  \lemma removeVar_<=-lem (t : GroupTerm V) (v : V) (withInv : Bool) {n : Nat} (p : n <= countVar t v withInv)
    : interpret (removeVar n t v withInv).1 * G.pow (if withInv (inverse (f v)) (f v)) n = interpret t
    => inv (pmap (_ * G.pow _ __) (MeetSemilattice.meet_<= p)) *> (removeVar-lem t v withInv).1

  \lemma removeVar-correct (t : GroupTerm V) (v : V) (n : Nat) (p : n <= countVar t v false) (q : n <= countVar t v true)
    : interpret (removeVar n (removeVar n t v true).1 v false).1 = interpret t
    => inv (*-assoc *> pmap (_ *) (inv (pmap (_ *) G.inverse_pow) *> inverse-right) *> ide-right) *>
       pmap (`* _) (removeVar_<=-lem (removeVar n t v true).1 v false $ transportInv (n <=) (count-remove-lem false) p) *>
       removeVar_<=-lem t v true q

  \lemma removeVars-correct (t : GroupTerm V) {l : List (\Sigma V Nat)} (a : All (\lam p => \Sigma (p.2 <= countVar t p.1 false) (p.2 <= countVar t p.1 true)) l) (b : All2 (__.1 /= __.1) l)
    : interpret (removeVars t l) = interpret t \elim l, a, b
    | nil, all-nil, all2-nil => idp
    | :: x l, all-cons p a, all2-cons q b => removeVar-correct (removeVars t l) x.1 x.2 (transportInv (x.2 <=) (count-removeVars-lem q) p.1) (transportInv (x.2 <=) (count-removeVars-lem q) p.2) *> removeVars-correct t {l} a b
    \where {
      \lemma count-removeVar-lem {t : GroupTerm V} {u v : V} {w w' : Bool} {n : Nat} (p : u /= v)
        : countVar (removeVar n t v w').1 u w = countVar t u w \elim t, n
        | t, 0 => idp
        | var x, suc n => mcases \with {
          | yes e, yes e' => absurd $ p (inv (pmap __.1 e') *> pmap __.1 e)
          | yes e, no q => idp
          | no q, yes e => rewrite (decideEq=_reduce e) idp
          | no _, no q => rewrite (decideEq/=_reduce q) idp
        }
        | :ide, suc n => idp
        | :inv t, suc n => count-removeVar-lem p
        | :* t t1, suc n => pmap2 (+) (count-removeVar-lem p) (count-removeVar-lem p)

      \lemma count-removeVars-lem {t : GroupTerm V} {l : List (\Sigma V Nat)} {v : V} {withInv : Bool} (a : All (v /= __.1) l)
        : countVar (removeVars t l) v withInv = countVar t v withInv \elim l, a
        | nil, all-nil => idp
        | :: x l, all-cons p a => count-removeVar-lem p *> count-removeVar-lem p *> count-removeVars-lem a
    }

  \lemma simplify-correct (t : GroupTerm V) : interpret t = interpret (simplify t)
    => inv $ unfold simplify (rewrite RedBlack.sort=insert $ removeVars-correct t (countVars-correct t (group-correct t) sort-correct) $ countVars-diff sort-correct $ group-diff $ Insertion.sort-sorted (toList t false))
} \where {
  \func removeVar (n : Nat) (t : GroupTerm Nat) (v : Nat) (withInv : Bool) : \Sigma (GroupTerm Nat) Nat \elim n, t
    | 0, t => (t, 0)
    | suc n, :ide => (:ide, suc n)
    | suc n, var x => \case decideEq (x,false) (v,withInv) \with {
      | yes _ => (:ide, n)
      | no _ => (var x, suc n)
    }
    | suc n, :inv t =>
      \have (t',n') => removeVar (suc n) t v (not withInv)
      \in (:inv t', n')
    | suc n, :* t1 t2 =>
      \have | (t1',n1) => removeVar (suc n) t1 v withInv
            | (t2',n2) => removeVar n1 t2 v withInv
      \in (t1' :* t2', n2)

  \func countVars (l : List (\Sigma (\Sigma Nat Bool) Nat)) : List (\Sigma Nat Nat) \elim l
    | nil => nil
    | :: _ nil => nil
    | :: ((x,b),n) (:: ((y,c),m) l) => \case decideEq x y \with {
      | yes _ => (x, n ∧ m) :: countVars l
      | no _ => countVars (((y,c),m) :: l)
    }

  \func removeVars (t : GroupTerm Nat) (l : List (\Sigma Nat Nat)) : GroupTerm Nat \elim l
    | nil => t
    | :: (v,n) l => (removeVar n (removeVar n (removeVars t l) v true).1 v false).1

  \func toList (t : GroupTerm Nat) (withInv : Bool) : List (\Sigma Nat Bool) \elim t
    | var v => (v, withInv) :: nil
    | :ide => nil
    | :inv t => toList t (not withInv)
    | :* t1 t2 => toList t1 withInv ++ toList t2 withInv

  \func simplify (t : GroupTerm Nat)
    => removeVars t $ countVars $ group $ RedBlack.sort $ toList t false

  -- Proof of correctness

  \func countVar (t : GroupTerm Nat) (v : Nat) (withInv : Bool) : Nat \elim t
    | var x => \case decideEq (x,false) (v,withInv) \with {
      | yes _ => 1
      | no _ => 0
    }
    | :ide => 0
    | :inv t => countVar t v (not withInv)
    | :* t1 t2 => countVar t1 v withInv + countVar t2 v withInv

  \lemma count-remove-lem {t : GroupTerm Nat} {v v' : Nat} (withInv : Bool) {n : Nat}
    : countVar (removeVar n t v' (not withInv)).1 v withInv = countVar t v withInv \elim t, n
    | t, 0 => idp
    | var x, suc n => mcases {1} \with {
      | yes e => mcases \with {
        | yes e' => \case rewriteF (inv (pmap __.2 e')) (pmap __.2 e)
        | no _ => idp
      }
      | no _ => idp
    }
    | :ide, suc n => idp
    | :inv t, suc n => count-remove-lem (not withInv)
    | :* t1 t2, suc n => pmap2 (+) (count-remove-lem withInv) (count-remove-lem withInv)

  \lemma toList-correct (t : GroupTerm Nat) (p : \Sigma Nat Bool) (b : Bool) : count (toList t b) p = countVar t p.1 (if b (not p.2) p.2) \elim t
    | var v => mcases \with {
      | yes _, yes _ => idp
      | yes e, no q => \case q $ ext (pmap __.1 e, \case \elim b, \elim e \with {
        | false, e => pmap __.2 e
        | true, e => rewriteI (pmap __.2 e) idp
      })
      | no q, yes e => \case q $ ext (pmap __.1 e, \case \elim b, \elim e \with {
        | false, e => pmap __.2 e
        | true, e => pmap (\lam s => not s.2) e *> not-isInv
      })
      | no _, no _ => idp
    }
    | :ide => idp
    | :inv t => toList-correct t p (not b) *> pmap (countVar t p.1) (\case \elim b \with {
      | false => idp
      | true => inv not-isInv
    })
    | :* t1 t2 => count_++ *> pmap2 (+) (toList-correct t1 p b) (toList-correct t2 p b)

  \lemma group-correct (t : GroupTerm Nat) : All (\lam p => p.2 <= countVar t p.1.1 p.1.2) $ group $ Insertion.sort $ toList t false
    => all-implies (group_count-lem (Insertion.sort-sorted (toList t false))) $ all-forall $
        \lam p c => rewrite c $ Preorder.=_<= $ inv (count_perm (Insertion.sort-perm (toList t false)) p.1) *> toList-correct t p.1 false

  \lemma countVars-correct (t : GroupTerm Nat) {l : List (\Sigma (\Sigma Nat Bool) Nat)} (a : All (\lam p => p.2 <= countVar t p.1.1 p.1.2) l)
                           (a' : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) l)
    : All (\lam p => \Sigma (p.2 <= countVar t p.1 false) (p.2 <= countVar t p.1 true)) (countVars l) \elim l, a, a'
    | nil, all-nil, allC-nil => all-nil
    | :: x nil, all-cons p a, allC-single => all-nil
    | :: ((b,x),n) (:: ((c,y),m) l), all-cons p (all-cons p' a), allC-cons q a' => mcases \with {
      | yes e => all-cons (meet-left <=∘ rewriteI (q e).1 p, rewrite e $ meet-right <=∘ rewriteI (q e).2 p') (countVars-correct t a (allC-tail a'))
      | no _ => countVars-correct t (all-cons p' a) a'
    }

  \lemma countVars-ineq {l : List (\Sigma (\Sigma Nat Bool) Nat)} {x : Nat} (a : All (x /= __.1.1) l) : All (x /= __.1) (countVars l) \elim l, a
    | nil, all-nil => all-nil
    | :: y nil, all-cons p a => all-nil
    | :: y (:: z l), all-cons p (all-cons a1 a2) => mcases \with {
      | yes e => all-cons p (countVars-ineq a2)
      | no _ => countVars-ineq (all-cons a1 a2)
    }

  \lemma countVars-diff {l : List (\Sigma (\Sigma Nat Bool) Nat)} (a' : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) l) (a : All2 (__.1 /= __.1) l)
    : All2 (__.1 /= __.1) (countVars l) \elim l, a', a
    | nil, allC-nil, all2-nil => all2-nil
    | :: x nil, allC-single, all2-cons a a1 => all2-nil
    | :: ((b,x),n) (:: ((c,y),m) l), allC-cons s a', all2-cons (all-cons _ a1) (all2-cons a2 a3) => mcases \with {
      | yes e =>
        all2-cons (countVars-ineq $ all-implies a1 $ all-implies a2 $ all-forall $ \lam q c d e' => cases (q.1.2 arg addPath) \with {
          | false, p => d $ ext (e', (s e).1 *> inv p)
          | true, p => c $ ext (inv e *> e', (s e).2 *> inv p)
        }) (countVars-diff (allC-tail a') a3)
      | no _ => countVars-diff a' (all2-cons a2 a3)
    }

  \lemma sort-correct-lem {l : List (\Sigma (\Sigma Nat Bool) Nat)} (s : Sorted (map __.1 l)) (a : All2 (__.1 /= __.1) l)
    : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) l \elim l, s, a
    | nil, _, _ => allC-nil
    | :: x nil, _, _ => allC-single
    | :: ((u,x),_) (:: ((v,y),_) l), sorted-cons e s, all2-cons (all-cons p _) a2 => allC-cons (\lam u=v => \case LinearOrder.trichotomy x y \with {
      | less x<y => \case \elim x, \elim y, \elim x<y \with {
        | false, true, BoolPoset.false<true => (idp,idp)
      }
      | equals x=y => absurd $ p $ pmap2 (__,__) u=v x=y
      | greater y<x => absurd $ e $ byRight (inv u=v, y<x)
    }) (sort-correct-lem s a2)

  \lemma sort-correct {l : List (\Sigma Nat Bool)} : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) $ group $ Insertion.sort l
    => sort-correct-lem (group-sorted (Insertion.sort-sorted l)) (group-diff (Insertion.sort-sorted l))
}