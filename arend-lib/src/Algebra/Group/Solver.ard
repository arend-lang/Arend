\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Ordered
\import Algebra.Pointed
\import Arith.Bool
\import Arith.Nat
\import Data.Bool
\import Data.List
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.Lexicographical
\import Order.LinearOrder
\import Order.PartialOrder \hiding (ProductPoset)
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\open Sort
\open OrderedAddMonoid

\data GroupTerm (V : \Type)
  | var V
  | :ide
  | :inv (GroupTerm V)
  | \infixl 6 :* (t s : GroupTerm V)

\class Data \noclassifying {G : Group} {V : \Set} (f : V -> G) {
  \func interpret (t : GroupTerm V) : G \elim t
    | var x => f x
    | :ide => ide
    | :inv t => inverse (interpret t)
    | :* t s => interpret t * interpret s
}

\class NatData \extends Data {
  | V => Nat
{-
  \data LeafRemovalInfo
    | this
    | other
    | none (rightmostLeaf : V) (withInv : Bool)

  \func remove-neighbours (t : GroupTerm V) (rightmostLeaf : V) (withInv : Bool)
    : \Sigma (GroupTerm V) (GroupTerm V) LeafRemovalInfo \elim t
    | var x :* r => \case decideEq (x, false) (rightmostLeaf, not withInv) \with {
      | yes _ => (r, r, this)
      | no _ => \let res => remove-neighbours r x false \in \case res.3 \with {
        | this => (res.1, res.1, other)
        | other => (var x :* res.1, var x :* res.1, other)
        | none y b => ()
      }
    }
 -}

  \func remove-pair-correctness (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat)
    : \case LinearOrder.trichotomy fstLeafToRemoveInd (suc lastVisitedLeafInd) \with {
    | less _ => (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).1 = t
    | equals _ => \case t \with {
      | l :* r => interpret ((remove-pair l fstLeafToRemoveInd lastVisitedLeafInd).1 :* get-rightmost-leaf l) = interpret l
      | :inv (var x) \as t' => (remove-pair t' fstLeafToRemoveInd lastVisitedLeafInd).1 = :ide
      | var x \as t' => (remove-pair t' fstLeafToRemoveInd lastVisitedLeafInd).1 = :ide
      | t' => (remove-pair t' fstLeafToRemoveInd lastVisitedLeafInd).1 = t'
    }
    | greater _ => {?}
  } => {?} \where {

  \func rp-correctness-less (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat) (p : fstLeafToRemoveInd < suc lastVisitedLeafInd)
    : (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).1 = t \elim t
    | l :* r => mcases {1} {arg addPath} \with {
      | true, q => absurd $ true/=false (inv q *> never-remove-lemma l fstLeafToRemoveInd lastVisitedLeafInd p)  -- rewrite (rp-correctness-less l fstLeafToRemoveInd lastVisitedLeafInd p) {?}
      | false, _ => mcases {1} {arg addPath} \with {
        | true, q => \let | res-l => remove-pair l fstLeafToRemoveInd lastVisitedLeafInd \in
          absurd $ true/=false (inv q *> never-remove-lemma r fstLeafToRemoveInd lastVisitedLeafInd p)
        | false, _ => {?}
      }
    }
  \where {
    \func never-remove-lemma (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat) (p : fstLeafToRemoveInd < suc lastVisitedLeafInd)
      : (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).3 = false \elim t
      | l :* r => mcases {1} {arg addPath} \with {
        | true, q => absurd (true/=false (inv q *> never-remove-lemma l fstLeafToRemoveInd lastVisitedLeafInd p))
        | false, q => mcases {_} {arg addPath} \with {
          | true, q =>\let | res-l => remove-pair l fstLeafToRemoveInd lastVisitedLeafInd
                            | p' : fstLeafToRemoveInd < suc res-l.2 =>
                               rewrite (rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd)
                                  (<_+ {_} {fstLeafToRemoveInd} {0} {suc lastVisitedLeafInd} {suc (count-leaves l)} p NatSemiring.zero<suc) \in
            absurd (true/=false (inv q *> never-remove-lemma r fstLeafToRemoveInd res-l.2 p'))
          | false, q => idp
        }
      }
      | :inv a \as t' => cases a idp \with {
        | var x => mcases \with {
          | yes p', _ => absurd $ <-irreflexive $ transport (\lam x => x < suc lastVisitedLeafInd) p' p
            -- (\lam {x y : NatSemiring} (p : x = y) => \case \elim x, \elim p \return (x < y) -> Empty \with { | _, idp => \lam p' => <-irreflexive {_} {x} p'}) p' p    -- contradiction {usingOnly (p, p')}
          | _, yes p' => absurd $ <-irreflexive $ transport (\lam x => x < suc (suc lastVisitedLeafInd)) p' (<_+ p (NatSemiring.zero<suc {0})) -- couldn't infer 0 in NatSemiring.zero<suc {0}!!
          | no _, no _ => idp
        }
      }
      | var x \as t' => mcases \with {
        | yes p', _ => absurd $ <-irreflexive $ transport (\lam x => x < suc lastVisitedLeafInd) p' p
        -- (\lam {x y : NatSemiring} (p : x = y) => \case \elim x, \elim p \return (x < y) -> Empty \with { | _, idp => \lam p' => <-irreflexive {_} {x} p'}) p' p    -- contradiction {usingOnly (p, p')}
        | _, yes p' => absurd $ <-irreflexive $ transport (\lam x => x < suc (suc lastVisitedLeafInd)) p' (<_+ p (NatSemiring.zero<suc {0})) -- couldn't infer 0 in NatSemiring.zero<suc {0}!!
        | no _, no _ => idp
      }
      | :ide => idp
  }
    {- -}

  \func rp-leaf-counter-lemma (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat)
    : (remove-pair t fstLeafToRemoveInd lastVisitedLeafInd).2 = lastVisitedLeafInd + count-leaves t
    \elim t
      -- Fix usages of duplicate code below!
      | l :* r => mcases {1} \with {
        | true =>
          \let leftProof => rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd
               | rightProof => rp-leaf-counter-lemma r fstLeafToRemoveInd (leftProof @ right) \in
            rewriteEq (idp {Nat}  {lastVisitedLeafInd + count-leaves l + count-leaves r}) (rewrite leftProof rightProof)
        | false => mcases {1}
            (
              \let | leftProof => rp-leaf-counter-lemma l fstLeafToRemoveInd lastVisitedLeafInd
                   | rightProof => rp-leaf-counter-lemma r fstLeafToRemoveInd (leftProof @ right) \in
                rewriteEq (idp {Nat} {lastVisitedLeafInd + count-leaves l + count-leaves r}) (rewrite leftProof rightProof)) \with {
        }
      }
      | :inv a \as t' => cases a idp \with { | var x => mcases idp \with {}}
      | var x \as t' => mcases idp \with {}
      | :ide => idp
  }

  \func get-rightmost-leaf (t : GroupTerm V) : GroupTerm V \elim t
    | l :* r => get-rightmost-leaf r
    | :inv (var x) \as t' => t'
    | var x \as t' => t'
    | t' => t'

  \func count-leaves (t : GroupTerm V) : Nat \elim t
    | l :* r => count-leaves l + count-leaves r
    | :inv (var x) => 1
    | :inv _ => 0
    | var x \as t' => 1
    | _ => 0

  \func remove-pair (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat)
    : \Sigma (GroupTerm V) Nat Bool \elim t
    | l :* r => \let res-l => remove-pair l fstLeafToRemoveInd lastVisitedLeafInd \in
                \case res-l.3 \with {
                  | true => remove-pair r fstLeafToRemoveInd res-l.2
                  -- Unfold res-r by hand because it does not unfold automatically when rewrite deals with it.
                  -- res-r should be used again once this issue is fixed.
                  | false => \let res-r => remove-pair r fstLeafToRemoveInd res-l.2 \in
                  \case res-r.3 \with {
                    | true => (res-l.1, (remove-pair r fstLeafToRemoveInd res-l.2).2, false)
                    | false => (res-l.1 :* res-r.1, (remove-pair r fstLeafToRemoveInd res-l.2).2, false)
                  }
                }
    | :inv (var x) \as t' => processLeaf t' fstLeafToRemoveInd lastVisitedLeafInd
    | :inv _ \as t' => (t', lastVisitedLeafInd, false)
    | var x \as t' => processLeaf t' fstLeafToRemoveInd lastVisitedLeafInd
    | ide => (ide, lastVisitedLeafInd, false)
    \where {
      \func processLeaf (t : GroupTerm V) (fstLeafToRemoveInd : Nat) (lastVisitedLeafInd : Nat) : \Sigma (GroupTerm V) Nat Bool =>
        \case decideEq fstLeafToRemoveInd (suc lastVisitedLeafInd), decideEq fstLeafToRemoveInd (suc (suc lastVisitedLeafInd)) \with {
          | no _, no _ => (t, suc lastVisitedLeafInd, false)
          | _, _ => (:ide, suc lastVisitedLeafInd, true)
        }
    }

  \func find-pair-to-remove (t : GroupTerm V) (lastVisitedLeafInd : Nat) (lastVisitedLeaf : V) (withInv : Bool)
    : \Sigma Nat V Bool Bool \elim t
    | :inv (var x) => processLeaf x true lastVisitedLeafInd lastVisitedLeaf withInv
    | var x => processLeaf x false lastVisitedLeafInd lastVisitedLeaf withInv
    | l :* r => \let res => find-pair-to-remove l lastVisitedLeafInd lastVisitedLeaf withInv \in \case res.4 \with {
      | true => res
      | false => find-pair-to-remove r res.1 res.2 res.3
    }
    | _ => (lastVisitedLeafInd, lastVisitedLeaf, withInv, false)
  \where {
    \func processLeaf (x : V) (xWithInv : Bool) (lastVisitedLeafInd : Nat) (lastVisitedLeaf : V) (withInv : Bool)
      : \Sigma Nat V Bool Bool => \case lastVisitedLeafInd \with {
      | suc n => \case decideEq (x, xWithInv) (lastVisitedLeaf, not withInv) \with {
        | yes _ => (n, lastVisitedLeaf, withInv, true)
        | no _ => (suc n, x, xWithInv, false)
      }
      | 0 => (1, x, xWithInv, false)
    }
  }

{-
  \func remove-leaves (t : GroupTerm V) (toRemove : List Nat) (leafInd : Nat) : \Sigma (GroupTerm V) Nat \elim t
    | :ide => (:ide, leafInd)
    | var x :* r => \case toRemove \with {
      | ind :: restToRemove => \case decideEq leafInd ind \with {
        | yes _ => remove-leaves r restToRemove (suc leafInd)
        | no _ => \let res => remove-leaves r toRemove (suc leafInd) \in (var x :* res.1, res.2)
      }
      | nil => (var x :* r, leafInd)
    }
    | l :* var x => {?}
  \where {
  --  \func processLeaf (x : V) (withInv : Bool)
  }

  \func leaves-to-remove (t : GroupTerm V) (notToRemove : List (\Sigma V Bool)) (toRemove : List Nat) (leafInd : Nat)
    : \Sigma (List (\Sigma V Bool)) (List Nat) Nat \elim t
    | :ide => (notToRemove, toRemove, leafInd)
    | l :* r => \let leftRes => leaves-to-remove l notToRemove toRemove leafInd \in leaves-to-remove r leftRes.1 leftRes.2 leftRes.3
    | :inv (var x) => processLeaf x true notToRemove toRemove leafInd
    | var x => processLeaf x false notToRemove toRemove leafInd
    | _ => (notToRemove, toRemove, leafInd)
    \where {
      \func processLeaf (x : V) (xWithInv : Bool) (notToRemove : List (\Sigma V Bool)) (toRemove : List Nat) (leafInd : Nat)
        : \Sigma (List (\Sigma V Bool)) (List Nat) Nat \elim notToRemove
        | (y, withInv) :: l \as notToRemove => \case decideEq (y, withInv) (x, not xWithInv) \with {
          | yes _ => (l, leafInd :: toRemove, suc leafInd)
          | no _ => ((x, xWithInv) :: notToRemove, toRemove, suc leafInd)
        }
        | _ => ((x, xWithInv) :: nil, nil, suc leafInd)
    }

 -}

  \func simplify (t : GroupTerm V) => {?}
}

\class CData \extends NatData {
  \override G : CGroup

  \lemma removeVar-lem (t : GroupTerm V) (v : V) (withInv : Bool) {n : Nat}
    : \Sigma (interpret (removeVar n t v withInv).1 * G.pow (if withInv (inverse (f v)) (f v)) (n ∧ countVar t v withInv) = interpret t)
             ((removeVar n t v withInv).2 = n -' countVar t v withInv) \elim t, n
    | t, 0 => (rewrite rdistr0 ide-right, idp)
    | var x, suc n => mcases \with {
      | yes e => (rewrite (NatSemiring.meet_+-left {1}, ldistr0) $ ide-left *> ide-left *> rewriteI (pmap __.2 e) (pmap (\lam s => f s.1) (inv e)), inv $ <=_exists zero<=_)
      | no q => (ide-right, idp)
    }
    | :ide, suc n => (ide-left, idp)
    | :inv t, suc n => (pmap (_ *) pow-lem *> *-comm *> inv G.inverse_* *> pmap inverse (removeVar-lem t v (not withInv)).1, (removeVar-lem t v (not withInv)).2)
    | :* t1 t2, suc n => (rewrite sum-lem $ pmap (_ *) G.pow_+ *> rewrite (removeVar-lem t1 v withInv).2 (equation *> pmap2 (*) (removeVar-lem t1 v withInv {suc n}).1 (removeVar-lem t2 v withInv {suc n -' countVar t1 v withInv}).1),
                          (removeVar-lem _ v withInv).2 *> rewrite (removeVar-lem t1 v withInv).2 -'-')
    \where {
      \open NatBSemilattice

      \lemma pow-lem {b : Bool} {n : Nat} {x : G} : G.pow (if b (inverse x) x) n = inverse (G.pow (if (not b) (inverse x) x) n) \elim b
        | false => inv $ G.inverse_pow *> pmap (G.pow __ n) (G.inverse-isInv x)
        | true => inv G.inverse_pow

      \lemma sum-lem {a b c : Nat} : a ∧ (b + c) = a ∧ b + (a -' b) ∧ c \elim a, b
        | 0, b => rdistr0 *> inv (pmap2 (+) rdistr0 rdistr0)
        | suc a, 0 => idp
        | suc a, suc b => NatSemiring.meet_+-left {1} *> pmap suc sum-lem *> inv (pmap (`+ _) (NatSemiring.meet_+-left {1}))
    }

  \lemma removeVar_<=-lem (t : GroupTerm V) (v : V) (withInv : Bool) {n : Nat} (p : n <= countVar t v withInv)
    : interpret (removeVar n t v withInv).1 * G.pow (if withInv (inverse (f v)) (f v)) n = interpret t
    => inv (pmap (_ * G.pow _ __) (MeetSemilattice.meet_<= p)) *> (removeVar-lem t v withInv).1

  \lemma removeVar-correct (t : GroupTerm V) (v : V) (n : Nat) (p : n <= countVar t v false) (q : n <= countVar t v true)
    : interpret (removeVar n (removeVar n t v true).1 v false).1 = interpret t
    => inv (*-assoc *> pmap (_ *) (inv (pmap (_ *) G.inverse_pow) *> inverse-right) *> ide-right) *>
       pmap (`* _) (removeVar_<=-lem (removeVar n t v true).1 v false $ transportInv (n <=) (count-remove-lem false) p) *>
       removeVar_<=-lem t v true q

  \lemma removeVars-correct (t : GroupTerm V) {l : List (\Sigma V Nat)} (a : All (\lam p => \Sigma (p.2 <= countVar t p.1 false) (p.2 <= countVar t p.1 true)) l) (b : All2 (__.1 /= __.1) l)
    : interpret (removeVars t l) = interpret t \elim l, a, b
    | nil, all-nil, all2-nil => idp
    | :: x l, all-cons p a, all2-cons q b => removeVar-correct (removeVars t l) x.1 x.2 (transportInv (x.2 <=) (count-removeVars-lem q) p.1) (transportInv (x.2 <=) (count-removeVars-lem q) p.2) *> removeVars-correct t {l} a b
    \where {
      \lemma count-removeVar-lem {t : GroupTerm V} {u v : V} {w w' : Bool} {n : Nat} (p : u /= v)
        : countVar (removeVar n t v w').1 u w = countVar t u w \elim t, n
        | t, 0 => idp
        | var x, suc n => mcases \with {
          | yes e, yes e' => absurd $ p (inv (pmap __.1 e') *> pmap __.1 e)
          | yes e, no q => idp
          | no q, yes e => rewrite (decideEq=_reduce e) idp
          | no _, no q => rewrite (decideEq/=_reduce q) idp
        }
        | :ide, suc n => idp
        | :inv t, suc n => count-removeVar-lem p
        | :* t t1, suc n => pmap2 (+) (count-removeVar-lem p) (count-removeVar-lem p)

      \lemma count-removeVars-lem {t : GroupTerm V} {l : List (\Sigma V Nat)} {v : V} {withInv : Bool} (a : All (v /= __.1) l)
        : countVar (removeVars t l) v withInv = countVar t v withInv \elim l, a
        | nil, all-nil => idp
        | :: x l, all-cons p a => count-removeVar-lem p *> count-removeVar-lem p *> count-removeVars-lem a
    }

  \lemma simplify-correct (t : GroupTerm V) : interpret t = interpret (simplify t)
    => inv $ unfold simplify (rewrite RedBlack.sort=insert $ removeVars-correct t (countVars-correct t (group-correct t) sort-correct) $ countVars-diff sort-correct $ group-diff $ Insertion.sort-sorted (toList t false))
} \where {
  \func removeVar (n : Nat) (t : GroupTerm Nat) (v : Nat) (withInv : Bool) : \Sigma (GroupTerm Nat) Nat \elim n, t
    | 0, t => (t, 0)
    | suc n, :ide => (:ide, suc n)
    | suc n, var x => \case decideEq (x,false) (v,withInv) \with {
      | yes _ => (:ide, n)
      | no _ => (var x, suc n)
    }
    | suc n, :inv t =>
      \have (t',n') => removeVar (suc n) t v (not withInv)
      \in (:inv t', n')
    | suc n, :* t1 t2 =>
      \have | (t1',n1) => removeVar (suc n) t1 v withInv
            | (t2',n2) => removeVar n1 t2 v withInv
      \in (t1' :* t2', n2)

  \func countVars (l : List (\Sigma (\Sigma Nat Bool) Nat)) : List (\Sigma Nat Nat) \elim l
    | nil => nil
    | :: _ nil => nil
    | :: ((x,b),n) (:: ((y,c),m) l) => \case decideEq x y \with {
      | yes _ => (x, n ∧ m) :: countVars l
      | no _ => countVars (((y,c),m) :: l)
    }

  \func removeVars (t : GroupTerm Nat) (l : List (\Sigma Nat Nat)) : GroupTerm Nat \elim l
    | nil => t
    | :: (v,n) l => (removeVar n (removeVar n (removeVars t l) v true).1 v false).1

  \func toList (t : GroupTerm Nat) (withInv : Bool) : List (\Sigma Nat Bool) \elim t
    | var v => (v, withInv) :: nil
    | :ide => nil
    | :inv t => toList t (not withInv)
    | :* t1 t2 => toList t1 withInv ++ toList t2 withInv

  \func simplify (t : GroupTerm Nat)
    => removeVars t $ countVars $ group $ RedBlack.sort $ toList t false

  -- Proof of correctness

  \func countVar (t : GroupTerm Nat) (v : Nat) (withInv : Bool) : Nat \elim t
    | var x => \case decideEq (x,false) (v,withInv) \with {
      | yes _ => 1
      | no _ => 0
    }
    | :ide => 0
    | :inv t => countVar t v (not withInv)
    | :* t1 t2 => countVar t1 v withInv + countVar t2 v withInv

  \lemma count-remove-lem {t : GroupTerm Nat} {v v' : Nat} (withInv : Bool) {n : Nat}
    : countVar (removeVar n t v' (not withInv)).1 v withInv = countVar t v withInv \elim t, n
    | t, 0 => idp
    | var x, suc n => mcases {1} \with {
      | yes e => mcases \with {
        | yes e' => \case rewriteF (inv (pmap __.2 e')) (pmap __.2 e)
        | no _ => idp
      }
      | no _ => idp
    }
    | :ide, suc n => idp
    | :inv t, suc n => count-remove-lem (not withInv)
    | :* t1 t2, suc n => pmap2 (+) (count-remove-lem withInv) (count-remove-lem withInv)

  \lemma toList-correct (t : GroupTerm Nat) (p : \Sigma Nat Bool) (b : Bool) : count (toList t b) p = countVar t p.1 (if b (not p.2) p.2) \elim t
    | var v => mcases \with {
      | yes _, yes _ => idp
      | yes e, no q => \case q $ ext (pmap __.1 e, \case \elim b, \elim e \with {
        | false, e => pmap __.2 e
        | true, e => rewriteI (pmap __.2 e) idp
      })
      | no q, yes e => \case q $ ext (pmap __.1 e, \case \elim b, \elim e \with {
        | false, e => pmap __.2 e
        | true, e => pmap (\lam s => not s.2) e *> not-isInv
      })
      | no _, no _ => idp
    }
    | :ide => idp
    | :inv t => toList-correct t p (not b) *> pmap (countVar t p.1) (\case \elim b \with {
      | false => idp
      | true => inv not-isInv
    })
    | :* t1 t2 => count_++ *> pmap2 (+) (toList-correct t1 p b) (toList-correct t2 p b)

  \lemma group-correct (t : GroupTerm Nat) : All (\lam p => p.2 <= countVar t p.1.1 p.1.2) $ group $ Insertion.sort $ toList t false
    => all-implies (group_count-lem (Insertion.sort-sorted (toList t false))) $ all-forall $
        \lam p c => rewrite c $ Preorder.=_<= $ inv (count_perm (Insertion.sort-perm (toList t false)) p.1) *> toList-correct t p.1 false

  \lemma countVars-correct (t : GroupTerm Nat) {l : List (\Sigma (\Sigma Nat Bool) Nat)} (a : All (\lam p => p.2 <= countVar t p.1.1 p.1.2) l)
                           (a' : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) l)
    : All (\lam p => \Sigma (p.2 <= countVar t p.1 false) (p.2 <= countVar t p.1 true)) (countVars l) \elim l, a, a'
    | nil, all-nil, allC-nil => all-nil
    | :: x nil, all-cons p a, allC-single => all-nil
    | :: ((b,x),n) (:: ((c,y),m) l), all-cons p (all-cons p' a), allC-cons q a' => mcases \with {
      | yes e => all-cons (meet-left <=∘ rewriteI (q e).1 p, rewrite e $ meet-right <=∘ rewriteI (q e).2 p') (countVars-correct t a (allC-tail a'))
      | no _ => countVars-correct t (all-cons p' a) a'
    }

  \lemma countVars-ineq {l : List (\Sigma (\Sigma Nat Bool) Nat)} {x : Nat} (a : All (x /= __.1.1) l) : All (x /= __.1) (countVars l) \elim l, a
    | nil, all-nil => all-nil
    | :: y nil, all-cons p a => all-nil
    | :: y (:: z l), all-cons p (all-cons a1 a2) => mcases \with {
      | yes e => all-cons p (countVars-ineq a2)
      | no _ => countVars-ineq (all-cons a1 a2)
    }

  \lemma countVars-diff {l : List (\Sigma (\Sigma Nat Bool) Nat)} (a' : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) l) (a : All2 (__.1 /= __.1) l)
    : All2 (__.1 /= __.1) (countVars l) \elim l, a', a
    | nil, allC-nil, all2-nil => all2-nil
    | :: x nil, allC-single, all2-cons a a1 => all2-nil
    | :: ((b,x),n) (:: ((c,y),m) l), allC-cons s a', all2-cons (all-cons _ a1) (all2-cons a2 a3) => mcases \with {
      | yes e =>
        all2-cons (countVars-ineq $ all-implies a1 $ all-implies a2 $ all-forall $ \lam q c d e' => cases (q.1.2 arg addPath) \with {
          | false, p => d $ ext (e', (s e).1 *> inv p)
          | true, p => c $ ext (inv e *> e', (s e).2 *> inv p)
        }) (countVars-diff (allC-tail a') a3)
      | no _ => countVars-diff a' (all2-cons a2 a3)
    }

  \lemma sort-correct-lem {l : List (\Sigma (\Sigma Nat Bool) Nat)} (s : Sorted (map __.1 l)) (a : All2 (__.1 /= __.1) l)
    : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) l \elim l, s, a
    | nil, _, _ => allC-nil
    | :: x nil, _, _ => allC-single
    | :: ((u,x),_) (:: ((v,y),_) l), sorted-cons e s, all2-cons (all-cons p _) a2 => allC-cons (\lam u=v => \case LinearOrder.trichotomy x y \with {
      | less x<y => \case \elim x, \elim y, \elim x<y \with {
        | false, true, BoolPoset.false<true => (idp,idp)
      }
      | equals x=y => absurd $ p $ pmap2 (__,__) u=v x=y
      | greater y<x => absurd $ e $ byRight (inv u=v, y<x)
    }) (sort-correct-lem s a2)

  \lemma sort-correct {l : List (\Sigma Nat Bool)} : AllC (\lam p1 p2 => p1.1.1 = p2.1.1 -> \Sigma (p1.1.2 = false) (p2.1.2 = true)) $ group $ Insertion.sort l
    => sort-correct-lem (group-sorted (Insertion.sort-sorted l)) (group-diff (Insertion.sort-sorted l))
}