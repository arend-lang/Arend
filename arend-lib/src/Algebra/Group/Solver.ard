\import Algebra.Group
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Pointed
\import Arith.Bool
\import Arith.Nat
\import Data.Bool
\import Data.List
\import Data.Or
\import Function.Meta ($)
\import Logic
\import Meta
\import Order.Lattice
\import Order.Lexicographical
\import Order.LinearOrder
\import Order.PartialOrder \hiding (ProductPoset)
\import Paths
\import Paths.Meta
\import Set
\open Sort

\data GroupTerm (V : \Type)
  | var V
  | :ide
  | :inv (GroupTerm V)
  | \infixl 6 :* (t s : GroupTerm V)

\class Data \noclassifying {G : Group} {V : \Set} (f : V -> G) {
  \func interpret (t : GroupTerm V) : G \elim t
    | var x => f x
    | :ide => ide
    | :inv t => inverse (interpret t)
    | :* t s => interpret t * interpret s
}

\class CData \extends Data {
  | V => Nat
  \override G : CGroup

  \func removeVar (n : Nat) (t : GroupTerm V) (v : V) (withInv : Bool) : \Sigma (GroupTerm V) Nat \elim n, t
    | 0, t => (t, 0)
    | suc n, :ide => (:ide, suc n)
    | suc n, var x => \case decideEq (x,false) (v,withInv) \with {
      | yes _ => (:ide, n)
      | no _ => (var x, suc n)
    }
    | suc n, :inv t =>
      \have (t',n') => removeVar (suc n) t v (not withInv)
      \in (:inv t', n')
    | suc n, :* t1 t2 =>
      \have | (t1',n1) => removeVar (suc n) t1 v withInv
            | (t2',n2) => removeVar n1 t2 v withInv
      \in (t1' :* t2', n2)

  \func countVars (l : List (\Sigma (\Sigma Bool V) Nat)) : List (\Sigma V Nat) \elim l
    | nil => nil
    | :: _ nil => nil
    | :: ((b,x),n) (:: ((c,y),m) l) => \case decideEq x y \with {
      | yes _ => (x, n ∧ m) :: countVars l
      | no _ => countVars (((c,y),m) :: l)
    }

  \func removeVars (t : GroupTerm V) (l : List (\Sigma V Nat)) : GroupTerm V \elim l
    | nil => t
    | :: (v,n) l => (removeVar n (removeVar n (removeVars t l) v true).1 v false).1

  \func toList (t : GroupTerm V) (withInv : Bool) : List (\Sigma Bool V) \elim t
    | var v => (withInv, v) :: nil
    | :ide => nil
    | :inv t => toList t (not withInv)
    | :* t1 t2 => toList t1 withInv ++ toList t2 withInv

  \func simplify (t : GroupTerm V)
    => removeVars t $ countVars $ group $ RedBlack.sort $ toList t false

  -- Proof of correctness

  \func countVar (t : GroupTerm V) (v : V) (withInv : Bool) : Nat \elim t
    | var x => \case decideEq (x,false) (v,withInv) \with {
      | yes _ => 1
      | no _ => 0
    }
    | :ide => 0
    | :inv t => countVar t v (not withInv)
    | :* t1 t2 => countVar t1 v withInv + countVar t2 v withInv

  \lemma removeVar-lem (t : GroupTerm V) (v : V) (withInv : Bool) {n : Nat}
    : \Sigma (interpret (removeVar n t v withInv).1 * G.pow (if withInv (inverse (f v)) (f v)) (n ∧ countVar t v withInv) = interpret t)
             ((removeVar n t v withInv).2 = n -' countVar t v withInv) \elim t, n
    | t, 0 => (rewrite rdistr0 ide-right, idp)
    | var x, suc n => mcases \with {
      | yes e => (rewrite (NatSemiring.meet_+-left {1}, ldistr0) $ ide-left *> ide-left *> rewriteI (pmap __.2 e) (pmap (\lam s => f s.1) (inv e)), inv $ <=_exists zero<=_)
      | no q => (ide-right, idp)
    }
    | :ide, suc n => (ide-left, idp)
    | :inv t, suc n => (pmap (_ *) pow-lem *> *-comm *> inv G.inverse_* *> pmap inverse (removeVar-lem t v (not withInv)).1, (removeVar-lem t v (not withInv)).2)
    | :* t1 t2, suc n => (rewrite sum-lem $ pmap (_ *) G.pow_+ *> rewrite (removeVar-lem t1 v withInv).2 (equation *> pmap2 (*) (removeVar-lem t1 v withInv {suc n}).1 (removeVar-lem t2 v withInv {suc n -' countVar t1 v withInv}).1),
                          (removeVar-lem _ v withInv).2 *> rewrite (removeVar-lem t1 v withInv).2 -'-')
    \where {
      \open NatBSemilattice

      \lemma pow-lem {b : Bool} {n : Nat} {x : G} : G.pow (if b (inverse x) x) n = inverse (G.pow (if (not b) (inverse x) x) n) \elim b
        | false => inv $ G.inverse_pow *> pmap (G.pow __ n) (G.inverse-isInv x)
        | true => inv G.inverse_pow

      \lemma sum-lem {a b c : Nat} : a ∧ (b + c) = a ∧ b + (a -' b) ∧ c \elim a, b
        | 0, b => rdistr0 *> inv (pmap2 (+) rdistr0 rdistr0)
        | suc a, 0 => idp
        | suc a, suc b => NatSemiring.meet_+-left {1} *> pmap suc sum-lem *> inv (pmap (`+ _) (NatSemiring.meet_+-left {1}))
    }

  \lemma removeVar_<=-lem (t : GroupTerm V) (v : V) (withInv : Bool) {n : Nat} (p : n <= countVar t v withInv)
    : interpret (removeVar n t v withInv).1 * G.pow (if withInv (inverse (f v)) (f v)) n = interpret t
    => inv (pmap (_ * G.pow _ __) (MeetSemilattice.meet_<= p)) *> (removeVar-lem t v withInv).1

  \lemma removeVar-correct (t : GroupTerm V) (v : V) (n : Nat) (p : n <= countVar t v false) (q : n <= countVar t v true)
    : interpret (removeVar n (removeVar n t v true).1 v false).1 = interpret t
    => inv (*-assoc *> pmap (_ *) (inv (pmap (_ *) G.inverse_pow) *> inverse-right) *> ide-right) *>
       pmap (`* _) (removeVar_<=-lem (removeVar n t v true).1 v false $ transportInv (n <=) (count-remove-lem false) p) *>
       removeVar_<=-lem t v true q
    \where {
      \lemma count-remove-lem {t : GroupTerm V} {v v' : V} (withInv : Bool) {n : Nat}
        : countVar (removeVar n t v' (not withInv)).1 v withInv = countVar t v withInv \elim t, n
        | t, 0 => idp
        | var x, suc n => mcases {1} \with {
          | yes e => mcases \with {
            | yes e' => \case rewriteF (inv (pmap __.2 e')) (pmap __.2 e)
            | no _ => idp
          }
          | no _ => idp
        }
        | :ide, suc n => idp
        | :inv t, suc n => count-remove-lem (not withInv)
        | :* t1 t2, suc n => pmap2 (+) (count-remove-lem withInv) (count-remove-lem withInv)
    }

  \lemma removeVars-correct (t : GroupTerm V) {l : List (\Sigma V Nat)} (a : All (\lam p => \Sigma (p.2 <= countVar t p.1 false) (p.2 <= countVar t p.1 true)) l) (b : All2 (__.1 /= __.1) l)
    : interpret (removeVars t l) = interpret t \elim l, a, b
    | nil, all-nil, all2-nil => idp
    | :: x l, all-cons p a, all2-cons q b => removeVar-correct (removeVars t l) x.1 x.2 (transportInv (x.2 <=) (count-removeVars-lem q) p.1) (transportInv (x.2 <=) (count-removeVars-lem q) p.2) *> removeVars-correct t {l} a b
    \where {
      \lemma count-removeVar-lem {t : GroupTerm V} {u v : V} {w w' : Bool} {n : Nat} (p : u /= v)
        : countVar (removeVar n t v w').1 u w = countVar t u w \elim t, n
        | t, 0 => idp
        | var x, suc n => mcases \with {
          | yes e, yes e' => absurd $ p (inv (pmap __.1 e') *> pmap __.1 e)
          | yes e, no q => idp
          | no q, yes e => rewrite (decideEq=_reduce e) idp
          | no _, no q => rewrite (decideEq/=_reduce q) idp
        }
        | :ide, suc n => idp
        | :inv t, suc n => count-removeVar-lem p
        | :* t t1, suc n => pmap2 (+) (count-removeVar-lem p) (count-removeVar-lem p)

      \lemma count-removeVars-lem {t : GroupTerm V} {l : List (\Sigma V Nat)} {v : V} {withInv : Bool} (a : All (v /= __.1) l)
        : countVar (removeVars t l) v withInv = countVar t v withInv \elim l, a
        | nil, all-nil => idp
        | :: x l, all-cons p a => count-removeVar-lem p *> count-removeVar-lem p *> count-removeVars-lem a
    }

  \lemma toList-correct (t : GroupTerm V) (p : \Sigma Bool Nat) (b : Bool) : count (toList t b) p = countVar t p.2 (if b (not p.1) p.1) \elim t
    | var v => mcases \with {
      | yes _, yes _ => idp
      | yes e, no q => \case q $ ext (pmap __.2 e, \case \elim b, \elim e \with {
        | false, e => pmap __.1 e
        | true, e => rewriteI (pmap __.1 e) idp
      })
      | no q, yes e => \case q $ ext (\case \elim b, \elim e \with {
        | false, e => pmap __.2 e
        | true, e => pmap (\lam s => not s.2) e *> not-isInv
      }, pmap __.1 e)
      | no _, no _ => idp
    }
    | :ide => idp
    | :inv t => toList-correct t p (not b) *> pmap (countVar t p.2) (\case \elim b \with {
      | false => idp
      | true => inv not-isInv
    })
    | :* t1 t2 => count_++ *> pmap2 (+) (toList-correct t1 p b) (toList-correct t2 p b)

  \lemma group-correct (t : GroupTerm V) : All (\lam p => p.2 <= countVar t p.1.2 p.1.1) $ group $ Insertion.sort $ toList t false
    => all-implies (group_count-lem (Insertion.sort-sorted (toList t false))) $ all-forall $
         \lam p c => rewrite c $ Preorder.=_<= $ inv (count_perm (Insertion.sort-perm (toList t false)) p.1) *> toList-correct t p.1 false

  \lemma countVars-correct (t : GroupTerm V) {l : List (\Sigma (\Sigma Bool V) Nat)} (a : All (\lam p => p.2 <= countVar t p.1.2 p.1.1) l)
                           (a' : AllC (\lam p1 p2 => p1.1.2 = p2.1.2 -> \Sigma (p1.1.1 = false) (p2.1.1 = true)) l)
    : All (\lam p => \Sigma (p.2 <= countVar t p.1 false) (p.2 <= countVar t p.1 true)) (countVars l) \elim l, a, a'
    | nil, all-nil, allC-nil => all-nil
    | :: x nil, all-cons p a, allC-single => all-nil
    | :: ((b,x),n) (:: ((c,y),m) l), all-cons p (all-cons p' a), allC-cons q a' => mcases \with {
      | yes e => all-cons (meet-left <=∘ rewriteI (q e).1 p, rewrite e $ meet-right <=∘ rewriteI (q e).2 p') (countVars-correct t a (allC-tail a'))
      | no _ => countVars-correct t (all-cons p' a) a'
    }

  \lemma countVars-ineq {l : List (\Sigma (\Sigma Bool V) Nat)} {x : V} (a : All (x /= __.1.2) l) : All (x /= __.1) (countVars l) \elim l, a
    | nil, all-nil => all-nil
    | :: y nil, all-cons p a => all-nil
    | :: y (:: z l), all-cons p (all-cons a1 a2) => mcases \with {
      | yes e => all-cons p (countVars-ineq a2)
      | no _ => countVars-ineq (all-cons a1 a2)
    }

  \lemma countVars-diff {l : List (\Sigma (\Sigma Bool V) Nat)} (a' : AllC (\lam p1 p2 => p1.1.2 = p2.1.2 -> \Sigma (p1.1.1 = false) (p2.1.1 = true)) l) (a : All2 (__.1 /= __.1) l)
    : All2 (__.1 /= __.1) (countVars l) \elim l, a', a
    | nil, allC-nil, all2-nil => all2-nil
    | :: x nil, allC-single, all2-cons a a1 => all2-nil
    | :: ((b,x),n) (:: ((c,y),m) l), allC-cons s a', all2-cons (all-cons _ a1) (all2-cons a2 a3) => mcases \with {
      | yes e =>
        all2-cons (countVars-ineq $ all-implies a1 $ all-implies a2 $ all-forall $ \lam q c d e' => cases (q.1.1 arg addPath) \with {
          | false, p => d $ ext ((s e).1 *> inv p, e')
          | true, p => c $ ext ((s e).2 *> inv p, inv e *> e')
        }) (countVars-diff (allC-tail a') a3)
      | no _ => countVars-diff a' (all2-cons a2 a3)
    }

  \lemma sort-correct-lem {l : List (\Sigma (\Sigma Bool V) Nat)} (s : Sorted (map __.1 l)) (a : All2 (__.1 /= __.1) l)
    : AllC (\lam p1 p2 => p1.1.2 = p2.1.2 -> \Sigma (p1.1.1 = false) (p2.1.1 = true)) l \elim l, s, a
    | nil, _, _ => allC-nil
    | :: x nil, _, _ => allC-single
    | :: ((x,u),_) (:: ((y,v),_) l), sorted-cons x<=y s, all2-cons (all-cons p _) a2 => allC-cons (\lam e => \case LinearOrder.<=-dec x<=y \with {
      | inl (byLeft x<y) => \case \elim x, \elim y, \elim x<y \with {
        | false, true, BoolPoset.false<true => (idp,idp)
      }
      | inl (byRight (x=y,_)) => \case p $ ext (x=y,e)
      | inr xu=yv => \case p xu=yv
    }) (sort-correct-lem s a2)

  \lemma sort-correct {l : List (\Sigma Bool V)} : AllC (\lam p1 p2 => p1.1.2 = p2.1.2 -> \Sigma (p1.1.1 = false) (p2.1.1 = true)) $ group $ Insertion.sort l
    => sort-correct-lem (group-sorted (Insertion.sort-sorted l)) (group-diff (Insertion.sort-sorted l))

  \lemma simplify-correct (t : GroupTerm V) : interpret t = interpret (simplify t)
    => inv $ unfold simplify (rewrite RedBlack.sort=insert $ removeVars-correct t (countVars-correct t (group-correct t) sort-correct) $ countVars-diff sort-correct $ group-diff $ Insertion.sort-sorted (toList t false))
}