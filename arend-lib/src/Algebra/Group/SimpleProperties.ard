\import Algebra.Group
\import Algebra.Group.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Pointed
\import Algebra.Pointed.Category
\import Category (Cat, Precat)
\import Category.Functor
\import Category.Meta
\import Category.Subcat
\import Equiv
\import Function
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set.Category

\func check-for-inv {E : Group} {x y : E} (p : x * y = ide) : y = inverse x
  =>  y                     ==< inv ide-left >==
      ide * y               ==< pmap (right-shift y) (inv inverse-left) >==
      inverse x * x * y     ==< *-assoc >==
      inverse x * (x * y)   ==< pmap (left-shift (inverse x)) p >==
      inverse x * ide       ==< ide-right >==
      inverse x `qed
\func equality-check {E : Group} {g h : E} (p : inverse g * h = ide) :  g = h =>
  g                   ==< inv ide-right >==
      g * ide             ==< pmap (left-shift g) (inv p) >==
      g * (inverse g * h) ==< inv *-assoc >==
      (g * inverse g) * h ==< pmap (right-shift h) inverse-right >==
      ide * h             ==< ide-left >==
      h `qed

\func equality-corrolary {E : Group} (g h : E) (p : g = h) : inverse g * h = ide =>
  inverse g * h ==< pmap (left-shift (inverse g)) (inv p) >==
      inverse g * g ==< inverse-left >==
      ide `qed
\func middle-ide {E : Group} {g h : E} : g * h = g * (ide * h)=> simplify

\func conjugation {E : Group} (g : E) (h : E) : E => inverse g * (h * g)
\func left-shift {E : Group} (g : E) (h : E) => g * h
\func right-shift {E : Group} (g : E) (h : E) => h * g
