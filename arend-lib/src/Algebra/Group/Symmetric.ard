\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Ring
\import Combinatorics.Factorial
\import Data.Array (Perm)
\import Data.Fin
\import Equiv
\import Equiv.Sigma
\import Function.Meta
\import Logic
\import Paths
\import Paths.Meta
\import Set.Fin
\import Set.Fin.Pigeonhole

\type Sym (n : Nat) => Equiv {Fin n} {Fin n}
  \where {
    \func fromEquiv {n : Nat} (e : Equiv {Fin n} {Fin n}) : Sym n => e

    \lemma equals {n : Nat} {x y : Sym n} (p : \Pi (j : Fin n) -> x j = y j) : x = y
      => pmap fromEquiv (Equiv.equals (ext p))

    \func sign {R : Ring} {n : Nat} (e : Sym n) : R \elim n
      | 0 => 1
      | suc n => R.pow -1 (e 0) * sign (reduce e)

    \func reduce {n : Nat} (e : Sym (suc n)) : Sym n
      => PigeonholeSet.isEquiv (\lam j => FinSet.skip (e 0) (e (suc j)) $ \lam p => \case Equiv.isInj p) $ \lam p => unfsuc $ Equiv.isInj (FinSet.skip-isInj p)
  }

\instance SymmetricGroup (n : Nat) : Group (Sym n)
  | ide => idEquiv
  | * e1 e2 => transEquiv e1 e2
  | ide-left => Sym.equals $ \lam j => idp
  | ide-right => Sym.equals $ \lam j => idp
  | *-assoc => Sym.equals $ \lam j => idp
  | inverse e => symQEquiv e
  | inverse-left => Sym.equals Equiv.f_ret
  | inverse-right => Sym.equals Equiv.ret_f

\func symmetric-rec {n : Nat} : QEquiv {Sym (suc n)} {\Sigma (Fin (suc n)) (Sym n)} \cowith
  | f e => (e 0, Sym.reduce e)
  | ret s => PigeonholeSet.isEquiv {FinFin (suc n)}
      (\case __ \with {
        | 0 => s.1
        | suc j => sface s.1 (s.2 j)
      }) (\lam {j} {j'} => \case \elim j, \elim j' \with {
        | 0, 0 => \lam _ => idp
        | 0, suc j' => \lam p => absurd $ sface-skip (inv p)
        | suc j, 0 => \lam p => absurd $ sface-skip p
        | suc j, suc j' => \lam p => pmap fsuc $ Equiv.isInj {s.2} (sface-inj p)
      })
  | ret_f e => Sym.equals $ \case \elim __ \with {
    | 0 => idp
    | suc j => FinSet.sface_skip
  }
  | f_sec s => pmap (s.1,__) $ Sym.equals $ \lam j => FinSet.skip_sface

\instance SymFin (n : Nat) : FinSet (Sym n) (fac n) \elim n
  | 0 => \new FinSet {
    | finEq => inP $ \new QEquiv {
      | f _ => 1
      | ret _ => 0
      | ret_f (0) => idp
      | f_sec e => Sym.equals (\case __)
    }
  }
  | suc n => \new FinSet {
    | finEq => \case finEq, finEq {SymFin n} \with {
      | inP e, inP e' => inP $ e `transEquiv` sigma-right (\lam _ => e') `transEquiv` symQEquiv symmetric-rec
    }
  }