\import Algebra.Group
\import Algebra.Group.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Pointed
\import Algebra.Pointed.Category
\import Category (Cat, Precat)
\import Category.Functor
\import Category.Meta
\import Category.Subcat
\import Equiv
\import Function
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set.Category
\import Algebra.Group.Category
\open Group
\open Algebra.Group.Sub

\func Quot {G H : Group}(f : GroupHom G H) : Group => f.Kernel.quotient

\func \infix 7 / (G : Group) (H : NormalSubGroup G) : Group => H.quotient

\func kernelEquivProp {G : Group} (N : NormalSubGroup G) (a : G)(p : N.contains a) : N.quotient.ide = in~ a => {?}


{- | a set function that having $G, H$ and $f : G \to H$ and a
 -    normal subgroup $N \leq G$ s.t. $N \leqslant \ker(f)$ produces for each element of $G/N$ an element of $H$.
 - One gets a diagram of the form
 - $$G \xrightarrow{\pi} G/N \xrightarrow{\text{this\,  function}} H $$ -}
\func universalQuotientMorphismSetwise {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G)
                                       (p : N SubGroupPreorder.<= f.Kernel)
                                       (a : N.quotient) : H \elim a
  | in~ n => f n
  | ~-equiv y x r => equality-check ((inverse (f y)) * (f x) ==< pmap (\lam y => y * (f x)) (inv f.func-inverse) >==
    f (inverse y) * (f x) ==< inv func-* >==
    f (inverse y * x) ==< lemma' f N p r >== ide `qed)
  \where
    \lemma lemma' {x y : G} (f : GroupHom G H) (N : NormalSubGroup G) (p : N SubGroupPreorder.<= f.Kernel)
                 (r : N.contains ((inverse y) * x)) : f (inverse y * x) = ide =>
      f (inverse y * x) ==< p ((inverse y) * x) r >== ide `qed

{- | this a synonym for universalQuotientMorphismSetwise used because it is shorter-}
\func uqms {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G) (p : N SubGroupPreorder.<= f.Kernel) => universalQuotientMorphismSetwise f N p


{- | this is a proof that in the previous assumptions the function
 - universalQuotientMorphismSetwise is multiplicative -}
\func universalQuotientMorphismMultiplicative {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G) (p : N SubGroupPreorder.<= f.Kernel)
                                              (x y : N.quotient) : uqms f N p (x N.quotient.* y) = (uqms f N p x) * (uqms f N p y) \elim x, y
  | in~ a, in~ a1 => uqms f N p ((in~ a) N.quotient.* (in~ a1)) ==< idp >== uqms f N p (in~ (a * a1))
                                                                              ==< idp >== f (a * a1) ==< f.func-* >== (f a) * (f a1)
                                                                                                                        ==< pmap ((f a)*) idp >== (f a) * uqms f N p (in~ a1)
                                                                                                                                                    ==< pmap (\lam x => x * uqms f N p (in~ a1)) idp >==
                                                                                                                                                  (uqms f N p (in~ a)) * (uqms f N p (in~ a1)) `qed

  {- | this is a function which gives the homomorphism in the universal property
 - of quotient groups. Basically, it proves
 - that the function universalQuotientMorphismSetwise
 - indeed gives a group homomorphism. Thus the arrow $G/N \xrightarrow{\text{uqms}} H$ indeed lies in Group-}
\func universalQuotientMorph {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G)
                             (p : N SubGroupPreorder.<= f.Kernel) : GroupHom (G / N) H \cowith
  | func => uqms f N p
  | func-ide => uqms f N p N.quotient.ide ==< idp >== uqms f N p (in~ 1) ==< idp >== f ide ==< f.func-ide >== ide `qed
  | func-* {x y : N.quotient} => universalQuotientMorphismMultiplicative f N p x y


\lemma universalQuotientProperty {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G)
                                 (p : N SubGroupPreorder.<= f.Kernel) :  (universalQuotientMorph f N p) GroupCat.∘ quotient-map = f
  => exts (\lam (x : G) => ((universalQuotientMorph f N p) GroupCat.∘ quotient-map) x ==< idp >==
  (universalQuotientMorph f N p) (quotient-map x) ==< idp >==
  (universalQuotientMorph f N p) (in~ x) ==< idp >== f x `qed)


{- | Now we apply all of these universal properties to the case when N = Ker f and we get the first isomorphism theorem in the end-}
\class FirstIsomorphismTheorem {
  | G : Group
  | H : Group
  | f : GroupHom G H

  \func univKer-hom : GroupHom (G / f.Kernel) H => universalQuotientMorph f (f.Kernel) SubGroupPreorder.<=-refl

  \lemma universalKerProp : univKer-hom GroupCat.∘ quotient-map = f
    => universalQuotientProperty f f.Kernel SubGroupPreorder.<=-refl

  \lemma universalQuotientKernel (g : G / f.Kernel)
                                 (q : univKer-hom g = ide) : g = f.Kernel.quotient.ide
    => \case g \as b, idp : g = b \with{
      | in~ a, p => {?} -- inv (kernelEquivProp f.Kernel a )
    }
    \where{
      \func helper-1 (a : G)
                     (q : univKer-hom (in~ a) = ide) : in~ a = f.Kernel.quotient.ide =>
        inv (kernelEquivProp f.Kernel a (universalQuotientKernel' a q))
    }


  \func evidTrivKer : univKer-hom.TrivialKernel =>
    \lam {g : G / f.Kernel} (p : univKer-hom.Kernel.contains g) => universalQuotientKernel g p

  \lemma universalQuotientKernel'  (a : G)
                                  (q : univKer-hom (in~ a) = ide) : f.Kernel.contains a
    =>
      f a ==< inv (technical-helper a) >==
      univKer-hom (in~ a) ==< q >==
      ide `qed
    \where \lemma technical-helper  (a : G) : univKer-hom (in~ a) = f a =>
      univKer-hom (in~ a) ==< pmap univKer-hom {in~ a} {quotient-map a} idp >==
      univKer-hom (quotient-map a) ==< idp >==
      (univKer-hom  GroupCat.∘ quotient-map) a ==< pmap (\lam (z : GroupHom G H) => z a) universalKerProp >==
      f a `qed


  \lemma univKer-mono : isInj univKer-hom.func => univKer-hom.Kernel-injectivity-test evidTrivKer

  \func univKer-epi (p : isSurj f): isSurj univKer-hom.func => {?}


  \func FirstIsoTheorem (p : isSurj f) : univKer-hom.isIsomorphism => (univKer-mono, univKer-epi p)
}




