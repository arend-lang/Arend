\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Pointed
\import Category (Cat)
\import Category.Sub
\import Equiv
\import Paths
\import Set.Category

\instance GroupCategory : Cat Group
  => subCat (\new Embedding {
    | f G => G
    | isEmb G H => \new Retraction {
      | sec => Group.equals G H
      | f_sec => idpe
    }
  })

\record AddMonoidHom \extends SetHom {
  \override Dom : AddMonoid
  \override Cod : AddMonoid
  | func-+ (x y : Dom) : func (x + y) = func x + func y
  | func-zro : func 0 = 0
} \where {
    \func toMonoidHom (f : AddGroupHom) : MonoidHom \cowith
      | Dom => \new Monoid f.Dom.E 0 (+ {f.Dom}) (zro-left {f.Dom}) (zro-right {f.Dom}) (+-assoc {f.Dom})
      | Cod => \new Monoid f.Cod.E 0 (+ {f.Cod}) (zro-left {f.Cod}) (zro-right {f.Cod}) (+-assoc {f.Cod})
      | func => f
      | func-* => func-+
      | func-ide => func-zro
  }

\record AddGroupHom \extends AddMonoidHom {
  \override Dom : AddGroup
  \override Cod : AddGroup
  | func-zro => AddGroup.cancel-left (func 0) (inv (func-+ 0 0) *> pmap func zro-right *> inv zro-right)
} \where {
  \func equals {A B : AddGroup} {f g : AddGroupHom A B} (p : \Pi (x : A) -> f x = g x) : f = g
    => path (\lam i => \new AddGroupHom A B (\lam x => p x @ i) (pathInProp (\lam j => \Pi (x y : A) -> p (x + y) @ j = (p x @ j) + (p y @ j)) f.func-+ g.func-+ @ i))
}

\instance AddGroupCategory : Cat AddGroup
  | Hom G H => AddGroupHom G H
  | id => id
  | o g f => \new AddGroupHom {
    | func x => g (f x)
    | func-+ x y => pmap g (func-+ x y) *> func-+ (f x) (f y)
  }
  | id-left _ => idp
  | id-right _ => idp
  | o-assoc _ _ _ => idp
  | univalence {A B : AddGroup} (f : AddGroupHom A B) (g : AddGroupHom B A) p q =>
    \let A=B => AddGroup.equals A B (path (iso f g (\lam x => path (\lam i => func {p @ i} x)) (\lam y => path (\lam i => func {q @ i} y)))) f.func-+
    \in (A=B, AddGroupHom.equals (\lam x => Jl {AddGroup} (\lam C A=C => func {transport (AddGroupHom A __) A=C (id A)} x = coe (A=C @ __) x right) idp A=B))
  \where
    \func id (G : AddGroup) : AddGroupHom G G \cowith
      | func x => x
      | func-+ _ _ => idp

\instance AbGroupCategory : Cat AbGroup
  => subCat (\new Embedding {AbGroup} {AddGroup} {
    | f A => A
    | isEmb A B => \new Retraction {
      | sec => AbGroup.equals A B
      | f_sec => idpe
    }
  })
