\import Algebra.Group
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Pointed.Category
\import Algebra.Pointed.Sub
\import Category (Cat, Iso)
\import Category.Functor
\import Category.Meta
\import Category.Subcat
\import Equiv
\import Function
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set.Category
\open Group

\record GroupHom \extends MonoidHom {
  \override Dom : Group
  \override Cod : Group

  | func-ide => cancel_*-left (func ide) $ inv func-* *> pmap func ide-left *> inv ide-right

  \lemma func-inverse {x : Dom} : func (inverse x) = inverse (func x) => check-for-inv $
    func x * func (inverse x)   ==< inv func-* >==
    func (x * inverse x)        ==< pmap func inverse-right >==
    func ide                    ==< func-ide >==
    ide `qed

  \func Ker : NormalSubGroup Dom \cowith
    | contains x => func x = ide
    | contains_ide => func-ide
    | contains_inverse {x : Dom} (p : func x = ide) =>
      func (inverse x)     ==< func-inverse >==
      inverse (func x)     ==< pmap inverse p >==
      inverse ide          ==< Group.inverse_ide >==
      ide `qed

    | isNormal g {h} p =>
      func (g * h * inverse g)                ==< func-* >==
      func (g * h) * func (inverse g)         ==< pmap (`* (func (inverse g))) func-* >==
      func g * func h * func (inverse g)      ==< pmap (\lam z => func g * z * func (inverse g)) p >==
      func g * ide * func (inverse g)         ==< pmap (`* (func (inverse g))) ide-right >==
      func g * func (inverse g)               ==< inv func-* >==
      func (g * inverse g)                    ==< pmap func inverse-right >==
      func ide                                ==< func-ide >==
      ide `qed

    | contains_* {x} {y} p q =>
      func (x * y)     ==< func-* >==
      func x * func y  ==< pmap (`* func y) p >==
      ide * func y     ==< ide-left >==
      func y           ==< q >==
      ide `qed

  \func sbgp-image (H : SubGroup Dom) : SubGroup Cod \cowith {
    | contains y => ∃ (x : Dom) (H x) (func x = y)
    | contains_ide => inP (ide, contains_ide, func-ide)
    | contains_* (inP (x0, A0, B0)) (inP (x1, A1, B1)) => inP (x0 * x1, contains_* A0 A1, rewrite (func-*, B0, B1) idp)
    | contains_inverse (inP (x0, A0, B0)) => inP (inverse x0, contains_inverse A0, rewrite (func-inverse, B0) idp)
  }

  \func sbgp-inverse-image (H : SubGroup Cod) : SubGroup Dom \cowith {
    | contains y => H.contains (func y)
    | contains_ide => rewrite func-ide contains_ide
    | contains_* x y => rewrite func-* (contains_* x y)
    | contains_inverse x => rewrite func-inverse (contains_inverse x)
  } \where {
    \func normal (n : SubGroup.isNormalSubGroup {H}) : SubGroup.isNormalSubGroup {sbgp-inverse-image H} =>
      \lam g {h} c => rewriteI (func-*, func-inverse, func-*) in (unfold conjugate in n (func g) {func h} c)
  }

  \func Im : SubGroup Cod \cowith
    | contains y => ∃ (x : Dom) (func x = y)
    | contains_ide => inP (ide, func-ide)
    | contains_* (inP (x0, A0)) (inP (x1, A1)) => inP (x0 * x1, rewrite (func-*, A0, A1) idp)
    | contains_inverse (inP (x0, A0)) => inP (inverse x0, rewrite (func-inverse, A0) idp) \where {

    \func Im=Cod (p : isSurj func) : Im.struct = Cod =>
      Cat.isotoid {GroupCat} {Im.struct} {Cod} (im.im_iso p)
  }

  \func ker : GroupHom Ker.struct Dom => Ker.embed \where {
     \func inj : isInj ker => \lam p => ext p
   }

  \func im : GroupHom Im.struct Cod => Im.embed \where {
    \func inj : isInj im => \lam p => ext p

    \func surj (s : isSurj func) : isSurj im => \lam y => \let A0 => s y \in \case \elim A0 \with {
      | inP (x, p) => inP ((func x, inP (x, idp)), p)
    }

    \func im_iso (p : isSurj func) : Iso {GroupCat} {Im.struct} {Cod} => (GroupCat.Iso<->Bijective im).2 (inj, surj p)
  }

  \func TrivialKernel : \Prop => \Pi {g : Dom} -> Ker g -> g = ide

  \func same-images-test {a b : Dom} (p : func a = func b) : Ker (inverse a * b) =>
    func (inverse a * b)          ==< func-* >==
    func (inverse a) * func b     ==< pmap (`* func b) func-inverse >==
    inverse (func a) * func b     ==< equality-corrolary (func a) (func b) p >==
    ide `qed

  \lemma Kernel-injectivity-test (p : TrivialKernel) : isInj func =>
    \lam q => equality-check (p (same-images-test q))

  \lemma Kernel-injectivity-corollary (p : isInj func) : TrivialKernel =>
    \lam q => p (q *> inv func-ide)

  \func asIso (p : isBijective) : Iso {GroupCat} {Dom} {Cod} => (GroupCat.Iso<->Bijective _).2 p
}

\instance GroupCat : Cat Group
  | Hom => GroupHom
  | id (G : Group) : GroupHom G G \cowith {
    | func x => x
    | func-ide => idp
    | func-* => idp
  }
  | o {x y z : Group} (g : GroupHom y z) (f : GroupHom x y) => \new GroupHom {
    | func x => g (f x)
    | func-ide => pmap g f.func-ide *> g.func-ide
    | func-* => pmap g f.func-* *> g.func-*
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip \lam f _ => exts (func-ide {f}, \lam _ _ => func-* {f}, \lam _ => GroupHom.func-inverse {f})
  \where {
    \func ForgetSet : FaithfulFunctor GroupCat SetCat \cowith
      | F G => G
      | Func f => f
      | Func-id => idp
      | Func-o => idp
      | isFaithful => \lam p => ext p

    -- TODO: Prove this more generally for algebraic theories?
    \lemma Iso<->Bijective {G H : Group} (f : GroupHom G H) : Iso {GroupCat} f <-> f.isBijective
      => (\lam p => SetIso->Inj+Surj (ForgetSet.Func-iso p),
          \lam p => \new Iso {
            | hinv => \new GroupHom {
              | func => Iso.hinv {this_iso p}
              | func-ide => inv $ rewrite (aux' (this_iso p), f.func-ide) idp
              | func-* {x y : H} => rewrite (this_inv_ap p x, this_inv_ap p y,
                                             inv f.func-*, inv $ inv_this_ap p (Iso.hinv {this_iso p} x G.* Iso.hinv {this_iso p} y),
                                             inv $ this_inv_ap p x, inv $ this_inv_ap p y ) idp
            }
            | hinv_f => exts \lam e => inv (inv_this_ap p e)
            | f_hinv => exts \lam e => inv (this_inv_ap p e)
          })
      \where {
      {- | some  set theoretic lemmas -}

        \lemma this_inv_ap (p : f.isBijective) (h : H) : h = f (Iso.hinv {this_iso p} h)
          => inv (path \lam i => (Iso.f_hinv {this_iso p} i) h)

        \lemma inv_this_ap (p : f.isBijective) (g : G) : g = Iso.hinv {this_iso p} (f g)
          => inv (path \lam i => (Iso.hinv_f {this_iso p} i) g)

        \func this_iso (p : f.isBijective) => Inj+Surj->SetIso f p.1 p.2

        \lemma aux' {A B : \Set} (f : Iso {SetCat} {A} {B}) {a : A} : a = f.hinv (f.f a)
          => inv (path (\lam i => (f.hinv_f i) a))

        \lemma aux'' {A B : \Set} (f : Iso {SetCat} {A} {B}) {b : B} : b = f.f (f.hinv b)
          => inv (path (\lam i => (f.f_hinv i) b))

        \lemma SetIso->Inj+Surj(f : Iso {SetCat}) : \Sigma (isInj f.f) (isSurj f.f)
          => (Equiv.isInj {SetIso->Equiv f}, Equiv.isSurj {SetIso->Equiv f})

        \lemma Inj+Surj->SetIso {X Y : \Set} (f : X -> Y) (p : isInj f) (q : isSurj f) : Iso {SetCat} f
          => Equiv->SetIso (Equiv.fromInjSurj f p q)

        \lemma Equiv->SetIso {X Y : \Set} {f : X -> Y} (eq : Equiv f) : Iso {SetCat} f \cowith
          | hinv => Equiv.ret {eq}
          | hinv_f => ext (Equiv.ret_f {eq})
          | f_hinv => ext (Equiv.f_ret {eq})

        \lemma SetIso->Equiv {X Y : \Set} {f : X -> Y} (p : Iso {SetCat} f) : Equiv f => \new QEquiv {
          | ret => Iso.hinv {p}
          | ret_f x => inv (aux' p {x})
          | f_sec y => inv (aux'' p {y})
        }
      }

    \lemma Iso<->TrivialKer+Surj {G H : Group} (f : GroupHom G H)
      : Iso {GroupCat} f <-> (\Sigma f.TrivialKernel (isSurj f))
      => <->trans (Iso<->Bijective f) helper
      \where \private \func helper : (\Sigma (isInj f)(isSurj f)) <-> (\Sigma f.TrivialKernel (isSurj f)) =>
        (\lam p => (f.Kernel-injectivity-corollary p.1, p.2),
         \lam p => (f.Kernel-injectivity-test p.1, p.2))
  }

\instance ImageGroup (f : GroupHom) : Group
  | Monoid => ImageMonoid f
  | inverse a => (inverse a.1, TruncP.map a.2 \lam s => (inverse s.1, f.func-inverse *> pmap inverse s.2))
  | inverse-left => ext inverse-left
  | inverse-right => ext inverse-right

\func ImageGroupLeftHom (f : GroupHom) : GroupHom f.Dom (ImageGroup f) \cowith
  | MonoidHom => ImageMonoidLeftHom f

\func ImageGroupRightHom (f : GroupHom) : GroupHom (ImageGroup f) f.Cod \cowith
  | MonoidHom => ImageMonoidRightHom f

\record AddGroupHom \extends AddMonoidHom {
  \override Dom : AddGroup
  \override Cod : AddGroup
  | func-zro => AddGroup.cancel-left (func 0) (inv func-+ *> pmap func zro-right *> inv zro-right)

  \lemma func-negative {x : Dom} : func (negative x) = negative (func x)
    => AddGroup.cancel-left (func x) (inv (negative-right *> inv (pmap func negative-right *> func-zro) *> func-+))

  \lemma func-minus {x y : Dom} : func (x - y) = func x - func y
    => func-+ *> pmap (_ +) func-negative

  \lemma injective (p : \Pi {a : Dom} -> func a = 0 -> a = 0) : isInj func
    => \lam q => AddGroup.fromZero $ p $ func-+ *> pmap (_ +) func-negative *> AddGroup.toZero q
}

\instance AddGroupCat : Cat AddGroup
  | Hom G H => AddGroupHom G H
  | id => id
  | o g f => \new AddGroupHom {
    | func x => g (f x)
    | func-+ => pmap g func-+ *> func-+
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {_} {A} {B} (p1 : AddGroupHom) _ => exts (p1.func-zro, \lam _ _ => p1.func-+, AddGroup.negative-equality A B p1.func-zro p1.func-+))
  \where {
    \func id (G : AddGroup) : AddGroupHom G G \cowith
      | func x => x
      | func-+ => idp

    \func forgetToAddMonoid : Functor AddGroupCat AddMonoidCat \cowith
      | F A => A
      | Func f => f
      | Func-id => idp
      | Func-o => idp

    \func forget : Functor AddGroupCat SetCat \cowith
      | F R => R
      | Func f => func {f}
      | Func-id => idp
      | Func-o => idp
  }

\instance AbGroupCat : Cat AbGroup
  => subCat (\new Embedding {AbGroup} {AddGroup} {
    | f A => A
    | isEmb A B => \new Retraction {
      | sec => AbGroup.equals A B
      | f_sec => idpe
    }
  })
  \where {
    \func forgetToAddGroup : Functor AbGroupCat AddGroupCat \cowith
      | F A => A
      | Func f => f
      | Func-id => idp
      | Func-o => idp

    \func forget : Functor AbGroupCat SetCat \cowith
      | F R => R
      | Func f => func {f}
      | Func-id => idp
      | Func-o => idp
  }

\instance KerAddGroup (f : AddGroupHom) : AddGroup
  | AddMonoid => KerAddMonoid f
  | negative a => (negative a.1, f.func-negative *> pmap negative a.2 *> AddGroup.negative_zro)
  | negative-left => ext negative-left
  | negative-right => ext negative-right

\func KerGroupHom (f : AddGroupHom) : AddGroupHom (KerAddGroup f) f.Dom \cowith
  | AddMonoidHom => KerMonoidHom f

\instance KerAbGroup {A : AbGroup} (f : AddGroupHom A) : AbGroup
  | AddGroup => KerAddGroup f
  | AbMonoid => KerAbMonoid f

\lemma kernel=0<->inj {f : AddGroupHom} : isInj f <-> (\Pi (x : Kernel f) -> x = 0)
  => (\lam fi x => ext $ fi $ x.2 *> inv func-zro,
      \lam c {a} {a'} p => AddGroup.fromZero $ pmap __.1 (c (a - a', func-+ *> pmap (_ +) f.func-negative *> AddGroup.toZero p)))

\instance ImageAddGroup (f : AddGroupHom) : AddGroup
  | AddMonoid => ImageAddMonoid f
  | negative a => (negative a.1, TruncP.map a.2 \lam s => (negative s.1, f.func-negative *> pmap negative s.2))
  | negative-left => ext negative-left
  | negative-right => ext negative-right

\func ImageAddGroupLeftHom (f : AddGroupHom) : AddGroupHom f.Dom (ImageAddGroup f) \cowith
  | AddMonoidHom => ImageAddMonoidLeftHom f

\func ImageAddGroupRightHom (f : AddGroupHom) : AddGroupHom (ImageAddGroup f) f.Cod \cowith
  | AddMonoidHom => ImageAddMonoidRightHom f

\instance ImageAbGroup {A : AddGroup} {B : AbGroup} (f : AddGroupHom A B) : AbGroup
  | AddGroup => ImageAddGroup f
  | AbMonoid => ImageAbMonoid f

\func conjugateHom {E : Group} (g : E) : GroupHom E E \cowith
  | func => conjugate g
  | func-ide => unfold conjugate $ rewrite (E.ide-right, E.inverse-right) idp
  | func-* {_ _ : E} =>
    \have aux {x y z w t e : E} : x * y * z * (w * t * e) = (x * y) * (z * w) * (t * e) => equation
    \in inv $ rewrite (aux, E.inverse-left, E.ide-right) equation

\lemma conjugate-via-id {G : Group} {g : G} : conjugate ide g = g =>
  conjugate ide g ==< idp >==
  ide * g * inverse ide ==< *-assoc >==
  ide * (g * inverse ide) ==< ide-left >==
  g * inverse ide ==< pmap (g *) inverse_ide >==
  g * ide ==< ide-right >==
  g `qed