\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import HLevel
\import Logic
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\open Monoid(LDiv,Inv)
\open Preorder(PreorderC,EquivRel)

\record GCD {M : CMonoid}
            (val1 val2 gcd : M)
            (gcd|val1 : LDiv gcd val1)
            (gcd|val2 : LDiv gcd val2)
            (gcd-univ : \Pi (g : M) -> LDiv g val1 -> LDiv g val2 -> LDiv g gcd)

\class GCDMonoid \extends CancelCMonoid
  | isGCD (x y : E) : TruncP (GCD x y)

-- | GCD monoids with a unique unit. This is useful because the GCD relation on them is functional.
\class UnitlessGCDMonoid \extends GCDMonoid {
  | uniqueUnit (j : Inv) : j.val = ide

  \lemma div-eq {x y : E} (d1 : LDiv x y) (d2 : LDiv y x) : x = y =>
    \let d1=ide : d1.inv = ide => uniqueUnit (Inv.lmake _ (cancel-left y (d2.inv * d1.inv) ide solve))
    \in
      x          ==< inv (ide-right x) >==
      x * ide    ==< pmap (x *) (inv d1=ide) >==
      x * d1.inv ==< d1.inv-right >==
      y          `qed

  \lemma GCD-isProp (x y : E) : isProp (GCD x y) =>
    \lam (g1 g2 : GCD x y) =>
      \let p => div-eq (g2.gcd-univ g1.gcd g1.gcd|val1 g1.gcd|val2)
                       (g1.gcd-univ g2.gcd g2.gcd|val1 g2.gcd|val2)
      \in path (\lam i => \new GCD x y {
        | gcd => p @ i
        | gcd|val1 => pathOver (LDiv.levelProp g2.gcd x (coe (\lam j => LDiv (p @ j) x) g1.gcd|val1 right) g2.gcd|val1) @ i
        | gcd|val2 => pathOver (LDiv.levelProp g2.gcd y (coe (\lam j => LDiv (p @ j) y) g1.gcd|val2 right) g2.gcd|val2) @ i
        | gcd-univ g g|x g|y => pathOver (LDiv.levelProp g g2.gcd (coe (\lam j => LDiv g (p @ j)) (g1.gcd-univ g g|x g|y) right) (g2.gcd-univ g g|x g|y)) @ i
      })

  \lemma gcdC (x y : E) : \level (GCD x y) (GCD-isProp x y)
    => TruncP.remove (GCD-isProp x y) (isGCD x y)

  \func gcd (x y : E) => GCD.gcd {gcdC x y}

  \lemma gcd_~ {x y : E} (g : GCD x y) : g.gcd = gcd x y
    => pmap (\lam (g : GCD x y) => g.gcd) (GCD-isProp x y g (gcdC x y))

  \lemma gcd_*-left (c a b : E) : c * gcd a b = gcd (c * a) (c * b) =>
    \let | d : GCD a b => gcdC a b
         | e : GCD (c * a) (c * b) => gcdC (c * a) (c * b)
         | cd|e : LDiv (c * d.gcd) e.gcd => e.gcd-univ (c * d.gcd) (LDiv.product-left c d.gcd a d.gcd|val1)
                                                       (LDiv.product-left c d.gcd b d.gcd|val2)
         | x => cd|e.inv
         | c[xd]=e =>
             c * (x * d.gcd) ==< pmap (c *) (*-comm x d.gcd) >==
             c * (d.gcd * x) ==< inv (*-assoc c d.gcd x) >==
             (c * d.gcd) * x ==< cd|e.inv-right >==
             e.gcd           `qed
         | xd|d : LDiv (x * d.gcd) d.gcd =>
             d.gcd-univ (x * d.gcd)
                        (LDiv.cancel-left c (x * d.gcd) a (rewrite c[xd]=e e.gcd|val1))
                        (LDiv.cancel-left c (x * d.gcd) b (rewrite c[xd]=e e.gcd|val2))
    \in pmap (c *) (div-eq (\new LDiv d.gcd (x * d.gcd) x (*-comm d.gcd x)) xd|d) *> c[xd]=e

  \lemma gcd_*-right (a b c : E) : gcd a b * c = gcd (a * c) (b * c)
    => *-comm (gcd a b) c *> gcd_*-left c a b *> pmap2 gcd (*-comm c a) (*-comm c b)

  -- | Every unit-less GCD-monoid is a semilattice.
  \func DivLattice : MeetSemilattice E \cowith
    | <= x y => LDiv y x
    | <=-reflexive x => \new LDiv x x ide (ide-right x)
    | <=-transitive x y z y|x z|y => LDiv.trans z y x z|y y|x
    | <=-antisymmetric x y y|x x|y => div-eq x|y y|x
    | meet => gcd
    | meet-left x y => GCD.gcd|val1 {gcdC x y}
    | meet-right x y => GCD.gcd|val2 {gcdC x y}
    | meet-univ x y => GCD.gcd-univ

  \lemma gcd_*-comm (a b c : E) : gcd a (b * c) = gcd a (gcd a b * c) =>
    gcd a (b * c)               ==< pmap (`gcd (b * c)) (inv (meet_<= {DivLattice} (a * c) a (\new LDiv a (a * c) c idp))) >==
    gcd (gcd (a * c) a) (b * c) ==< pmap (\lam x => gcd x (b * c)) (meet-comm {DivLattice} _ _) >==
    gcd (gcd a (a * c)) (b * c) ==< meet-assoc {DivLattice} a (a * c) (b * c) >==
    gcd a (gcd (a * c) (b * c)) ==< pmap (gcd a) (inv (gcd_*-right a b c)) >==
    gcd a (gcd a b * c)         `qed

  \lemma gcd_*_div (a b c : E) (a|bc : LDiv a (b * c)) : LDiv a (gcd a b * c)
    => rewriteI {1} (inv (gcd_*-comm a b c) *> meet-comm {DivLattice} _ _ *> meet_<= {DivLattice} (b * c) a a|bc)
                    (GCD.gcd|val2 {gcdC a (gcd a b * c)})
} \where \open MeetSemilattice

-- | The quotient of a monoid by the equivalence relation ``x ~ y`` iff ``x | y`` and ``y | x``.
\func DivQuotient (M : CMonoid) => PreorderC {DivPreoder M}
  \where {
    {- | The preoreder on a monoid in which ``x <= y`` iff ``y | x``.
     -   We define {DivQuotient} as the poset completion of this preorder.
     -}
    \func DivPreoder (M : CMonoid) : Preorder M \cowith
      | <= x y => TruncP (LDiv y x)
      | <=-reflexive x => inP (\new LDiv x x ide (ide-right x))
      | <=-transitive x y z [y|x] [z|y] => \case [y|x], [z|y] \with {
        | inP (y|x : LDiv y x), inP (z|y : LDiv z y) => inP (LDiv.trans z y x z|y y|x)
      }

    \func \infix 4 ~ {M : CMonoid} => Equivalence.~ {EquivRel {DivPreoder M}}

    \lemma make~ {M : CMonoid} (x y : M) (p : in~ x = {DivQuotient M} in~ y) : x ~ y =>
      Quotient.equalityEquiv (Preorder.EquivRel {DivPreoder M}) x y p

    -- | The quotient monoid is indeed a monoid.
    \instance DivQuotientMonoid (M : CMonoid) : CMonoid (DivQuotient M)
      | ide => in~ ide
      | * => *'
      | ide-left [x] => \case \elim [x] \with {
        | in~ x => pmap in~ (ide-left x)
      }
      | *-assoc [x] [y] [z] => \case \elim [x], \elim [y], \elim [z] \with {
        | in~ x, in~ y, in~ z => pmap in~ (*-assoc x y z)
      }
      | *-comm [x] [y] => \case \elim [x], \elim [y] \with {
        | in~ x, in~ y => pmap in~ (*-comm x y)
      }
    \where {
      \func \infixl 7 *' {M : CMonoid} (x y : DivQuotient M) : DivQuotient M
        | in~ x, in~ y => in~ (x * y)
        | in~ x, ~-equiv y y' y~y' i => ~-equiv (x * y) (x * y') (\case y~y' \with {
          | (inP y'|y, inP y|y') => (inP (LDiv.product-left x y' y y'|y), inP (LDiv.product-left x y y' y|y'))
        }) i
        | ~-equiv x x' x~x' i, in~ y => ~-equiv (x * y) (x' * y) (\case x~x' \with {
          | (inP x'|x, inP x|x') => (inP (LDiv.product-right x' x y x'|x), inP (LDiv.product-right x x' y x|x'))
        }) i
    }

    -- | If the original monoid is cancellative, then so is the quotient monoid.
    \instance DivQuotientCancelMonoid (M : CancelCMonoid) : CancelCMonoid
      | CMonoid => DivQuotientMonoid M
      | cancel-left [x] [y] [z] [x*y=x*z] => \case \elim [x], \elim [y], \elim [z], [x*y=x*z] \with {
        | in~ x, in~ y, in~ z, x*y=x*z => path (~-equiv y z (
          \case make~ (x * y) (x * z) x*y=x*z \return y ~ z \with {
            | (inP x*z|x*y, inP x*y|x*z) => (inP (LDiv.cancel-left x z y x*z|x*y), inP (LDiv.cancel-left x y z x*y|x*z))
          }
        ))
      }

    \lemma inv~ide {M : CMonoid} (i : Inv {M}) : i.val ~ ide =>
      (inP (\new LDiv ide i.val i.val (ide-left i.val)), inP (\new LDiv i.val ide i.inv i.inv-right))

    \func div-to~ {M : CMonoid} {x y : M} (x|y : LDiv x y) : LDiv (in~ x) (in~ y) \cowith
      | inv => in~ x|y.inv
      | inv-right => pmap in~ x|y.inv-right

    \lemma div-from~ {M : CancelCMonoid} {x y : M} (d : LDiv (in~ x) (in~ y)) : LDiv x y =>
      \case d.inv \as i, d.inv-right : in~ x * i = in~ y \return LDiv x y \with {
        | in~ i, ~x*i=y => \case (make~ (x * i) y ~x*i=y).2 \return LDiv x y \with {
          | inP (x*i|y : LDiv (x * i) y) => \new LDiv x y (i * x*i|y.inv) (inv (*-assoc _ _ _) *> x*i|y.inv-right)
        }
      }

    -- | If the original monoid is a GCD-monoid, then the quotient monoid is a unit-less GCD-monoid.
    \instance DivQuotientGCDMonoid (M : GCDMonoid) : UnitlessGCDMonoid
      | CancelCMonoid => DivQuotientCancelMonoid M
      | isGCD [x] [y] => \case \elim [x], \elim [y] \with {
        | in~ x, in~ y => TruncP.map (isGCD x y) (\lam (g : GCD x y) => \new GCD (in~ x) (in~ y) (in~ g.gcd) {
          | gcd|val1 => div-to~ g.gcd|val1
          | gcd|val2 => div-to~ g.gcd|val2
          | gcd-univ [g'] [g']|x [g']|y =>
            \case \elim [g'], [g']|x, [g']|y \return \level (LDiv [g'] (in~ g.gcd)) (LDiv.levelProp [g'] (in~ g.gcd)) \with {
              | in~ g' \as [g'], (in~ x', ~x'*g'=x), (in~ y', ~y'*g'=y) =>
                  div-to~ (g.gcd-univ g' (div-from~ (\new LDiv { | inv => in~ x' | inv-right => ~x'*g'=x }))
                                         (div-from~ (\new LDiv { | inv => in~ y' | inv-right => ~y'*g'=y })))
            }
        })
      }
      | uniqueUnit (j : Inv) => \case j.val \as [x], j.inv \as [y], j.inv-right : [x] * [y] = in~ ide \return [x] = in~ ide \with {
        | in~ x, in~ y, p => path (~-equiv x ide (inv~ide (\let d : LDiv x ide => div-from~ (\new LDiv { | inv => in~ y | inv-right => p }) \in Inv.rmake d.inv d.inv-right)))
      }

    \func gcd-to~ {M : CancelCMonoid} {x y z : M} (g : GCD x y z) : GCD (in~ x) (in~ y) (in~ z) \cowith
      | gcd|val1 => DivQuotient.div-to~ g.gcd|val1
      | gcd|val2 => DivQuotient.div-to~ g.gcd|val2
      | gcd-univ [g] [g]|[x] [g]|[y] =>
          \case \elim [g], [g]|[x], [g]|[y] \return \level (LDiv [g] (in~ z)) (LDiv.levelProp [g] (in~ z)) \with {
            | in~ g', ~g'|x, ~g'|y => DivQuotient.div-to~ (g.gcd-univ g' (DivQuotient.div-from~ ~g'|x) (DivQuotient.div-from~ ~g'|y))
          }
  }

\lemma gcd_*_div {M : GCDMonoid} (a b c : M) (a|bc : LDiv a (b * c)) (a_b : GCD a b ide) : LDiv a c
  => div-from~ (later rewriteI (pmap (`* in~ c) (inv (gcd_~ (gcd-to~ a_b))) *> ide-left (in~ c))
                               (gcd_*_div (in~ a) (in~ b) (in~ c) (div-to~ a|bc)))
  \where {
    \open UnitlessGCDMonoid
    \open DivQuotient
  }
