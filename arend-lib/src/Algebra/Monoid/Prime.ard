\import Algebra.Monoid
\import Algebra.Monoid.GCD
\import Algebra.Pointed
\import Data.Or
\import Logic
\import Paths
\open CMonoid(Inv,Div)

\record Prime {M : CMonoid} (e : M) (notInv : Not (Inv e))
  | isPrime (x y : M) : Div e (x * y) -> Div e x || Div e y

\record Irr {M : CMonoid} (e : M) (notInv : Not (Inv e)) {
  | isIrr (x y : M) : e = x * y -> Inv x || Inv y

  \func decide (x y : M) (e=x*y : e = x * y) : Inv x `Or` Inv y =>
    ||.rec (Or.isProp (\lam (i : Inv x) (j : Inv y) => notInv (transport (\lam x => Inv x) (inv e=x*y) (Inv.product i j)))) inl inr (isIrr x y e=x*y)
}

\lemma Prime-isIrr {M : CancelCMonoid} (p : Prime {M}) : Irr p.e p.notInv \cowith
  | isIrr x y p=x*y => \case p.isPrime x y (\new Div p.e (x * y) ide (ide-left p.e *> p=x*y)) \with {
    | byLeft p|x =>
      \let j => Div.inv {p|x}
      \in byRight (\new Inv y j (M.cancel-right (j * y) ide x (
        (j * y) * x ==< *-assoc j y x >==
        j * (y * x) ==< pmap (j *) (*-comm y x) >==
        j * (x * y) ==< pmap (j *) (inv p=x*y) >==
        j * p.e     ==< Div.inv-left {p|x} >==
        x           ==< inv (ide-left x) >==
        ide * x     `qed
      )))
    | byRight p|y =>
      \let j => Div.inv {p|y}
      \in byLeft (\new Inv x j (M.cancel-right (j * x) ide y (
        (j * x) * y ==< *-assoc j x y >==
        j * (x * y) ==< pmap (j *) (inv p=x*y) >==
        j * p.e     ==< Div.inv-left {p|y} >==
        y           ==< inv (ide-left y) >==
        ide * y     `qed
      )))
  }

\func Coprime {M : CMonoid} (x y : M) => \Pi (z : M) -> Div z x -> Div z y -> Inv z
  \where {
    \func =>gcd {M : CMonoid} (x y : M) (c : Coprime x y) : GCD x y ide \cowith
      | gcd|val1 => \new Div ide x x (ide-right x)
      | gcd|val2 => \new Div ide y y (ide-right y)
      | gcd-univ g g|x g|y => \let i : Inv g => c g g|x g|y
                              \in \new Div g ide i.inv i.inv-left

    \func <=gcd {M : CMonoid} (x y : M) (g : GCD x y ide) : Coprime x y =>
      \lam z z|x z|y => \new Inv { | Div => g.gcd-univ z z|x z|y }
  }

\lemma irr-isPrime {M : GCDMonoid} (p : Irr {M}) : Prime p.e p.notInv \cowith
  | isPrime x y p|x*y => \case irr-cmp p x \with {
    | byLeft p|x => byLeft p|x
    | byRight p_x => byRight (gcd_*_div p.e x y p|x*y (Coprime.=>gcd p.e x p_x))
  }
  \where {
    \open DivQuotient

    \lemma irr-cmp {M : GCDMonoid} (p : Irr {M}) (a : M) : Div p.e a || Coprime p.e a => \case isGCD p.e a \with {
      | inP gc' =>
        \let | gc : GCD p.e a => gc'
             | g => gc.gcd
             | g|p : Div g p.e => gc.gcd|val1
             | g|a : Div g a => gc.gcd|val2
             | x => g|p.inv
        \in \case p.isIrr x g (inv g|p.inv-left) \with {
          | byLeft xi' => \let xi : Inv x => xi' \in byLeft (\new Div p.e a (g|a.inv * xi.inv) (
            (g|a.inv * xi.inv) * p.e     ==< *-assoc _ _ _ >==
            g|a.inv * (xi.inv * p.e)     ==< pmap (\lam t => g|a.inv * (xi.inv * t)) (inv g|p.inv-left) >==
            g|a.inv * (xi.inv * (x * g)) ==< pmap (g|a.inv *) (inv (*-assoc _ _ _)) >==
            g|a.inv * ((xi.inv * x) * g) ==< pmap (\lam t => g|a.inv * (t * g)) xi.inv-left >==
            g|a.inv * (ide * g)          ==< pmap (g|a.inv *) (ide-left g) >==
            g|a.inv * g                  ==< g|a.inv-left >==
            a                            `qed
          ))
          | byRight gi' => byRight (\lam z z|p z|a =>
            \let | gi : Inv g => gi'
                 | z|g : Div z g => gc.gcd-univ z z|p z|a
            \in \new Inv z (gi.inv * z|g.inv) (
              (gi.inv * z|g.inv) * z ==< *-assoc _ _ _ >==
              gi.inv * (z|g.inv * z) ==< pmap (gi.inv *) z|g.inv-left >==
              gi.inv * g             ==< gi.inv-left >==
              ide                    `qed
            ))
        }
    }
  }
