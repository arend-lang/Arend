\import Algebra.Monoid
\import Algebra.Pointed
\import Arith.Nat
\import Data.List
\import Function.Meta
\import Paths
\import Paths.Meta

\data MonoidTerm (V : \Type)
  | var V
  | :ide
  | \infixl 7 :* (t s : MonoidTerm V)

\func normalize {V : \Type} (t : MonoidTerm V) => aux t nil
  \where
    \func aux {V : \Type} (t : MonoidTerm V) (acc : List V) : List V \elim t
      | var v => v :: acc
      | :ide => acc
      | :* t s => aux t (aux s acc)

\class Data \noclassifying {V : \Type} {M : Monoid} (f : V -> M) {
  \func interpret (t : MonoidTerm V) : M \elim t
    | var x => f x
    | :ide => ide
    | :* t s => interpret t * interpret s

  \func interpretNF (l : List V) : M \elim l
    | nil => ide
    | :: x nil => f x
    | :: x l => f x * interpretNF l
    \where
      \lemma cons (x : V) (l : List V) : interpretNF (x :: l) = f x * interpretNF l \elim l
        | nil => inv (ide-right (f x))
        | :: a l => idp

  \lemma normalize-consistent (t : MonoidTerm V) : interpret t = interpretNF (normalize t)
    => inv (ide-right _) *> aux t nil
    \where
      \lemma aux (t : MonoidTerm V) (acc : List V) : interpret t * interpretNF acc = interpretNF (normalize.aux t acc) \elim t
        | var x => inv (interpretNF.cons x acc)
        | :ide => ide-left _
        | :* t s => *-assoc _ _ _ *> pmap (interpret t *) (aux s acc) *> aux t (normalize.aux s acc)

  \lemma terms-equality (t s : MonoidTerm V) (p : interpretNF (normalize t) = interpretNF (normalize s)) : interpret t = interpret s
    => normalize-consistent t *> p *> inv (normalize-consistent s)

  \lemma terms-equality-conv (t s : MonoidTerm V) (p : interpret t = interpret s) : interpretNF (normalize t) = interpretNF (normalize s)
    => inv (normalize-consistent t) *> p *> normalize-consistent s

  \lemma interpretAppend (l1 l2 : List V) : interpretNF (l1 ++ l2) = interpretNF l1 * interpretNF l2 \elim l1
    | nil => inv (ide-left _)
    | :: a l1 => repeat {2} (rewrite interpretNF.cons) $ rewrite interpretAppend (inv (*-assoc _ _ _))

  \lemma replace-consistent (l : List V) (i s : Nat) (r : List V) (p : interpretNF (slice l i s) = interpretNF r)
    : interpretNF l = interpretNF(replace l i s r)
    => rewriteI {1} (slice.appendLem l i s) $
       repeat {4} (rewrite interpretAppend) $
       rewriteI p idp
}
