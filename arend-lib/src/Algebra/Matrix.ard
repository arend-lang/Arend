\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Fin
\import Arith.Int
\import Arith.Nat
\import Data.Array
\import Data.Fin (fsuc, fsuc/=)
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\open FinLinearOrder

\type Matrix (R : \Type) (n m : Nat) => Array (Array R m) n

\func mkMatrix {R : \Type} {n m : Nat} (f : Fin n -> Fin m -> R) : Matrix R n m
  => \new Array (Array R m) n $ \lam i => \new Array R m (f i)

\func matrixFromArrays {R : \Type} {n m : Nat} (M : Array (Array R m) n) : Matrix R n m => M

\func matrixExt {R : \Type} {n m : Nat} {M N : Matrix R n m} (p : \Pi (i : Fin n) (j : Fin m) -> M i j = N i j) : M = N
  => path (\lam i => mkMatrix (\lam j k => p j k i))

\instance MatrixModule (R : Ring) (n m : Nat) : LModule' R \cowith
  | E => Matrix R n m
  | zro => mkMatrix $ \lam _ _ => zro
  | + => MatrixRing.add
  | zro-left => matrixExt $ \lam i j => zro-left
  | +-assoc => matrixExt $ \lam i j => +-assoc
  | +-comm => matrixExt $ \lam i j => +-comm
  | negative M => mkMatrix $ \lam i j => negative (M i j)
  | negative-left => matrixExt $ \lam i j => negative-left
  | *c a M => mkMatrix $ \lam i j => a * M i j
  | *c-assoc => matrixExt $ \lam i j => *-assoc
  | *c-ldistr => matrixExt $ \lam i j => ldistr
  | *c-rdistr => matrixExt $ \lam i j => rdistr
  | ide_*c => matrixExt $ \lam i j => ide-left

\instance MatrixRing (R : Ring) (n : Nat) : Ring (Matrix R n n)
  | AbGroup => MatrixModule R n n
  | ide : Matrix R n n => mkMatrix $ \lam i j => \case decideEq i j \with {
    | yes _ => R.ide
    | no _ => zro
  }
  | * => product
  | ide-left => product_ide-left
  | ide-right => product_ide-right
  | *-assoc => product-assoc
  | ldistr => matrix_ldistr
  | rdistr => matrix_rdistr
  \where {
    \open AddMonoid

    \func add {R : AddMonoid} {n m : Nat} (M N : Matrix R n m) : Matrix R n m
      => mkMatrix $ \lam i j => M i j + N i j

    \func product {R : Ring} {n m k : Nat} (M : Matrix R n m) (N : Matrix R m k) : Matrix R n k
      => mkMatrix $ \lam i k => BigSum $ \new Array R m $ \lam j => M i j * N j k

    \lemma product_ide-left {R : Ring} {n m : Nat} {M : Matrix R n m} : product ide M = M
      => matrixExt $ \lam i j => BigSum-unique i (\lam k i/=k => later $ rewrite (decideEq/=_reduce i/=k) R.zro_*-left) *> rewrite (decideEq=_reduce idp) ide-left

    \lemma product_ide-right {R : Ring} {n m : Nat} {M : Matrix R n m} : product M ide = M
      => matrixExt $ \lam i j => BigSum-unique j (\lam k j/=k => later $ rewrite (decideEq/=_reduce (\lam t => j/=k (inv t))) R.zro_*-right) *> rewrite (decideEq=_reduce idp) ide-right

    \lemma product-assoc {R : Ring} {n m k l : Nat} {M : Matrix R n m} {N : Matrix R m k} {L : Matrix R k l} : product (product M N) L = product M (product N L)
      => matrixExt $ \lam j1 j2 => path (\lam i => BigSum (\new Array R k (\lam j3 => R.BigSum-rdistr {\new Array R m (\lam j4 => M j1 j4 * N j4 j3)} {L j3 j2} i))) *>
            R.BigSum-transpose _ *> pmap BigSum (arrayExt $ \lam j3 => pmap BigSum $ arrayExt $ \lam j4 => *-assoc) *>
            inv (path (\lam i => BigSum (\new Array R m (\lam j3 => R.BigSum-ldistr {M j1 j3} {\new Array R k (\lam j4 => N j3 j4 * L j4 j2)} i))))

    \lemma matrix_ldistr {R : Ring} {n m k : Nat} {L : Matrix R n m} {M N : Matrix R m k} : product L (add M N) = add (product L M) (product L N)
      => matrixExt $ \lam i j => pmap BigSum (arrayExt $ \lam k => ldistr) *> R.BigSum_+

    \lemma matrix_rdistr {R : Ring} {n m k : Nat} {M N : Matrix R n m} {L : Matrix R m k} : product (add M N) L = add (product M L) (product N L)
      => matrixExt $ \lam i j => pmap BigSum (arrayExt $ \lam k => rdistr) *> R.BigSum_+

    \lemma ide_generates {R : Ring} {n : Nat} : LModule.isGenerated {ArrayLModule n (RingLModule R)} ide
      => \lam l => inP (l, arrayExt $ \lam j => inv $ ArrayLModule.BigSum-index *> R.BigSum-unique j (\lam i j/=i => later $ rewrite (decideEq/=_reduce $ \lam p => j/=i (inv p)) zro_*-right) *> rewrite (decideEq=_reduce idp) ide-right)

    -- | A recursive definition of the identity matrix is sometimes more convenient.
    \func ide' {R : Ring} {n : Nat} : Array (Array R n) n \elim n
      | 0 => nil
      | suc n => (1 :: replicate n zro) :: map (\lam l => R.zro :: l) ide'

    \lemma ide=ide' {R : Ring} {n : Nat} : ide {R} {n} = ide' \elim n
      | 0 => idp
      | suc n => matrixExt $ \case \elim __, \elim __ \with {
        | 0, 0 => idp
        | 0, suc j => idp
        | suc i, 0 => idp
        | suc i, suc j => (later $ cases (decideEq i j) \with {
          | yes e => rewrite (decideEq=_reduce $ pmap fsuc e) idp
          | no q => rewrite (decideEq/=_reduce $ fsuc/= q) idp
        }) *> pmap (__ i j) ide=ide'
      }
  }

\func determinant {R : CRing} {n : Nat} (M : Matrix R n n) : R \elim n
  | 0 => 1
  | suc n => determinantN {R} {suc n} 0 M
  \where {
    \func minor {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m
      => map (skip __ j0) (skip M i0)

    \func minor' {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m
      => skip (map (skip __ j0) M) i0

    \func minor=minor' {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : minor M i0 j0 = minor' M i0 j0
      => matrixExt (aux M i0 j0)
      \where {
        \func aux {R : \Type} {n m : Nat} (M : Array (Array R (suc m)) (suc n)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) (i : Fin n) (j : Fin m)
          : skip (skip M i0 i) j0 j = skip {Array R m} (map (skip __ j0) M) i0 i j \elim n, M, i0, i
          | suc n, l :: M, 0, i => idp
          | suc n, l :: M, suc i0, 0 => idp
          | suc n, l :: M, suc i0, suc i => aux M i0 j0 i j
      }

    \lemma multilinear {R : CRing} {n : Nat} : isMultiLinear {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinant M) \elim n
      | 0 => ()
      | suc n => determinantN.multilinear {R} {suc n} 0

    \lemma alternating {R : CRing} {n : Nat} : isAlternating {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinant M) \elim n
      | 0 => ((), \lam _ (t,_,_,_) => \case t)
      | suc n => determinantN.alternating {R} {suc n} 0
  }

\func determinantN {R : CRing} {n : Nat} (k : Fin n) (M : Matrix R n n) : R \elim n
  | 0 => 1
  | suc n => R.BigSum $ \lam i => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)
  \where {
    \open determinant
    \open skip
    \open ArrayLModule

    \lemma minor_insert {R : CRing} {n m : Nat} {i : Fin (suc n)} {x : Array R (suc m)} {l : Array (Array R (suc m)) n} {j : Fin (suc m)}
      : minor (insert x l i) i j = \new Array (Array R m) n (\lam i => skip (l i) j)
      => path (\lam i' => map (skip __ j) (skip_insert_= i'))

    \lemma aux/= {R : CRing} {n m : Nat} {j i : Fin (suc n)} (p : j /= i) {k : Fin (suc m)} {x : Array R (suc m)} {M : Array (Array R (suc m)) n}
      : insert {Array R (suc m)} x M j i k = M (newIndex (\lam q => p (inv q))) k \elim n, j, i, M
      | _, 0, 0, _ => absurd (p idp)
      | suc n, 0, suc i, y :: M => idp
      | suc n, suc j, 0, y :: M => idp
      | suc n, suc j, suc i, y :: M => aux/= (\lam q => p (pmap fsuc q))

    \func minor_replace {R : CRing} {n : Nat} {i k : Fin (suc n)} {M : Array (Array R (suc n)) (suc n)} {j : Fin (suc n)} {x : Array R (suc n)} (p : j /= i)
      : minor (replace M j x) i k = replace (minor M i k) (newIndex p) (skip x k)
      => path (\lam i => map (skip __ k) (skip_replace_/= p i)) *> pmap matrixFromArrays (map_replace (skip __ k))

    \lemma multilinear {R : CRing} {n : Nat} (k : Fin n) : isMultiLinear {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinantN k M) \elim n
      | 0 => ()
      | suc n => isMultilinear_BigSum {R} {suc n} {ArrayLModule (suc n) (RingLModule R)} (\lam i M => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)) $ \lam i M j => \case decideEq j i \with {
        | yes e => \new LinearMap {
          | func-+ {a} {b} => rewrite e $ *-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)}) *> rdistr *> pmap2 (+)
                                (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
                                (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
        | func-*c {r} {a} => rewrite e $ *-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)}) *> *-assoc *> pmap (r *) (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
        }
        | no q => \new LinearMap {
          | func-+ => rewrite (aux/= q, aux/= q, aux/= q) $ pmap (_ *) (inv (path (\lam i' => determinant (minor (replace_insert {_} {M} {j} {replicate (suc n) R.zro} i') i k))) *> pmap determinant (minor_replace q) *> rewrite skip_+ (func-+ {isMultiLinear.toReplace {R} {_} {_} {n} determinant.multilinear _ _} *> pmap2 (determinant __ + determinant __) (inv (minor_replace q) *> path (\lam i' => minor (replace_insert i') i k)) (inv (minor_replace q) *> path (\lam i' => minor (replace_insert i') i k)))) *> ldistr
          | func-*c {r} {x} => rewrite (aux/= q, aux/= q) $ pmap (_ * _ * __) (inv (path (\lam i' => determinant (minor (replace_insert {_} {M} {j} {replicate (suc n) R.zro} i') i k))) *> pmap determinant (minor_replace q) *> rewrite skip_*c (func-*c {isMultiLinear.toReplace {R} {_} {_} {n} determinant.multilinear _ _} *> pmap (r * determinant __) (inv (minor_replace q))) *> path (\lam i' => r * determinant (minor (replace_insert i') i k)) *> *-comm) *> inv *-assoc *> *-comm
        }
      }

    \lemma alternating {R : CRing} {n : Nat} (k : Fin n) : isAlternating {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinantN k M) \elim n
      | 0 => ((), \lam _ => \case __.1)
      | suc n => (multilinear k, aux k)
      \where {
        \open NatSemiring(<,suc<suc)

        \func permutation1 {R : \Type} {n : Nat} (j : Fin (suc n)) (l : Array R (suc n)) : Perm l (l j :: skip l j) \elim n, j, l
          | 0, 0, l => Perm.perm-refl
          | suc n, 0, l => Perm.perm-refl
          | suc n, suc j, a :: l => perm-trans (perm-:: idp (permutation1 j l)) (perm-swap idp idp idp)

        \func permutation {R : \Type} {n : Nat} {i j : Fin (suc n)} (p : i < j) (l : Array R (suc n)) (q : l i = l j) : Perm (skip l i) (skip l j) \elim n, i, j, p, l, q
          | 0, 0, 0, (), _, _
          | suc n, 0, suc j, _, a :: l, idp => permutation1 j l
          | suc n, suc i, suc j, suc<suc p, a :: l, q => perm-:: idp (permutation p l q)

        \lemma permutation1_inversions {R : \Type} {n : Nat} {j : Fin (suc n)} {l : Array R (suc n)} : Perm.inversions (permutation1 j l) = j \elim n, j, l
          | 0, 0, l => idp
          | suc n, 0, a :: l => Perm.inversions_perm-:: *> Perm.inversions_perm-refl
          | suc n, suc j, a :: l => pmap suc permutation1_inversions

        \lemma permutation_inversions {R : \Type} {n : Nat} {i j : Fin (suc n)} {p : i < j} {l : Array R (suc n)} {q : l i = l j} : Perm.inversions (permutation p l q) = j -' suc i \elim n, i, j, p, l, q
          | 0, 0, 0, (), _, _
          | suc n, 0, suc j, _, a :: l, idp => permutation1_inversions *> inv -'0
          | suc n, suc i, suc j, suc<suc p, a :: l, q => Perm.inversions_perm-:: *> permutation_inversions

        \lemma aux {R : CRing} {n : Nat} (k : Fin n) (M : Array (Array R n) n) (t : \Sigma (i j : Fin n) (i < j) (M i = M j)) : determinantN k M = 0 \elim n
          | 0 => \case t.1
          | suc n => R.BigSum-unique2 {\lam i => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)} t.3 (\lam i i/=t1 i/=t2 => pmap (_ *) (determinant.alternating.2 (minor M i k) (newIndex $ \lam p => i/=t1 (inv p), newIndex $ \lam p => i/=t2 (inv p), newIndex_< t.3, pmap (skip __ k) $ skip-index *> t.4 *> inv skip-index)) *> zro_*-right) *>
                      rewrite (pmap {Array R _} (__ k) t.4) (pmap2 (+) *-assoc *-assoc *> inv ldistr *> pmap (_ *) (later $ rewrite (minor=minor', minor=minor', isAlternating.alternating_perm {R} determinant.alternating $ permutation t.3 (map (skip __ k) M) $ pmap (skip __ k) t.4) $ rewriteI *-assoc $ inv rdistr *> pmap (`* _) (unfold Perm.sign $ rewrite (permutation_inversions, inv R.pow_+, inv R.pow_-1_+2) $
                        \have s : t.1 Nat.+ k Nat.+ (t.2 -' suc t.1) Nat.+ 2 = suc (t.2 Nat.+ k) => pmap suc $ unpos $ pmap (pos (suc (t.1 Nat.+ k)) +) (-'=- $ suc_<_<= t.3) *> linarith
                        \in pmap (R.pow -1 __ + _) s *> pmap (`+ _) R.negative_ide-right *> negative-left) *> zro_*-left) *> zro_*-right)
      }

    \lemma determinantN_ide {R : CRing} {n : Nat} (k : Fin n) : determinantN k (MatrixRing.ide {R} {n}) = 1 \elim n
      | 0 => idp
      | suc n => R.BigSum-unique {\lam i => MatrixRing.ide i k * R.pow -1 (i Nat.+ k) * determinant (minor MatrixRing.ide i k)} k (\lam j k/=j => rewrite (decideEq/=_reduce $ \lam p => k/=j $ inv p) simplify) *>
                  rewrite (decideEq=_reduce idp, ide-left) (pmap2 (*) R.pow_-1_even (pmap determinant (pmap (minor __ k k) MatrixRing.ide=ide' *> ide'_minor k *> inv MatrixRing.ide=ide') *> determinant_ide {R} {n}) *> ide-left)
      \where {
        \func double-skip {R : \Set} {n m : Nat} {M : Array (Array R n) (suc m)} {k : Fin (suc m)} {i : Fin m} {j : Fin n}
          : skip {Array R _} M k i j = skip (map {Array R n} (__ j) M) k i \elim m, M, k, i
          | suc m, l :: M, 0, i => idp
          | suc m, l :: M, suc k, 0 => idp
          | suc m, l :: M, suc k, suc i => double-skip

        \lemma ide'_minor {R : Ring} {n : Nat} (k : Fin (suc n)) : determinant.minor (MatrixRing.ide' {R}) k k = MatrixRing.ide' \elim n, k
          | 0, k => idp
          | suc n, 0 => idp
          | suc n, suc k => pmap matrixFromArrays $ pmap2 (::) (pmap (\lam l => R.ide :: l) (skip_replicate R.zro)) $ arrayExt $ \lam i => pmap2 (::) (double-skip *> pmap {Array R _} (__ i) (skip_replicate R.zro {k})) $ cong (arrayExt $ \lam j => double-skip *> inv double-skip) *> pmap {Matrix R n n} (__ i) (ide'_minor k)
      }

    \lemma =determinant {R : CRing} {n : Nat} {k : Fin n} {M : Matrix R n n} : determinantN k M = determinant M
      => alternating-unique {R} (alternating k) determinant.alternating MatrixRing.ide_generates (determinantN_ide k *> inv determinant_ide) M
  }

\lemma determinant_ide {R : CRing} {n : Nat} : determinant (MatrixRing.ide {R} {n}) = 1 \elim n
  | 0 => idp
  | suc n => determinantN.determinantN_ide {R} {suc n} 0
  \where {
    \lemma ide_minor {R : Ring} {n : Nat} : determinant.minor (MatrixRing.ide {R} {suc n}) 0 0 = 1 \elim n
      | 0 => idp
      | suc n => matrixExt $ \lam i j => mcases {2} \with {
        | yes p => rewrite (decideEq=_reduce $ pmap fsuc p) idp
        | no q => rewrite (decideEq/=_reduce $ fsuc/= q) idp
      }
  }

\lemma determinant_* {R : CRing} {n : Nat} (M N : Matrix R n n) : determinant (M * N) = determinant M * determinant N
  => alternating-unique {R}
      (isAlternating_linear-left {R} (\new LinearMap {
        | func (l : Array R n) => mkArray $ \lam k => R.BigSum $ \lam j => l j * N j k
        | func-+ => arrayExt $ \lam k => pmap R.BigSum (arrayExt $ \lam j => rdistr) *> R.BigSum_+
        | func-*c => arrayExt $ \lam k => pmap R.BigSum (arrayExt $ \lam j => *-assoc) *> inv R.BigSum-ldistr
      }) determinant.alternating)
      (isAlternating_linear-right {R} determinant.alternating RingLModule.*_hom-right)
      MatrixRing.ide_generates
      (pmap determinant ide-left *> inv (pmap (`* _) determinant_ide *> ide-left))
      M

\func adjugate {R : CRing} {n : Nat} (M : Matrix R n n) : Matrix R n n \elim n
  | 0 => M
  | suc n => mkMatrix $ \lam i j => Monoid.pow -1 (j + i) * determinant (determinant.minor M j i)

\lemma determinant_adjugate_= {R : CRing} {n : Nat} {M : Matrix R (suc n) (suc n)} (k : Fin (suc n)) : determinant M = R.BigSum (\lam j => M j k * adjugate M k j)
  => inv ({?} *> determinantN.=determinant {R} {suc n} {k} {M})

\lemma adjugate-left {R : CRing} {n : Nat} {M : Matrix R n n} : adjugate M * M = determinant M *c ide
 => matrixExt $ \lam i k => mcases \with {
      | yes p => rewrite p {?} *> inv ide-right
      | no q => {?} *> inv zro_*-right
    }