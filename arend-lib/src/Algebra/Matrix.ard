\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Fin
\import Arith.Int
\import Arith.Nat
\import Data.Array
\import Data.Fin (fsuc)
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set
\open FinLinearOrder

\type Matrix (R : \Type) (n m : Nat) => Array (Array R m) n

\func mkMatrix {R : \Type} {n m : Nat} (f : Fin n -> Fin m -> R) : Matrix R n m
  => \new Array (Array R m) n $ \lam i => \new Array R m (f i)

\func matrixFromArrays {R : \Type} {n m : Nat} (M : Array (Array R m) n) : Matrix R n m => M

\func matrixExt {R : \Type} {n m : Nat} {M N : Matrix R n m} (p : \Pi (i : Fin n) (j : Fin m) -> M i j = N i j) : M = N
  => path (\lam i => mkMatrix (\lam j k => p j k i))

\instance MatrixModule (R : Ring) (n m : Nat) : LModule' R \cowith
  | E => Matrix R n m
  | zro => mkMatrix $ \lam _ _ => zro
  | + => MatrixRing.add
  | zro-left => matrixExt $ \lam i j => zro-left
  | +-assoc => matrixExt $ \lam i j => +-assoc
  | +-comm => matrixExt $ \lam i j => +-comm
  | negative M => mkMatrix $ \lam i j => negative (M i j)
  | negative-left => matrixExt $ \lam i j => negative-left
  | *c a M => mkMatrix $ \lam i j => a * M i j
  | *c-assoc => matrixExt $ \lam i j => *-assoc
  | *c-ldistr => matrixExt $ \lam i j => ldistr
  | *c-rdistr => matrixExt $ \lam i j => rdistr
  | ide_*c => matrixExt $ \lam i j => ide-left

\instance MatrixRing (R : Ring) (n : Nat) : Ring (Matrix R n n)
  | AbGroup => MatrixModule R n n
  | ide : Matrix R n n => mkMatrix $ \lam i j => \case decideEq i j \with {
    | yes _ => R.ide
    | no _ => zro
  }
  | * => product
  | ide-left => product_ide-left
  | ide-right => product_ide-right
  | *-assoc => product-assoc
  | ldistr => matrix_ldistr
  | rdistr => matrix_rdistr
  \where {
    \open AddMonoid

    \func add {R : AddMonoid} {n m : Nat} (M N : Matrix R n m) : Matrix R n m
      => mkMatrix $ \lam i j => M i j + N i j

    \func product {R : Ring} {n m k : Nat} (M : Matrix R n m) (N : Matrix R m k) : Matrix R n k
      => mkMatrix $ \lam j k => BigSum $ \new Array R m $ \lam i => M j i * N i k

    \lemma product_ide-left {R : Ring} {n m : Nat} {M : Matrix R n m} : product ide M = M
      => matrixExt $ \lam i j => BigSum-unique i (\lam k i/=k => later $ rewrite (decideEq/=_reduce i/=k) R.zro_*-left) *> rewrite (decideEq=_reduce idp) ide-left

    \lemma product_ide-right {R : Ring} {n m : Nat} {M : Matrix R n m} : product M ide = M
      => matrixExt $ \lam i j => BigSum-unique j (\lam k j/=k => later $ rewrite (decideEq/=_reduce (\lam t => j/=k (inv t))) R.zro_*-right) *> rewrite (decideEq=_reduce idp) ide-right

    \lemma product-assoc {R : Ring} {n m k l : Nat} {M : Matrix R n m} {N : Matrix R m k} {L : Matrix R k l} : product (product M N) L = product M (product N L)
      => matrixExt $ \lam j1 j2 => path (\lam i => BigSum (\new Array R k (\lam j3 => R.BigSum-rdistr {\new Array R m (\lam j4 => M j1 j4 * N j4 j3)} {L j3 j2} i))) *>
            R.BigSum-transpose _ *> pmap BigSum (arrayExt $ \lam j3 => pmap BigSum $ arrayExt $ \lam j4 => *-assoc) *>
            inv (path (\lam i => BigSum (\new Array R m (\lam j3 => R.BigSum-ldistr {M j1 j3} {\new Array R k (\lam j4 => N j3 j4 * L j4 j2)} i))))

    \lemma matrix_ldistr {R : Ring} {n m k : Nat} {L : Matrix R n m} {M N : Matrix R m k} : product L (add M N) = add (product L M) (product L N)
      => matrixExt $ \lam i j => pmap BigSum (arrayExt $ \lam k => ldistr) *> R.BigSum_+

    \lemma matrix_rdistr {R : Ring} {n m k : Nat} {M N : Matrix R n m} {L : Matrix R m k} : product (add M N) L = add (product M L) (product N L)
      => matrixExt $ \lam i j => pmap BigSum (arrayExt $ \lam k => rdistr) *> R.BigSum_+
  }

\func determinant {R : CRing} {n : Nat} (M : Matrix R n n) : R \elim n
  | 0 => 1
  | suc n => determinantN {R} {suc n} 0 M
  \where {
    \func minor {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m
      => map (skip __ j0) (skip M i0)

    \func minor' {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m
      => skip (map (skip __ j0) M) i0

    \func minor=minor' {R : \Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : minor M i0 j0 = minor' M i0 j0
      => matrixExt (aux M i0 j0)
      \where {
        \func aux {R : \Type} {n m : Nat} (M : Array (Array R (suc m)) (suc n)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) (i : Fin n) (j : Fin m)
          : skip (skip M i0 i) j0 j = skip {Array R m} (map (skip __ j0) M) i0 i j \elim n, M, i0, i
          | suc n, l :: M, 0, i => idp
          | suc n, l :: M, suc i0, 0 => idp
          | suc n, l :: M, suc i0, suc i => aux M i0 j0 i j
      }

    \lemma multilinear {R : CRing} {n : Nat} : isMultiLinear {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinant M) \elim n
      | 0 => ()
      | suc n => determinantN.multilinear {R} {suc n} 0

    \lemma alternating {R : CRing} {n : Nat} : isAlternating {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinant M) \elim n
      | 0 => ((), \lam _ (t,_,_,_) => \case t)
      | suc n => determinantN.alternating {R} {suc n} 0
  }

\func determinantN {R : CRing} {n : Nat} (k : Fin n) (M : Matrix R n n) : R \elim n
  | 0 => 1
  | suc n => R.BigSum $ \lam i => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)
  \where {
    \open determinant
    \open skip
    \open ArrayLModule

    \lemma minor_insert {R : CRing} {n m : Nat} {i : Fin (suc n)} {x : Array R (suc m)} {l : Array (Array R (suc m)) n} {j : Fin (suc m)}
      : minor (insert x l i) i j = \new Array (Array R m) n (\lam i => skip (l i) j)
      => path (\lam i' => map (skip __ j) (skip_insert_= i'))

    \lemma aux/= {R : CRing} {n m : Nat} {j i : Fin (suc n)} (p : j /= i) {k : Fin (suc m)} {x : Array R (suc m)} {M : Array (Array R (suc m)) n}
      : insert {Array R (suc m)} x M j i k = M (newIndex (\lam q => p (inv q))) k \elim n, j, i, M
      | _, 0, 0, _ => absurd (p idp)
      | suc n, 0, suc i, y :: M => idp
      | suc n, suc j, 0, y :: M => idp
      | suc n, suc j, suc i, y :: M => aux/= (\lam q => p (pmap fsuc q))

    \func minor_replace {R : CRing} {n : Nat} {i k : Fin (suc n)} {M : Array (Array R (suc n)) (suc n)} {j : Fin (suc n)} {x : Array R (suc n)} (p : j /= i)
      : minor (replace M j x) i k = replace (minor M i k) (newIndex p) (skip x k)
      => path (\lam i => map (skip __ k) (skip_replace_/= p i)) *> pmap matrixFromArrays (map_replace (skip __ k))

    \lemma multilinear {R : CRing} {n : Nat} (k : Fin n) : isMultiLinear {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinantN k M) \elim n
      | 0 => ()
      | suc n => isMultilinear_BigSum {R} {suc n} {ArrayLModule (suc n) (RingLModule R)} (\lam i M => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)) $ \lam i M j => \case decideEq j i \with {
        | yes e => \new LinearMap {
          | func-+ {a} {b} => rewrite e $ *-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)}) *> rdistr *> pmap2 (+)
                                (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
                                (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
        | func-*c {r} {a} => rewrite e $ *-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)}) *> *-assoc *> pmap (r *) (pmap (\lam x => _ * (_ * determinant x)) (minor_insert *> inv minor_insert) *> inv (*-assoc *> pmap {Array R (suc n)} (__ k * _) (insert-index {Array R (suc n)})))
        }
        | no q => \new LinearMap {
          | func-+ => rewrite (aux/= q, aux/= q, aux/= q) $ pmap (_ *) (inv (path (\lam i' => determinant (minor (replace_insert {_} {M} {j} {replicate (suc n) R.zro} i') i k))) *> pmap determinant (minor_replace q) *> rewrite skip_+ (func-+ {isMultiLinear.toReplace {R} {_} {_} {n} determinant.multilinear _ _} *> pmap2 (determinant __ + determinant __) (inv (minor_replace q) *> path (\lam i' => minor (replace_insert i') i k)) (inv (minor_replace q) *> path (\lam i' => minor (replace_insert i') i k)))) *> ldistr
          | func-*c {r} {x} => rewrite (aux/= q, aux/= q) $ pmap (_ * _ * __) (inv (path (\lam i' => determinant (minor (replace_insert {_} {M} {j} {replicate (suc n) R.zro} i') i k))) *> pmap determinant (minor_replace q) *> rewrite skip_*c (func-*c {isMultiLinear.toReplace {R} {_} {_} {n} determinant.multilinear _ _} *> pmap (r * determinant __) (inv (minor_replace q))) *> path (\lam i' => r * determinant (minor (replace_insert i') i k)) *> *-comm) *> inv *-assoc *> *-comm
        }
      }

    \lemma alternating {R : CRing} {n : Nat} (k : Fin n) : isAlternating {R} {n} {ArrayLModule n (RingLModule R)} {RingLModule R} (\lam M => determinantN k M) \elim n
      | 0 => ((), \lam _ => \case __.1)
      | suc n => (multilinear k, aux k)
      \where {
        \open NatSemiring(<,suc<suc)

        \func permutation1 {R : \Type} {n : Nat} (j : Fin (suc n)) (l : Array R (suc n)) : Perm l (l j :: skip l j) \elim n, j, l
          | 0, 0, l => Perm.perm-refl
          | suc n, 0, l => Perm.perm-refl
          | suc n, suc j, a :: l => perm-trans (perm-:: idp (permutation1 j l)) (perm-swap idp idp idp)

        \func permutation {R : \Type} {n : Nat} {i j : Fin (suc n)} (p : i < j) (l : Array R (suc n)) (q : l i = l j) : Perm (skip l i) (skip l j) \elim n, i, j, p, l, q
          | 0, 0, 0, (), _, _
          | suc n, 0, suc j, _, a :: l, idp => permutation1 j l
          | suc n, suc i, suc j, suc<suc p, a :: l, q => perm-:: idp (permutation p l q)

        \lemma permutation1_inversions {R : \Type} {n : Nat} {j : Fin (suc n)} {l : Array R (suc n)} : Perm.inversions (permutation1 j l) = j \elim n, j, l
          | 0, 0, l => idp
          | suc n, 0, a :: l => Perm.inversions_perm-:: *> Perm.inversions_perm-refl
          | suc n, suc j, a :: l => pmap suc permutation1_inversions

        \lemma permutation_inversions {R : \Type} {n : Nat} {i j : Fin (suc n)} {p : i < j} {l : Array R (suc n)} {q : l i = l j} : Perm.inversions (permutation p l q) = j -' suc i \elim n, i, j, p, l, q
          | 0, 0, 0, (), _, _
          | suc n, 0, suc j, _, a :: l, idp => permutation1_inversions *> inv -'0
          | suc n, suc i, suc j, suc<suc p, a :: l, q => Perm.inversions_perm-:: *> permutation_inversions

        \lemma aux {R : CRing} {n : Nat} (k : Fin n) (M : Array (Array R n) n) (t : \Sigma (i j : Fin n) (i < j) (M i = M j)) : determinantN k M = 0 \elim n
          | 0 => \case t.1
          | suc n => R.BigSum-unique2 {\lam i => M i k * R.pow -1 (i Nat.+ k) * determinant (minor M i k)} t.3 (\lam i i/=t1 i/=t2 => pmap (_ *) (determinant.alternating.2 (minor M i k) (newIndex $ \lam p => i/=t1 (inv p), newIndex $ \lam p => i/=t2 (inv p), newIndex_< t.3, pmap (skip __ k) $ skip-index *> t.4 *> inv skip-index)) *> zro_*-right) *>
                      rewrite (pmap {Array R _} (__ k) t.4) (pmap2 (+) *-assoc *-assoc *> inv ldistr *> pmap (_ *) (later $ rewrite (minor=minor', minor=minor', isAlternating.alternating_perm {R} determinant.alternating $ permutation t.3 (map (skip __ k) M) $ pmap (skip __ k) t.4) $ rewriteI *-assoc $ inv rdistr *> pmap (`* _) (unfold Perm.sign $ rewrite (permutation_inversions, inv R.pow_+, inv R.pow_-1_+2) $
                        \have s : t.1 Nat.+ k Nat.+ (t.2 -' suc t.1) Nat.+ 2 = suc (t.2 Nat.+ k) => pmap suc $ unpos $ pmap (pos (suc (t.1 Nat.+ k)) +) (-'=- $ suc_<_<= t.3) *> linarith
                        \in pmap (R.pow -1 __ + _) s *> pmap (`+ _) R.negative_ide-right *> negative-left) *> zro_*-left) *> zro_*-right)
      }
  }