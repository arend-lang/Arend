\import Data.Fin
\import Logic
\import Paths
\import Paths.Meta

\class SolverModel (M : \Set) {
  | \protected Term : \Set -> \Set
  | \protected NF : \Set -> \Set
  | \protected normalize {V : \Set} : Term V -> NF V
  | \protected interpret {V : \Set} (env : V -> M) : Term V -> M
  | \protected interpretNF {n : Nat} (env : Fin n -> M) : NF (Fin n) -> M
  | \protected interpretNF-consistent {n : Nat} {env : Fin n -> M} {t : Term (Fin n)} : interpretNF env (normalize t) = interpret env t

  | \protected nfVar {V : \Set} : V -> NF V
  | \protected \infixl 2 >>= {U V : \Set} : NF U -> (U -> NF V) -> NF V
  | \protected >>=-consistent {m n : Nat} {env : Fin n -> M} {nf : NF (Fin m)} {k : Fin m -> NF (Fin n)}
    : interpretNF env (nf >>= k) = interpretNF (\lam v => interpretNF env (k v)) nf

  \protected \lemma terms-equality (env : Array M) (t s : Term (Fin env.len)) (p : interpretNF env (normalize t) = interpretNF env (normalize s)) : interpret env t = interpret env s
    => inv interpretNF-consistent *> p *> interpretNF-consistent

  \protected \lemma terms-equality-conv (env : Array M) (t s : Term (Fin env.len)) (p : interpret env t = interpret env s) : interpretNF env (normalize t) = interpretNF env (normalize s)
    => interpretNF-consistent *> p *> inv interpretNF-consistent

  \lemma apply-axiom (env : Array M) (t s : Term (Fin env.len)) (p : interpret env t = interpret env s) (pattern : NF (Fin (suc env.len))) : interpretNF env (pattern >>= fcase (normalize t) nfVar) = interpretNF env (pattern >>= fcase (normalize s) nfVar)
    => >>=-consistent *> pmap (interpretNF __ pattern) (ext \case \elim __ \with {
      | 0 => terms-equality-conv env t s p
      | suc v => idp
    }) *> inv >>=-consistent
}