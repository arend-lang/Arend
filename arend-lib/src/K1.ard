\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Pointed (ide)
\import Homotopy.Cube
\import Homotopy.Pointed
\import Logic
\import Paths
\import Equiv (QEquiv, Retraction, Section)
\import Equiv
\open Equiv.Reasoning
\import Equiv.Univalence

\truncated \data K1 (G : Group) : \1-Type
  | base
  | loop G (i : I) \elim i {
    | left => base
    | right => base
  }
  | relation (g g' : G) (i : I) (j : I) \elim i, j {
    | left, j => base
    | right, j => loop g' j
    | i, left => loop g i
    | i, right => loop (g * g') i
  }
  \where {
    \func loop-comp {G : Group} (g g' : G) : path (loop g) *> path (loop g') = path (loop (g * g'))
      => movePath2 (Equiv.ret {=-to-Equiv (Cube2.equality (path (loop g)) (path (loop (g * g'))) idp (path (loop g')))}
                             (path (\lam j => path (\lam i => relation g g' i j))))
  }

\func movePath1 {A : \1-Type} {a a' a'' : A} {p : a = a'} {q : a' = a''} {r : a = a''} (h : p *> q = r) : p = r *> inv q
  => (inv (pmap (p *>) (*>_inv q)) *> inv (*>-assoc p q (inv q))) *> pmap (`*> inv q) h

\func movePath2 {A : \Type} {a a' a'' : A} {p : a = a'} {q : a' = a''} {r : a = a''} (h : p = r *> inv q) : p *> q = r
  => (pmap (`*> q) h) *> (*>-assoc r (inv q) q) *> pmap (r *>) (inv_*> q)

\func isConnected (X : \Type) => \Pi (x y : X) -> TruncP (x = y)

\func K1-connected (G : Group) : isConnected (K1 G)
  => {?}

\func grp-to-ptconn (G : Group) : \Sigma (X : Pointed) (isConnected X) => (\new Pointed (K1 G) { | base => base}, K1-connected G)

\func leftMulEquiv {G : Group} (g : G) : QEquiv (g *) \cowith
  | ret => inverse g *
  | ret_f h => inv (*-assoc _ _ _) *> pmap (`* h) (inverse-left g) *> ide-left h
  | f_sec h => inv (*-assoc _ _ _) *> pmap (`* h) (inverse-right g) *> ide-left h

\func rightMulEquiv {G : Group} (g : G) : QEquiv (`* g) \cowith
  | ret => `* (inverse g)
  | ret_f h => (*-assoc _ _ _) *> pmap (h *) (inverse-right g) *> ide-right h
  | f_sec h => (*-assoc _ _ _) *> pmap (h * ) (inverse-left g) *> ide-right h

\func =-to-Equiv-functorial {A B C : \Type} (p : A = B) (q : B = C)
  : =-to-Equiv (p *> q) = ((=-to-Equiv p) >~~ (=-to-Equiv q)) \elim q
  | idp => Path.inProp {Equiv (Equiv.f {=-to-Equiv p})} (=-to-Equiv p) ((=-to-Equiv p) >~~ (=-to-Equiv idp))

\func Equiv-to-=-functorial {A B C : \Type} (e1 : Equiv {A} {B}) (e2 : Equiv {B} {C})
  : Equiv-to-= e1 *> Equiv-to-= e2 = Equiv-to-= (e1 >~~ e2)
  => Equiv-to-= e1 *> Equiv-to-= e2 ==< inv (Section.ret_f {univalence {A} {C}} (Equiv-to-= e1 *> Equiv-to-= e2)) >==
  Equiv-to-= (=-to-Equiv (Equiv-to-= e1 *> Equiv-to-= e2)) ==< pmap Equiv-to-= (=-to-Equiv-functorial (Equiv-to-= e1) (Equiv-to-= e2)) >==
  Equiv-to-= ((=-to-Equiv (Equiv-to-= e1)) >~~ (=-to-Equiv (Equiv-to-= e2))) ==<
                  pmap (\lam x => Equiv-to-= (x >~~ (=-to-Equiv (Equiv-to-= e2)))) (Retraction.f_sec {univalence {A} {B}} e1) >==
  Equiv-to-= (e1 >~~ (=-to-Equiv (Equiv-to-= e2))) ==<
                  pmap (\lam x => Equiv-to-= (e1 >~~ x)) (Retraction.f_sec {univalence {B} {C}} e2) >==
  Equiv-to-= (e1 >~~ e2) `qed

\func rMul-functorial {G : Group} (g g' : G) :
  (\lam x => Equiv.f {rightMulEquiv g'} (Equiv.f {rightMulEquiv g} x)) = (\lam x => Equiv.f {rightMulEquiv (g * g')} x)
  => path (\lam (i : I) (x : G) => ((x * g) * g' ==< *-assoc x g g' >== x * (g * g') `qed) @ i)

\func equivFibr {G : Group} (g g' : G) (i : I) => Equiv {G} {G} ((rMul-functorial g g') @ i)

\func compToMult {G : Group} (g g' : G) : Path (equivFibr g g') ((rightMulEquiv g) >~~ (rightMulEquiv g')) (rightMulEquiv (g * g'))
  => pathInProp (equivFibr g g') ((rightMulEquiv g) >~~ (rightMulEquiv g')) (rightMulEquiv (g * g'))

\func equivPathComposition {G : Group} (g g' : G)
  : (Equiv-to-= (rightMulEquiv g)) *> (Equiv-to-= (rightMulEquiv g')) = {G = {\Set} G} (Equiv-to-= (rightMulEquiv (g * g')))
  => Equiv-to-= (rightMulEquiv g) *> Equiv-to-= (rightMulEquiv g') ==<
            Equiv-to-=-functorial (rightMulEquiv g) (rightMulEquiv g') >==
     Equiv-to-= ((rightMulEquiv g) >~~ (rightMulEquiv g')) ==<
            path (\lam i => Equiv-to-= ((compToMult g g') @ i)) >==
     Equiv-to-= (rightMulEquiv (g * g')) `qed

\func code {G : Group} (x : K1 G) : \Set \elim x
  | base => G
  | loop g j => Equiv-to-= (rightMulEquiv g) @ j
  | relation g g' i j => Cube2.map {\Set} (Equiv-to-= (rightMulEquiv g)) (Equiv-to-= (rightMulEquiv (g * g'))) idp (Equiv-to-= (rightMulEquiv g'))
                                   (movePath1 (equivPathComposition g g')) @ j @ i

\func encode {G : Group} (x : K1 G) (p : base = x) : code x
   => transport code p ide

\func decode {G : Group} (x : K1 G) : code x -> base = x \elim x
  | base => \lam c => path (loop c)
  | loop g i => (decode_loop_hetero g) @ i
  \where {
    \func wind {G : Group} (g : G) : base {G} = base => path (loop g)

    \func decode_loop_homo {G : Group} (g h : G)
      => transport (\lam x => code {G} x -> base = x) (wind g) wind h ==< transport_pi (code {G}) (base {G} =) (wind g) wind h >==
         transport (base =) (wind g) (wind (transport code (inv (wind g)) h)) ==< transport_path-right (wind g) (wind (transport code (inv (wind g)) h)) >==
         wind (transport code (inv (wind g)) h) *> wind g ==< pmap (`*> wind g) (pmap wind (transport_inv_func (code {G}) (wind g) (Equiv.ret {rightMulEquiv g}) (Equiv.ret_f {rightMulEquiv g}) h)) >==
         wind (Equiv.ret {rightMulEquiv g} h) *> wind g ==< K1.loop-comp (Equiv.ret {rightMulEquiv g} h) g >==
         wind (Equiv.f {rightMulEquiv g} (Equiv.ret {rightMulEquiv g} h)) ==< pmap wind (Equiv.f_sec {rightMulEquiv g} h) >==
         wind h `qed

    \func decode_loop_hetero {G : Group} (g : G)
      => pathOver (path (\lam j x => decode_loop_homo g x @ j))
  }