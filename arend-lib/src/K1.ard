\import Algebra.Group
\import Algebra.Monoid
\import Homotopy.Cube
\import Homotopy.Pointed
\import Logic
\import Paths
\import Equiv (QEquiv, Retraction, Section)
\import Equiv
\open Equiv.Reasoning
\import Equiv.Univalence

\data K1 (G : Group)
  | base
  | loop G (i : I) \elim i {
    | left => base
    | right => base
  }
  | relation (g g' : G) (i : I) (j : I) \elim i, j {
    | left, j => base
    | right, j => loop g' j
    | i, left => loop g i
    | i, right => loop (g * g') i
  }

\func isConnected (X : \Type) => \Pi (x y : X) -> TruncP (x = y)

\func K1-connected (G : Group) : isConnected (K1 G)
  => {?}

\func grp-to-ptconn (G : Group) : \Sigma (X : Pointed) (isConnected X) => (\new Pointed (K1 G) { | base => base}, K1-connected G)

\func leftMulEquiv {G : Group} (g : G) : QEquiv (g *) \cowith
  | ret => inverse g *
  | ret_f h => inv (*-assoc _ _ _) *> pmap (`* h) (inverse-left g) *> ide-left h
  | f_sec h => inv (*-assoc _ _ _) *> pmap (`* h) (inverse-right g) *> ide-left h

\func rightMulEquiv {G : Group} (g : G) : QEquiv (`* g) \cowith
  | ret => `* (inverse g) -- \lam x => x * (inverse g)
  | ret_f h => (*-assoc _ _ _) *> pmap (h *) (inverse-right g) *> ide-right h
  | f_sec h => (*-assoc _ _ _) *> pmap (h * ) (inverse-left g) *> ide-right h

\func =-to-Equiv-functorial {A B C : \Type} (p : A = B) (q : B = C)
  : =-to-Equiv (p *> q) = ((=-to-Equiv p) >~~ (=-to-Equiv q)) \elim q
  | idp => Path.inProp {Equiv (Equiv.f {=-to-Equiv p})} (=-to-Equiv p) ((=-to-Equiv p) >~~ (=-to-Equiv idp))

\func Equiv-to-=-functorial {A B C : \Type} (e1 : Equiv {A} {B}) (e2 : Equiv {B} {C})
  : Equiv-to-= e1 *> Equiv-to-= e2 = Equiv-to-= (e1 >~~ e2)
  => Equiv-to-= e1 *> Equiv-to-= e2 ==< inv (Section.ret_f {univalence {A} {C}} (Equiv-to-= e1 *> Equiv-to-= e2)) >==
  Equiv-to-= (=-to-Equiv (Equiv-to-= e1 *> Equiv-to-= e2)) ==< pmap Equiv-to-= (=-to-Equiv-functorial (Equiv-to-= e1) (Equiv-to-= e2)) >==
  Equiv-to-= ((=-to-Equiv (Equiv-to-= e1)) >~~ (=-to-Equiv (Equiv-to-= e2))) ==<
                  pmap (\lam x => Equiv-to-= (x >~~ (=-to-Equiv (Equiv-to-= e2)))) (Retraction.f_sec {univalence {A} {B}} e1) >==
  Equiv-to-= (e1 >~~ (=-to-Equiv (Equiv-to-= e2))) ==<
                  pmap (\lam x => Equiv-to-= (e1 >~~ x)) (Retraction.f_sec {univalence {B} {C}} e2) >==
  Equiv-to-= (e1 >~~ e2) `qed

\func rMul-functorial {G : Group} (g g' : G) :
  (\lam x => Equiv.f {rightMulEquiv g'} (Equiv.f {rightMulEquiv g} x)) = (\lam x => Equiv.f {rightMulEquiv (g * g')} x)
  => path (\lam (i : I) (x : G) => ((x * g) * g' ==< *-assoc x g g' >== x * (g * g') `qed) @ i)

\func equivFibr {G : Group} (g g' : G) (i : I) => Equiv {G} {G} ((rMul-functorial g g') @ i)

\func compToMult {G : Group} (g g' : G) : Path (equivFibr g g') ((rightMulEquiv g) >~~ (rightMulEquiv g')) (rightMulEquiv (g * g'))
  => pathInProp (equivFibr g g') ((rightMulEquiv g) >~~ (rightMulEquiv g')) (rightMulEquiv (g * g'))

\func equivPathComposition {G : Group} (g g' : G)
  : (Equiv-to-= (rightMulEquiv g)) *> (Equiv-to-= (rightMulEquiv g')) = (Equiv-to-= (rightMulEquiv (g * g')))
  => Equiv-to-= (rightMulEquiv g) *> Equiv-to-= (rightMulEquiv g') ==<
            Equiv-to-=-functorial (rightMulEquiv g) (rightMulEquiv g') >==
     Equiv-to-= ((rightMulEquiv g) >~~ (rightMulEquiv g')) ==<
            path (\lam i => Equiv-to-= ((compToMult g g') @ i)) >==
     Equiv-to-= (rightMulEquiv (g * g')) `qed

\func code {G : Group} (x : K1 G) : \Type \lp \oo \elim x
  | base => G
  | loop g j => Equiv-to-= (rightMulEquiv g) @ j
  | relation g g' i j => Cube2.map (Equiv-to-= (rightMulEquiv g)) (Equiv-to-= (rightMulEquiv (g * g'))) idp (Equiv-to-= (rightMulEquiv g'))
                                   (movePath (equivPathComposition g g')) @ j @ i
  \where {
    \func movePath {A : \Type} {a a' a'' : A} {p : a = a'} {q : a' = a''} {r : a = a''} (h : p *> q = r) : p = r *> inv q
      => (inv (pmap (p *>) (*>_inv q)) *> inv (*>-assoc p q (inv q))) *> pmap (`*> inv q) h
  }