\import Equiv
\import Function
\import Homotopy.Pointed
\import Homotopy.Sphere
\import Homotopy.Square
\import Homotopy.Suspension
\import Logic
\import Paths

\class Pushout (square : Square)
  | pushout-univ {Z : \Type} : Equiv {square.Y -> Z} {Square { | Y => Z | U => square.U | V => square.V | X => square.X | uv => square.uv | ux => square.ux }} (Square.push square)
  \where {
    -- | Pushouts are functorial
    \func map (p : Pushout) (s : Square)
              (f : p.square.U -> s.U)
              (g : p.square.V -> s.V)
              (h : p.square.X -> s.X)
              (e1 : \Pi (u : p.square.U) -> s.uv (f u) = g (p.square.uv u))
              (e2 : \Pi (u : p.square.U) -> s.ux (f u) = h (p.square.ux u))
              : p.square.Y -> s.Y
      => p.pushout-univ.ret (\new Square {
        | vy v => s.vy (g v)
        | xy x => s.xy (h x)
        | sqcomm u => pmap s.vy (inv (e1 u)) <* s.sqcomm (f u) *> pmap s.xy (e2 u)
      })

    -- | {map} preserves identity maps
    \func map_id (p : Pushout) (y : p.square.Y) : map p p.square id id id (\lam _ => idp) (\lam _ => idp) = id
      => p.pushout-univ.ret_f (\lam x => x)
  }

\data PushoutData {A B C : \Type} (f : A -> B) (g : A -> C)
  | pinl B
  | pinr C
  | pglue (a : A) (i : I) \elim i {
    | left => pinl (f a)
    | right => pinr (g a)
  }
  \where {
    \func ppglue {A B C : \Type} {f : A -> B} {g : A -> C} (a : A) : pinl (f a) = {PushoutData f g} pinr (g a) => path (pglue a)

    \func rec {A B C : \Type} {f : A -> B} {g : A -> C} {Z : \Type} (lm : B -> Z) (rm : C -> Z) (gm : \Pi (a : A) -> lm (f a) = rm (g a)) (x : PushoutData f g) : Z \elim x
      | pinl b => lm b
      | pinr c => rm c
      | pglue a i => gm a @ i

    \func fibration-lemma {A B C : \Type} {f : A -> B} {g : A -> C} (F : PushoutData f g -> \Type)
      : QEquiv {\Sigma (w : PushoutData f g) (F w)} {total F} \cowith
      | f => sigmaPushout F
      | ret => pushoutSigma F
      | ret_f => sigmaPushoutSigma F
      | f_sec => pushoutSigmaPushout F
    \where {
      \func total {A B C : \Type} {f : A -> B} {g : A -> C} (F : PushoutData f g -> \Type)
        => PushoutData {\Sigma (x : A) (F (pinl (f x)))} {\Sigma (y : B) (F (pinl y))} {\Sigma (z : C) (F (pinr z))} (\lam p => (f p.1, p.2)) (\lam p => (g p.1, transport F (ppglue p.1) p.2))

      \func pushoutSigma {A B C : \Type} {f : A -> B} {g : A -> C} (F : PushoutData f g -> \Type) (p : total F) : \Sigma (w : PushoutData f g) (F w) \elim p
        | pinl (y,t) => (pinl y, t)
        | pinr (z,t) => (pinr z, t)
        | pglue (x,t) i => (pglue x i, coe (\lam j => F (pglue x j)) t i)

      \func sigmaPushout {A B C : \Type} {f : A -> B} {g : A -> C} (F : PushoutData f g -> \Type) (s : \Sigma (w : PushoutData f g) (F w)) : total F \elim s
        | (pinl y, t) => pinl (y,t)
        | (pinr z, t) => pinr (z,t)
        | (pglue x i, t) =>
          \let | R => total F
               | p t' =>
                   transport (\lam w => F w -> R) (ppglue x) (\lam t' => pinl (f x, t')) t' ==< transport_pi F (\lam _ => R) (ppglue x) (\lam t' => pinl (f x, t')) t' >==
                   pinl (f x, transport F (inv (ppglue x)) t')                              ==< {R} ppglue ((x, transport F (inv (ppglue x)) t') : \Sigma (x : A) (F (pinl (f x)))) >==
                   pinr (g x, transport F (ppglue x) (transport F (inv (ppglue x)) t'))     ==< {R} pmap (\lam s => (pinr (g x, s) : R)) (transport_id_inv F (ppglue x) t') >==
                   (pinr (g x, t') : R)                                                     `qed
          \in (pathOver (path (\lam j t' => p t' @ j)) @ i) t

      \func pushoutSigmaPushout {A B C : \Type} {f : A -> B} {g : A -> C} (F : PushoutData f g -> \Type) (p : total F) : sigmaPushout F (pushoutSigma F p) = p \elim p
        | pinl (y,t) => idp
        | pinr (z,t) => idp
        | pglue (x,t) i =>
          \let | A' => \Sigma (x : A) (F (pinl (f x)))
               | R => total F
               | w => coe (\lam j => F (pglue x j)) t
               | f' t' : R => pinl (f x, t')
               | g' t' : R => pinr (g x, t')
               | q1 t' => transport_pi F (\lam _ => R) (ppglue x) f' t'
               | q2 t' => ppglue ((x, transport F (inv (ppglue x)) t') : A')
               | q3 t' => pmap g' (transport_id_inv F (ppglue x) t')
               | r => path (\lam i => coe (\lam j => F (pglue x j) -> R) f' i (w i))
               | u => inv (transport_inv_id F (ppglue x) t)
               | p => path (\lam i => (pathOver (path (\lam j t' => (q1 t' *> q2 t' *> q3 t') @ j)) @ i) (w i))                   ==< Jl (\lam x1 p1 => path (\lam i => (pathOver p1 @ i) (w i)) = r *> pmap (\lam h => h (w right)) p1) idp (path (\lam j t' => (q1 t' *> q2 t' *> q3 t') @ j)) >==
                      r *> q1 (w right) *> q2 (w right) *> q3 (w right)                                                           ==< inv (*>-assoc r (q1 (w right)) (q2 (w right) *> q3 (w right))) >==
                      (r *> q1 (w right)) *> q2 (w right) *> q3 (w right)                                                         ==< pmap (\lam s => s *> q2 (w right) *> q3 (w right)) (Jl (\lam x1 p1 => path (\lam i => coe (\lam j => F (p1 @ j) -> R) f' i (coe (\lam j => F (p1 @ j)) t i)) *> transport_pi F (\lam _ => R) p1 f' (transport F p1 t) = pmap f' (inv (transport_inv_id F p1 t))) idp (ppglue x)) >==
                      pmap f' (inv (transport_inv_id F (ppglue x) t)) *> q2 (w right) *> q3 (w right)                             ==< inv (*>-assoc (pmap f' (inv (transport_inv_id F (ppglue x) t))) (q2 (w right)) (q3 (w right))) >==
                      (pmap f' u *> q2 (w right)) *> q3 (w right)                                                                 ==< pmap (\lam s => s *> q3 (w right)) (Jl (\lam x1 p1 => pmap f' p1 *> ppglue ((x,x1) : A') = ppglue ((x,t) : A') *> pmap (\lam t' => g' (transport F (ppglue x) t')) p1) (idp_*> (ppglue ((x,t) : A'))) u) >==
                      (ppglue ((x,t) : A') *> pmap (\lam t' => g' (transport F (ppglue x) t')) u) *> q3 (w right)                 ==< *>-assoc (ppglue ((x,t) : A')) (pmap (\lam t' => g' (transport F (ppglue x) t')) u) (q3 (w right)) >==
                      ppglue ((x,t) : A') *> pmap (\lam t' => g' (transport F (ppglue x) t')) u *> q3 (w right)                   ==< pmap (ppglue ((x,t) : A') *>) (inv (pmap_*>-comm g' (pmap (transport F (ppglue x)) u) (transport_id_inv F (ppglue x) (w right)))) >==
                      ppglue ((x,t) : A') *> pmap g' (pmap (transport F (ppglue x)) u *> transport_id_inv F (ppglue x) (w right)) ==< pmap (\lam s => ppglue ((x,t) : A') *> pmap g' s) (Jl (\lam x1 p1 => pmap (transport F p1) (inv (transport_inv_id F p1 t)) *> transport_id_inv F p1 (transport F p1 t) = idp) idp (ppglue x)) >==
                      ppglue ((x,t) : A')                                                                                         `qed
          \in path (\lam j => p @ j @ i)

      \func sigmaPushoutSigma {A B C : \Type} {f : A -> B} {g : A -> C} (F : PushoutData f g -> \Type) (s : \Sigma (w : PushoutData f g) (F w)) : pushoutSigma F (sigmaPushout F s) = s \elim s
        | (pinl y, t) => idp
        | (pinr z, t) => idp
        | (pglue x i, t) =>
          \let p t' => transport (\lam w => \Pi (t' : F w) -> pushoutSigma F (sigmaPushout F (w,t')) = (w,t')) (ppglue x) (\lam _ => idp) t' ==< {?} >==
                       idp                                                                                                                   `qed
          \in (pathOver (path (\lam j t' => p t' @ j)) @ i) t
          {-
          \let | S => \Sigma (w : PushoutData f g) (F w)
               | R => total F
               | q t' => transport_pi F (\lam _ => R) (ppglue x) (\lam t' => pinl (f x, t')) t' *>
                         ppglue ((x, transport F (inv (ppglue x)) t') : \Sigma (x : A) (F (pinl (f x)))) *>
                         pmap (\lam s => (pinr (g x, s) : R)) (transport_id_inv F (ppglue x) t')
               | p : path (\lam i t => pushoutSigma F ((pathOver (path (\lam j t' => q t' @ j)) @ i) t)) = {Path (\lam i => F (pglue x i) -> S) _ _} path (\lam i t => (pglue x i, t))
                   => {?}
          \in path (\lam j => (p @ j @ i) t)
          -}
    }
  }

\open PushoutData

\instance PushoutPointed {A B C : \Type} {P : Pointed B} {f : A -> B} {g : A -> C} : Pointed (PushoutData f g)
  | base => pinl base

\func pushoutData {A B C : \Type} (f : A -> B) (g : A -> C) : Pushout \cowith
  | square {
    | U => A
    | V => B
    | X => C
    | Y => PushoutData f g
    | ux => g
    | vy => pinl
    | uv => f
    | xy => pinr
    | sqcomm a => path (pglue a)
  }
  | pushout-univ {Z} => \new QEquiv {
    | ret (s : Square) => rec s.vy s.xy s.sqcomm
    | ret_f h => path (\lam i p => (\case p \as p \return rec (h `o` pinl) (h `o` pinr) (\lam a => path (\lam j => h (pglue a j))) p = h p \with {
      | pinl _ => idp
      | pinr _ => idp
      | pglue _ _ => idp
    }) @ i)
    | f_sec _ => idp
  }