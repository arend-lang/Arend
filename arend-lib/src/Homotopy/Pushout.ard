\import Equiv
\import Function
\import Homotopy.Pointed
\import Homotopy.Sphere
\import Homotopy.Square
\import Homotopy.Suspension
\import Logic
\import Paths

\data PushoutData {A B C : \Type} (f : A -> B) (g : A -> C)
  | pinl B
  | pinr C
  | pglue (a : A) (i : I) \elim i {
    | left => pinl (f a)
    | right => pinr (g a)
  }
  \where {
    \func rec {A B C : \Type} {f : A -> B} {g : A -> C} {Z : \Type} (lm : B -> Z) (rm : C -> Z) (gm : \Pi (a : A) -> lm (f a) = rm (g a)) (x : PushoutData f g) : Z \elim x
      | pinl b => lm b
      | pinr c => rm c
      | pglue a i => gm a @ i
  }

\open PushoutData

\instance PushoutPointed {A B C : \Type} {P : Pointed B} {f : A -> B} {g : A -> C} : Pointed (PushoutData f g)
  | base => pinl base

\class Pushout (square : Square)
  | pushout-univ {Z : \Type} : Equiv {square.Y -> Z} {Square { | Y => Z | U => square.U | V => square.V | X => square.X | uv => square.uv | ux => square.ux }} (Square.push square)

\func pushoutData {A B C : \Type} (f : A -> B) (g : A -> C) : Pushout \cowith
  | square {
    | U => A
    | V => B
    | X => C
    | Y => PushoutData f g
    | ux => g
    | vy => pinl
    | uv => f
    | xy => pinr
    | sqcomm a => path (pglue a)
  }
  | pushout-univ {Z} => \new QEquiv {
    | ret (s : Square) => rec s.vy s.xy s.sqcomm
    | ret_f h => path (\lam i p => (\case p \as p \return rec (h `o` pinl) (h `o` pinr) (\lam a => path (\lam j => h (pglue a j))) p = h p \with {
      | pinl _ => idp
      | pinr _ => idp
      | pglue _ _ => idp
    }) @ i)
    | f_sec _ => idp
  }