\import Equiv
\import Equiv.Univalence
\import Homotopy.Cube
\import Homotopy.Join
\import Homotopy.Pointed
\import Homotopy.Sphere
\import Homotopy.Sphere.Circle
\import Homotopy.Suspension
\import Logic
\import Paths

\class HSpace \extends Pointed
  | \infixl 7 * : E -> E -> E
  | base-left (x : E) : base * x = x
  | base-right (x : E) : x * base = x

-- | If a point {x} in an H-space belongs to the same connected component as {base}, then ``(x *)`` is an equivalence.
\lemma HSpace-conn {A : HSpace} (x : A) (c : TruncP (base = x)) : Equiv (x *) \elim c
  | inP base=x => transport (\lam f => Equiv f)
                            (path (\lam i y => (inv (base-left y) *> pmap (\lam z => z * y) base=x) @ i))
                            idEquiv

\lemma Sphere1_conn (x y : Sphere 1) : TruncP (x = y)
  => transport (\lam X => \Pi (x y : X) -> TruncP (x = y)) (QEquiv-to-= Sphere1-equiv) circle x y
  \where
    \lemma circle (x y : Sphere1) : TruncP (x = y)
      | base1, base1 => inP idp

\instance Circle_HSpace : HSpace Sphere1
  | base => base1
  | * => mult
  | base-left _ => idp
  | base-right => mult-right
  \where {
    \open Sphere1(ploop)

    \func circle-loop (y : Sphere1) : y = y
      | base1 => path loop
      | loop i => Cube2.map ploop ploop ploop ploop (inv (<*_idp ploop) *> pmap (ploop <*) (inv (*>_inv ploop))) @ i

    \func mult (x y : Sphere1) : Sphere1 \elim x
      | base1 => y
      | loop i => circle-loop y @ i

    \func mult-right (x : Sphere1) : mult x base1 = x
      | base1 => idp
      | loop i => idp
  }

\instance Sphere1_HSpace : HSpace (Sphere 1) => transport (\lam X => HSpace X) (QEquiv-to-= Sphere1-equiv) Circle_HSpace

\func hopf {A : HSpace} (c : \Pi (x y : A) -> TruncP (x = y)) (x : Susp A) : \Type \elim x
  | north => A
  | south => A
  | merid a i => Equiv-to-= (HSpace-conn a (c base a)) @ i
  \where {
    \func total-equiv {A : HSpace} (c : \Pi (x y : A) -> TruncP (x = y)) : QEquiv {\Sigma (x : Susp A) (hopf c x)} {Join A A} => {?}
  }

\func hopfS2 => hopf Sphere1_conn
  \where
    \func total-equiv =>
      (\Sigma (x : Sphere 2) (hopfS2 x)) ==< QEquiv-to-= (hopf.total-equiv Sphere1_conn) >==
      Join (Sphere 1) (Sphere 1)         ==< Join_Sphere (Sphere 1) 1 >==
      Sphere 3                           `qed
