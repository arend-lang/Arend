\import Equiv
\import Equiv.Univalence
\import Homotopy.Connected
\import Homotopy.Cube
\import Homotopy.Join
\import Homotopy.Pointed
\import Homotopy.Pushout
\import Homotopy.Sphere
\import Homotopy.Sphere.Circle
\import Homotopy.Suspension
\import Logic
\import Paths

\class HSpace \extends Pointed
  | \infixl 7 * : E -> E -> E
  | base-left (x : E) : base * x = x
  | base-right (x : E) : x * base = x

\class HSpaceConn \extends HSpace, Connected

-- | If a point {x} in an H-space belongs to the same connected component as {base}, then ``(x *)`` is an equivalence.
\lemma HSpace-conn {A : HSpace} (x : A) (c : TruncP (base = x)) : Equiv (x *) \elim c
  | inP base=x => transport (\lam f => Equiv f)
                            (path (\lam i y => (inv (base-left y) *> pmap (\lam z => z * y) base=x) @ i))
                            idEquiv

\instance Circle_HSpace : HSpaceConn Sphere1
  | base => base1
  | * => mult
  | base-left _ => idp
  | base-right => mult-right
  | isConn x y => \case x \as x, y \as y \return TruncP (x = y) \with {
    | base1, base1 => inP idp
  }
  \where {
    \open Sphere1(ploop)

    \func circle-loop (y : Sphere1) : y = y
      | base1 => path loop
      | loop i => Cube2.map ploop ploop ploop ploop (inv (<*_idp ploop) *> pmap (ploop <*) (inv (*>_inv ploop))) @ i

    \func mult (x y : Sphere1) : Sphere1 \elim x
      | base1 => y
      | loop i => circle-loop y @ i

    \func mult-right (x : Sphere1) : mult x base1 = x
      | base1 => idp
      | loop i => idp
  }

\instance Sphere1_HSpace : HSpaceConn (Sphere 1) => transport (\lam X => HSpaceConn X) (QEquiv-to-= Sphere1-equiv) Circle_HSpace

\func hopf {A : HSpaceConn} (x : Susp A) : \Type \elim x
  | pinl _ => A
  | pinr _ => A
  | pglue a i => Equiv-to-= (HSpace-conn a (isConn base a)) @ i
  \where
    \func total-equiv {A : HSpaceConn} : QEquiv {\Sigma (x : Susp A) (hopf x)} {Join A A}
      => transQEquiv (PushoutData.fibration-lemma hopf) total_join
      \where {
        \open PushoutData.fibration-lemma(total)

        \func total_join {A : HSpaceConn} : QEquiv {total (hopf {A})} {Join A A} => {?}
      }

\func hopfS2 (x : Sphere 2) => hopf x
  \where
    \func total-equiv =>
      (\Sigma (x : Sphere 2) (hopfS2 x)) ==< QEquiv-to-= hopf.total-equiv >==
      Join (Sphere 1) (Sphere 1)         ==< Join_Sphere (Sphere 1) 1 >==
      Sphere 3                           `qed
