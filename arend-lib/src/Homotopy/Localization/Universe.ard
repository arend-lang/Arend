\import Data.Sigma
\import Equiv
\import Function
\import HLevel
\import Homotopy.Square
\import Paths

\class Universe
  | isLocal : \Type -> \Prop

-- | The type of local types
\class Local {U : Universe} (X : \Type)
  | local : isLocal X

-- TODO: Prove the following lemmas.

-- | The type of localizations of a type
\class Localization {U : Universe} (X : \Type) (X' : Local)
  | inL : X -> X'
  | local-univ (Y : Local) : Equiv {X' -> Y} {X -> Y} (-o inL)
  \where
    \use \level isProp {U : Universe} (X : \Type) (l1 l2 : Localization X) : l1 = l2
      => \let | p1 : l1.X' = {\Type} l2.X' => path (iso (Equiv.sec {l1.local-univ l2.X'} l2.inL) (Equiv.sec {l2.local-univ l1.X'} l1.inL) {?} {?})
              | p2 i => local {pathInProp (\lam j => Local (p1 @ j)) (\new l1.X') (\new l2.X') @ i}
              | q1 : l1.X' = {Local} l2.X' => path (\lam i => \new Local (p1 @ i) (p2 i))
              | q2 x => transport_pi {Local} (\lam _ => X) (\lam Y => Y) q1 l1.inL x *> path (\lam i => (Equiv.f_sec {l1.local-univ l2.X'} l2.inL @ i) x)
              | q2' i => pathOver (path (\lam j x => q2 x @ j)) @ i
         \in path (\lam i => \new Localization X (q1 @ i) (q2' i) (local-univ {pathInProp (\lam j => Localization X (q1 @ j) (q2' j)) (\new l1) (\new l2) @ i}))

\class ReflUniverse \extends Universe
  | localization (X : \Type) : Localization X

-- | ``inL : X -> X'`` is an equivalence if ``X`` is local.
\lemma localizationOfLocalType {U : ReflUniverse} (X : Local) : Equiv (inL {localization X})
  => lem X (localization X)
  \where
    \lemma lem {U : Universe} (X : Local) (L : Localization X) : Equiv {X} {L.X'} inL
      => {?}

-- | If ``inL : X -> X'`` is a section, then ``X`` is local.
\lemma localizationWithRetraction {U : ReflUniverse} (X : \Type) (s : Section (inL {localization X})) : Local X
  => lem (localization X) s
  \where
    \lemma lem {U : Universe} (L : Localization) (s : Section {L.X} {L.X'} inL) : Local L.X
      => {?}

-- | Contractible types with a localization are local.
\lemma contrLocal {U : ReflUniverse} (C : Contr) : Local C
  => lem C (localization C)
  \where
    \lemma lem {U : Universe} (C : Contr) (L : Localization C) : Local C
      => localizationWithRetraction.lem L (\new Section { | ret _ => C.center | ret_f => C.contraction })

-- | The unit type is local if it has a localization.
\lemma unitLocal {U : ReflUniverse} : Local (\Sigma) => contrLocal unit-isContr
  \where
    \lemma lem {U : Universe} (L : Localization (\Sigma)) : Local (\Sigma) => contrLocal.lem unit-isContr L

-- | Pullbacks of local types with a localization are local.
\lemma pullbackLocal {U : ReflUniverse} (P : Pullback) (VL : Local P.square.V) (XL : Local P.square.X) (YL : Local P.square.Y) : Local P.square.U
  => lem P (localization P.square.U) VL XL YL
  \where
    \lemma lem {U : Universe} (P : Pullback) (L : Localization P.square.U) (VL : Local P.square.V) (XL : Local P.square.X) (YL : Local P.square.Y) : Local P.square.U
      => {?}

-- | Products of local types with a localization are local.
\lemma productLocal {U : ReflUniverse} {A B : Local} : Local (\Sigma A B)
  => pullbackLocal (productPullback A B) (\new Local A A.local) (\new Local B B.local) unitLocal

-- | Path types of local types with a localization are local.
\lemma pathLocal {U : ReflUniverse} {A : Local} (x y : A) : Local (x = y)
  => lem x y (localization (x = y))
  \where
    \lemma lem {U : Universe} {A : Local} (x y : A) (L : Localization (x = y)) : Local (x = y)
      => {?}

-- | Pi-types of local types with a localization are local.
\lemma piLocal {U : ReflUniverse} {A : \Type} (B : A -> Local) : Local (\Pi (x : A) -> B x)
  => lem B (localization (\Pi (x : A) -> B x))
  \where
    \lemma lem {U : Universe} {A : \Type} (B : A -> Local) (L : Localization (\Pi (x : A) -> B x)) : Local (\Pi (x : A) -> B x)
      => {?}

