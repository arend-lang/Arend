\import Equiv
\import Equiv.Sigma
\import Equiv.Univalence
\import HLevel
\import Homotopy.Image
\import Homotopy.Localization.Equiv
\import Homotopy.Localization.Universe
\import Logic
\import Paths

\func Separated (U : Universe) : Universe \cowith
  | isLocal Z => \Pi (z z' : Z) -> isLocal (z = z')

\func ReflSeparated (U : ReflUniverse) : ReflUniverse \cowith
  | Universe => Separated U
  | localization A =>
    \let | p (a a' : A) : Local (F a = F a') => pathLocal a a'
         | q (a a' : A) : LType (a = a') = {\Type} (F a = F a') => {?} -- pathEquiv a a'
         | r (a a' : A) : Localization (a = a') (p a a') =>
             coe (\lam i => Localization (a = a') (\new Local (q a a' @ i) (pathInProp (\lam j => isLocal (q a a' @ j)) (local {LType (a = a')}) (local {p a a'}) @ i)))
                 (\new localization (a = a')) right
    \in (separatedLocalization (YImage.dom-map-surj S) (\lam a a' => (p a a', r a a'))).2

{-
\func ReflSeparated (U : ReflUniverse) : ReflUniverse (\suc (\suc \lp)) \oo \cowith
  | Universe => Separated U
  | localization A =>
    \let | foo (a a' : A) : \Prop => Local \lp (F \lp a = (F \lp a'))
         | p (a a' : A) : foo a a' => pathLocal \lp a a'
         | q (a a' : A) : LType (a = a') = {\oo-Type (\suc \lp)} (Local.S (\suc \lp) \oo {p a a'}) => {?}
         | r (a a' : A) : Localization (a = a') (p a a') =>
           coe (\lam i => Localization (\suc (\suc \lp)) \oo (a = a') (\new Local (\suc (\suc \lp)) \oo (@ (\suc (\suc \lp)) \oo (q a a') i) (pathInProp (\lam j => isLocal (q a a' @ j)) (local {LType (a = a')}) (local {p a a'}) @ i)))
               (\new localization (a = a')) right
    \in (separatedLocalization (\suc (\suc \lp)) \oo (YImage.dom-map-surj \lp S) (\lam a a' => (p a a', r a a'))).2
 -}
  \where {
    \func S {U : ReflUniverse} {A : \Type} (a a' : A) : \Type => LType (a = a')

    \func F {U : ReflUniverse} {A : \Type} (a : A) => YImage.dom-map S a

    \lemma pathLocal {U : ReflUniverse} {A : \Type} (a a' : A) : Local (F a = F a')
      => transport (\lam X => Local X)
                   (inv (QEquiv-to-= (Embedding.pmap-isEquiv {YImage.cod-map-emb S} {F a} {F a'}) *> QEquiv-to-= (piEquiv (\lam _ => \Type) (S a) (S a'))))
                   (piLocal (\lam x => typePathsLocal (LType (a = x)) (LType (a' = x))))

    \open Localization(lift,remove_inL)

    \func pathEquiv {U : ReflUniverse} {A : \Type} (a a' : A) : LType (a = a') = {\Type} (F a = F a') =>
      \let | lType X : \Type => LType X
           | E => \Pi (x : A) -> Equiv {S a x} {S a' x}
           | EP => \Pi (x : A) -> S a x = S a' x
           -- The composite of the sequence (a = a' -> E -> G -> L (a = a')) is lEta.
           -- The last map is an equivalence by the local Yoneda lemma and the second map is an embedding by {m} below.
           -- Thus E -> G -> L (a = a') is an equivalence by {localizationFactorEmbedding} and E -> G is an equivalence by 2-out-of-3.
           {-  | G => \Pi (x : A) -> S a x -> S a' x
           | g (lq : LType (a' = a)) : E => \lam x => lift {localization (a' = a)} {equivLocal (LType (a = x)) (LType (a' = x))} (\lam q => transport (\lam y => Equiv {S y x} {S a' x}) q idEquiv) lq
           | m => \new Embedding {E} {G} (\lam h x => Equiv.f {h x}) (\lam e e' => \new Retraction { | sec p => path (\lam i x => Equiv.equals (path (\lam j => (p @ j) x)) @ i) | f_sec => idpe })
           | h l[a'=a] x => lift {localization (a = x)} {LType (a' = x)} (\lam a=x => transport (\lam y => lType (a' = y)) a=x l[a'=a])
           | h=mg l[a'=a] x l[a=x] : h l[a'=a] x l[a=x] = Equiv.f {g l[a'=a] x} l[a=x] => path (\lam i =>
               remove_inL {localization (a' = a)}
                          {LType (a' = x)}
                          (\lam l => h l x l[a=x])
                          (\lam l => Equiv.f {g l x} l[a=x])
                          (\lam a'=a => remove_inL {localization (a = x)}
                                                   {LType (a' = x)}
                                                   (h (inL a'=a) x)
                                                   (Equiv.f {g (inL a'=a) x})
                                                   (\lam a=x => {?})
                                                   l[a=x])
                          l[a'=a] @ i)
           | ye : Equiv (\lam l => Embedding.f {m} (g l)) => transport {lType (a' = a) -> G} (\lam k => Equiv k) (path (\lam i l x l' => h=mg l x l' @ i)) (symQEquiv (QEquiv.fromEquiv' (localYoneda a (\lam y => LType (a' = y))))) -}
      \in lType (a = a') ==< pmap lType (path-sym a a') >==
          lType (a' = a) ==< {?} >== -- Equiv-to-= {_} {E} (TwoOutOfThree.rightEmbedding {lType (a' = a)} {E} {G} g m ye) >==
          E              ==< path (\lam i => \Pi (x : A) -> inv (QEquiv-to-= univalence) @ {_} {Equiv {S a x} {S a' x}} i) >==
          EP             ==< path (iso {EP} (\lam h => path (\lam i x => h x @ i)) (\lam p x => path (\lam i => (p @ i) x)) idpe idpe) >==
          (S a = S a')   ==< inv (QEquiv-to-= (Embedding.pmap-isEquiv {YImage.cod-map-emb S})) >==
          (F a = F a')   `qed

    \lemma separatedLocalization {U : Universe} (f : Surjection) (p : \Pi (a a' : f.A) -> \Sigma (P : Local (f.f a = f.f a')) (Localization (a = a') P))
      : \Sigma (L : Local {Separated U} f.B) (Localization {Separated U} f.A L f.f)
      => \let B-local (b b' : f.B) : isLocal (b = b') =>
                \case f.isSurj b, f.isSurj b' \with {
                  | inP (a,q), inP (a',q') => transport2 (\lam x x' => isLocal (x = x')) q q' (local {(p a a').1})
                }
         \in (\new Local { | local => B-local }, \new Localization { | local-univ C => Extension.contr-equiv f.f (\lam g b =>
            \case f.isSurj b \with {
              | inP (a',q) => transport (\lam b' => Contr (\Sigma (c : C) (\Pi (a : f.A) -> f.f a = b' -> g a = c))) q
                                        (coe (\lam i => Contr (\Sigma (c : C) (\Pi (a : f.A) -> inv (Equiv-to-= (local-univ {(p a a').2} (\new Local (g a = c) (local {C} (g a) c)))) @ i)))
                                             (coe (\lam i => Contr (\Sigma (c : C) (inv (QEquiv-to-= (pi-contr-right a' (\lam x _ => g x = c))) @ i))) (lsigma (g a')) right) right)
            }) })
  }