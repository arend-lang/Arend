\import Equiv
\import Equiv.Fiber
\import Equiv.Univalence
\import Homotopy.Join
\import Homotopy.Localization.Accessible
\import Homotopy.Localization.Connected
\import Homotopy.Localization.Universe
\import Homotopy.Pushout
\import Logic
\import Paths

\lemma genBlakersMassey {d : Data} (x0 : X) (y0 : Y) : isConnectedMap (pbMap {d} {x0} {y0})
  => {?}
  \where {
    \open Localization

    \lemma equiv-lemma {U : ReflUniverse} {A B : \Type} (M : A -> Connected) (N : B -> Connected)
                       (f : \Sigma (a : A) (M a) -> \Sigma (b : B) (N b))
                       (g : \Sigma (b : B) (N b) -> \Sigma (a : A) (M a))
                       (p : \Pi (a : A) (m : M a) -> (g (f (a,m))).1 = a)
                       (q : \Pi (b : B) (n : N b) -> (f (g (b,n))).1 = b)
                       : Equiv {LType A} {LType B} (lift (\lam a => Equiv.sec {Connected.equiv {M a} (LType B)} (\lam m => lEta (f (a,m)).1)))
      => \let | E1 a => Connected.equiv {M a} (LType B)
              | E2 b => Connected.equiv {N b} (LType A)
              | f1 a m => lEta (f (a,m)).1
              | g1 b n => lEta (g (b,n)).1
              | F a => Equiv.sec {E1 a} (f1 a)
              | G b => Equiv.sec {E2 b} (g1 b)
         \in localization-equiv F G
                (\lam a => Equiv.sec {Connected.equiv {M a} (pathLocal (lift G (F a)) (lEta a))}
                                     (\lam m => lift G (F a)        ==< path (\lam i => lift G ((Equiv.f_sec {E1 a} (f1 a) @ i) m)) >==
                                                lift G (f1 a m)     ==< lift-prop G (f (a,m)).1 >==
                                                G (f (a,m)).1       ==< path (\lam i => (Equiv.f_sec {E2 (f (a,m)).1} (g1 (f (a,m)).1) @ i) (f (a,m)).2) >==
                                                inL (g (f (a,m))).1 ==< pmap inL (p a m) >==
                                                inL a               `qed))
                (\lam b => Equiv.sec {Connected.equiv {N b} (pathLocal (lift F (G b)) (lEta b))}
                                     (\lam n => lift F (G b)        ==< path (\lam i => lift F ((Equiv.f_sec {E2 b} (g1 b) @ i) n)) >==
                                                lift F (g1 b n)     ==< lift-prop F (g (b,n)).1 >==
                                                F (g (b,n)).1       ==< path (\lam i => (Equiv.f_sec {E1 (g (b,n)).1} (f1 (g (b,n)).1) @ i) (g (b,n)).2) >==
                                                inL (f (g (b,n))).1 ==< pmap inL (q b n) >==
                                                inL b               `qed))

    \class Data \extends ReflUniverse {
      | X : \Type
      | Y : \Type
      | Q : X -> Y -> \Type
      | ch {x x' : X} {y y' : Y} (q0 : Q x y) (q1 : Q x y') (q2 : Q x' y)
        : isConnectedType (Join (\Sigma (p : y = y') (transport (Q x) p q0 = q1)) (\Sigma (p : x = x') (transport (`Q y) p q0 = q2)))

      \func ST => \Sigma (x : X) (y : Y) (Q x y)

      \func PO => PushoutData {ST} (\lam p => p.1) (\lam p => p.2)

      \func pbMap {x : X} {y : Y} (q : Q x y) : pinl x = {PO} pinr y => PushoutData.ppglue ((x,y,q) : ST)

      \func code {x0 : X} {y0 : Y} (q0 : Q x0 y0) (w : PO) (p : pinl x0 = w) : \oo-Type \elim w
        | pinl x => LType (Fib (\lam q => pbMap q0 *> inv (pbMap q)) p)
        | pinr y => LType (Fib pbMap p)
        | pglue (x,y,q) i =>
          \let | F p : \Type => LType (Fib (\lam q1 => pbMap q0 *> inv (pbMap q1)) p)
               | t p' =>
                   transport_pi (\lam w => pinl x0 = w) (\lam _ => \oo-Type) (pbMap q) F p' *>
                   pmap F (transport_path-right (inv (pbMap q)) p') *>
                   Jl (\lam z r => \Pi (p' : pinl x0 = z) -> F (p' *> inv r) = {\Type} LType (\Sigma (q1 : Q x y0) (pbMap q0 *> inv (pbMap q1) *> r = p'))) (\lam _ => idp) (pbMap q) p' *>
                   QEquiv-to-= (equiv q0 q p')
          \in (pathOver (path (\lam j p' => t p' @ j)) @ i) p
        \where {
          \func equiv {x0 x : X} {y0 y : Y} (q0 : Q x0 y0) (q : Q x y) (p : pinl x0 = {PO} pinr y)
            => \let | A => \Sigma (q1 : Q x y0) (pbMap q0 *> inv (pbMap q1) *> pbMap q = p)
                    | B => Fib pbMap p
                    | M (a : A) => Join (\Sigma (p : y0 = y) (transport (Q x) p a.1 = q)) (\Sigma (p : x = x0) (transport (`Q y0) p a.1 = q0))
                    | N (b : B) => Join (\Sigma (p : y = y0) (transport (Q x0) p b.1 = q0)) (\Sigma (p : x0 = x) (transport (`Q y) p b.1 = q))
               \in equiv-lemma (\lam a => \new Connected { | X => M a | connected => ch a.1 q q0 })
                               (\lam b => \new Connected { | X => N b | connected => ch b.1 q0 q })
                               (\lam ad => LR q0 q p ad.1 ad.2)
                               (\lam bd => RL q0 q p bd.1 bd.2)
                               (LRL q0 q p)
                               (RLR q0 q p)

          \func LR {x0 x : X} {y0 y : Y} (q0 : Q x0 y0) (q : Q x y) (p : pinl x0 = {PO} pinr y)
                   (a : \Sigma (q1 : Q x y0) (pbMap q0 *> inv (pbMap q1) *> pbMap q = p))
                   (m : Join (\Sigma (p : y0 = y) (transport (Q x) p a.1 = q)) (\Sigma (p : x = x0) (transport (`Q y0) p a.1 = q0)))
                   : \Sigma (b : Fib pbMap p) (Join (\Sigma (p : y = y0) (transport (Q x0) p b.1 = q0)) (\Sigma (p : x0 = x) (transport (`Q y) p b.1 = q)))
            \elim a, m
            | (a1,idp), pinl (idp,idp) => ((q0, inv (pmap (pbMap q0 *>) (inv_*> (pbMap a1)))),                                             pinl (idp,idp))
            | (a1,idp), pinr (idp,idp) => ((q,  Jl (\lam _ r => r = pbMap a1 *> inv (pbMap a1) *> r) (inv (*>_inv (pbMap a1))) (pbMap q)), pinr (idp,idp))
            | (a1,idp), pglue ((idp,idp),(idp,idp)) i =>
                \let t => Jl (\lam _ s => inv (pmap (s *>) (inv_*> s)) = Jl (\lam _ r => r = s *> inv s *> r) (inv (*>_inv s)) s) idp (pbMap q0)
                \in ((q0, t @ i), pglue ((idp,idp),(idp,idp)) i)

          \func RL {x0 x : X} {y0 y : Y} (q0 : Q x0 y0) (q : Q x y) (p : pinl x0 = {PO} pinr y)
                   (b : \Sigma (q2 : Q x0 y) (pbMap q2 = p))
                   (n : Join (\Sigma (p : y = y0) (transport (Q x0) p b.1 = q0)) (\Sigma (p : x0 = x) (transport (`Q y) p b.1 = q)))
                   : \Sigma (a : \Sigma (q1 : Q x y0) (pbMap q0 *> inv (pbMap q1) *> pbMap q = p))
                            (Join (\Sigma (p : y0 = y) (transport (Q x) p a.1 = q)) (\Sigma (p : x = x0) (transport (`Q y0) p a.1 = q0)))
            \elim b, n
            | (b1,idp), pinl (idp,idp) => ((q,  pmap (pbMap q0 *>) (inv_*> (pbMap q))),                                              pinl (idp,idp))
            | (b1,idp), pinr (idp,idp) => ((q0, Jl (\lam _ r => pbMap q0 *> inv (pbMap q0) *> r = r) (*>_inv (pbMap q0)) (pbMap q)), pinr (idp,idp))
            | (b1,idp), pglue ((idp,idp),(idp,idp)) i =>
                \let t => Jl (\lam _ s =>  pmap (s *>) (inv_*> s) = Jl (\lam _ r => s *> inv s *> r = r) (*>_inv s) s) idp (pbMap q0)
                \in ((q0, t @ i), pglue ((idp,idp),(idp,idp)) i)

          \func LRL {x0 x : X} {y0 y : Y} (q0 : Q x0 y0) (q : Q x y) (p : pinl x0 = {PO} pinr y)
                    (a : \Sigma (q1 : Q x y0) (pbMap q0 *> inv (pbMap q1) *> pbMap q = p))
                    (m : Join (\Sigma (p : y0 = y) (transport (Q x) p a.1 = q)) (\Sigma (p : x = x0) (transport (`Q y0) p a.1 = q0)))
                    : (RL q0 q p (LR q0 q p a m).1 (LR q0 q p a m).2).1 = a
            \elim a, m
            | (a1,idp), pinl (idp,idp) => {?}
            | (a1,idp), pinr (idp,idp) => {?}
            | (a1,idp), pglue ((idp,idp),(idp,idp)) i => {?}

          \func RLR {x0 x : X} {y0 y : Y} (q0 : Q x0 y0) (q : Q x y) (p : pinl x0 = {PO} pinr y)
                    (b : \Sigma (q2 : Q x0 y) (pbMap q2 = p))
                    (n : Join (\Sigma (p : y = y0) (transport (Q x0) p b.1 = q0)) (\Sigma (p : x0 = x) (transport (`Q y) p b.1 = q)))
                    : (LR q0 q p (RL q0 q p b n).1 (RL q0 q p b n).2).1 = b
            => {?}
        }
    }

    \open Data
  }