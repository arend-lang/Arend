{
    parserClass = "org.vclang.lang.parser.VcParser"

    implements = 'org.vclang.psi.ext.VcCompositeElement'
    extends = 'org.vclang.psi.ext.VcCompositeElementImpl'

    elementTypeHolderClass = "org.vclang.psi.VcElementTypes"

    elementTypeClass = "org.vclang.psi.VcCompositeElementType"
    tokenTypeClass = "org.vclang.psi.VcTokenType"

    psiClassPrefix = "Vc"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.vclang.psi"
    psiImplPackage = "org.vclang.psi.impl"

    generateTokenAccessors = true

    tokens = [
        LBRACE              = '{'
        RBRACE              = '}'
        LGOAL               = '{?'
        LPAREN              = '('
        RPAREN              = ')'
        COLON               = ':'
        COLONCOLON          = '::'
        ARROW               = '->'
        FAT_ARROW           = '=>'
        DOT                 = '.'
        COMMA               = ','
        UNDERSCORE          = '_'
        GRAVE               = '`'
        PIPE                = '|'
        BLOCK_COMMENT_START = '{-'
        BLOCK_COMMENT_END   = '-}'

        OPEN_KW             = '\open'
        EXPORT_KW           = '\export'
        HIDING_KW           = '\hiding'
        FUNCTION_KW         = '\function'
        NON_ASSOC_KW        = '\infix'
        LEFT_ASSOC_KW       = '\infixl'
        RIGHT_ASSOC_KW      = '\infixr'
        PROP_KW             = '\Prop'
        WHERE_KW            = '\where'
        WITH_KW             = '\with'
        ELIM_KW             = '\elim'
        NEW_KW              = '\new'
        PI_KW               = '\Pi'
        SIGMA_KW            = '\Sigma'
        LAM_KW              = '\lam'
        LET_KW              = '\let'
        IN_KW               = '\in'
        CASE_KW             = '\case'
        DATA_KW             = '\data'
        CLASS_KW            = '\class'
        EXTENDS_KW          = '\extends'
        VIEW_KW             = '\view'
        ON_KW               = '\on'
        BY_KW               = '\by'
        INSTANCE_KW         = '\instance'
        TRUNCATED_KW        = '\truncated'
        DEFAULT_KW          = '\default'
        LP_KW               = '\lp'
        LH_KW               = '\lh'
        SUC_KW              = '\suc'
        MAX_KW              = '\max'

        LINE_COMMENT        = "regexp:--[^\r\n]*"
        BLOCK_COMMENT       = '{- BLOCK_COMMENT -}'
    ]

    extends("def(Function|Data|Class|ClassView|Instance)") = definition
    extends("(arr|binOp|pi|sigma|lam|let|case)Expr") = expr
    extends("(universe|setUniverse|truncatedUniverse|argument)BinOp") = binOpArg
    extends("(atom|suc|max)LevelExpr") = levelExpr
}

statements ::= topStatement*

private topStatement ::= !<<eof>> statement { recoverWhile = statement_recover }

private statement_recover ::= !(OPEN_KW      | EXPORT_KW    | FUNCTION_KW |
                                TRUNCATED_KW | DATA_KW      | CLASS_KW    |
                                VIEW_KW      | DEFAULT_KW   | INSTANCE_KW)

statement ::= statCmd | definition

statCmd ::= nsCmd nsCmdRoot (DOT refIdentifier)* [HIDING_KW? LPAREN <<comma_separated_sequence refIdentifier>> RPAREN] {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.ChildNamespaceCommand" ]
    mixin = "org.vclang.psi.ext.VcStatCmdImplMixin"
}

nsCmd ::= OPEN_KW | EXPORT_KW

nsCmdRoot ::= moduleName | refIdentifier {
    mixin = "org.vclang.psi.ext.VcNsCmdRootImplMixin"
}

classStat ::= classField
    | classImplement
    | definition

classField ::= PIPE prec? defIdentifier COLON expr {
    pin = 4
    implements = [ "org.vclang.psi.ext.PsiConcreteReferable"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassField" ]
    mixin = "org.vclang.psi.ext.impl.ClassFieldAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassFieldStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

classImplement ::= PIPE refIdentifier FAT_ARROW expr {
    pin = 3
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassFieldImpl" ]
    mixin = "org.vclang.psi.ext.impl.ClassFieldImplAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassImplementStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

definition ::= defFunction
    | defData
    | defClass
    | defClassView
    | defInstance {
    implements = [ "org.vclang.psi.ext.PsiConcreteReferable"
                   "com.jetbrains.jetpad.vclang.term.ChildGroup" ]
    mixin = "org.vclang.psi.ext.impl.DefinitionAdapter"
}

defFunction ::= FUNCTION_KW prec? defIdentifier tele* [COLON expr] functionBody where? {
    pin = 1
    mixin = "org.vclang.psi.ext.impl.FunctionDefinitionAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefFunctionStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defData ::= TRUNCATED_KW? DATA_KW prec? defIdentifier tele* [COLON expr] dataBody {
    pin = 2
    mixin = "org.vclang.psi.ext.impl.DataDefinitionAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefDataStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defClass ::= CLASS_KW prec? defIdentifier tele* [EXTENDS_KW <<comma_separated_sequence atomFieldsAcc>>] [LBRACE classStat* RBRACE] where? {
    pin = 1
    mixin = "org.vclang.psi.ext.impl.ClassDefinitionAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefClassStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defClassView ::= VIEW_KW defIdentifier ON_KW expr BY_KW refIdentifier LBRACE classViewField* RBRACE {
    pin = 1
    mixin = "org.vclang.psi.ext.impl.ClassViewAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefClassViewStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defInstance ::= DEFAULT_KW? INSTANCE_KW defIdentifier tele* FAT_ARROW expr {
    pin = 2
    mixin = "org.vclang.psi.ext.impl.InstanceAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefInstanceStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

functionBody ::= FAT_ARROW !ELIM_KW expr | elim? functionClauses {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.FunctionBody" ]
    mixin = "org.vclang.psi.ext.VcFunctionBodyImplMixin"
}

dataBody ::= elim constructorClause* | [FAT_ARROW PIPE? constructor] (PIPE constructor)*

constructorClause ::= PIPE <<comma_separated_sequence pattern>> FAT_ARROW (constructor | LBRACE <<pipe_separated_sequence constructor>> RBRACE) {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ConstructorClause" ]
    mixin = "org.vclang.psi.ext.VcConstructorClauseImplMixin"
}

elim ::= WITH_KW | FAT_ARROW ELIM_KW <<comma_separated_sequence atomFieldsAcc>>

classViewField ::= defIdentifier [FAT_ARROW prec? refIdentifier] {
    implements = "org.vclang.psi.ext.PsiConcreteReferable"
    mixin = "org.vclang.psi.ext.impl.ClassViewFieldAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassViewFieldStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

where ::= WHERE_KW (LBRACE statement* RBRACE | statement) { pin = 1 }

pattern ::= atomPattern | patternConstructor {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Pattern" ]
    mixin = "org.vclang.psi.ext.VcPatternImplMixin"
}

patternConstructor ::= prefixName atomPatternOrPrefix* { pin = 1 }

atomPatternOrPrefix ::= atomPattern | prefixName {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Pattern" ]
    mixin = "org.vclang.psi.ext.VcAtomPatternOrPrefixImplMixin"
}

atomPattern ::= LPAREN pattern? RPAREN
    | LBRACE pattern RBRACE
    | UNDERSCORE

constructor ::= prec? defIdentifier tele* [elim? clausesWithBraces] {
    pin = 2
    implements = [ "org.vclang.psi.ext.PsiConcreteReferable"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Constructor" ]
    mixin = "org.vclang.psi.ext.impl.ConstructorAdapter"
    stubClass = "org.vclang.psi.stubs.VcConstructorStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

prec ::= (NON_ASSOC_KW | LEFT_ASSOC_KW | RIGHT_ASSOC_KW) NUMBER

expr ::= arrExpr
    | caseExpr
    | sigmaExpr
    | piExpr
    | lamExpr
    | letExpr
    | binOpExpr {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Expression"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Parameter" ]
    mixin = "org.vclang.psi.ext.VcExprImplMixin"
}

arrExpr ::= expr ARROW expr {
    pin = 2
    rightAssociative = true
    mixin = "org.vclang.psi.ext.VcArrExprImplMixin"
}

binOpExpr ::= newExpr binOpRight* {
    mixin = "org.vclang.psi.ext.VcBinOpExprImplMixin"
}

caseExpr ::= CASE_KW <<comma_separated_sequence expr>> WITH_KW clausesWithBraces {
    pin = 1
    mixin = "org.vclang.psi.ext.VcCaseExprImplMixin"
}

piExpr ::= PI_KW tele+ ARROW expr {
    pin = 1
    mixin = "org.vclang.psi.ext.VcPiExprImplMixin"
}

sigmaExpr ::= SIGMA_KW tele+ {
    pin = 1
    mixin = "org.vclang.psi.ext.VcSigmaExprImplMixin"
}

lamExpr ::= LAM_KW tele+ FAT_ARROW expr {
    pin = 1
    mixin = "org.vclang.psi.ext.VcLamExprImplMixin"
}

letExpr ::= LET_KW <<pipe_separated_sequence letClause>> IN_KW expr {
    pin = 1
    mixin = "org.vclang.psi.ext.VcLetExprImplMixin"
}

functionClauses ::= clausesWithBraces | (PIPE clause)*
private clausesWithBraces ::= LBRACE <<pipe_separated_sequence clause>>? RBRACE { pin = 1 }

letClause ::= defIdentifier tele* typeAnnotation? FAT_ARROW expr {
    pin = 1
    implements = [ "org.vclang.psi.ext.PsiReferable"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LetClause" ]
    mixin = "org.vclang.psi.ext.VcLetClauseImplMixin"
}

typeAnnotation ::= COLON expr { pin = 1 }

clause ::= <<comma_separated_sequence pattern>> [FAT_ARROW expr] {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.FunctionClause" ]
    mixin = "org.vclang.psi.ext.VcClauseImplMixin"
}

levelExpr ::= atomLevelExpr
    | sucLevelExpr
    | maxLevelExpr {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression" ]
    mixin = "org.vclang.psi.ext.VcLevelExprImplMixin"
}

atomLevelExpr ::= LP_KW
    | LH_KW
    | NUMBER
    | LPAREN levelExpr RPAREN {
    implements = "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression"
    mixin = "org.vclang.psi.ext.VcAtomLevelExprImplMixin"
}

sucLevelExpr ::= SUC_KW atomLevelExpr {
    pin = 1
    implements = "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression"
    mixin = "org.vclang.psi.ext.VcSucLevelExprImplMixin"
}

maxLevelExpr ::= MAX_KW atomLevelExpr atomLevelExpr {
    pin = 1
    implements = "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression"
    mixin = "org.vclang.psi.ext.VcMaxLevelExprImplMixin"
}

binOpArg ::= universeBinOp
    | setUniverseBinOp
    | truncatedUniverseBinOp
    | argumentBinOp {
    implements = "org.vclang.psi.VcExpr"
}

universeBinOp ::= UNIVERSE [atomLevelExpr atomLevelExpr?] {
    pin = 1
    mixin = "org.vclang.psi.ext.VcUniverseBinOpImplMixin"
}

setUniverseBinOp ::= SET atomLevelExpr? {
    pin = 1
    mixin = "org.vclang.psi.ext.VcSetUniverseBinOpImplMixin"
}

truncatedUniverseBinOp ::= TRUNCATED_UNIVERSE atomLevelExpr? {
    pin = 1
    mixin = "org.vclang.psi.ext.VcTruncatedUniverseBinOpImplMixin"
}

argumentBinOp ::= atomFieldsAcc argument* {
    mixin = "org.vclang.psi.ext.VcArgumentBinOpImplMixin"
}

binOpRight ::= infixName newExpr | postfixName {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.BinOpSequenceElem" ]
    mixin = "org.vclang.psi.ext.VcBinOpRightImplMixin"
}

newExpr ::= NEW_KW? binOpArg implementStatements? {
    pin = 1
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcNewExprImplMixin"
}

fieldAcc ::= DOT (NUMBER | refIdentifier) {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcReferenceElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.FieldAcc" ]
    mixin = "org.vclang.psi.ext.VcFieldAccImplMixin"
}

moduleName ::= (COLONCOLON moduleNamePart)+

moduleNamePart ::= refIdentifier {
    implements = [ "org.vclang.psi.ext.VcReferenceElement" ]
    mixin = "org.vclang.psi.ext.VcModuleNamePartImplMixin"
}

atom ::= literal
    | tuple
    | NUMBER
    | atomModuleCall {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcAtomImplMixin"
}

tuple ::= LPAREN <<comma_separated_sequence expr>> RPAREN

atomModuleCall ::= moduleName

atomFieldsAcc ::= atom fieldAcc* {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcAtomFieldsAccImplMixin"
}

implementStatements ::= LBRACE <<pipe_separated_sequence implementStatement>>? RBRACE

implementStatement ::= refIdentifier FAT_ARROW expr {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassFieldImpl" ]
    mixin = "org.vclang.psi.ext.VcImplementStatementImplMixin"
}

argument ::= atomFieldsAcc
    | universeAtom
    | LBRACE expr RBRACE {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Argument" ]
    mixin = "org.vclang.psi.ext.VcArgumentImplMixin"
}

literal ::= prefixName
    | PROP_KW
    | UNDERSCORE
    | goal {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcLiteralImplMixin"
}

goal ::= LGOAL defIdentifier? [LBRACE expr RBRACE] RBRACE {
    pin = 1
    implements = "org.vclang.psi.ext.PsiReferable"
    mixin = "org.vclang.psi.ext.PsiReferableImpl"
}

universeAtom ::= SET
    | UNIVERSE
    | TRUNCATED_UNIVERSE {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcUniverseAtomImplMixin"
}

tele ::= literal
    | universeAtom
    | LPAREN typedExpr RPAREN
    | LBRACE typedExpr RBRACE {
        implements = [ "org.vclang.psi.ext.VcCompositeElement"
                       "com.jetbrains.jetpad.vclang.term.abs.Abstract.Parameter" ]
        mixin = "org.vclang.psi.ext.VcTeleImplMixin"
    }

typedExpr ::= identifierOrUnknown+ COLON expr | expr  // expr [COLON expr]

identifierOrUnknown ::= defIdentifier | UNDERSCORE

defIdentifier ::= PREFIX | INFIX {
    implements = [ "org.vclang.psi.ext.VcReferenceElement"
                   "com.jetbrains.jetpad.vclang.naming.reference.Referable" ]
    mixin = "org.vclang.psi.ext.VcDefIdentifierImplMixin"
}

refIdentifier ::= PREFIX | INFIX {
    implements = "org.vclang.psi.ext.VcReferenceElement"
    mixin = "org.vclang.psi.ext.VcRefIdentifierImplMixin"
}

prefixName ::= PREFIX | PREFIX_INFIX {
    implements = [ "org.vclang.psi.ext.VcReferenceElement"
                   "com.jetbrains.jetpad.vclang.naming.reference.Referable" ]
    mixin = "org.vclang.psi.ext.VcPrefixImplMixin"
}

infixName ::= INFIX | INFIX_PREFIX {
    implements = "org.vclang.psi.ext.VcReferenceElement"
    mixin = "org.vclang.psi.ext.VcInfixImplMixin"
}

postfixName ::= POSTFIX_INFIX | POSTFIX_PREFIX {
    implements = "org.vclang.psi.ext.VcReferenceElement"
    mixin = "org.vclang.psi.ext.VcPostfixImplMixin"
}

private meta comma_separated_sequence ::= <<p>> (COMMA <<p>>)* { pin(".*") = 1 }

private meta pipe_separated_sequence ::= PIPE? <<p>> (PIPE <<p>>)* { pin(".*") = 1 }
