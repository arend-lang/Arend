{
    parserClass = "org.vclang.lang.parser.VcParser"

    implements = 'org.vclang.psi.ext.VcCompositeElement'
    extends = 'org.vclang.psi.ext.VcCompositeElementImpl'

    elementTypeHolderClass = "org.vclang.psi.VcElementTypes"

    elementTypeClass = "org.vclang.psi.VcCompositeElementType"
    tokenTypeClass = "org.vclang.psi.VcTokenType"

    psiClassPrefix = "Vc"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.vclang.psi"
    psiImplPackage = "org.vclang.psi.impl"

    generateTokenAccessors = true

    tokens = [
        LBRACE              = '{'
        RBRACE              = '}'
        LGOAL               = '{?'
        LPAREN              = '('
        RPAREN              = ')'
        COLON               = ':'
        ARROW               = '->'
        FAT_ARROW           = '=>'
        DOT                 = '.'
        COMMA               = ','
        UNDERSCORE          = '_'
        PIPE                = '|'
        BLOCK_COMMENT_START = '{-'
        BLOCK_COMMENT_END   = '-}'

        OPEN_KW             = '\open'
        IMPORT_KW           = '\import'
        HIDING_KW           = '\hiding'
        USING_KW            = '\using'
        AS_KW               = '\as'
        FUNCTION_KW         = '\func'
        NON_ASSOC_KW        = '\fix'
        LEFT_ASSOC_KW       = '\fixl'
        RIGHT_ASSOC_KW      = '\fixr'
        INFIX_NON_KW        = '\infix'
        INFIX_LEFT_KW       = '\infixl'
        INFIX_RIGHT_KW      = '\infixr'
        PROP_KW             = '\Prop'
        WHERE_KW            = '\where'
        WITH_KW             = '\with'
        ELIM_KW             = '\elim'
        NEW_KW              = '\new'
        PI_KW               = '\Pi'
        SIGMA_KW            = '\Sigma'
        LAM_KW              = '\lam'
        LET_KW              = '\let'
        IN_KW               = '\in'
        CASE_KW             = '\case'
        DATA_KW             = '\data'
        CLASS_KW            = '\class'
        EXTENDS_KW          = '\extends'
        ON_KW               = '\on'
        BY_KW               = '\by'
        INSTANCE_KW         = '\instance'
        TRUNCATED_KW        = '\truncated'
        LP_KW               = '\lp'
        LH_KW               = '\lh'
        SUC_KW              = '\suc'
        LEVELS_KW           = '\levels'
        MAX_KW              = '\max'
        INVALID_KW          = '\invalid'

        LINE_COMMENT        = "regexp:--[^\r\n]*"
        BLOCK_COMMENT       = '{- BLOCK_COMMENT -}'
    ]

    extends("def(Function|Data|Class|Instance)") = definition
    extends("(arr|new|pi|sigma|lam|let|case)Expr") = expr
    extends("(universe|setUniverse|truncatedUniverse|argument)AppExpr") = appExpr
    extends("atomArgument|newArg|universeAtom|implicitArgument|infixArgument|postfixArgument") = argument
}

statements ::= topStatement*

private topStatement ::= !<<eof>> statement { recoverWhile = topStatement_recover }

private topStatement_recover ::= !(OPEN_KW      | IMPORT_KW | FUNCTION_KW  |
                                TRUNCATED_KW | DATA_KW   | CLASS_KW     | INSTANCE_KW | <<eof>>)

private statement_recover ::= (!WHERE_KW) & topStatement_recover

statement ::= statCmd | definition

statCmd ::= nsCmd ns_longName nsUsing? [HIDING_KW LPAREN <<comma_separated_sequence refIdentifier>> RPAREN] {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.NamespaceCommandHolder" ]
    mixin = "org.vclang.psi.ext.VcStatCmdImplMixin"
}

private ns_longName ::= longName {
    recoverWhile = ns_longName_recover
}

private ns_longName_recover ::= !(USING_KW | LPAREN | HIDING_KW) & statement_recover

nsCmd ::= OPEN_KW | IMPORT_KW

nsUsing ::= USING_KW? LPAREN <<comma_separated_sequence nsId>>? RPAREN {
  recoverWhile = nsUsing_recover
}

private nsUsing_recover ::= !(LPAREN | HIDING_KW) & statement_recover

nsId ::= ns_refIdentifier [AS_KW prec? defIdentifier] {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.NameRenaming" ]
    mixin = "org.vclang.psi.ext.VcNsIdImplMixin"
}

private ns_refIdentifier ::= refIdentifier {
    recoverWhile = ns_refIdentifier_recover
}

private ns_refIdentifier_recover ::= !(AS_KW | COMMA | RPAREN)

private classStats ::= LBRACE classStat* RBRACE { pin = 1 }

classStat ::= classFieldOrImplement | definition { recoverWhile = classStat_recover }

private classStat_recover ::= !(PIPE | FUNCTION_KW | TRUNCATED_KW | DATA_KW | CLASS_KW | INSTANCE_KW | RBRACE)

private classFieldOrImplement ::= pipe_def (classField | classImplement) { pin = 1 }

classField ::= prec? defIdentifier typeTele* COLON expr {
    implements = [ "org.vclang.psi.ext.PsiLocatedReferable"
                   "com.jetbrains.jetpad.vclang.term.group.Group.InternalReferable"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassField" ]
    mixin = "org.vclang.psi.ext.impl.ClassFieldAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassFieldStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

classFieldSyn ::= pipe_def refIdentifier fat_arrow_def prec? defIdentifier {
    pin = 1
    implements = [ "org.vclang.psi.ext.PsiLocatedReferable"
                   "com.jetbrains.jetpad.vclang.term.group.Group.InternalReferable"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassFieldSynonym" ]
    mixin = "org.vclang.psi.ext.impl.ClassFieldSynAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassFieldSynStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

classImplement ::= refIdentifier nameTele* FAT_ARROW expr {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassFieldImpl" ]
    mixin = "org.vclang.psi.ext.impl.ClassFieldImplAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassImplementStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

definition ::= defFunction
    | defData
    | defClass
    | defInstance {
    implements = [ "org.vclang.psi.ext.PsiConcreteReferable"
                   "com.jetbrains.jetpad.vclang.term.group.ChildGroup" ]
    mixin = "org.vclang.psi.ext.impl.DefinitionAdapter"
}

defFunction ::= FUNCTION_KW prec? defIdentifier nameTele* [COLON expr] functionBody where? {
    pin = 1
    mixin = "org.vclang.psi.ext.impl.FunctionDefinitionAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefFunctionStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defData ::= TRUNCATED_KW? DATA_KW prec? defIdentifier typeTele* [COLON expr] dataBody where? {
    pin = 2
    mixin = "org.vclang.psi.ext.impl.DataDefinitionAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefDataStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defClass ::= CLASS_KW prec? defIdentifier fieldTele? [EXTENDS_KW <<comma_separated_sequence longName>>] [classBodySyn | classStats] where? {
    pin = 1
    implements = "com.jetbrains.jetpad.vclang.naming.reference.ClassReferable"
    mixin = "org.vclang.psi.ext.impl.ClassDefinitionAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefClassStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defInstance ::= INSTANCE_KW defIdentifier nameTele* COLON longName coClauses where? {
    pin = 1
    mixin = "org.vclang.psi.ext.impl.InstanceAdapter"
    stubClass = "org.vclang.psi.stubs.VcDefInstanceStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

private classBodySyn ::= fat_arrow_def refIdentifier [LBRACE classFieldSyn* RBRACE] { pin = 1 }

functionBody ::= FAT_ARROW expr | elim? functionClauses

dataBody ::= elim constructorClause* | [fat_arrow_def_pipe pipe_def? constructor] (pipe_def constructor)*

private fat_arrow_def_pipe ::= FAT_ARROW {
    recoverWhile = def_pipe_recover
}

private def_pipe_recover ::= !(ID | PIPE | assoc)

private pipe_def ::= PIPE {
    recoverWhile = def_recover
}

private def_recover ::= !(ID | assoc)

constructorClause ::= PIPE <<comma_separated_sequence pattern>> fat_arrow_def_pipe_lbrace (constructor | LBRACE <<pipe_separated_sequence constructor>> RBRACE) {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ConstructorClause" ]
    mixin = "org.vclang.psi.ext.VcConstructorClauseImplMixin"
}

private fat_arrow_def ::= FAT_ARROW {
    recoverWhile = def_recover
}

private fat_arrow_def_pipe_lbrace ::= FAT_ARROW {
    recoverWhile = def_pipe_lbrace_recover
}

private def_pipe_lbrace_recover ::= !(ID | PIPE | LBRACE | assoc)

elim ::= WITH_KW | ELIM_KW <<comma_separated_sequence refIdentifier>>

where ::= WHERE_KW (LBRACE statement* RBRACE | statement) { pin = 1 }

pattern ::= atomPattern | patternConstructor {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Pattern" ]
    mixin = "org.vclang.psi.ext.VcPatternImplMixin"
    recoverWhile = pattern_recover
}

private pattern_recover ::= !(RPAREN | RBRACE | FAT_ARROW | PIPE | COMMA) & statement_recover

patternConstructor ::= defIdentifier atomPatternOrPrefix* { pin = 1 }

atomPatternOrPrefix ::= atomPattern | defIdentifier {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Pattern" ]
    mixin = "org.vclang.psi.ext.VcAtomPatternOrPrefixImplMixin"
}

atomPattern ::= LPAREN pattern? RPAREN
    | LBRACE pattern RBRACE
    | UNDERSCORE

constructor ::= prec? defIdentifier typeTele* [elim? clausesWithBraces] {
    pin = 2
    implements = [ "org.vclang.psi.ext.PsiLocatedReferable"
                   "com.jetbrains.jetpad.vclang.term.group.Group.InternalReferable"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Constructor"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ConstructorClause" ]
    mixin = "org.vclang.psi.ext.impl.ConstructorAdapter"
    stubClass = "org.vclang.psi.stubs.VcConstructorStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

private assoc ::= NON_ASSOC_KW | LEFT_ASSOC_KW | RIGHT_ASSOC_KW | INFIX_NON_KW | INFIX_LEFT_KW | INFIX_RIGHT_KW

prec ::= assoc NUMBER

expr ::= arrExpr
    | caseExpr
    | sigmaExpr
    | piExpr
    | lamExpr
    | letExpr
    | newExpr {
    implements = [ "org.vclang.psi.ext.VcSourceNode"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Expression"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Parameter" ]
    mixin = "org.vclang.psi.ext.VcExprImplMixin"
}

arrExpr ::= expr ARROW expr {
    pin = 2
    rightAssociative = true
    mixin = "org.vclang.psi.ext.VcArrExprImplMixin"
}

newExpr ::= NEW_KW? appExpr [LBRACE <<pipe_separated_sequence internal_coClause>>? RBRACE (argument | argumentRecovery)*] {
    mixin = "org.vclang.psi.ext.VcNewExprImplMixin"
}

appExpr ::= universeAppExpr
    | setUniverseAppExpr
    | truncatedUniverseAppExpr
    | argumentAppExpr {
    implements = "org.vclang.psi.VcExpr"
}

caseExpr ::= CASE_KW <<comma_separated_sequence expr>> WITH_KW clausesWithBraces {
    pin = 1
    mixin = "org.vclang.psi.ext.VcCaseExprImplMixin"
}

piExpr ::= PI_KW typeTele+ ARROW expr {
    pin = 1
    mixin = "org.vclang.psi.ext.VcPiExprImplMixin"
}

sigmaExpr ::= SIGMA_KW typeTele+ {
    pin = 1
    mixin = "org.vclang.psi.ext.VcSigmaExprImplMixin"
}

lamExpr ::= LAM_KW nameTele+ FAT_ARROW expr {
    pin = 1
    mixin = "org.vclang.psi.ext.VcLamExprImplMixin"
}

letExpr ::= LET_KW <<pipe_separated_sequence letClause>> IN_KW expr {
    pin = 1
    mixin = "org.vclang.psi.ext.VcLetExprImplMixin"
}

functionClauses ::= clausesWithBraces | (PIPE external_clause)*
private clausesWithBraces ::= LBRACE [pipe_def? internal_clause] (pipe_def internal_clause)* RBRACE { pin = 1 }

coClauses ::= LBRACE <<pipe_separated_sequence internal_coClause>>? RBRACE | (PIPE external_coClause)*

private internal_coClause ::= coClause {
    recoverWhile = pipe_seq_recover
}

private external_coClause ::= coClause {
    recoverWhile = external_pipe_seq_recover
}

private pipe_seq_recover ::= !(PIPE | RBRACE)

private external_pipe_seq_recover ::= pipe_seq_recover & statement_recover

clause ::= <<comma_separated_sequence pattern>> [FAT_ARROW expr] {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.FunctionClause" ]
    mixin = "org.vclang.psi.ext.VcClauseImplMixin"
}

private internal_clause ::= clause {
    recoverWhile = pipe_seq_recover
}

private external_clause ::= clause {
    recoverWhile = external_pipe_seq_recover
}

coClause ::= refIdentifier nameTele* FAT_ARROW expr {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassFieldImpl" ]
    mixin = "org.vclang.psi.ext.VcCoClauseImplMixin"
}

letClause ::= defIdentifier nameTele* typeAnnotation? FAT_ARROW expr {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LetClause" ]
    mixin = "org.vclang.psi.ext.VcLetClauseImplMixin"
}

typeAnnotation ::= COLON expr { pin = 1 }

levelExpr ::= atomLevelExpr
    | SUC_KW atomLevelExpr
    | MAX_KW atomLevelExpr atomLevelExpr {
    implements = [ "org.vclang.psi.ext.VcSourceNode"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression" ]
    mixin = "org.vclang.psi.ext.VcLevelExprImplMixin"
}

atomLevelExpr ::= LP_KW
    | LH_KW
    | NUMBER
    | LPAREN levelExpr RPAREN {
    implements = [ "org.vclang.psi.ext.VcSourceNode"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression" ]
    mixin = "org.vclang.psi.ext.VcAtomLevelExprImplMixin"
}

universeAppExpr ::= UNIVERSE [atomLevelExpr atomLevelExpr?] {
    pin = 1
    mixin = "org.vclang.psi.ext.VcUniverseAppExprImplMixin"
}

setUniverseAppExpr ::= SET atomLevelExpr? {
    pin = 1
    mixin = "org.vclang.psi.ext.VcSetUniverseAppExprImplMixin"
}

truncatedUniverseAppExpr ::= TRUNCATED_UNIVERSE atomLevelExpr? {
    pin = 1
    mixin = "org.vclang.psi.ext.VcTruncatedUniverseAppExprImplMixin"
}

onlyLevelExpr ::= atomOnlyLevelExpr
    | MAX_KW atomLevelExpr atomLevelExpr
    | SUC_KW atomLevelExpr {
    implements = [ "org.vclang.psi.ext.VcSourceNode"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression" ]
    mixin = "org.vclang.psi.ext.VcOnlyLevelExprImplMixin"
}

maybeAtomLevelExpr ::= atomLevelExpr | UNDERSCORE

levelsExpr ::= LEVELS_KW (maybeAtomLevelExpr maybeAtomLevelExpr | PROP_KW) | LPAREN levelsExpr RPAREN

atomOnlyLevelExpr ::= LP_KW
    | LH_KW
    | LPAREN onlyLevelExpr RPAREN {
    implements = [ "org.vclang.psi.ext.VcSourceNode"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LevelExpression" ]
    mixin = "org.vclang.psi.ext.VcAtomOnlyLevelExprImplMixin"
}

argumentAppExpr ::= (longName (levelsExpr | atomOnlyLevelExpr atomOnlyLevelExpr?) | atomFieldsAcc) (argument | argumentRecovery)* {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcArgumentAppExprImplMixin"
}

fieldAcc ::= DOT NUMBER

atom ::= literal
    | tuple
    | NUMBER {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcAtomImplMixin"
}

tuple ::= LPAREN <<comma_separated_sequence expr>> RPAREN {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcTupleImplMixin"
}

atomFieldsAcc ::= atom fieldAcc* {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcAtomFieldsAccImplMixin"
}

argument ::= atomArgument
    | newArg
    | universeAtom
    | implicitArgument
    | infixArgument
    | postfixArgument {
    implements = [ "org.vclang.psi.ext.VcCompositeElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Argument"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.BinOpSequenceElem" ]
    mixin = "org.vclang.psi.ext.VcArgumentImplMixin"
}

private argumentRecovery ::= argument_recover {
    recoverWhile = argument_recover
}

private argument_recover ::= !(NEW_KW | NUMBER | INFIX | POSTFIX) & typeTele_recover

atomArgument ::= atomFieldsAcc {
    implements = "org.vclang.psi.ext.VcCompositeElement"
    mixin = "org.vclang.psi.ext.VcAtomArgumentImplMixin"
}

implicitArgument ::= LBRACE expr RBRACE {
    implements = "org.vclang.psi.ext.VcCompositeElement"
    mixin = "org.vclang.psi.ext.VcImplicitArgumentImplMixin"
}

infixArgument ::= INFIX {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcInfixArgumentImplMixin"
}

postfixArgument ::= POSTFIX {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcPostfixArgumentImplMixin"
}

newArg ::= NEW_KW appExpr [LBRACE <<pipe_separated_sequence internal_coClause>>? RBRACE] {
    pin = 1
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcNewArgImplMixin"
}

longName ::= refIdentifier (DOT refIdentifier)* {
    pin = 1
    implements = [ "org.vclang.psi.ext.VcSourceNode"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.LongReference" ]
    mixin = "org.vclang.psi.ext.VcLongNameImplMixin"
}

literal ::= longName
    | PROP_KW
    | UNDERSCORE
    | goal {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcLiteralImplMixin"
}

goal ::= LGOAL defIdentifier? [LBRACE expr RBRACE] RBRACE {
    pin = 1
    implements = "org.vclang.psi.ext.PsiReferable"
    mixin = "org.vclang.psi.ext.PsiReferableImpl"
}

universeAtom ::= SET
    | UNIVERSE
    | TRUNCATED_UNIVERSE {
    implements = "org.vclang.psi.VcExpr"
    mixin = "org.vclang.psi.ext.VcUniverseAtomImplMixin"
}

nameTele ::= identifierOrUnknown
    | LPAREN identifierOrUnknown+ COLON expr RPAREN
    | LBRACE identifierOrUnknown [identifierOrUnknown* COLON expr] RBRACE {
        implements = [ "org.vclang.psi.ext.VcCompositeElement"
                       "com.jetbrains.jetpad.vclang.term.abs.Abstract.Parameter" ]
        mixin = "org.vclang.psi.ext.VcNameTeleImplMixin"
        recoverWhile = nameTele_recover
    }

private nameTele_recover ::= !(ID | UNDERSCORE | LPAREN | LBRACE | FAT_ARROW | COLON | PIPE | WITH_KW | ELIM_KW) & statement_recover

fieldTele ::= LPAREN fieldDefIdentifier COLON expr RPAREN {
        implements = [ "org.vclang.psi.ext.VcCompositeElement"
                       "com.jetbrains.jetpad.vclang.term.abs.Abstract.Parameter"
                       "com.jetbrains.jetpad.vclang.term.abs.Abstract.ClassField" ]
        mixin = "org.vclang.psi.ext.VcFieldTeleImplMixin"
    }

typeTele ::= literal
    | universeAtom
    | LPAREN typedExpr RPAREN
    | LBRACE typedExpr RBRACE {
        implements = [ "org.vclang.psi.ext.VcCompositeElement"
                       "com.jetbrains.jetpad.vclang.term.abs.Abstract.Parameter" ]
        mixin = "org.vclang.psi.ext.VcTypeTeleImplMixin"
        recoverWhile = typeTele_recover
    }

private typeTele_recover ::= !(LPAREN | LBRACE | ID | COLON | WITH_KW | ELIM_KW | FAT_ARROW | RPAREN | RBRACE | PIPE | ARROW | COMMA | IN_KW | SET | UNIVERSE | TRUNCATED_UNIVERSE | PROP_KW | UNDERSCORE | LGOAL) & statement_recover

typedExpr ::= identifierOrUnknown+ COLON expr | expr

identifierOrUnknown ::= defIdentifier | UNDERSCORE

fieldDefIdentifier ::= defIdentifier {
    implements = [ "org.vclang.psi.ext.PsiLocatedReferable"
                   "com.jetbrains.jetpad.vclang.term.group.Group.InternalReferable"
                   "org.vclang.psi.ext.VcReferenceElement" ]
    mixin = "org.vclang.psi.ext.impl.FieldDefIdentifierAdapter"
    stubClass = "org.vclang.psi.stubs.VcClassFieldParamStub"
    elementTypeFactory = "org.vclang.psi.stubs.StubImplementationsKt.factory"
}

defIdentifier ::= ID {
    implements = [ "org.vclang.psi.ext.PsiReferable"
                   "org.vclang.psi.ext.VcReferenceElement" ]
    mixin = "org.vclang.psi.ext.VcDefIdentifierImplMixin"
    recoverWhile = typeTele_recover
}

refIdentifier ::= ID {
    implements = [ "org.vclang.psi.ext.VcReferenceElement"
                   "com.jetbrains.jetpad.vclang.term.abs.Abstract.Reference" ]
    mixin = "org.vclang.psi.ext.VcRefIdentifierImplMixin"
}

private meta comma_separated_sequence ::= <<p>> (COMMA <<p>>)* { pin(".*") = 1 }

private meta pipe_separated_sequence ::= pipe_def? <<p>> (pipe_def <<p>>)*
