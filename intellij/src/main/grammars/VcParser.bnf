{
    parserClass="org.vclang.lang.core.parser.VcParser"
    parserUtilClass="org.vclang.lang.core.parser.VcParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Vc"
    psiImplClassSuffix="Impl"
    psiPackage="org.vclang.lang.core.psi"
    psiImplPackage="org.vclang.lang.core.psi.impl"
    psiImplUtilClass="org.vclang.lang.core.psi.impl.VcPsiImplUtil"

    elementTypeHolderClass="org.vclang.lang.core.psi.VcTypes"
    elementTypeClass="org.vclang.lang.core.psi.VcElementType"
    tokenTypeClass="org.vclang.lang.core.psi.VcTokenType"

    generateTokenAccessors=true

    tokens=[
        LBRACE             = '{'
        RBRACE             = '}'
        LPAREN             = '('
        RPAREN             = ')'
        COLON              = ':'
        COLONCOLON         = '::'
        ARROW              = '->'
        FAT_ARROW          = '=>'
        DOT                = '.'
        COMMA              = ','
        UNDERSCORE         = '_'
        GRAVE              = '`'
        HOLE               = '{?}'
        OR                 = '|'

        OPEN_KW            = '\open'
        EXPORT_KW          = '\export'
        HIDING_KW          = '\hiding'
        FUNCTION_KW        = '\function'
        NON_ASSOC_KW       = '\infix'
        LEFT_ASSOC_KW      = '\infixl'
        RIGHT_ASSOC_KW     = '\infixr'
        PROP_KW            = '\Prop'
        WHERE_KW           = '\where'
        WITH_KW            = '\with'
        ELIM_KW            = '\elim'
        FIELD_KW           = '\field'
        NEW_KW             = '\new'
        PI_KW              = '\Pi'
        SIGMA_KW           = '\Sigma'
        LAM_KW             = '\lam'
        LET_KW             = '\let'
        IN_KW              = '\in'
        CASE_KW            = '\case'
        WITH_KW            = '\with'
        IMPLEMENT_KW       = '\implement'
        DATA_KW            = '\data'
        CLASS_KW           = '\class'
        EXTENDS_KW         = '\extends'
        VIEW_KW            = '\view'
        ON_KW              = '\on'
        BY_KW              = '\by'
        INSTANCE_KW        = '\instance'
        TRUNCATED_KW       = '\truncated'
        DEFAULT_KW         = '\default'
        LP_KW              = '\lp'
        LH_KW              = '\lh'
        SUC_KW             = '\suc'
        MAX_KW             = '\max'

        ID                 = "regexp:\p{Alpha}\w*'*(-\p{Alpha}\w*'*)*"
        NUMBER             = "regexp:\d+"
        BIN_OP             = "regexp:[~!@#$%\^&*\\\-+=<>?/|.:]+"
        SET                = "regexp:\\Set\d*"
        UNIVERSE           = "regexp:\\Type\d*"
        TRUNCATED_UNIVERSE = "regexp:\\(\d+|oo)-Type\d*"
        LINE_COMMENT       = "regexp:--.*"
        BLOCK_COMMENT      = "regexp:\{-[^]*-\}"
    ]

    extends("binOpExpr|arrExpr|piExpr|sigmaExpr|lamExpr|letExpr|caseExpr") = expr
}

file ::= topStatement*
statements ::= statement*

statement ::= command | definition
topStatement ::= !<<eof>> statement {
    recoverWhile = statementRecover
}
private statementRecover ::= !(OPEN_KW  | EXPORT_KW | FUNCTION_KW | FIELD_KW   | IMPLEMENT_KW | TRUNCATED_KW |
                               DATA_KW  | CLASS_KW  | VIEW_KW     | DEFAULT_KW | INSTANCE_KW)

command ::= nsCmd (modulePath | identifier) fieldAcc* [HIDING_KW? <<parenSequence identifier>>] { pin = 1 }

definition ::= defFunction
    | defAbstract
    | defImplement
    | defData
    | defClass
    | defClassView
    | defInstance

defFunction ::= FUNCTION_KW precedence identifier tele* [COLON expr] functionBody where? { pin = 1 }
defAbstract ::= FIELD_KW precedence identifier COLON expr { pin = 1 }
defImplement ::= IMPLEMENT_KW identifier FAT_ARROW expr { pin = 1 }
defData ::= TRUNCATED_KW? DATA_KW precedence identifier tele* [COLON expr] dataBody { pin = 2 }
defClass ::= CLASS_KW ID tele* [EXTENDS_KW <<sequence expr>>] [LBRACE statements RBRACE] where? { pin = 1 }
defClassView ::= VIEW_KW ID ON_KW expr BY_KW identifier LBRACE classViewField* RBRACE { pin = 1 }
defInstance ::= DEFAULT_KW? INSTANCE_KW ID tele* FAT_ARROW expr { pin = 2 }

functionBody ::= withoutElim | withElim
private withoutElim ::= FAT_ARROW expr
private withElim ::= elim? clauses

dataBody ::= dataClauses | dataConstructors
private dataClauses ::= elim constructorClause*
private dataConstructors ::= [FAT_ARROW COLON? constructor] (OR constructor)*

constructorClause ::= OR <<sequence pattern>> FAT_ARROW (constructor | <<braceAlter constructor>>)

elim ::= WITH_KW | FAT_ARROW ELIM_KW expr? (COMMA expr)*

classViewField ::= identifier [FAT_ARROW precedence identifier]

where ::= WHERE_KW (LBRACE statements RBRACE | statement) { pin = 1 }

nsCmd ::= OPEN_KW | EXPORT_KW

pattern ::= atomPattern | identifier (atomPattern | ID)*

atomPattern ::= LPAREN pattern? RPAREN
    | LBRACE pattern RBRACE
    | UNDERSCORE

constructor ::= precedence identifier tele* [elim? clausesWithBraces]

precedence ::= [associativity NUMBER]

associativity ::= NON_ASSOC_KW
    | LEFT_ASSOC_KW
    | RIGHT_ASSOC_KW

identifier ::= ID | LPAREN BIN_OP RPAREN

expr ::= arrExpr
    | binOpExpr
    | piExpr
    | sigmaExpr
    | lamExpr
    | letExpr
    | caseExpr

arrExpr ::= expr ARROW expr { rightAssociative = true }
binOpExpr ::= binOpLeft* binOpArg
piExpr ::= PI_KW tele+ ARROW expr { pin = 1 }
sigmaExpr ::= SIGMA_KW tele+ { pin = 1 }
lamExpr ::= LAM_KW tele+ FAT_ARROW expr { pin = 1 }
letExpr ::= LET_KW <<alter letClause>> IN_KW expr { pin = 1 }
caseExpr ::= CASE_KW <<sequence expr>> WITH_KW? clauses { pin = 1 }

clauses ::= clausesWithBraces | (OR clause)*
private clausesWithBraces ::= LBRACE clause? (OR clause)* RBRACE

letClause ::= ID tele* typeAnnotation? FAT_ARROW expr

typeAnnotation ::= COLON expr { pin = 1 }

clause ::= <<sequence pattern>> [FAT_ARROW expr]

levelExpr ::= levelAtom
    | levelSuc
    | levelMax

levelAtom ::= LP_KW
    | LH_KW
    | NUMBER
    | LPAREN levelExpr RPAREN

levelSuc ::= SUC_KW levelAtom { pin = 1 }

levelMax ::= MAX_KW levelAtom levelAtom { pin = 1 }

binOpArg ::= binOpUniverse
    | binOpTruncatedUniverse
    | binOpSet
    | binOpArgument

binOpUniverse ::= UNIVERSE levelAtom? levelAtom? { pin = 1 }

binOpTruncatedUniverse ::= TRUNCATED_UNIVERSE levelAtom? { pin = 1 }

binOpSet ::= SET levelAtom? { pin = 1 }

binOpArgument ::= NEW_KW? atomFieldsAcc argument*

binOpLeft ::= binOpArg infix

fieldAcc ::= DOT (NUMBER | identifier) { pin = 1 }

infix ::= BIN_OP | GRAVE ID GRAVE

modulePath ::= (COLONCOLON ID)+

atom ::= literal
    | <<parenSequence expr>>
    | NUMBER
    | modulePath

atomFieldsAcc ::= atom fieldAcc* implementStatements?

implementStatements ::= LBRACE implementStatement* RBRACE

implementStatement ::= OR? identifier FAT_ARROW expr

argument ::= atomFieldsAcc
    | universeAtom
    | LBRACE expr RBRACE

literal ::= identifier
    | PROP_KW
    | UNDERSCORE
    | HOLE

universeAtom ::= SET
    | UNIVERSE
    | TRUNCATED_UNIVERSE

tele ::= literal
    | universeAtom
    | LPAREN typedExpr RPAREN
    | LBRACE typedExpr RBRACE

typedExpr ::= expr [COLON expr]

private meta sequence ::= <<p>> (COMMA <<p>>)* { pin(".*") = 1 }
private meta parenSequence ::= LPAREN <<p>> (COMMA <<p>>)* RPAREN { pin(".*") = 1 }
private meta alter ::= OR? <<p>> (OR <<p>>)* { pin(".*") = 1 }
private meta braceAlter ::= LBRACE OR? <<p>> (OR <<p>>)* RBRACE { pin(".*") = 1 }
