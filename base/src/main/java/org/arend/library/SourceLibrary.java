package org.arend.library;

import org.arend.ext.ArendExtension;
import org.arend.ext.DefaultArendExtension;
import org.arend.ext.error.ErrorReporter;
import org.arend.ext.module.ModulePath;
import org.arend.ext.typechecking.DefinitionListener;
import org.arend.ext.typechecking.ListDefinitionListener;
import org.arend.ext.ui.ArendUI;
import org.arend.extImpl.*;
import org.arend.library.classLoader.MultiClassLoader;
import org.arend.library.error.LibraryError;
import org.arend.module.error.ExceptionError;
import org.arend.module.error.ModuleNotFoundError;
import org.arend.module.scopeprovider.ModuleScopeProvider;
import org.arend.module.scopeprovider.SimpleModuleScopeProvider;
import org.arend.naming.scope.Scope;
import org.arend.prelude.Prelude;
import org.arend.source.BinarySource;
import org.arend.source.PersistableBinarySource;
import org.arend.source.Source;
import org.arend.source.SourceLoader;
import org.arend.term.group.ConcreteGroup;
import org.arend.typechecking.order.dependency.DependencyListener;
import org.arend.typechecking.order.dependency.DummyDependencyListener;
import org.arend.typechecking.order.listener.TypecheckingOrderingListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

// TODO[server2]: Delete this and the whole Library hierarchy together with LibraryManager
public abstract class SourceLibrary extends BaseLibrary {
  public enum Flag { RECOMPILE }
  private final EnumSet<Flag> myFlags = EnumSet.noneOf(Flag.class);
  private final SimpleModuleScopeProvider myAdditionalModuleScopeProvider = new SimpleModuleScopeProvider();
  private ArendExtension myExtension;

  /**
   * Adds a flag.
   */
  public void addFlag(Flag flag) {
    myFlags.add(flag);
  }

  /**
   * Removes a flag.
   */
  public void removeFlag(Flag flag) {
    myFlags.remove(flag);
  }

  /**
   * Gets the raw source (that is, the source containing not typechecked data) for a given module path.
   *
   * @param modulePath  a path to the source.
   *
   * @return the raw source corresponding to the given path or null if the source is not found.
   */
  @Nullable
  public abstract Source getRawSource(ModulePath modulePath);

  /**
   * Gets the test source for a given module path.
   *
   * @param modulePath  a path to the source.
   *
   * @return the test source corresponding to the given path or null if the source is not found.
   */
  @Nullable
  public Source getTestSource(ModulePath modulePath) {
    return null;
  }

  /**
   * Gets the binary source (that is, the source containing typechecked data) for a given module path.
   *
   * @param modulePath  a path to the source.
   *
   * @return the binary source corresponding to the given path or null if the source is not found.
   */
  @Nullable
  public BinarySource getBinarySource(ModulePath modulePath) {
    return getPersistableBinarySource(modulePath);
  }

  @Nullable
  public abstract PersistableBinarySource getPersistableBinarySource(ModulePath modulePath);

  /**
   * Gets the collection of modules generated by the language extension.
   *
   * @return the collection of additional modules.
   */
  public @NotNull Collection<? extends Map.Entry<ModulePath, Scope>> getAdditionalModules() {
    return myAdditionalModuleScopeProvider.getRegisteredEntries();
  }

  @Override
  public final @NotNull ModuleScopeProvider getModuleScopeProvider() {
    return module -> {
      Scope scope = myAdditionalModuleScopeProvider.forModule(module);
      return scope != null ? scope : getDeclaredModuleScopeProvider().forModule(module);
    };
  }

  @NotNull
  @Override
  public ArendExtension getArendExtension() {
    return myExtension != null ? myExtension : super.getArendExtension();
  }

  public void setArendExtension(ArendExtension extension) {
    myExtension = extension;
  }

  @Nullable
  public ArendUI getUI() {
    return null;
  }

  /**
   * Invoked by a source after it loads the group of a module.
   *
   * @param modulePath  the path to the loaded module.
   * @param group       the group of the loaded module or null if the group was not loaded.
   * @param isRaw       true if the module was loaded from a raw source, false otherwise.
   */
  public void groupLoaded(ModulePath modulePath, @Nullable ConcreteGroup group, boolean isRaw, boolean inTests) {

  }

  /**
   * Invoked by a binary source after it is loaded.
   *
   * @param modulePath  the path to the loaded module.
   * @param isComplete  true if the module was loaded completely, false otherwise.
   */
  public void binaryLoaded(ModulePath modulePath, boolean isComplete) {

  }

  /**
   * Checks if this library has any raw sources.
   * Note that currently libraries without raw sources do not work properly with class synonyms.
   *
   * @return true if the library has raw sources, false otherwise.
   */
  public boolean hasRawSources() {
    return true;
  }

  /**
   * Gets a dependency listener for definitions loaded from binary sources.
   *
   * @return a dependency listener.
   */
  @NotNull
  public DependencyListener getDependencyListener() {
    return DummyDependencyListener.INSTANCE;
  }

  /**
   * Indicates whether the library should be loaded if some errors occur.
   *
   * @return true if the library should be loaded despite errors, false otherwise.
   */
  protected boolean mustBeLoaded() {
    return !isExternal();
  }

  protected void loadGeneratedModules() {}

  @Override
  public boolean load(OldLibraryManager libraryManager, TypecheckingOrderingListener typechecking) {
    return false;
  }

  public boolean loadTests(OldLibraryManager libraryManager, Collection<? extends ModulePath> modules) {
    return new SourceLoader(this, libraryManager).loadRawSources(modules, true).size() == modules.size();
  }

  @Override
  public boolean loadTests(OldLibraryManager libraryManager) {
    return loadTests(libraryManager, getTestModules());
  }

  @Override
  public boolean unload() {
    myAdditionalModuleScopeProvider.clear();
    return super.unload();
  }

  @Override
  public boolean containsModule(ModulePath modulePath) {
    return false;
  }

  public boolean supportsPersisting() {
    return !isExternal();
  }

  public boolean persistModule(ModulePath modulePath, ErrorReporter errorReporter) {
    /* TODO[server2]
    PersistableBinarySource source = getPersistableBinarySource(modulePath);
    if (source == null) {
      errorReporter.report(new PersistingError(modulePath));
      return false;
    } else {
      return source.persist(this, errorReporter);
    }
    */
    return true;
  }

  public boolean persistUpdatedModules(ErrorReporter errorReporter) {
    boolean ok = true;
    for (ModulePath module : getUpdatedModules()) {
      if (getModuleGroup(module, false) != null && !persistModule(module, errorReporter)) {
        ok = false;
      }
    }
    return ok;
  }

  public boolean deleteModule(ModulePath modulePath) {
    PersistableBinarySource source = getPersistableBinarySource(modulePath);
    return source != null && source.delete(this);
  }
}
